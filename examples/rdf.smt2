(set-info :smt-lib-version |2.6|)
(set-info :category |"industrial"|)
(set-info :boogie-vc-id CheckWellformed$$PagedBetreeRefinement.__default.ReceiptDropFirst)
(set-option :print-success false)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
(set-option :timeout 0)
(set-option :rlimit 16350000)
(declare-sort T@U 0)
(declare-sort T@T 0)
(declare-fun tickleBool (Bool) Bool)
(declare-fun UOrdering2 (T@U T@U) Bool)
(declare-fun type (T@U) T@T)
(declare-fun TyTagFamilyType () T@T)
(declare-fun tytagFamily$Delta () T@U)
(declare-fun tytagFamily$uint128 () T@U)
(declare-fun tytagFamily$nat64 () T@U)
(declare-fun tytagFamily$nat32 () T@U)
(declare-fun tytagFamily$nat16 () T@U)
(declare-fun tytagFamily$nat8 () T@U)
(declare-fun tytagFamily$uint64 () T@U)
(declare-fun tytagFamily$int64 () T@U)
(declare-fun tytagFamily$uint32 () T@U)
(declare-fun tytagFamily$int32 () T@U)
(declare-fun tytagFamily$uint16 () T@U)
(declare-fun tytagFamily$int16 () T@U)
(declare-fun tytagFamily$sbyte () T@U)
(declare-fun tytagFamily$Option () T@U)
(declare-fun tytagFamily$KeyedMessage () T@U)
(declare-fun tytagFamily$Step () T@U)
(declare-fun tytagFamily$Path () T@U)
(declare-fun tytagFamily$Buffer () T@U)
(declare-fun tytagFamily$Memtable () T@U)
(declare-fun tytagFamily$Variables () T@U)
(declare-fun tytagFamily$byte () T@U)
(declare-fun tytagFamily$Value () T@U)
(declare-fun tytagFamily$MsgHistory () T@U)
(declare-fun tytagFamily$TransitionLabel () T@U)
(declare-fun tytagFamily$Stamped () T@U)
(declare-fun tytagFamily$TotalMap () T@U)
(declare-fun tytagFamily$QueryReceiptLine () T@U)
(declare-fun tytagFamily$BufferStack () T@U)
(declare-fun tytagFamily$Message () T@U)
(declare-fun tytagFamily$ChildMap () T@U)
(declare-fun tytagFamily$QueryReceipt () T@U)
(declare-fun tytagFamily$Key () T@U)
(declare-fun tytagFamily$BetreeNode () T@U)
(declare-fun |tytagFamily$_#TotalFunc1LL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1LL| () T@U)
(declare-fun |tytagFamily$_#Func1LL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1SS| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1SS| () T@U)
(declare-fun |tytagFamily$_#Func1SS| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2LLO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2LLO| () T@U)
(declare-fun |tytagFamily$_#Func2LLO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2SSO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2SSO| () T@U)
(declare-fun |tytagFamily$_#Func2SSO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3LLOL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3LLOL| () T@U)
(declare-fun |tytagFamily$_#Func3LLOL| () T@U)
(declare-fun |tytagFamily$_tuple#2OLL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1LO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1LO| () T@U)
(declare-fun |tytagFamily$_#Func1LO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1OL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1OL| () T@U)
(declare-fun |tytagFamily$_#Func1OL| () T@U)
(declare-fun |tytagFamily$_tuple#0| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2LOO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2LOO| () T@U)
(declare-fun |tytagFamily$_#Func2LOO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc0L| () T@U)
(declare-fun |tytagFamily$_#PartialFunc0L| () T@U)
(declare-fun |tytagFamily$_#Func0L| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1OS| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1OS| () T@U)
(declare-fun |tytagFamily$_#Func1OS| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3LLOO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3LLOO| () T@U)
(declare-fun |tytagFamily$_#Func3LLOO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2OSO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2OSO| () T@U)
(declare-fun |tytagFamily$_#Func2OSO| () T@U)
(declare-fun |tytagFamily$_tuple#2| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3| () T@U)
(declare-fun |tytagFamily$_#Func3| () T@U)
(declare-fun |tytagFamily$_#TotalFunc4| () T@U)
(declare-fun |tytagFamily$_#PartialFunc4| () T@U)
(declare-fun |tytagFamily$_#Func4| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2| () T@U)
(declare-fun |tytagFamily$_#Func2| () T@U)
(declare-fun tytagFamily$_default () T@U)
(declare-fun |tytagFamily$_#TotalFunc0| () T@U)
(declare-fun |tytagFamily$_#PartialFunc0| () T@U)
(declare-fun |tytagFamily$_#Func0| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1| () T@U)
(declare-fun |tytagFamily$_#Func1| () T@U)
(declare-fun tytagFamily$array () T@U)
(declare-fun tytagFamily$object () T@U)
(declare-fun tytagFamily$nat () T@U)
(declare-fun Ctor (T@T) Int)
(declare-fun TyTagType () T@T)
(declare-fun Tagclass.AbstractMap.__default () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun class.AbstractMap.__default () T@U)
(declare-fun class.AbstractMap.Variables () T@U)
(declare-fun DtCtorIdType () T@T)
(declare-fun |##AbstractMap.Variables.Variables| () T@U)
(declare-fun class.AbstractMap.TransitionLabel () T@U)
(declare-fun |##AbstractMap.TransitionLabel.InternalLabel| () T@U)
(declare-fun |##AbstractMap.TransitionLabel.FreezeAsLabel| () T@U)
(declare-fun |##AbstractMap.TransitionLabel.QueryEndLsnLabel| () T@U)
(declare-fun |##AbstractMap.TransitionLabel.PutLabel| () T@U)
(declare-fun |##AbstractMap.TransitionLabel.QueryLabel| () T@U)
(declare-fun Tagclass.PagedBetree.__default () T@U)
(declare-fun class.PagedBetree.__default () T@U)
(declare-fun class.PagedBetree.Step () T@U)
(declare-fun |##PagedBetree.Step.InternalCompactStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalFlushStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalSplitStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalGrowStep| () T@U)
(declare-fun |##PagedBetree.Step.FreezeAsStep| () T@U)
(declare-fun |##PagedBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun |##PagedBetree.Step.PutStep| () T@U)
(declare-fun |##PagedBetree.Step.QueryStep| () T@U)
(declare-fun class.PagedBetree.Path () T@U)
(declare-fun |##PagedBetree.Path.Path| () T@U)
(declare-fun class.PagedBetree.Variables () T@U)
(declare-fun |##PagedBetree.Variables.Variables| () T@U)
(declare-fun class.PagedBetree.QueryReceipt () T@U)
(declare-fun |##PagedBetree.QueryReceipt.QueryReceipt| () T@U)
(declare-fun class.PagedBetree.QueryReceiptLine () T@U)
(declare-fun |##PagedBetree.QueryReceiptLine.QueryReceiptLine| () T@U)
(declare-fun class.PagedBetree.BetreeNode () T@U)
(declare-fun |##PagedBetree.BetreeNode.BetreeNode| () T@U)
(declare-fun |##PagedBetree.BetreeNode.Nil| () T@U)
(declare-fun class.PagedBetree.ChildMap () T@U)
(declare-fun |##PagedBetree.ChildMap.ChildMap| () T@U)
(declare-fun class.PagedBetree.TransitionLabel () T@U)
(declare-fun |##PagedBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.FreezeAsLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.QueryEndLsnLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.PutLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.QueryLabel| () T@U)
(declare-fun Tagclass.MemtableMod.__default () T@U)
(declare-fun class.MemtableMod.__default () T@U)
(declare-fun class.MemtableMod.Memtable () T@U)
(declare-fun |##MemtableMod.Memtable.Memtable| () T@U)
(declare-fun Tagclass.Buffers.__default () T@U)
(declare-fun class.Buffers.__default () T@U)
(declare-fun class.Buffers.BufferStack () T@U)
(declare-fun |##Buffers.BufferStack.BufferStack| () T@U)
(declare-fun class.Buffers.Buffer () T@U)
(declare-fun |##Buffers.Buffer.Buffer| () T@U)
(declare-fun Tagclass.MsgHistoryMod.__default () T@U)
(declare-fun class.MsgHistoryMod.__default () T@U)
(declare-fun class.MsgHistoryMod.MsgHistory () T@U)
(declare-fun |##MsgHistoryMod.MsgHistory.MsgHistory| () T@U)
(declare-fun class.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun |##MsgHistoryMod.KeyedMessage.KeyedMessage| () T@U)
(declare-fun Tagclass.Maps.__default () T@U)
(declare-fun class.Maps.__default () T@U)
(declare-fun Tagclass.MapRemove_s.__default () T@U)
(declare-fun class.MapRemove_s.__default () T@U)
(declare-fun Tagclass.Sequences.__default () T@U)
(declare-fun class.Sequences.__default () T@U)
(declare-fun Tagclass.LinearSequence__i.__default () T@U)
(declare-fun class.LinearSequence__i.__default () T@U)
(declare-fun Tagclass.Mathematics.__default () T@U)
(declare-fun class.Mathematics.__default () T@U)
(declare-fun Tagclass.SequencesLite.__default () T@U)
(declare-fun class.SequencesLite.__default () T@U)
(declare-fun Tagclass.StampedMod.__default () T@U)
(declare-fun class.StampedMod.__default () T@U)
(declare-fun class.StampedMod.Stamped () T@U)
(declare-fun |##StampedMod.Stamped.Stamped| () T@U)
(declare-fun Tagclass.LSNMod.__default () T@U)
(declare-fun class.LSNMod.__default () T@U)
(declare-fun Tagclass.TotalKMMapMod.__default () T@U)
(declare-fun class.TotalKMMapMod.__default () T@U)
(declare-fun class.ValueMessage.Message () T@U)
(declare-fun |##ValueMessage.Message.Update| () T@U)
(declare-fun |##ValueMessage.Message.Define| () T@U)
(declare-fun Tagclass.ValueMessage.__default () T@U)
(declare-fun class.ValueMessage.__default () T@U)
(declare-fun class.ValueMessage.Delta () T@U)
(declare-fun Tagclass.ValueMessage.Delta () T@U)
(declare-fun |##ValueMessage.Delta.NoDelta| () T@U)
(declare-fun Tagclass.LinearExtern.__default () T@U)
(declare-fun class.LinearExtern.__default () T@U)
(declare-fun class.LinearExtern.predefined () T@U)
(declare-fun Tagclass.LinearMaybe.__default () T@U)
(declare-fun class.LinearMaybe.__default () T@U)
(declare-fun class.LinearMaybe.predefined () T@U)
(declare-fun Tagclass.ValueType.__default () T@U)
(declare-fun class.ValueType.__default () T@U)
(declare-fun Tagclass.KeyType.__default () T@U)
(declare-fun class.KeyType.__default () T@U)
(declare-fun Tagclass.NativeTypes.__default () T@U)
(declare-fun class.NativeTypes.__default () T@U)
(declare-fun class.NativeTypes.uint128 () T@U)
(declare-fun Tagclass.NativeTypes.uint128 () T@U)
(declare-fun class.NativeTypes.nat64 () T@U)
(declare-fun Tagclass.NativeTypes.nat64 () T@U)
(declare-fun class.NativeTypes.nat32 () T@U)
(declare-fun Tagclass.NativeTypes.nat32 () T@U)
(declare-fun class.NativeTypes.nat16 () T@U)
(declare-fun Tagclass.NativeTypes.nat16 () T@U)
(declare-fun class.NativeTypes.nat8 () T@U)
(declare-fun Tagclass.NativeTypes.nat8 () T@U)
(declare-fun class.NativeTypes.uint64 () T@U)
(declare-fun Tagclass.NativeTypes.uint64 () T@U)
(declare-fun class.NativeTypes.int64 () T@U)
(declare-fun Tagclass.NativeTypes.int64 () T@U)
(declare-fun class.NativeTypes.uint32 () T@U)
(declare-fun Tagclass.NativeTypes.uint32 () T@U)
(declare-fun class.NativeTypes.int32 () T@U)
(declare-fun Tagclass.NativeTypes.int32 () T@U)
(declare-fun class.NativeTypes.uint16 () T@U)
(declare-fun Tagclass.NativeTypes.uint16 () T@U)
(declare-fun class.NativeTypes.int16 () T@U)
(declare-fun Tagclass.NativeTypes.int16 () T@U)
(declare-fun class.NativeTypes.byte () T@U)
(declare-fun class.NativeTypes.sbyte () T@U)
(declare-fun Tagclass.NativeTypes.sbyte () T@U)
(declare-fun Tagclass.Options.__default () T@U)
(declare-fun class.Options.__default () T@U)
(declare-fun class.Options.Option () T@U)
(declare-fun |##Options.Option.Some| () T@U)
(declare-fun Tagclass.Options.Option () T@U)
(declare-fun |##Options.Option.None| () T@U)
(declare-fun Tagclass.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun Tagclass.PagedBetree.Step () T@U)
(declare-fun Tagclass.PagedBetree.Path () T@U)
(declare-fun Tagclass.Buffers.Buffer () T@U)
(declare-fun Tagclass.MemtableMod.Memtable () T@U)
(declare-fun Tagclass.AbstractMap.Variables () T@U)
(declare-fun Tagclass.PagedBetree.Variables () T@U)
(declare-fun Tagclass.NativeTypes.byte () T@U)
(declare-fun Tagclass.ValueType.Value () T@U)
(declare-fun Tagclass.MsgHistoryMod.MsgHistory () T@U)
(declare-fun Tagclass.AbstractMap.TransitionLabel () T@U)
(declare-fun Tagclass.PagedBetree.TransitionLabel () T@U)
(declare-fun Tagclass.StampedMod.Stamped () T@U)
(declare-fun Tagclass.TotalKMMapMod.TotalMap () T@U)
(declare-fun Tagclass.PagedBetree.QueryReceiptLine () T@U)
(declare-fun Tagclass.Buffers.BufferStack () T@U)
(declare-fun Tagclass.ValueMessage.Message () T@U)
(declare-fun Tagclass.PagedBetree.ChildMap () T@U)
(declare-fun Tagclass.PagedBetree.QueryReceipt () T@U)
(declare-fun Tagclass.KeyType.Key () T@U)
(declare-fun Tagclass.PagedBetree.BetreeNode () T@U)
(declare-fun Tagclass.PagedBetreeRefinement.__default () T@U)
(declare-fun class.PagedBetreeRefinement.__default () T@U)
(declare-fun Tagclass._System.___hTotalFunc1LL () T@U)
(declare-fun Tagclass._System.___hPartialFunc1LL () T@U)
(declare-fun Tagclass._System.___hFunc1LL () T@U)
(declare-fun Tagclass._System.___hTotalFunc1SS () T@U)
(declare-fun Tagclass._System.___hPartialFunc1SS () T@U)
(declare-fun Tagclass._System.___hFunc1SS () T@U)
(declare-fun Tagclass._System.___hTotalFunc2LLO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2LLO () T@U)
(declare-fun Tagclass._System.___hFunc2LLO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2SSO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2SSO () T@U)
(declare-fun Tagclass._System.___hFunc2SSO () T@U)
(declare-fun Tagclass._System.___hTotalFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hPartialFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hFunc3LLOL () T@U)
(declare-fun class._System.Tuple2OLL () T@U)
(declare-fun Tagclass._System.Tuple2OLL () T@U)
(declare-fun |##_System._tuple#2OLL._#Make2| () T@U)
(declare-fun Tagclass._System.___hTotalFunc1LO () T@U)
(declare-fun Tagclass._System.___hPartialFunc1LO () T@U)
(declare-fun Tagclass._System.___hFunc1LO () T@U)
(declare-fun Tagclass._System.___hTotalFunc1OL () T@U)
(declare-fun Tagclass._System.___hPartialFunc1OL () T@U)
(declare-fun Tagclass._System.___hFunc1OL () T@U)
(declare-fun class._System.Tuple0 () T@U)
(declare-fun Tagclass._System.Tuple0 () T@U)
(declare-fun |##_System._tuple#0._#Make0| () T@U)
(declare-fun Tagclass._System.___hTotalFunc2LOO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2LOO () T@U)
(declare-fun Tagclass._System.___hFunc2LOO () T@U)
(declare-fun Tagclass._System.___hTotalFunc0L () T@U)
(declare-fun Tagclass._System.___hPartialFunc0L () T@U)
(declare-fun Tagclass._System.___hFunc0L () T@U)
(declare-fun Tagclass._System.___hTotalFunc1OS () T@U)
(declare-fun Tagclass._System.___hPartialFunc1OS () T@U)
(declare-fun Tagclass._System.___hFunc1OS () T@U)
(declare-fun Tagclass._System.___hTotalFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hPartialFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2OSO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2OSO () T@U)
(declare-fun Tagclass._System.___hFunc2OSO () T@U)
(declare-fun class._System.Tuple2 () T@U)
(declare-fun Tagclass._System.Tuple2 () T@U)
(declare-fun |##_System._tuple#2._#Make2| () T@U)
(declare-fun Tagclass._System.___hTotalFunc3 () T@U)
(declare-fun Tagclass._System.___hPartialFunc3 () T@U)
(declare-fun Tagclass._System.___hFunc3 () T@U)
(declare-fun Tagclass._System.___hTotalFunc4 () T@U)
(declare-fun Tagclass._System.___hPartialFunc4 () T@U)
(declare-fun Tagclass._System.___hFunc4 () T@U)
(declare-fun Tagclass._System.___hTotalFunc2 () T@U)
(declare-fun Tagclass._System.___hPartialFunc2 () T@U)
(declare-fun Tagclass._System.___hFunc2 () T@U)
(declare-fun Tagclass._System.__default () T@U)
(declare-fun class._System.__default () T@U)
(declare-fun Tagclass._System.___hTotalFunc0 () T@U)
(declare-fun Tagclass._System.___hPartialFunc0 () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hTotalFunc1 () T@U)
(declare-fun Tagclass._System.___hPartialFunc1 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.array? () T@U)
(declare-fun class._System.array? () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun Tagclass._System.object? () T@U)
(declare-fun class._System.object? () T@U)
(declare-fun Tagclass._System.nat () T@U)
(declare-fun NameFamilyType () T@T)
(declare-fun allocName () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun boolType () T@T)
(declare-fun alloc () T@U)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun class._System.multiset () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.int () T@U)
(declare-fun TagClass () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagORDINAL () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagBool () T@U)
(declare-fun TyType () T@T)
(declare-fun TORDINAL () T@U)
(declare-fun TReal () T@U)
(declare-fun TInt () T@U)
(declare-fun TChar () T@U)
(declare-fun TBool () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TBitvector (Int) T@U)
(declare-fun Inv0_TBitvector (T@U) Int)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun $Box (T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun LitInt (Int) Int)
(declare-fun int_2_U (Int) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun real_2_U (Real) T@U)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun charType () T@T)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun |char#Plus| (T@U T@U) T@U)
(declare-fun |char#Minus| (T@U T@U) T@U)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun refType () T@T)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun MapType1Type () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun U_2_int (T@U) Int)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun Tclass._System.Tuple2 (T@U T@U) T@U)
(declare-fun |Map#Items| (T@U) T@U)
(declare-fun |Map#Values| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Items| (T@U) T@U)
(declare-fun |IMap#Values| (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object? () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun |ORD#Offset| (T@U) Int)
(declare-fun |ORD#FromNat| (Int) T@U)
(declare-fun |ORD#IsNat| (T@U) Bool)
(declare-fun |ORD#Less| (T@U T@U) Bool)
(declare-fun |ORD#LessThanLimit| (T@U T@U) Bool)
(declare-fun |ORD#Plus| (T@U T@U) T@U)
(declare-fun |ORD#Minus| (T@U T@U) T@U)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun LayerTypeType () T@T)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun DeclName (T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Real (Int) Real)
(declare-fun q@Int (Real) Int)
(declare-fun $OneHeap () T@U)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Build_inv1| (T@U) T@U)
(declare-fun |Seq#Build_inv0| (T@U) T@U)
(declare-fun |Seq#Create| (T@U T@U Int T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |#_System._tuple#2._#Make2| (T@U T@U) T@U)
(declare-fun _System.Tuple2._1 (T@U) T@U)
(declare-fun _System.Tuple2._0 (T@U) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Merge| (T@U T@U) T@U)
(declare-fun |Map#Subtract| (T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun |IMap#Merge| (T@U T@U) T@U)
(declare-fun |IMap#Subtract| (T@U T@U) T@U)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun Mul (Int Int) Int)
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun _System.__default.rank__is__less__than (T@U T@U T@U T@U) Bool)
(declare-fun Tclass._System.nat () T@U)
(declare-fun TagFamily (T@U) T@U)
(declare-fun null () T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun Tclass._System.array? (T@U) T@U)
(declare-fun Tclass._System.array?_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.__default () T@U)
(declare-fun |_System.__default.rank__is__less__than#canCall|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun |_System.__default.rank__is__less__than#requires|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun Tclass._System.___hFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_2 (T@U) T@U)
(declare-fun Handle2 (T@U T@U T@U) T@U)
(declare-fun Apply2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType3Select (T@U T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType3TypeInv3 (T@T) T@T)
(declare-fun MapType3Type (T@T T@T T@T T@T) T@T)
(declare-fun MapType3TypeInv2 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun Requires2 (T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_4 (T@U) T@U)
(declare-fun Handle4 (T@U T@U T@U) T@U)
(declare-fun Apply4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType4Select (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType4Store (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType4TypeInv5 (T@T) T@T)
(declare-fun MapType4Type (T@T T@T T@T T@T T@T T@T) T@T)
(declare-fun MapType4TypeInv4 (T@T) T@T)
(declare-fun MapType4TypeInv3 (T@T) T@T)
(declare-fun MapType4TypeInv2 (T@T) T@T)
(declare-fun MapType4TypeInv1 (T@T) T@T)
(declare-fun MapType4TypeInv0 (T@T) T@T)
(declare-fun Requires4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_4 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_4 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_3 (T@U) T@U)
(declare-fun Handle3 (T@U T@U T@U) T@U)
(declare-fun Apply3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType5Select (T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType5Store (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType5TypeInv4 (T@T) T@T)
(declare-fun MapType5Type (T@T T@T T@T T@T T@T) T@T)
(declare-fun MapType5TypeInv3 (T@T) T@T)
(declare-fun MapType5TypeInv2 (T@T) T@T)
(declare-fun MapType5TypeInv1 (T@T) T@T)
(declare-fun MapType5TypeInv0 (T@T) T@T)
(declare-fun Requires3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_3 (T@U) T@U)
(declare-fun DatatypeCtorId (T@U) T@U)
(declare-fun _System.Tuple2.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2_1 (T@U) T@U)
(declare-fun |$IsA#_System.Tuple2| (T@U) Bool)
(declare-fun |_System.Tuple2#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_2 (T@U) T@U)
(declare-fun |#_System._tuple#0._#Make0| () T@U)
(declare-fun _System.Tuple0.___hMake0_q (T@U) Bool)
(declare-fun Tclass._System.Tuple0 () T@U)
(declare-fun |$IsA#_System.Tuple0| (T@U) Bool)
(declare-fun |_System.Tuple0#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO_1 (T@U) T@U)
(declare-fun |#_System._tuple#2OLL._#Make2| (T@U T@U) T@U)
(declare-fun _System.Tuple2OLL.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2OLL (T@U T@U) T@U)
(declare-fun Tclass._System.Tuple2OLL_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2OLL_1 (T@U) T@U)
(declare-fun _System.Tuple2OLL._0 (T@U) T@U)
(declare-fun _System.Tuple2OLL._1 (T@U) T@U)
(declare-fun |$IsA#_System.Tuple2OLL| (T@U) Bool)
(declare-fun |_System.Tuple2OLL#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL_1 (T@U) T@U)
(declare-fun Tclass.PagedBetreeRefinement.__default () T@U)
(declare-fun PagedBetreeRefinement.__default.BuildQueryReceipt
             (T@U T@U T@U)
             T@U)
(declare-fun $LZ () T@U)
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun Tclass.PagedBetree.BetreeNode () T@U)
(declare-fun Tclass.KeyType.Key () T@U)
(declare-fun Tclass.PagedBetree.QueryReceipt () T@U)
(declare-fun PagedBetree.QueryReceipt.key (T@U) T@U)
(declare-fun PagedBetree.QueryReceipt.Valid (T@U) Bool)
(declare-fun PagedBetree.BetreeNode.WF (T@U T@U) Bool)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
             (T@U T@U)
             Bool)
(declare-fun |PagedBetreeRefinement.__default.BuildQueryReceipt#requires|
             (T@U T@U T@U)
             Bool)
(declare-fun PagedBetree.QueryReceipt.lines (T@U) T@U)
(declare-fun ValueMessage.__default.Merge (T@U T@U) T@U)
(declare-fun ValueMessage.__default.DefaultValue () T@U)
(declare-fun |#ValueMessage.Message.Define| (T@U) T@U)
(declare-fun |#PagedBetree.BetreeNode.Nil| () T@U)
(declare-fun |#PagedBetree.QueryReceiptLine.QueryReceiptLine| (T@U T@U) T@U)
(declare-fun |#PagedBetree.QueryReceipt.QueryReceipt| (T@U T@U T@U) T@U)
(declare-fun PagedBetree.QueryReceipt.Result (T@U) T@U)
(declare-fun Buffers.BufferStack.Query (T@U T@U) T@U)
(declare-fun PagedBetree.BetreeNode.buffers (T@U) T@U)
(declare-fun PagedBetree.ChildMap.mapp (T@U) T@U)
(declare-fun PagedBetree.BetreeNode.children (T@U) T@U)
(declare-fun PagedBetree.BetreeNode.Nil_q (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.QueryReceipt_q (T@U) Bool)
(declare-fun |ValueMessage.__default.Merge#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Result#canCall| (T@U) Bool)
(declare-fun |Buffers.BufferStack.Query#canCall| (T@U T@U) Bool)
(declare-fun PagedBetree.ChildMap.ChildMap_q (T@U) Bool)
(declare-fun |ValueMessage.__default.DefaultValue#canCall| () Bool)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun Tclass.PagedBetree.ChildMap () T@U)
(declare-fun Tclass.ValueMessage.Message () T@U)
(declare-fun Tclass.Buffers.BufferStack () T@U)
(declare-fun Tclass.PagedBetree.QueryReceiptLine () T@U)
(declare-fun PagedBetreeRefinement.__default.INodeAt (T@U T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.INodeAt#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.INodeAt#requires| (T@U T@U) Bool)
(declare-fun PagedBetreeRefinement.__default.INode (T@U T@U) T@U)
(declare-fun Tclass.TotalKMMapMod.TotalMap () T@U)
(declare-fun |PagedBetreeRefinement.__default.INode#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.INode#requires| (T@U T@U) Bool)
(declare-fun |lambda#5| (T@U) T@U)
(declare-fun |lambda#4| (T@U) T@U)
(declare-fun TotalKMMapMod.__default.AnyKey (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.AnyKey#canCall| (T@U) Bool)
(declare-fun Tclass.StampedMod.Stamped (T@U) T@U)
(declare-fun Tclass.StampedMod.Stamped_0 (T@U) T@U)
(declare-fun StampedMod.Stamped.value (T@U) T@U)
(declare-fun PagedBetreeRefinement.__default.IStampedBetree (T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.IStampedBetree#canCall|
             (T@U)
             Bool)
(declare-fun |PagedBetreeRefinement.__default.IStampedBetree#requires|
             (T@U)
             Bool)
(declare-fun StartFuel_PagedBetreeRefinement._default.INode () T@U)
(declare-fun |#StampedMod.Stamped.Stamped| (T@U Int) T@U)
(declare-fun StampedMod.Stamped.seqEnd (T@U) Int)
(declare-fun StampedMod.Stamped.Stamped_q (T@U) Bool)
(declare-fun Tclass.PagedBetree.TransitionLabel () T@U)
(declare-fun Tclass.AbstractMap.TransitionLabel () T@U)
(declare-fun PagedBetreeRefinement.__default.ILbl (T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.ILbl#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.ILbl#requires| (T@U) Bool)
(declare-fun |#AbstractMap.TransitionLabel.InternalLabel| () T@U)
(declare-fun StampedMod.__default.Empty () T@U)
(declare-fun |#AbstractMap.TransitionLabel.FreezeAsLabel| (T@U) T@U)
(declare-fun |#AbstractMap.TransitionLabel.QueryEndLsnLabel| (Int) T@U)
(declare-fun |#AbstractMap.TransitionLabel.PutLabel| (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.puts (T@U) T@U)
(declare-fun |#AbstractMap.TransitionLabel.QueryLabel| (Int T@U T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.key (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.value (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.stampedBetree (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.FreezeAsLabel_q (T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.endLsn (T@U) Int)
(declare-fun PagedBetree.TransitionLabel.QueryEndLsnLabel_q (T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.PutLabel_q (T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.QueryLabel_q (T@U) Bool)
(declare-fun |StampedMod.__default.Empty#canCall| () Bool)
(declare-fun |PagedBetree.BetreeNode.WF#canCall| (T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.MsgHistory () T@U)
(declare-fun Tclass.ValueType.Value () T@U)
(declare-fun Tclass.NativeTypes.byte () T@U)
(declare-fun Tclass.PagedBetree.Variables () T@U)
(declare-fun Tclass.AbstractMap.Variables () T@U)
(declare-fun PagedBetreeRefinement.__default.I (T@U) T@U)
(declare-fun PagedBetree.Variables.WF (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.I#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.I#requires| (T@U) Bool)
(declare-fun |#AbstractMap.Variables.Variables| (T@U) T@U)
(declare-fun PagedBetree.BetreeNode.PushMemtable (T@U T@U) T@U)
(declare-fun PagedBetree.Variables.memtable (T@U) T@U)
(declare-fun PagedBetree.Variables.root (T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.PushMemtable#canCall| (T@U T@U) Bool)
(declare-fun PagedBetree.Variables.Variables_q (T@U) Bool)
(declare-fun Tclass.MemtableMod.Memtable () T@U)
(declare-fun Tclass.Buffers.Buffer () T@U)
(declare-fun PagedBetreeRefinement.__default.MapApply (T@U T@U T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.MapApply#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.MapApply#requires|
             (T@U T@U T@U)
             Bool)
(declare-fun |lambda#23| (T@U T@U) T@U)
(declare-fun MemtableMod.Memtable.Get (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.Get#canCall| (T@U T@U) Bool)
(declare-fun Tclass.PagedBetree.Path () T@U)
(declare-fun PagedBetreeRefinement.__default.ReceiptDropFirst (T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.ReceiptDropFirst#canCall|
             (T@U)
             Bool)
(declare-fun |PagedBetreeRefinement.__default.ReceiptDropFirst#requires|
             (T@U)
             Bool)
(declare-fun PagedBetree.QueryReceipt.root (T@U) T@U)
(declare-fun Tclass.PagedBetree.Step () T@U)
(declare-fun PagedBetreeRefinement.__default.EquivalentBufferCompaction
             (T@U T@U)
             Bool)
(declare-fun |PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall|
             (T@U T@U)
             Bool)
(declare-fun |PagedBetreeRefinement.__default.EquivalentBufferCompaction#requires|
             (T@U T@U)
             Bool)
(declare-fun |PagedBetree.ChildMap#Equal| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.Equivalent (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.BetreeNode_q (T@U) Bool)
(declare-fun |$IsA#PagedBetree.ChildMap| (T@U) Bool)
(declare-fun |Buffers.BufferStack.Equivalent#canCall| (T@U T@U) Bool)
(declare-fun PagedBetreeRefinement.__default.Inv (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.Inv#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.Inv#requires| (T@U) Bool)
(declare-fun |PagedBetree.Variables.WF#canCall| (T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun |#Options.Option.None| () T@U)
(declare-fun Options.Option.None_q (T@U) Bool)
(declare-fun Tclass.Options.Option (T@U) T@U)
(declare-fun Tclass.Options.Option_0 (T@U) T@U)
(declare-fun |#Options.Option.Some| (T@U) T@U)
(declare-fun Options.Option.Some_q (T@U) Bool)
(declare-fun Options.Option.value (T@U) T@U)
(declare-fun |$IsA#Options.Option| (T@U) Bool)
(declare-fun |Options.Option#Equal| (T@U T@U) Bool)
(declare-fun Tclass.Options.__default () T@U)
(declare-fun Options.__default.MapOption (T@U T@U T@U T@U T@U) T@U)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |Options.__default.MapOption#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Options.__default.MapOption#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Options.__default.FlatMapOption (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Options.__default.FlatMapOption#canCall|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun |Options.__default.FlatMapOption#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Tclass.NativeTypes.sbyte () T@U)
(declare-fun Tclass.NativeTypes.int16 () T@U)
(declare-fun Tclass.NativeTypes.uint16 () T@U)
(declare-fun Tclass.NativeTypes.int32 () T@U)
(declare-fun Tclass.NativeTypes.uint32 () T@U)
(declare-fun Tclass.NativeTypes.int64 () T@U)
(declare-fun Tclass.NativeTypes.uint64 () T@U)
(declare-fun Tclass.NativeTypes.nat8 () T@U)
(declare-fun Tclass.NativeTypes.nat16 () T@U)
(declare-fun Tclass.NativeTypes.nat32 () T@U)
(declare-fun Tclass.NativeTypes.nat64 () T@U)
(declare-fun Tclass.NativeTypes.uint128 () T@U)
(declare-fun Tclass.NativeTypes.__default () T@U)
(declare-fun NativeTypes.__default.Uint64Size () Int)
(declare-fun |NativeTypes.__default.Uint64Size#requires| () Bool)
(declare-fun NativeTypes.__default.Uint32Size () Int)
(declare-fun |NativeTypes.__default.Uint32Size#requires| () Bool)
(declare-fun NativeTypes.__default.Uint16Size () Int)
(declare-fun |NativeTypes.__default.Uint16Size#requires| () Bool)
(declare-fun |NativeTypes.__default.Uint64UpperBound#requires| () Bool)
(declare-fun NativeTypes.__default.Uint64UpperBound () Int)
(declare-fun |NativeTypes.__default.Uint32UpperBound#requires| () Bool)
(declare-fun NativeTypes.__default.Uint32UpperBound () Int)
(declare-fun NativeTypes.__default.Uint8UpperBound () Int)
(declare-fun |NativeTypes.__default.Uint8UpperBound#requires| () Bool)
(declare-fun Tclass.KeyType.__default () T@U)
(declare-fun KeyType.__default.MaxLen () Int)
(declare-fun |KeyType.__default.MaxLen#requires| () Bool)
(declare-fun Tclass.ValueType.__default () T@U)
(declare-fun ValueType.__default.MaxLen () Int)
(declare-fun |ValueType.__default.MaxLen#requires| () Bool)
(declare-fun ValueType.__default.DefaultValue () T@U)
(declare-fun |ValueType.__default.DefaultValue#requires| () Bool)
(declare-fun ValueType.__default.Len (T@U) Int)
(declare-fun |ValueType.__default.Len#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.Len#requires| (T@U) Bool)
(declare-fun ValueType.__default.ValidMessageBytestring (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestring#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestring#requires| (T@U) Bool)
(declare-fun |ValueType.__default.MaxLen#canCall| () Bool)
(declare-fun ValueType.__default.ValidMessageBytestrings (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestrings#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestrings#requires| (T@U) Bool)
(declare-fun Tclass.LinearMaybe.__default () T@U)
(declare-fun |#$maybe| (T@U) T@U)
(declare-fun LinearMaybe.__default.has (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.has#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.has#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.read (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.read#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.read#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.peek (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.peek#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.peek#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.unwrap (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.unwrap#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.unwrap#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.give (T@U T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.give#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.give#requires| (T@U T@U T@U) Bool)
(declare-fun LinearMaybe.__default.empty (T@U) T@U)
(declare-fun |LinearMaybe.__default.empty#requires| (T@U) Bool)
(declare-fun LinearMaybe.__default.discard (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.discard#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.discard#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.imagine (T@U Bool T@U) T@U)
(declare-fun |LinearMaybe.__default.imagine#canCall| (T@U Bool T@U) Bool)
(declare-fun |LinearMaybe.__default.imagine#requires| (T@U Bool T@U) Bool)
(declare-fun Tclass.LinearExtern.__default () T@U)
(declare-fun LinearExtern.__default.seq_get (T@U T@U Int) T@U)
(declare-fun |LinearExtern.__default.seq_get#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearExtern.__default.seq_get#requires| (T@U T@U Int) Bool)
(declare-fun LinearExtern.__default.seq_set (T@U T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.seq_set#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.seq_set#requires| (T@U T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.seq_length (T@U T@U) Int)
(declare-fun |LinearExtern.__default.seq_length#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_length#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.seq_empty (T@U) T@U)
(declare-fun |LinearExtern.__default.seq_empty#requires| (T@U) Bool)
(declare-fun LinearExtern.__default.seq_alloc (T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.seq_alloc#canCall| (T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.seq_alloc#requires| (T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.seq_free (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.seq_free#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_free#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.seq_unleash (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.seq_unleash#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_unleash#requires| (T@U T@U) Bool)
(declare-fun |#$lseq| (T@U) T@U)
(declare-fun LinearExtern.__default.lseqs__raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseqs__raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseqs__raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq__has (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseq__has#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq__has#requires| (T@U T@U) Bool)
(declare-fun |lambda#92| (Bool) T@U)
(declare-fun |lambda#93| (T@U) T@U)
(declare-fun |lambda#91| (T@U Int Int) T@U)
(declare-fun |lambda#90| (T@U T@U) T@U)
(declare-fun |lambda#94| (T@U) T@U)
(declare-fun LinearExtern.__default.imagine__lseq__raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.imagine__lseq__raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.imagine__lseq__raw#requires|
             (T@U T@U)
             Bool)
(declare-fun LinearExtern.__default.lseq_length_raw (T@U T@U) Int)
(declare-fun |LinearExtern.__default.lseq_length_raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_length_raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_alloc_raw (T@U Int) T@U)
(declare-fun |LinearExtern.__default.lseq_alloc_raw#canCall| (T@U Int) Bool)
(declare-fun |LinearExtern.__default.lseq_alloc_raw#requires| (T@U Int) Bool)
(declare-fun LinearExtern.__default.lseq_free_raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseq_free_raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_free_raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_swap_raw_fun (T@U T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.lseq_swap_raw_fun#canCall|
             (T@U T@U Int T@U)
             Bool)
(declare-fun |LinearExtern.__default.lseq_swap_raw_fun#requires|
             (T@U T@U Int T@U)
             Bool)
(declare-fun LinearExtern.__default.lseq_share_raw (T@U T@U Int) T@U)
(declare-fun |LinearExtern.__default.lseq_share_raw#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearExtern.__default.lseq_share_raw#requires|
             (T@U T@U Int)
             Bool)
(declare-fun |#ValueMessage.Delta.NoDelta| () T@U)
(declare-fun ValueMessage.Delta.NoDelta_q (T@U) Bool)
(declare-fun Tclass.ValueMessage.Delta () T@U)
(declare-fun |$IsA#ValueMessage.Delta| (T@U) Bool)
(declare-fun |ValueMessage.Delta#Equal| (T@U T@U) Bool)
(declare-fun Tclass.ValueMessage.__default () T@U)
(declare-fun ValueMessage.__default.NopDelta () T@U)
(declare-fun |ValueMessage.__default.NopDelta#requires| () Bool)
(declare-fun |ValueMessage.__default.DefaultValue#requires| () Bool)
(declare-fun |ValueType.__default.DefaultValue#canCall| () Bool)
(declare-fun ValueMessage.__default.CombineDeltas (T@U T@U) T@U)
(declare-fun |ValueMessage.__default.CombineDeltas#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.CombineDeltas#requires| (T@U T@U) Bool)
(declare-fun ValueMessage.__default.ApplyDelta (T@U T@U) T@U)
(declare-fun |ValueMessage.__default.ApplyDelta#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.ApplyDelta#requires| (T@U T@U) Bool)
(declare-fun ValueMessage.__default.MakeValueMessage (T@U) T@U)
(declare-fun |ValueMessage.__default.MakeValueMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.MakeValueMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.__default.EncodableMessage (T@U) Bool)
(declare-fun |ValueMessage.__default.EncodableMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.EncodableMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.Message.Define_q (T@U) Bool)
(declare-fun ValueMessage.__default.EvaluateMessage (T@U) T@U)
(declare-fun |ValueMessage.__default.EvaluateMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.EvaluateMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.Message.value (T@U) T@U)
(declare-fun |ValueMessage.__default.Merge#requires| (T@U T@U) Bool)
(declare-fun |#ValueMessage.Message.Update| (T@U) T@U)
(declare-fun ValueMessage.Message.delta (T@U) T@U)
(declare-fun ValueMessage.__default.IdentityMessage () T@U)
(declare-fun |ValueMessage.__default.IdentityMessage#requires| () Bool)
(declare-fun |ValueMessage.__default.NopDelta#canCall| () Bool)
(declare-fun ValueMessage.__default.DefaultMessage () T@U)
(declare-fun |ValueMessage.__default.DefaultMessage#requires| () Bool)
(declare-fun ValueMessage.Message.Update_q (T@U) Bool)
(declare-fun |$IsA#ValueMessage.Message| (T@U) Bool)
(declare-fun |ValueMessage.Message#Equal| (T@U T@U) Bool)
(declare-fun Tclass.TotalKMMapMod.__default () T@U)
(declare-fun TotalKMMapMod.__default.TerminalValue (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TerminalValue#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TerminalValue#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.DefaultV () T@U)
(declare-fun |TotalKMMapMod.__default.DefaultV#requires| () Bool)
(declare-fun |ValueMessage.__default.DefaultMessage#canCall| () Bool)
(declare-fun |TotalKMMapMod.__default.AnyKey#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.Defined (T@U T@U) Bool)
(declare-fun |TotalKMMapMod.__default.Defined#canCall| (T@U T@U) Bool)
(declare-fun |TotalKMMapMod.__default.Defined#requires| (T@U T@U) Bool)
(declare-fun TotalKMMapMod.__default.TotalMapIsFull (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TotalMapIsFull#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TotalMapIsFull#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.EmptyTotalMap () T@U)
(declare-fun |TotalKMMapMod.__default.EmptyTotalMap#requires| () Bool)
(declare-fun |lambda#101| (T@U) T@U)
(declare-fun |TotalKMMapMod.__default.DefaultV#canCall| () Bool)
(declare-fun TotalKMMapMod.__default.Witness () T@U)
(declare-fun |TotalKMMapMod.__default.Witness#requires| () Bool)
(declare-fun Tclass.LSNMod.__default () T@U)
(declare-fun |$IsA#StampedMod.Stamped| (T@U) Bool)
(declare-fun |StampedMod.Stamped#Equal| (T@U T@U) Bool)
(declare-fun Tclass.StampedMod.__default () T@U)
(declare-fun |StampedMod.__default.Empty#requires| () Bool)
(declare-fun |TotalKMMapMod.__default.EmptyTotalMap#canCall| () Bool)
(declare-fun Tclass.SequencesLite.__default () T@U)
(declare-fun SequencesLite.__default.Last (T@U T@U) T@U)
(declare-fun |SequencesLite.__default.Last#canCall| (T@U T@U) Bool)
(declare-fun |SequencesLite.__default.Last#requires| (T@U T@U) Bool)
(declare-fun SequencesLite.__default.DropLast (T@U T@U) T@U)
(declare-fun |SequencesLite.__default.DropLast#canCall| (T@U T@U) Bool)
(declare-fun |SequencesLite.__default.DropLast#requires| (T@U T@U) Bool)
(declare-fun Tclass.Mathematics.__default () T@U)
(declare-fun Mathematics.__default.min (Int Int) Int)
(declare-fun |Mathematics.__default.min#requires| (Int Int) Bool)
(declare-fun Mathematics.__default.max (Int Int) Int)
(declare-fun |Mathematics.__default.max#requires| (Int Int) Bool)
(declare-fun Mathematics.__default.Set (T@U T@U) T@U)
(declare-fun |Mathematics.__default.Set#canCall| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.Set#requires| (T@U T@U) Bool)
(declare-fun |lambda#104| (T@U T@U Int) T@U)
(declare-fun Mathematics.__default.ISet (T@U T@U) T@U)
(declare-fun |Mathematics.__default.ISet#canCall| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.ISet#requires| (T@U T@U) Bool)
(declare-fun |lambda#106| (T@U T@U) T@U)
(declare-fun Tclass.LinearSequence__i.__default () T@U)
(declare-fun LinearSequence__i.__default.seq__alloc__init (T@U Int T@U) T@U)
(declare-fun |LinearSequence__i.__default.seq__alloc__init#canCall|
             (T@U Int T@U)
             Bool)
(declare-fun |LinearSequence__i.__default.seq__alloc__init#requires|
             (T@U Int T@U)
             Bool)
(declare-fun LinearSequence__i.__default.lseqs (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseqs#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseqs#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.imagine__lseq (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.imagine__lseq#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.imagine__lseq#requires|
             (T@U T@U)
             Bool)
(declare-fun LinearSequence__i.__default.linLast (T@U T@U) T@U)
(declare-fun LinearSequence__i.__default.operator_kcardinality_qlseq
             (T@U T@U)
             Int)
(declare-fun |LinearSequence__i.__default.linLast#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.linLast#requires| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
             (T@U T@U)
             Bool)
(declare-fun LinearSequence__i.__default.ldroplast (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.ldroplast#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.ldroplast#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__has__all (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__has__all#canCall|
             (T@U T@U)
             Bool)
(declare-fun |LinearSequence__i.__default.lseq__has__all#requires|
             (T@U T@U)
             Bool)
(declare-fun LinearSequence__i.__default.lseq__length__as__uint64 (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.lseq__length__as__uint64#canCall|
             (T@U T@U)
             Bool)
(declare-fun |LinearSequence__i.__default.lseq__length__as__uint64#requires|
             (T@U T@U)
             Bool)
(declare-fun LinearSequence__i.__default.lseq__length (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.lseq__length#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__length#requires| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.operator_kcardinality_qlseq#requires|
             (T@U T@U)
             Bool)
(declare-fun LinearSequence__i.__default.operator_ksubscript_qlseq
             (T@U T@U Int)
             T@U)
(declare-fun |LinearSequence__i.__default.operator_ksubscript_qlseq#canCall|
             (T@U T@U Int)
             Bool)
(declare-fun |LinearSequence__i.__default.operator_ksubscript_qlseq#requires|
             (T@U T@U Int)
             Bool)
(declare-fun LinearSequence__i.__default.operator_kin_qlseq (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.operator_kin_qlseq#canCall|
             (T@U T@U Int)
             Bool)
(declare-fun |LinearSequence__i.__default.operator_kin_qlseq#requires|
             (T@U T@U Int)
             Bool)
(declare-fun LinearSequence__i.__default.lseq__add (T@U T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseq__add#canCall| (T@U T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__add#requires|
             (T@U T@U T@U)
             Bool)
(declare-fun LinearSequence__i.__default.lseq__peek (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.lseq__peek#canCall|
             (T@U T@U Int)
             Bool)
(declare-fun |LinearSequence__i.__default.lseq__peek#requires|
             (T@U T@U Int)
             Bool)
(declare-fun LinearSequence__i.__default.lseq__free__fun (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseq__free__fun#canCall|
             (T@U T@U)
             Bool)
(declare-fun |LinearSequence__i.__default.lseq__free__fun#requires|
             (T@U T@U)
             Bool)
(declare-fun LinearSequence__i.__default.lseq__take__fun (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.lseq__take__fun#canCall|
             (T@U T@U Int)
             Bool)
(declare-fun |LinearSequence__i.__default.lseq__take__fun#requires|
             (T@U T@U Int)
             Bool)
(declare-fun LinearSequence__i.__default.lseq__full (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__full#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__full#requires| (T@U T@U) Bool)
(declare-fun Tclass.Sequences.__default () T@U)
(declare-fun Sequences.__default.Last (T@U T@U) T@U)
(declare-fun |Sequences.__default.Last#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.Last#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.FirstOpt (T@U T@U) T@U)
(declare-fun |Sequences.__default.FirstOpt#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FirstOpt#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.DropLast (T@U T@U) T@U)
(declare-fun |Sequences.__default.DropLast#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.DropLast#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.Set (T@U T@U) T@U)
(declare-fun |Sequences.__default.Set#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.Set#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.ISet (T@U T@U) T@U)
(declare-fun |Sequences.__default.ISet#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.ISet#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.NoDupes (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.NoDupes#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.NoDupes#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IndexOf (T@U T@U T@U) Int)
(declare-fun |Sequences.__default.IndexOf#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IndexOf#requires| (T@U T@U T@U) Bool)
(declare-fun |$let#0_i| (T@U T@U T@U) Int)
(declare-fun |$let#0$canCall| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Range (T@U Int) T@U)
(declare-fun |Sequences.__default.Range#canCall| (Int) Bool)
(declare-fun |Sequences.__default.Range#requires| (T@U Int) Bool)
(declare-fun Sequences.__default.Apply (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Apply#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Apply#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#115| (T@U Int Int T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |lambda#113| (T@U Int Int T@U T@U T@U T@U) T@U)
(declare-fun |lambda#112| (T@U T@U T@U T@U) T@U)
(declare-fun Sequences.__default.ApplyOpaque (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.ApplyOpaque#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.ApplyOpaque#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Sequences.__default.Filter (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Filter#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Filter#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldLeft (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldLeft#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldLeft#requires|
             (T@U T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Sequences.__default.FoldRight (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldRight#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldRight#requires|
             (T@U T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Sequences.__default.FoldFromRight (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldFromRight#canCall|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun |Sequences.__default.FoldFromRight#requires|
             (T@U T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Sequences.__default.FoldSets (T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldSets#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldSets#requires| (T@U T@U) Bool)
(declare-fun |lambda#130| (T@U) T@U)
(declare-fun |lambda#128| (T@U T@U) T@U)
(declare-fun |lambda#127| () T@U)
(declare-fun Sequences.__default.remove (T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.remove#canCall| (T@U T@U Int) Bool)
(declare-fun |Sequences.__default.remove#requires| (T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.RemoveOneValue (T@U T@U T@U T@U) T@U)
(declare-fun StartFuel_Sequences._default.NoDupes () T@U)
(declare-fun |Sequences.__default.RemoveOneValue#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.RemoveOneValue#requires|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun |$let#4_i| (T@U T@U T@U) Int)
(declare-fun |$let#4$canCall| (T@U T@U T@U) Bool)
(declare-fun StartFuelAssert_Sequences._default.NoDupes () T@U)
(declare-fun MoreFuel_Sequences._default.NoDupes0 () T@U)
(declare-fun MoreFuel_Sequences._default.NoDupes1 () T@U)
(declare-fun MoreFuel_Sequences._default.NoDupes2 () T@U)
(declare-fun Sequences.__default.insert (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.insert#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.insert#requires| (T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.replace1with2 (T@U T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.replace1with2#canCall|
             (T@U T@U T@U T@U Int)
             Bool)
(declare-fun |Sequences.__default.replace1with2#requires|
             (T@U T@U T@U T@U T@U Int)
             Bool)
(declare-fun Sequences.__default.replace2with1 (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.replace2with1#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.replace2with1#requires|
             (T@U T@U T@U T@U Int)
             Bool)
(declare-fun Sequences.__default.concat (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concat#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.concat#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.concat3 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concat3#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.concat3#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.concatSeq (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concatSeq#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.concatSeq#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IsPrefix (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsPrefix#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsPrefix#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IsSuffix (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsSuffix#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsSuffix#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.SeqIndexIterate (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.SeqIndexIterate#canCall|
             (T@U T@U T@U Int)
             Bool)
(declare-fun |Sequences.__default.SeqIndexIterate#requires|
             (T@U T@U T@U T@U Int)
             Bool)
(declare-fun Sequences.__default.SeqIndex (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.SeqIndex#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqIndex#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.SeqIndexIterate () T@U)
(declare-fun Sequences.__default.SeqOfLength (T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.SeqOfLength#canCall| (T@U Int T@U) Bool)
(declare-fun |Sequences.__default.SeqOfLength#requires| (T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.SeqIndexUpdate (T@U T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.SeqIndexUpdate#canCall|
             (T@U T@U Int T@U)
             Bool)
(declare-fun |Sequences.__default.SeqIndexUpdate#requires|
             (T@U T@U T@U Int T@U)
             Bool)
(declare-fun Sequences.__default.Zip (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Zip#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Zip#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Unzip (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Unzip#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Unzip#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FlattenShape (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FlattenShape#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FlattenShape#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FlattenLength (T@U T@U) Int)
(declare-fun |Sequences.__default.FlattenLength#canCall| (T@U) Bool)
(declare-fun |Sequences.__default.FlattenLength#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.Flatten (T@U T@U T@U) T@U)
(declare-fun StartFuel_Sequences._default.FlattenShape () T@U)
(declare-fun StartFuel_Sequences._default.FlattenLength () T@U)
(declare-fun |Sequences.__default.Flatten#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.Flatten#requires| (T@U T@U T@U) Bool)
(declare-fun StartFuelAssert_Sequences._default.FlattenShape () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenShape0 () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenShape1 () T@U)
(declare-fun Sequences.__default.FlattenIndex (T@U Int Int) Int)
(declare-fun |Sequences.__default.FlattenIndex#canCall| (T@U Int Int) Bool)
(declare-fun |Sequences.__default.FlattenIndex#requires| (T@U Int Int) Bool)
(declare-fun Sequences.__default.UnflattenIndex (T@U T@U Int) T@U)
(declare-fun |Sequences.__default.UnflattenIndex#canCall| (T@U Int) Bool)
(declare-fun |Sequences.__default.UnflattenIndex#requires| (T@U T@U Int) Bool)
(declare-fun StartFuelAssert_Sequences._default.FlattenLength () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenLength0 () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenLength1 () T@U)
(declare-fun Sequences.__default.seqMax (T@U T@U) Int)
(declare-fun |Sequences.__default.seqMax#canCall| (T@U) Bool)
(declare-fun |Sequences.__default.seqMax#requires| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.max#canCall| (Int Int) Bool)
(declare-fun Sequences.__default.fill (T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.fill#canCall| (T@U Int T@U) Bool)
(declare-fun |Sequences.__default.fill#requires| (T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.SeqHasUniqueElems (T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqHasUniqueElems#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqHasUniqueElems#requires| (T@U T@U) Bool)
(declare-fun Tclass.MapRemove_s.__default () T@U)
(declare-fun MapRemove_s.__default.MapRemove1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |MapRemove_s.__default.MapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |MapRemove_s.__default.MapRemove1#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun |lambda#148| (T@U) T@U)
(declare-fun |lambda#147| (T@U T@U T@U) T@U)
(declare-fun Tclass.Maps.__default () T@U)
(declare-fun Maps.__default.IMapsTo (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsTo#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsTo#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsTo (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsTo#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsTo#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapInjective (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInjective#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInjective#requires| (T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsAgreeOnKey (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgreeOnKey#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgreeOnKey#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Maps.__default.IMapsAgreeOnKey (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsAgreeOnKey#canCall|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun |Maps.__default.IMapsAgreeOnKey#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Maps.__default.IsSubIMap (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubIMap#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubIMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IsSubMap (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubMap#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsAgree (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgree#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgree#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapRemove (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#153| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapRemoveStrong (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemoveStrong#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemoveStrong#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun StartFuelAssert_Maps._default.MapRemove () T@U)
(declare-fun MoreFuel_Maps._default.MapRemove0 () T@U)
(declare-fun StartFuel_Maps._default.MapRemove () T@U)
(declare-fun MoreFuel_Maps._default.MapRemove1 () T@U)
(declare-fun Maps.__default.MapRemove1 (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove1#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_MapRemove_s._default.MapRemove1 () T@U)
(declare-fun Maps.__default.MapRemove1Strong (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove1Strong#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove1Strong#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun StartFuelAssert_MapRemove_s._default.MapRemove1 () T@U)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove10 () T@U)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove11 () T@U)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove12 () T@U)
(declare-fun Maps.__default.IMapInvert (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapInvert#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInvert#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |$let#8_a| (T@U T@U T@U T@U) T@U)
(declare-fun |$let#8$canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#158| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.IMapRemove (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRemove#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRemove#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapRemove1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRemove1#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#169| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapIRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapIRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapIRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapDisjointUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapDisjointUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapDisjointUnion#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun |lambda#184| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapUnionPreferA (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnionPreferA#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnionPreferA#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Maps.__default.MapUnionPreferB (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnionPreferB#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnionPreferB#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Maps.__default.MapUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.MapUnionPreferA () T@U)
(declare-fun Maps.__default.IMapUnionPreferA (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnionPreferA#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnionPreferA#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Maps.__default.IMapUnionPreferB (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnionPreferB#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnionPreferB#requires|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun Maps.__default.IMapUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.IMapUnionPreferA () T@U)
(declare-fun Maps.__default.MapDisjointUnion3 (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun StartFuel_Maps._default.MapDisjointUnion () T@U)
(declare-fun |Maps.__default.MapDisjointUnion3#canCall|
             (T@U T@U T@U T@U T@U)
             Bool)
(declare-fun |Maps.__default.MapDisjointUnion3#requires|
             (T@U T@U T@U T@U T@U T@U)
             Bool)
(declare-fun |lambda#204| (T@U T@U T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapToImap (T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapToImap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapToImap#requires| (T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapLookupOption (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapLookupOption#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapLookupOption#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.ImapLookupOption (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.ImapLookupOption#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.ImapLookupOption#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |#MsgHistoryMod.KeyedMessage.KeyedMessage| (T@U T@U) T@U)
(declare-fun MsgHistoryMod.KeyedMessage.KeyedMessage_q (T@U) Bool)
(declare-fun MsgHistoryMod.KeyedMessage.key (T@U) T@U)
(declare-fun MsgHistoryMod.KeyedMessage.message (T@U) T@U)
(declare-fun |$IsA#MsgHistoryMod.KeyedMessage| (T@U) Bool)
(declare-fun |MsgHistoryMod.KeyedMessage#Equal| (T@U T@U) Bool)
(declare-fun |#MsgHistoryMod.MsgHistory.MsgHistory| (T@U Int Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.MsgHistory_q (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.msgs (T@U) T@U)
(declare-fun MsgHistoryMod.MsgHistory.seqStart (T@U) Int)
(declare-fun MsgHistoryMod.MsgHistory.seqEnd (T@U) Int)
(declare-fun |$IsA#MsgHistoryMod.MsgHistory| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory#Equal| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.WF (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.WF#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.WF#requires| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.ContainsExactly (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ContainsExactly#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ContainsExactly#requires| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Contains (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Contains#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Contains#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.LSNSet (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.LSNSet#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.LSNSet#requires| (T@U T@U) Bool)
(declare-fun |lambda#211| (T@U Int Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.IsEmpty (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IsEmpty#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IsEmpty#requires| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Len (T@U) Int)
(declare-fun |MsgHistoryMod.MsgHistory.Len#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Len#requires| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.CanConcat (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanConcat#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanConcat#requires| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.CanFollow (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanFollow#canCall| (T@U Int) Bool)
(declare-fun StartFuel_MsgHistoryMod.MsgHistory.LSNSet () T@U)
(declare-fun MsgHistoryMod.MsgHistory.Concat (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.Concat#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Concat#requires| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanFollow#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.ApplyToStampedMap (T@U T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
             (T@U T@U)
             Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires|
             (T@U T@U T@U)
             Bool)
(declare-fun MsgHistoryMod.MsgHistory.DiscardRecent (T@U Int) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.CanDiscardTo (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanDiscardTo#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.DiscardOld (T@U Int) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardOld#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardOld#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.MaybeDiscardOld (T@U Int) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardRecent#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.IncludesSubseq (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IncludesSubseq#requires| (T@U T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.__default () T@U)
(declare-fun MsgHistoryMod.__default.EmptyHistoryAt (Int) T@U)
(declare-fun |MsgHistoryMod.__default.EmptyHistoryAt#canCall| (Int) Bool)
(declare-fun |MsgHistoryMod.__default.EmptyHistoryAt#requires| (Int) Bool)
(declare-fun MsgHistoryMod.__default.SingletonAt (Int T@U) T@U)
(declare-fun |MsgHistoryMod.__default.SingletonAt#canCall| (Int T@U) Bool)
(declare-fun |MsgHistoryMod.__default.SingletonAt#requires| (Int T@U) Bool)
(declare-fun MsgHistoryMod.__default.MapPlusHistory (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.__default.MapPlusHistory#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.__default.MapPlusHistory#requires| (T@U T@U) Bool)
(declare-fun |#Buffers.Buffer.Buffer| (T@U) T@U)
(declare-fun Buffers.Buffer.Buffer_q (T@U) Bool)
(declare-fun Buffers.Buffer.mapp (T@U) T@U)
(declare-fun |$IsA#Buffers.Buffer| (T@U) Bool)
(declare-fun |Buffers.Buffer#Equal| (T@U T@U) Bool)
(declare-fun Buffers.Buffer.Query (T@U T@U) T@U)
(declare-fun |Buffers.Buffer.Query#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.Buffer.Query#requires| (T@U T@U) Bool)
(declare-fun Buffers.Buffer.ApplyFilter (T@U T@U) T@U)
(declare-fun |Buffers.Buffer.ApplyFilter#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.Buffer.ApplyFilter#requires| (T@U T@U) Bool)
(declare-fun |#Buffers.BufferStack.BufferStack| (T@U) T@U)
(declare-fun Buffers.BufferStack.BufferStack_q (T@U) Bool)
(declare-fun Buffers.BufferStack.buffers (T@U) T@U)
(declare-fun |$IsA#Buffers.BufferStack| (T@U) Bool)
(declare-fun |Buffers.BufferStack#Equal| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.QueryUpTo (T@U T@U T@U Int) T@U)
(declare-fun |Buffers.BufferStack.QueryUpTo#canCall| (T@U T@U Int) Bool)
(declare-fun |Buffers.BufferStack.QueryUpTo#requires| (T@U T@U T@U Int) Bool)
(declare-fun |Buffers.BufferStack.Query#requires| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.ApplyFilter (T@U T@U) T@U)
(declare-fun |Buffers.BufferStack.ApplyFilter#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.ApplyFilter#requires| (T@U T@U) Bool)
(declare-fun |lambda#227| (T@U T@U) T@U)
(declare-fun Buffers.BufferStack.PushBufferStack (T@U T@U) T@U)
(declare-fun |Buffers.BufferStack.PushBufferStack#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.PushBufferStack#requires| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.Equivalent#requires| (T@U T@U) Bool)
(declare-fun Buffers.__default.AnyKey (T@U) Bool)
(declare-fun |Buffers.__default.AnyKey#canCall| (T@U) Bool)
(declare-fun Tclass.Buffers.__default () T@U)
(declare-fun |Buffers.__default.AnyKey#requires| (T@U) Bool)
(declare-fun Buffers.__default.Total (T@U) Bool)
(declare-fun |Buffers.__default.Total#canCall| (T@U) Bool)
(declare-fun |Buffers.__default.Total#requires| (T@U) Bool)
(declare-fun Buffers.__default.AllKeys () T@U)
(declare-fun |Buffers.__default.AllKeys#requires| () Bool)
(declare-fun |lambda#242| (T@U) T@U)
(declare-fun |#MemtableMod.Memtable.Memtable| (T@U Int) T@U)
(declare-fun MemtableMod.Memtable.Memtable_q (T@U) Bool)
(declare-fun MemtableMod.Memtable.mapp (T@U) T@U)
(declare-fun MemtableMod.Memtable.seqEnd (T@U) Int)
(declare-fun |$IsA#MemtableMod.Memtable| (T@U) Bool)
(declare-fun |MemtableMod.Memtable#Equal| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.Get#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.ApplyPut (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.ApplyPut#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.ApplyPut#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.ApplyPuts (T@U T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.ApplyPuts#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.ApplyPuts#requires| (T@U T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.Query (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.Query#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.Query#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.Drain (T@U) T@U)
(declare-fun |MemtableMod.Memtable.Drain#canCall| (T@U) Bool)
(declare-fun |MemtableMod.Memtable.Drain#requires| (T@U) Bool)
(declare-fun MemtableMod.__default.EmptyMemtable (Int) T@U)
(declare-fun |MemtableMod.__default.EmptyMemtable#canCall| (Int) Bool)
(declare-fun MemtableMod.Memtable.IsEmpty (T@U) Bool)
(declare-fun |MemtableMod.Memtable.IsEmpty#canCall| (T@U) Bool)
(declare-fun |MemtableMod.Memtable.IsEmpty#requires| (T@U) Bool)
(declare-fun Tclass.MemtableMod.__default () T@U)
(declare-fun |MemtableMod.__default.EmptyMemtable#requires| (Int) Bool)
(declare-fun |#PagedBetree.TransitionLabel.QueryLabel| (Int T@U T@U) T@U)
(declare-fun |#PagedBetree.TransitionLabel.PutLabel| (T@U) T@U)
(declare-fun |#PagedBetree.TransitionLabel.QueryEndLsnLabel| (Int) T@U)
(declare-fun |#PagedBetree.TransitionLabel.FreezeAsLabel| (T@U) T@U)
(declare-fun |#PagedBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun PagedBetree.TransitionLabel.InternalLabel_q (T@U) Bool)
(declare-fun |$IsA#PagedBetree.TransitionLabel| (T@U) Bool)
(declare-fun |PagedBetree.TransitionLabel#Equal| (T@U T@U) Bool)
(declare-fun |#PagedBetree.ChildMap.ChildMap| (T@U) T@U)
(declare-fun PagedBetree.ChildMap.WF (T@U T@U) Bool)
(declare-fun |PagedBetree.ChildMap.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.ChildMap.WF#requires| (T@U T@U) Bool)
(declare-fun |#PagedBetree.BetreeNode.BetreeNode| (T@U T@U) T@U)
(declare-fun |$IsA#PagedBetree.BetreeNode| (T@U) Bool)
(declare-fun |PagedBetree.BetreeNode#Equal| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.WF#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.Child (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Child#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Child#requires| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.PushMemtable#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.PushBufferStack (T@U T@U) T@U)
(declare-fun PagedBetree.BetreeNode.Promote (T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.PushBufferStack#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Promote#canCall| (T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.PushBufferStack#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.FilterBuffersAndChildren (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
             (T@U T@U)
             Bool)
(declare-fun |PagedBetree.BetreeNode.FilterBuffersAndChildren#requires|
             (T@U T@U)
             Bool)
(declare-fun |lambda#245| (T@U T@U T@U) T@U)
(declare-fun PagedBetree.BetreeNode.Split (T@U T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Split#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Split#requires| (T@U T@U T@U) Bool)
(declare-fun |lambda#251| (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Promote#requires| (T@U) Bool)
(declare-fun PagedBetree.__default.EmptyRoot () T@U)
(declare-fun |PagedBetree.__default.EmptyRoot#canCall| () Bool)
(declare-fun PagedBetree.BetreeNode.Flush (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Flush#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Flush#requires| (T@U T@U) Bool)
(declare-fun |lambda#257| (T@U T@U T@U T@U) T@U)
(declare-fun |Buffers.__default.AllKeys#canCall| () Bool)
(declare-fun PagedBetree.QueryReceiptLine.QueryReceiptLine_q (T@U) Bool)
(declare-fun PagedBetree.QueryReceiptLine.node (T@U) T@U)
(declare-fun PagedBetree.QueryReceiptLine.result (T@U) T@U)
(declare-fun |$IsA#PagedBetree.QueryReceiptLine| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceiptLine#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.QueryReceiptLine.WF (T@U) Bool)
(declare-fun |PagedBetree.QueryReceiptLine.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceiptLine.WF#requires| (T@U) Bool)
(declare-fun |$IsA#PagedBetree.QueryReceipt| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.Structure (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Structure#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Structure#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.AllLinesWF (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.AllLinesWF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.AllLinesWF#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.ChildAt (T@U Int) T@U)
(declare-fun |PagedBetree.QueryReceipt.ChildAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ChildAt#requires| (T@U Int) Bool)
(declare-fun PagedBetree.QueryReceipt.ChildLinkedAt (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ChildLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ChildLinkedAt#requires| (T@U Int) Bool)
(declare-fun PagedBetree.QueryReceipt.ResultAt (T@U Int) T@U)
(declare-fun |PagedBetree.QueryReceipt.ResultAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ResultAt#requires| (T@U Int) Bool)
(declare-fun PagedBetree.QueryReceipt.ResultLinkedAt (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ResultLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ResultLinkedAt#requires| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.Valid#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Valid#requires| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Result#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.ValidFor (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.ValidFor#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.ValidFor#requires| (T@U T@U T@U) Bool)
(declare-fun |#PagedBetree.Variables.Variables| (T@U T@U) T@U)
(declare-fun |$IsA#PagedBetree.Variables| (T@U) Bool)
(declare-fun |PagedBetree.Variables#Equal| (T@U T@U) Bool)
(declare-fun |PagedBetree.Variables.WF#requires| (T@U) Bool)
(declare-fun |#PagedBetree.Path.Path| (T@U T@U T@U) T@U)
(declare-fun PagedBetree.Path.Path_q (T@U) Bool)
(declare-fun PagedBetree.Path.node (T@U) T@U)
(declare-fun PagedBetree.Path.key (T@U) T@U)
(declare-fun PagedBetree.Path.routing (T@U) T@U)
(declare-fun |$IsA#PagedBetree.Path| (T@U) Bool)
(declare-fun |PagedBetree.Path#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.Path.Subpath (T@U) T@U)
(declare-fun |PagedBetree.Path.Subpath#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.Subpath#requires| (T@U) Bool)
(declare-fun PagedBetree.Path.CommonChildren (T@U) Bool)
(declare-fun |PagedBetree.Path.CommonChildren#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.CommonChildren#requires| (T@U) Bool)
(declare-fun PagedBetree.Path.Valid (T@U T@U) Bool)
(declare-fun |PagedBetree.Path.Valid#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.Valid#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.Path.Target (T@U T@U) T@U)
(declare-fun |PagedBetree.Path.Target#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.Target#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.Path.ReplacedChildren (T@U T@U T@U) T@U)
(declare-fun |PagedBetree.Path.ReplacedChildren#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.Path.ReplacedChildren#requires| (T@U T@U T@U) Bool)
(declare-fun |lambda#263| (T@U T@U T@U) T@U)
(declare-fun PagedBetree.Path.Substitute (T@U T@U T@U) T@U)
(declare-fun |PagedBetree.Path.Substitute#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.Path.Substitute#requires| (T@U T@U T@U) Bool)
(declare-fun |#PagedBetree.Step.QueryStep| (T@U) T@U)
(declare-fun PagedBetree.Step.QueryStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.receipt (T@U) T@U)
(declare-fun |#PagedBetree.Step.PutStep| () T@U)
(declare-fun PagedBetree.Step.PutStep_q (T@U) Bool)
(declare-fun |#PagedBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun PagedBetree.Step.QueryEndLsnStep_q (T@U) Bool)
(declare-fun |#PagedBetree.Step.FreezeAsStep| () T@U)
(declare-fun PagedBetree.Step.FreezeAsStep_q (T@U) Bool)
(declare-fun |#PagedBetree.Step.InternalGrowStep| () T@U)
(declare-fun PagedBetree.Step.InternalGrowStep_q (T@U) Bool)
(declare-fun |#PagedBetree.Step.InternalSplitStep| (T@U T@U T@U) T@U)
(declare-fun PagedBetree.Step.InternalSplitStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.path (T@U) T@U)
(declare-fun PagedBetree.Step.leftKeys (T@U) T@U)
(declare-fun PagedBetree.Step.rightKeys (T@U) T@U)
(declare-fun |#PagedBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun PagedBetree.Step.InternalFlushMemtableStep_q (T@U) Bool)
(declare-fun |#PagedBetree.Step.InternalFlushStep| (T@U T@U) T@U)
(declare-fun PagedBetree.Step.InternalFlushStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.downKeys (T@U) T@U)
(declare-fun |#PagedBetree.Step.InternalCompactStep| (T@U T@U) T@U)
(declare-fun PagedBetree.Step.InternalCompactStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.compactedBuffers (T@U) T@U)
(declare-fun |$IsA#PagedBetree.Step| (T@U) Bool)
(declare-fun |PagedBetree.Step#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.Step.WF (T@U) Bool)
(declare-fun |PagedBetree.Step.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Step.WF#requires| (T@U) Bool)
(declare-fun Tclass.PagedBetree.__default () T@U)
(declare-fun PagedBetree.__default.EmptyImage () T@U)
(declare-fun |PagedBetree.__default.EmptyImage#requires| () Bool)
(declare-fun PagedBetree.__default.ConstantChildMap (T@U) T@U)
(declare-fun |PagedBetree.__default.ConstantChildMap#canCall| (T@U) Bool)
(declare-fun |PagedBetree.__default.ConstantChildMap#requires| (T@U) Bool)
(declare-fun PagedBetree.__default.EmptyChildMap () T@U)
(declare-fun |PagedBetree.__default.EmptyChildMap#requires| () Bool)
(declare-fun |PagedBetree.__default.EmptyRoot#requires| () Bool)
(declare-fun PagedBetree.__default.Query (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Query#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Query#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.Put (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Put#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Put#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.QueryEndLsn (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.QueryEndLsn#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.QueryEndLsn#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.FreezeAs (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.FreezeAs#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.FreezeAs#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalFlushMemtable (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalFlushMemtable#canCall|
             (T@U T@U T@U)
             Bool)
(declare-fun |PagedBetree.__default.InternalFlushMemtable#requires|
             (T@U T@U T@U)
             Bool)
(declare-fun PagedBetree.__default.InternalGrow (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalGrow#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalGrow#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalSplit (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalSplit#canCall|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun |PagedBetree.__default.InternalSplit#requires|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun PagedBetree.__default.InternalFlush (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalFlush#canCall|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun |PagedBetree.__default.InternalFlush#requires|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun PagedBetree.__default.CompactedNode (T@U T@U) T@U)
(declare-fun |PagedBetree.__default.CompactedNode#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.__default.CompactedNode#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalCompact (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalCompact#canCall|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun |PagedBetree.__default.InternalCompact#requires|
             (T@U T@U T@U T@U)
             Bool)
(declare-fun PagedBetree.__default.Init (T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Init#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Init#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.__default.NextStep (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.NextStep#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.NextStep#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.Next (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Next#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Next#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.TransitionLabel.QueryLabel_q (T@U) Bool)
(declare-fun AbstractMap.TransitionLabel.endLsn (T@U) Int)
(declare-fun AbstractMap.TransitionLabel.key (T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.value (T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.PutLabel_q (T@U) Bool)
(declare-fun AbstractMap.TransitionLabel.puts (T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.QueryEndLsnLabel_q (T@U) Bool)
(declare-fun AbstractMap.TransitionLabel.FreezeAsLabel_q (T@U) Bool)
(declare-fun AbstractMap.TransitionLabel.stampedMap (T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.InternalLabel_q (T@U) Bool)
(declare-fun |$IsA#AbstractMap.TransitionLabel| (T@U) Bool)
(declare-fun |AbstractMap.TransitionLabel#Equal| (T@U T@U) Bool)
(declare-fun AbstractMap.Variables.Variables_q (T@U) Bool)
(declare-fun AbstractMap.Variables.stampedMap (T@U) T@U)
(declare-fun |$IsA#AbstractMap.Variables| (T@U) Bool)
(declare-fun |AbstractMap.Variables#Equal| (T@U T@U) Bool)
(declare-fun Tclass.AbstractMap.__default () T@U)
(declare-fun AbstractMap.__default.Query (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Query#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Query#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.Put (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Put#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Put#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.QueryEndLsn (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.QueryEndLsn#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.QueryEndLsn#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.FreezeAs (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.FreezeAs#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.FreezeAs#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.Init (T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Init#canCall| (T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Init#requires| (T@U T@U) Bool)
(declare-fun AbstractMap.__default.Next (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Next#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Next#requires| (T@U T@U T@U) Bool)
(declare-fun |lambda#0| (T@U T@U T@U Bool) T@U)
(declare-fun MapType6Type (T@T T@T) T@T)
(declare-fun MapType6Select (T@U T@U T@U) T@U)
(declare-fun MapType6Store (T@U T@U T@U T@U) T@U)
(declare-fun MapType6TypeInv1 (T@T) T@T)
(declare-fun MapType6TypeInv0 (T@T) T@T)
(declare-fun |lambda#1| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#2| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#3| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#8| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#9| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#12| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#13| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#14| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#15| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#16| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#17| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#18| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#19| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#20| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#21| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#28| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#29| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#32| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#33| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#34| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#35| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#36| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#37| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#38| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#39| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#40| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#41| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#42| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#43| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#44| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#45| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#46| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#47| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#48| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#49| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#50| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#51| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#52| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#53| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#54| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#55| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#56| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#57| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#58| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#59| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#60| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#61| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#62| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#63| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#64| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#65| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#66| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#67| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#68| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#69| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#70| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#71| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#72| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#73| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#74| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#75| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#76| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#77| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#78| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#79| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#80| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#81| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#82| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#83| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#84| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#85| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#86| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#87| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#88| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#89| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#114|
             (T@U Int Int T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U)
             T@U)
(declare-fun |out#0| () T@U)
(declare-fun StartFuelAssert_PagedBetreeRefinement._default.MapApply () T@U)
(declare-fun StartFuel_PagedBetreeRefinement._default.MapApply () T@U)
(declare-fun StartFuelAssert_PagedBetreeRefinement._default.INode () T@U)
(declare-fun StartFuelAssert_PagedBetree.Path.ReplacedChildren () T@U)
(declare-fun StartFuel_PagedBetree.Path.ReplacedChildren () T@U)
(declare-fun StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet () T@U)
(declare-fun StartFuelAssert_Maps._default.MapDisjointUnion3 () T@U)
(declare-fun StartFuel_Maps._default.MapDisjointUnion3 () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnion () T@U)
(declare-fun StartFuel_Maps._default.IMapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnionPreferB () T@U)
(declare-fun StartFuel_Maps._default.IMapUnionPreferB () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnionPreferA () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnion () T@U)
(declare-fun StartFuel_Maps._default.MapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnionPreferB () T@U)
(declare-fun StartFuel_Maps._default.MapUnionPreferB () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnionPreferA () T@U)
(declare-fun StartFuelAssert_Maps._default.MapDisjointUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapRemove1 () T@U)
(declare-fun StartFuel_Maps._default.IMapRemove1 () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapRemove () T@U)
(declare-fun StartFuel_Maps._default.IMapRemove () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapInvert () T@U)
(declare-fun StartFuel_Maps._default.IMapInvert () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemove1Strong () T@U)
(declare-fun StartFuel_Maps._default.MapRemove1Strong () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemoveStrong () T@U)
(declare-fun StartFuel_Maps._default.MapRemoveStrong () T@U)
(declare-fun StartFuelAssert_Sequences._default.fill () T@U)
(declare-fun StartFuel_Sequences._default.fill () T@U)
(declare-fun StartFuelAssert_Sequences._default.seqMax () T@U)
(declare-fun StartFuel_Sequences._default.seqMax () T@U)
(declare-fun StartFuelAssert_Sequences._default.Flatten () T@U)
(declare-fun StartFuel_Sequences._default.Flatten () T@U)
(declare-fun StartFuelAssert_Sequences._default.Unzip () T@U)
(declare-fun StartFuel_Sequences._default.Unzip () T@U)
(declare-fun StartFuelAssert_Sequences._default.Zip () T@U)
(declare-fun StartFuel_Sequences._default.Zip () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndexUpdate () T@U)
(declare-fun StartFuel_Sequences._default.SeqIndexUpdate () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqOfLength () T@U)
(declare-fun StartFuel_Sequences._default.SeqOfLength () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndex () T@U)
(declare-fun StartFuel_Sequences._default.SeqIndex () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndexIterate () T@U)
(declare-fun StartFuelAssert_Sequences._default.IsSuffix () T@U)
(declare-fun StartFuel_Sequences._default.IsSuffix () T@U)
(declare-fun StartFuelAssert_Sequences._default.IsPrefix () T@U)
(declare-fun StartFuel_Sequences._default.IsPrefix () T@U)
(declare-fun StartFuelAssert_Sequences._default.concatSeq () T@U)
(declare-fun StartFuel_Sequences._default.concatSeq () T@U)
(declare-fun StartFuelAssert_Sequences._default.concat3 () T@U)
(declare-fun StartFuel_Sequences._default.concat3 () T@U)
(declare-fun StartFuelAssert_Sequences._default.concat () T@U)
(declare-fun StartFuel_Sequences._default.concat () T@U)
(declare-fun StartFuelAssert_Sequences._default.replace2with1 () T@U)
(declare-fun StartFuel_Sequences._default.replace2with1 () T@U)
(declare-fun StartFuelAssert_Sequences._default.replace1with2 () T@U)
(declare-fun StartFuel_Sequences._default.replace1with2 () T@U)
(declare-fun StartFuelAssert_Sequences._default.insert () T@U)
(declare-fun StartFuel_Sequences._default.insert () T@U)
(declare-fun StartFuelAssert_Sequences._default.RemoveOneValue () T@U)
(declare-fun StartFuel_Sequences._default.RemoveOneValue () T@U)
(declare-fun StartFuelAssert_Sequences._default.remove () T@U)
(declare-fun StartFuel_Sequences._default.remove () T@U)
(declare-fun StartFuelAssert_Sequences._default.ApplyOpaque () T@U)
(declare-fun StartFuel_Sequences._default.ApplyOpaque () T@U)
(declare-fun StartFuelAssert_Sequences._default.Range () T@U)
(declare-fun StartFuel_Sequences._default.Range () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun |receipt#0@@9| () T@U)
(declare-fun $Heap@@50 () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun |b$reqreads#0@0| () Bool)
(assert (and (tickleBool true) (tickleBool false)))
(assert (forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :no-pattern (U_2_int x@@5)
     :no-pattern (U_2_bool x@@5)
     :qid |bg:subtype-refl|)))
(assert (forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (=> (and (= (type y) (type x@@6))
              (= (type z) (type x@@6))
              (UOrdering2 x@@6 y)
              (UOrdering2 y z))
         (UOrdering2 x@@6 z))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|)))
(assert (forall ((x@@7 T@U) (y@@0 T@U))
  (! (=> (= (type y@@0) (type x@@7))
         (=> (and (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7)) (= x@@7 y@@0)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|)))
(assert (let ((a!1 (forall ((arg0@@11 T@T))
             (! (= (Ctor (FieldType arg0@@11)) 9) :qid |ctor:FieldType|)))
      (a!2 (forall ((arg0@@12 T@T))
             (! (= (FieldTypeInv0 (FieldType arg0@@12)) arg0@@12)
                :pattern ((FieldType arg0@@12))
                :qid |typeInv:FieldTypeInv0|))))
  (and (= (Ctor TyType) 6)
       (= (type TBool) TyType)
       (= (type TChar) TyType)
       (= (type TInt) TyType)
       (= (type TReal) TyType)
       (= (type TORDINAL) TyType)
       (= (Ctor TyTagType) 7)
       (= (type TagBool) TyTagType)
       (= (type TagChar) TyTagType)
       (= (type TagInt) TyTagType)
       (= (type TagReal) TyTagType)
       (= (type TagORDINAL) TyTagType)
       (= (type TagSet) TyTagType)
       (= (type TagISet) TyTagType)
       (= (type TagMultiSet) TyTagType)
       (= (type TagSeq) TyTagType)
       (= (type TagMap) TyTagType)
       (= (type TagIMap) TyTagType)
       (= (type TagClass) TyTagType)
       (= (Ctor ClassNameType) 8)
       (= (type class._System.int) ClassNameType)
       (= (type class._System.bool) ClassNameType)
       (= (type class._System.set) ClassNameType)
       (= (type class._System.seq) ClassNameType)
       (= (type class._System.multiset) ClassNameType)
       a!1
       a!2
       (= (type alloc) (FieldType boolType))
       (= (Ctor NameFamilyType) 10)
       (= (type allocName) NameFamilyType)
       (= (type Tagclass._System.nat) TyTagType)
       (= (type class._System.object?) ClassNameType)
       (= (type Tagclass._System.object?) TyTagType)
       (= (type Tagclass._System.object) TyTagType)
       (= (type class._System.array?) ClassNameType)
       (= (type Tagclass._System.array?) TyTagType)
       (= (type Tagclass._System.array) TyTagType)
       (= (type Tagclass._System.___hFunc1) TyTagType)
       (= (type Tagclass._System.___hPartialFunc1) TyTagType)
       (= (type Tagclass._System.___hTotalFunc1) TyTagType)
       (= (type Tagclass._System.___hFunc0) TyTagType)
       (= (type Tagclass._System.___hPartialFunc0) TyTagType)
       (= (type Tagclass._System.___hTotalFunc0) TyTagType)
       (= (type class._System.__default) ClassNameType)
       (= (type Tagclass._System.__default) TyTagType)
       (= (type Tagclass._System.___hFunc2) TyTagType)
       (= (type Tagclass._System.___hPartialFunc2) TyTagType)
       (= (type Tagclass._System.___hTotalFunc2) TyTagType)
       (= (type Tagclass._System.___hFunc4) TyTagType)
       (= (type Tagclass._System.___hPartialFunc4) TyTagType)
       (= (type Tagclass._System.___hTotalFunc4) TyTagType)
       (= (type Tagclass._System.___hFunc3) TyTagType)
       (= (type Tagclass._System.___hPartialFunc3) TyTagType)
       (= (type Tagclass._System.___hTotalFunc3) TyTagType)
       (= (Ctor DtCtorIdType) 11)
       (= (type |##_System._tuple#2._#Make2|) DtCtorIdType)
       (= (type Tagclass._System.Tuple2) TyTagType)
       (= (type class._System.Tuple2) ClassNameType)
       (= (type Tagclass._System.___hFunc2OSO) TyTagType)
       (= (type Tagclass._System.___hPartialFunc2OSO) TyTagType)
       (= (type Tagclass._System.___hTotalFunc2OSO) TyTagType)
       (= (type Tagclass._System.___hFunc3LLOO) TyTagType)
       (= (type Tagclass._System.___hPartialFunc3LLOO) TyTagType)
       (= (type Tagclass._System.___hTotalFunc3LLOO) TyTagType)
       (= (type Tagclass._System.___hFunc1OS) TyTagType)
       (= (type Tagclass._System.___hPartialFunc1OS) TyTagType)
       (= (type Tagclass._System.___hTotalFunc1OS) TyTagType)
       (= (type Tagclass._System.___hFunc0L) TyTagType)
       (= (type Tagclass._System.___hPartialFunc0L) TyTagType)
       (= (type Tagclass._System.___hTotalFunc0L) TyTagType)
       (= (type Tagclass._System.___hFunc2LOO) TyTagType)
       (= (type Tagclass._System.___hPartialFunc2LOO) TyTagType)
       (= (type Tagclass._System.___hTotalFunc2LOO) TyTagType)
       (= (type |##_System._tuple#0._#Make0|) DtCtorIdType)
       (= (type Tagclass._System.Tuple0) TyTagType)
       (= (type class._System.Tuple0) ClassNameType)
       (= (type Tagclass._System.___hFunc1OL) TyTagType)
       (= (type Tagclass._System.___hPartialFunc1OL) TyTagType)
       (= (type Tagclass._System.___hTotalFunc1OL) TyTagType)
       (= (type Tagclass._System.___hFunc1LO) TyTagType)
       (= (type Tagclass._System.___hPartialFunc1LO) TyTagType)
       (= (type Tagclass._System.___hTotalFunc1LO) TyTagType)
       (= (type |##_System._tuple#2OLL._#Make2|) DtCtorIdType)
       (= (type Tagclass._System.Tuple2OLL) TyTagType)
       (= (type class._System.Tuple2OLL) ClassNameType)
       (= (type Tagclass._System.___hFunc3LLOL) TyTagType)
       (= (type Tagclass._System.___hPartialFunc3LLOL) TyTagType)
       (= (type Tagclass._System.___hTotalFunc3LLOL) TyTagType)
       (= (type Tagclass._System.___hFunc2SSO) TyTagType)
       (= (type Tagclass._System.___hPartialFunc2SSO) TyTagType)
       (= (type Tagclass._System.___hTotalFunc2SSO) TyTagType)
       (= (type Tagclass._System.___hFunc2LLO) TyTagType)
       (= (type Tagclass._System.___hPartialFunc2LLO) TyTagType)
       (= (type Tagclass._System.___hTotalFunc2LLO) TyTagType)
       (= (type Tagclass._System.___hFunc1SS) TyTagType)
       (= (type Tagclass._System.___hPartialFunc1SS) TyTagType)
       (= (type Tagclass._System.___hTotalFunc1SS) TyTagType)
       (= (type Tagclass._System.___hFunc1LL) TyTagType)
       (= (type Tagclass._System.___hPartialFunc1LL) TyTagType)
       (= (type Tagclass._System.___hTotalFunc1LL) TyTagType)
       (= (type class.PagedBetreeRefinement.__default) ClassNameType)
       (= (type Tagclass.PagedBetreeRefinement.__default) TyTagType)
       (= (type Tagclass.PagedBetree.BetreeNode) TyTagType)
       (= (type Tagclass.KeyType.Key) TyTagType)
       (= (type Tagclass.PagedBetree.QueryReceipt) TyTagType)
       (= (type Tagclass.PagedBetree.ChildMap) TyTagType)
       (= (type Tagclass.ValueMessage.Message) TyTagType)
       (= (type Tagclass.Buffers.BufferStack) TyTagType)
       (= (type Tagclass.PagedBetree.QueryReceiptLine) TyTagType)
       (= (type Tagclass.TotalKMMapMod.TotalMap) TyTagType)
       (= (type Tagclass.StampedMod.Stamped) TyTagType)
       (= (type Tagclass.PagedBetree.TransitionLabel) TyTagType)
       (= (type Tagclass.AbstractMap.TransitionLabel) TyTagType)
       (= (type Tagclass.MsgHistoryMod.MsgHistory) TyTagType)
       (= (type Tagclass.ValueType.Value) TyTagType)
       (= (type Tagclass.NativeTypes.byte) TyTagType)
       (= (type Tagclass.PagedBetree.Variables) TyTagType)
       (= (type Tagclass.AbstractMap.Variables) TyTagType)
       (= (type Tagclass.MemtableMod.Memtable) TyTagType)
       (= (type Tagclass.Buffers.Buffer) TyTagType)
       (= (type Tagclass.PagedBetree.Path) TyTagType)
       (= (type Tagclass.PagedBetree.Step) TyTagType)
       (= (type Tagclass.MsgHistoryMod.KeyedMessage) TyTagType)
       (= (type |##Options.Option.None|) DtCtorIdType)
       (= (type Tagclass.Options.Option) TyTagType)
       (= (type |##Options.Option.Some|) DtCtorIdType)
       (= (type class.Options.Option) ClassNameType)
       (= (type class.Options.__default) ClassNameType)
       (= (type Tagclass.Options.__default) TyTagType)
       (= (type Tagclass.NativeTypes.sbyte) TyTagType)
       (= (type class.NativeTypes.sbyte) ClassNameType)
       (= (type class.NativeTypes.byte) ClassNameType)
       (= (type Tagclass.NativeTypes.int16) TyTagType)
       (= (type class.NativeTypes.int16) ClassNameType)
       (= (type Tagclass.NativeTypes.uint16) TyTagType)
       (= (type class.NativeTypes.uint16) ClassNameType)
       (= (type Tagclass.NativeTypes.int32) TyTagType)
       (= (type class.NativeTypes.int32) ClassNameType)
       (= (type Tagclass.NativeTypes.uint32) TyTagType)
       (= (type class.NativeTypes.uint32) ClassNameType)
       (= (type Tagclass.NativeTypes.int64) TyTagType)
       (= (type class.NativeTypes.int64) ClassNameType)
       (= (type Tagclass.NativeTypes.uint64) TyTagType)
       (= (type class.NativeTypes.uint64) ClassNameType)
       (= (type Tagclass.NativeTypes.nat8) TyTagType)
       (= (type class.NativeTypes.nat8) ClassNameType)
       (= (type Tagclass.NativeTypes.nat16) TyTagType)
       (= (type class.NativeTypes.nat16) ClassNameType)
       (= (type Tagclass.NativeTypes.nat32) TyTagType)
       (= (type class.NativeTypes.nat32) ClassNameType)
       (= (type Tagclass.NativeTypes.nat64) TyTagType)
       (= (type class.NativeTypes.nat64) ClassNameType)
       (= (type Tagclass.NativeTypes.uint128) TyTagType)
       (= (type class.NativeTypes.uint128) ClassNameType)
       (= (type class.NativeTypes.__default) ClassNameType)
       (= (type Tagclass.NativeTypes.__default) TyTagType)
       (= (type class.KeyType.__default) ClassNameType)
       (= (type Tagclass.KeyType.__default) TyTagType)
       (= (type class.ValueType.__default) ClassNameType)
       (= (type Tagclass.ValueType.__default) TyTagType)
       (= (type class.LinearMaybe.predefined) ClassNameType)
       (= (type class.LinearMaybe.__default) ClassNameType)
       (= (type Tagclass.LinearMaybe.__default) TyTagType)
       (= (type class.LinearExtern.predefined) ClassNameType)
       (= (type class.LinearExtern.__default) ClassNameType)
       (= (type Tagclass.LinearExtern.__default) TyTagType)
       (= (type |##ValueMessage.Delta.NoDelta|) DtCtorIdType)
       (= (type Tagclass.ValueMessage.Delta) TyTagType)
       (= (type class.ValueMessage.Delta) ClassNameType)
       (= (type class.ValueMessage.__default) ClassNameType)
       (= (type Tagclass.ValueMessage.__default) TyTagType)
       (= (type |##ValueMessage.Message.Define|) DtCtorIdType)
       (= (type |##ValueMessage.Message.Update|) DtCtorIdType)
       (= (type class.ValueMessage.Message) ClassNameType)
       (= (type class.TotalKMMapMod.__default) ClassNameType)
       (= (type Tagclass.TotalKMMapMod.__default) TyTagType)
       (= (type class.LSNMod.__default) ClassNameType)
       (= (type Tagclass.LSNMod.__default) TyTagType)
       (= (type |##StampedMod.Stamped.Stamped|) DtCtorIdType)
       (= (type class.StampedMod.Stamped) ClassNameType)
       (= (type class.StampedMod.__default) ClassNameType)
       (= (type Tagclass.StampedMod.__default) TyTagType)
       (= (type class.SequencesLite.__default) ClassNameType)
       (= (type Tagclass.SequencesLite.__default) TyTagType)
       (= (type class.Mathematics.__default) ClassNameType)
       (= (type Tagclass.Mathematics.__default) TyTagType)
       (= (type class.LinearSequence__i.__default) ClassNameType)
       (= (type Tagclass.LinearSequence__i.__default) TyTagType)
       (= (type class.Sequences.__default) ClassNameType)
       (= (type Tagclass.Sequences.__default) TyTagType)
       (= (type class.MapRemove_s.__default) ClassNameType)
       (= (type Tagclass.MapRemove_s.__default) TyTagType)
       (= (type class.Maps.__default) ClassNameType)
       (= (type Tagclass.Maps.__default) TyTagType)
       (= (type |##MsgHistoryMod.KeyedMessage.KeyedMessage|) DtCtorIdType)
       (= (type class.MsgHistoryMod.KeyedMessage) ClassNameType)
       (= (type |##MsgHistoryMod.MsgHistory.MsgHistory|) DtCtorIdType)
       (= (type class.MsgHistoryMod.MsgHistory) ClassNameType)
       (= (type class.MsgHistoryMod.__default) ClassNameType)
       (= (type Tagclass.MsgHistoryMod.__default) TyTagType)
       (= (type |##Buffers.Buffer.Buffer|) DtCtorIdType)
       (= (type class.Buffers.Buffer) ClassNameType)
       (= (type |##Buffers.BufferStack.BufferStack|) DtCtorIdType)
       (= (type class.Buffers.BufferStack) ClassNameType)
       (= (type class.Buffers.__default) ClassNameType)
       (= (type Tagclass.Buffers.__default) TyTagType)
       (= (type |##MemtableMod.Memtable.Memtable|) DtCtorIdType)
       (= (type class.MemtableMod.Memtable) ClassNameType)
       (= (type class.MemtableMod.__default) ClassNameType)
       (= (type Tagclass.MemtableMod.__default) TyTagType)
       (= (type |##PagedBetree.TransitionLabel.QueryLabel|) DtCtorIdType)
       (= (type |##PagedBetree.TransitionLabel.PutLabel|) DtCtorIdType)
       (= (type |##PagedBetree.TransitionLabel.QueryEndLsnLabel|) DtCtorIdType)
       (= (type |##PagedBetree.TransitionLabel.FreezeAsLabel|) DtCtorIdType)
       (= (type |##PagedBetree.TransitionLabel.InternalLabel|) DtCtorIdType)
       (= (type class.PagedBetree.TransitionLabel) ClassNameType)
       (= (type |##PagedBetree.ChildMap.ChildMap|) DtCtorIdType)
       (= (type class.PagedBetree.ChildMap) ClassNameType)
       (= (type |##PagedBetree.BetreeNode.Nil|) DtCtorIdType)
       (= (type |##PagedBetree.BetreeNode.BetreeNode|) DtCtorIdType)
       (= (type class.PagedBetree.BetreeNode) ClassNameType)
       (= (type |##PagedBetree.QueryReceiptLine.QueryReceiptLine|) DtCtorIdType)
       (= (type class.PagedBetree.QueryReceiptLine) ClassNameType)
       (= (type |##PagedBetree.QueryReceipt.QueryReceipt|) DtCtorIdType)
       (= (type class.PagedBetree.QueryReceipt) ClassNameType)
       (= (type |##PagedBetree.Variables.Variables|) DtCtorIdType)
       (= (type class.PagedBetree.Variables) ClassNameType)
       (= (type |##PagedBetree.Path.Path|) DtCtorIdType)
       (= (type class.PagedBetree.Path) ClassNameType)
       (= (type |##PagedBetree.Step.QueryStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.PutStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.QueryEndLsnStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.FreezeAsStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.InternalGrowStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.InternalSplitStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.InternalFlushMemtableStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.InternalFlushStep|) DtCtorIdType)
       (= (type |##PagedBetree.Step.InternalCompactStep|) DtCtorIdType)
       (= (type class.PagedBetree.Step) ClassNameType)
       (= (type class.PagedBetree.__default) ClassNameType)
       (= (type Tagclass.PagedBetree.__default) TyTagType)
       (= (type |##AbstractMap.TransitionLabel.QueryLabel|) DtCtorIdType)
       (= (type |##AbstractMap.TransitionLabel.PutLabel|) DtCtorIdType)
       (= (type |##AbstractMap.TransitionLabel.QueryEndLsnLabel|) DtCtorIdType)
       (= (type |##AbstractMap.TransitionLabel.FreezeAsLabel|) DtCtorIdType)
       (= (type |##AbstractMap.TransitionLabel.InternalLabel|) DtCtorIdType)
       (= (type class.AbstractMap.TransitionLabel) ClassNameType)
       (= (type |##AbstractMap.Variables.Variables|) DtCtorIdType)
       (= (type class.AbstractMap.Variables) ClassNameType)
       (= (type class.AbstractMap.__default) ClassNameType)
       (= (type Tagclass.AbstractMap.__default) TyTagType)
       (= (Ctor TyTagFamilyType) 12)
       (= (type tytagFamily$nat) TyTagFamilyType)
       (= (type tytagFamily$object) TyTagFamilyType)
       (= (type tytagFamily$array) TyTagFamilyType)
       (= (type |tytagFamily$_#Func1|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc1|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc1|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func0|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc0|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc0|) TyTagFamilyType)
       (= (type tytagFamily$_default) TyTagFamilyType)
       (= (type |tytagFamily$_#Func2|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc2|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc2|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func4|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc4|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc4|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func3|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc3|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc3|) TyTagFamilyType)
       (= (type |tytagFamily$_tuple#2|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func2OSO|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc2OSO|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc2OSO|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func3LLOO|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc3LLOO|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc3LLOO|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func1OS|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc1OS|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc1OS|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func0L|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc0L|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc0L|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func2LOO|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc2LOO|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc2LOO|) TyTagFamilyType)
       (= (type |tytagFamily$_tuple#0|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func1OL|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc1OL|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc1OL|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func1LO|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc1LO|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc1LO|) TyTagFamilyType)
       (= (type |tytagFamily$_tuple#2OLL|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func3LLOL|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc3LLOL|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc3LLOL|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func2SSO|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc2SSO|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc2SSO|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func2LLO|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc2LLO|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc2LLO|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func1SS|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc1SS|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc1SS|) TyTagFamilyType)
       (= (type |tytagFamily$_#Func1LL|) TyTagFamilyType)
       (= (type |tytagFamily$_#PartialFunc1LL|) TyTagFamilyType)
       (= (type |tytagFamily$_#TotalFunc1LL|) TyTagFamilyType)
       (= (type tytagFamily$BetreeNode) TyTagFamilyType)
       (= (type tytagFamily$Key) TyTagFamilyType)
       (= (type tytagFamily$QueryReceipt) TyTagFamilyType)
       (= (type tytagFamily$ChildMap) TyTagFamilyType)
       (= (type tytagFamily$Message) TyTagFamilyType)
       (= (type tytagFamily$BufferStack) TyTagFamilyType)
       (= (type tytagFamily$QueryReceiptLine) TyTagFamilyType)
       (= (type tytagFamily$TotalMap) TyTagFamilyType)
       (= (type tytagFamily$Stamped) TyTagFamilyType)
       (= (type tytagFamily$TransitionLabel) TyTagFamilyType)
       (= (type tytagFamily$MsgHistory) TyTagFamilyType)
       (= (type tytagFamily$Value) TyTagFamilyType)
       (= (type tytagFamily$byte) TyTagFamilyType)
       (= (type tytagFamily$Variables) TyTagFamilyType)
       (= (type tytagFamily$Memtable) TyTagFamilyType)
       (= (type tytagFamily$Buffer) TyTagFamilyType)
       (= (type tytagFamily$Path) TyTagFamilyType)
       (= (type tytagFamily$Step) TyTagFamilyType)
       (= (type tytagFamily$KeyedMessage) TyTagFamilyType)
       (= (type tytagFamily$Option) TyTagFamilyType)
       (= (type tytagFamily$sbyte) TyTagFamilyType)
       (= (type tytagFamily$int16) TyTagFamilyType)
       (= (type tytagFamily$uint16) TyTagFamilyType)
       (= (type tytagFamily$int32) TyTagFamilyType)
       (= (type tytagFamily$uint32) TyTagFamilyType)
       (= (type tytagFamily$int64) TyTagFamilyType)
       (= (type tytagFamily$uint64) TyTagFamilyType)
       (= (type tytagFamily$nat8) TyTagFamilyType)
       (= (type tytagFamily$nat16) TyTagFamilyType)
       (= (type tytagFamily$nat32) TyTagFamilyType)
       (= (type tytagFamily$nat64) TyTagFamilyType)
       (= (type tytagFamily$uint128) TyTagFamilyType)
       (= (type tytagFamily$Delta) TyTagFamilyType))))
(assert (distinct TBool
          TChar
          TInt
          TReal
          TORDINAL
          TagBool
          TagChar
          TagInt
          TagReal
          TagORDINAL
          TagSet
          TagISet
          TagMultiSet
          TagSeq
          TagMap
          TagIMap
          TagClass
          class._System.int
          class._System.bool
          class._System.set
          class._System.seq
          class._System.multiset
          alloc
          allocName
          Tagclass._System.nat
          class._System.object?
          Tagclass._System.object?
          Tagclass._System.object
          class._System.array?
          Tagclass._System.array?
          Tagclass._System.array
          Tagclass._System.___hFunc1
          Tagclass._System.___hPartialFunc1
          Tagclass._System.___hTotalFunc1
          Tagclass._System.___hFunc0
          Tagclass._System.___hPartialFunc0
          Tagclass._System.___hTotalFunc0
          class._System.__default
          Tagclass._System.__default
          Tagclass._System.___hFunc2
          Tagclass._System.___hPartialFunc2
          Tagclass._System.___hTotalFunc2
          Tagclass._System.___hFunc4
          Tagclass._System.___hPartialFunc4
          Tagclass._System.___hTotalFunc4
          Tagclass._System.___hFunc3
          Tagclass._System.___hPartialFunc3
          Tagclass._System.___hTotalFunc3
          |##_System._tuple#2._#Make2|
          Tagclass._System.Tuple2
          class._System.Tuple2
          Tagclass._System.___hFunc2OSO
          Tagclass._System.___hPartialFunc2OSO
          Tagclass._System.___hTotalFunc2OSO
          Tagclass._System.___hFunc3LLOO
          Tagclass._System.___hPartialFunc3LLOO
          Tagclass._System.___hTotalFunc3LLOO
          Tagclass._System.___hFunc1OS
          Tagclass._System.___hPartialFunc1OS
          Tagclass._System.___hTotalFunc1OS
          Tagclass._System.___hFunc0L
          Tagclass._System.___hPartialFunc0L
          Tagclass._System.___hTotalFunc0L
          Tagclass._System.___hFunc2LOO
          Tagclass._System.___hPartialFunc2LOO
          Tagclass._System.___hTotalFunc2LOO
          |##_System._tuple#0._#Make0|
          Tagclass._System.Tuple0
          class._System.Tuple0
          Tagclass._System.___hFunc1OL
          Tagclass._System.___hPartialFunc1OL
          Tagclass._System.___hTotalFunc1OL
          Tagclass._System.___hFunc1LO
          Tagclass._System.___hPartialFunc1LO
          Tagclass._System.___hTotalFunc1LO
          |##_System._tuple#2OLL._#Make2|
          Tagclass._System.Tuple2OLL
          class._System.Tuple2OLL
          Tagclass._System.___hFunc3LLOL
          Tagclass._System.___hPartialFunc3LLOL
          Tagclass._System.___hTotalFunc3LLOL
          Tagclass._System.___hFunc2SSO
          Tagclass._System.___hPartialFunc2SSO
          Tagclass._System.___hTotalFunc2SSO
          Tagclass._System.___hFunc2LLO
          Tagclass._System.___hPartialFunc2LLO
          Tagclass._System.___hTotalFunc2LLO
          Tagclass._System.___hFunc1SS
          Tagclass._System.___hPartialFunc1SS
          Tagclass._System.___hTotalFunc1SS
          Tagclass._System.___hFunc1LL
          Tagclass._System.___hPartialFunc1LL
          Tagclass._System.___hTotalFunc1LL
          class.PagedBetreeRefinement.__default
          Tagclass.PagedBetreeRefinement.__default
          Tagclass.PagedBetree.BetreeNode
          Tagclass.KeyType.Key
          Tagclass.PagedBetree.QueryReceipt
          Tagclass.PagedBetree.ChildMap
          Tagclass.ValueMessage.Message
          Tagclass.Buffers.BufferStack
          Tagclass.PagedBetree.QueryReceiptLine
          Tagclass.TotalKMMapMod.TotalMap
          Tagclass.StampedMod.Stamped
          Tagclass.PagedBetree.TransitionLabel
          Tagclass.AbstractMap.TransitionLabel
          Tagclass.MsgHistoryMod.MsgHistory
          Tagclass.ValueType.Value
          Tagclass.NativeTypes.byte
          Tagclass.PagedBetree.Variables
          Tagclass.AbstractMap.Variables
          Tagclass.MemtableMod.Memtable
          Tagclass.Buffers.Buffer
          Tagclass.PagedBetree.Path
          Tagclass.PagedBetree.Step
          Tagclass.MsgHistoryMod.KeyedMessage
          |##Options.Option.None|
          Tagclass.Options.Option
          |##Options.Option.Some|
          class.Options.Option
          class.Options.__default
          Tagclass.Options.__default
          Tagclass.NativeTypes.sbyte
          class.NativeTypes.sbyte
          class.NativeTypes.byte
          Tagclass.NativeTypes.int16
          class.NativeTypes.int16
          Tagclass.NativeTypes.uint16
          class.NativeTypes.uint16
          Tagclass.NativeTypes.int32
          class.NativeTypes.int32
          Tagclass.NativeTypes.uint32
          class.NativeTypes.uint32
          Tagclass.NativeTypes.int64
          class.NativeTypes.int64
          Tagclass.NativeTypes.uint64
          class.NativeTypes.uint64
          Tagclass.NativeTypes.nat8
          class.NativeTypes.nat8
          Tagclass.NativeTypes.nat16
          class.NativeTypes.nat16
          Tagclass.NativeTypes.nat32
          class.NativeTypes.nat32
          Tagclass.NativeTypes.nat64
          class.NativeTypes.nat64
          Tagclass.NativeTypes.uint128
          class.NativeTypes.uint128
          class.NativeTypes.__default
          Tagclass.NativeTypes.__default
          class.KeyType.__default
          Tagclass.KeyType.__default
          class.ValueType.__default
          Tagclass.ValueType.__default
          class.LinearMaybe.predefined
          class.LinearMaybe.__default
          Tagclass.LinearMaybe.__default
          class.LinearExtern.predefined
          class.LinearExtern.__default
          Tagclass.LinearExtern.__default
          |##ValueMessage.Delta.NoDelta|
          Tagclass.ValueMessage.Delta
          class.ValueMessage.Delta
          class.ValueMessage.__default
          Tagclass.ValueMessage.__default
          |##ValueMessage.Message.Define|
          |##ValueMessage.Message.Update|
          class.ValueMessage.Message
          class.TotalKMMapMod.__default
          Tagclass.TotalKMMapMod.__default
          class.LSNMod.__default
          Tagclass.LSNMod.__default
          |##StampedMod.Stamped.Stamped|
          class.StampedMod.Stamped
          class.StampedMod.__default
          Tagclass.StampedMod.__default
          class.SequencesLite.__default
          Tagclass.SequencesLite.__default
          class.Mathematics.__default
          Tagclass.Mathematics.__default
          class.LinearSequence__i.__default
          Tagclass.LinearSequence__i.__default
          class.Sequences.__default
          Tagclass.Sequences.__default
          class.MapRemove_s.__default
          Tagclass.MapRemove_s.__default
          class.Maps.__default
          Tagclass.Maps.__default
          |##MsgHistoryMod.KeyedMessage.KeyedMessage|
          class.MsgHistoryMod.KeyedMessage
          |##MsgHistoryMod.MsgHistory.MsgHistory|
          class.MsgHistoryMod.MsgHistory
          class.MsgHistoryMod.__default
          Tagclass.MsgHistoryMod.__default
          |##Buffers.Buffer.Buffer|
          class.Buffers.Buffer
          |##Buffers.BufferStack.BufferStack|
          class.Buffers.BufferStack
          class.Buffers.__default
          Tagclass.Buffers.__default
          |##MemtableMod.Memtable.Memtable|
          class.MemtableMod.Memtable
          class.MemtableMod.__default
          Tagclass.MemtableMod.__default
          |##PagedBetree.TransitionLabel.QueryLabel|
          |##PagedBetree.TransitionLabel.PutLabel|
          |##PagedBetree.TransitionLabel.QueryEndLsnLabel|
          |##PagedBetree.TransitionLabel.FreezeAsLabel|
          |##PagedBetree.TransitionLabel.InternalLabel|
          class.PagedBetree.TransitionLabel
          |##PagedBetree.ChildMap.ChildMap|
          class.PagedBetree.ChildMap
          |##PagedBetree.BetreeNode.Nil|
          |##PagedBetree.BetreeNode.BetreeNode|
          class.PagedBetree.BetreeNode
          |##PagedBetree.QueryReceiptLine.QueryReceiptLine|
          class.PagedBetree.QueryReceiptLine
          |##PagedBetree.QueryReceipt.QueryReceipt|
          class.PagedBetree.QueryReceipt
          |##PagedBetree.Variables.Variables|
          class.PagedBetree.Variables
          |##PagedBetree.Path.Path|
          class.PagedBetree.Path
          |##PagedBetree.Step.QueryStep|
          |##PagedBetree.Step.PutStep|
          |##PagedBetree.Step.QueryEndLsnStep|
          |##PagedBetree.Step.FreezeAsStep|
          |##PagedBetree.Step.InternalGrowStep|
          |##PagedBetree.Step.InternalSplitStep|
          |##PagedBetree.Step.InternalFlushMemtableStep|
          |##PagedBetree.Step.InternalFlushStep|
          |##PagedBetree.Step.InternalCompactStep|
          class.PagedBetree.Step
          class.PagedBetree.__default
          Tagclass.PagedBetree.__default
          |##AbstractMap.TransitionLabel.QueryLabel|
          |##AbstractMap.TransitionLabel.PutLabel|
          |##AbstractMap.TransitionLabel.QueryEndLsnLabel|
          |##AbstractMap.TransitionLabel.FreezeAsLabel|
          |##AbstractMap.TransitionLabel.InternalLabel|
          class.AbstractMap.TransitionLabel
          |##AbstractMap.Variables.Variables|
          class.AbstractMap.Variables
          class.AbstractMap.__default
          Tagclass.AbstractMap.__default
          tytagFamily$nat
          tytagFamily$object
          tytagFamily$array
          |tytagFamily$_#Func1|
          |tytagFamily$_#PartialFunc1|
          |tytagFamily$_#TotalFunc1|
          |tytagFamily$_#Func0|
          |tytagFamily$_#PartialFunc0|
          |tytagFamily$_#TotalFunc0|
          tytagFamily$_default
          |tytagFamily$_#Func2|
          |tytagFamily$_#PartialFunc2|
          |tytagFamily$_#TotalFunc2|
          |tytagFamily$_#Func4|
          |tytagFamily$_#PartialFunc4|
          |tytagFamily$_#TotalFunc4|
          |tytagFamily$_#Func3|
          |tytagFamily$_#PartialFunc3|
          |tytagFamily$_#TotalFunc3|
          |tytagFamily$_tuple#2|
          |tytagFamily$_#Func2OSO|
          |tytagFamily$_#PartialFunc2OSO|
          |tytagFamily$_#TotalFunc2OSO|
          |tytagFamily$_#Func3LLOO|
          |tytagFamily$_#PartialFunc3LLOO|
          |tytagFamily$_#TotalFunc3LLOO|
          |tytagFamily$_#Func1OS|
          |tytagFamily$_#PartialFunc1OS|
          |tytagFamily$_#TotalFunc1OS|
          |tytagFamily$_#Func0L|
          |tytagFamily$_#PartialFunc0L|
          |tytagFamily$_#TotalFunc0L|
          |tytagFamily$_#Func2LOO|
          |tytagFamily$_#PartialFunc2LOO|
          |tytagFamily$_#TotalFunc2LOO|
          |tytagFamily$_tuple#0|
          |tytagFamily$_#Func1OL|
          |tytagFamily$_#PartialFunc1OL|
          |tytagFamily$_#TotalFunc1OL|
          |tytagFamily$_#Func1LO|
          |tytagFamily$_#PartialFunc1LO|
          |tytagFamily$_#TotalFunc1LO|
          |tytagFamily$_tuple#2OLL|
          |tytagFamily$_#Func3LLOL|
          |tytagFamily$_#PartialFunc3LLOL|
          |tytagFamily$_#TotalFunc3LLOL|
          |tytagFamily$_#Func2SSO|
          |tytagFamily$_#PartialFunc2SSO|
          |tytagFamily$_#TotalFunc2SSO|
          |tytagFamily$_#Func2LLO|
          |tytagFamily$_#PartialFunc2LLO|
          |tytagFamily$_#TotalFunc2LLO|
          |tytagFamily$_#Func1SS|
          |tytagFamily$_#PartialFunc1SS|
          |tytagFamily$_#TotalFunc1SS|
          |tytagFamily$_#Func1LL|
          |tytagFamily$_#PartialFunc1LL|
          |tytagFamily$_#TotalFunc1LL|
          tytagFamily$BetreeNode
          tytagFamily$Key
          tytagFamily$QueryReceipt
          tytagFamily$ChildMap
          tytagFamily$Message
          tytagFamily$BufferStack
          tytagFamily$QueryReceiptLine
          tytagFamily$TotalMap
          tytagFamily$Stamped
          tytagFamily$TransitionLabel
          tytagFamily$MsgHistory
          tytagFamily$Value
          tytagFamily$byte
          tytagFamily$Variables
          tytagFamily$Memtable
          tytagFamily$Buffer
          tytagFamily$Path
          tytagFamily$Step
          tytagFamily$KeyedMessage
          tytagFamily$Option
          tytagFamily$sbyte
          tytagFamily$int16
          tytagFamily$uint16
          tytagFamily$int32
          tytagFamily$uint32
          tytagFamily$int64
          tytagFamily$uint64
          tytagFamily$nat8
          tytagFamily$nat16
          tytagFamily$nat32
          tytagFamily$nat64
          tytagFamily$uint128
          tytagFamily$Delta))
(assert $$Language$Dafny)
(assert (forall ((arg0@@13 Int))
  (! (= (type (TBitvector arg0@@13)) TyType)
     :pattern ((TBitvector arg0@@13))
     :qid |funType:TBitvector|)))
(assert (forall ((w Int))
  (! (= (Inv0_TBitvector (TBitvector w)) w)
     :pattern ((TBitvector w))
     :skolemid |347|
     :qid |DafnyPreludebpl.34:15|)))
(assert (let ((a!1 (forall ((arg0@@14 T@U))
             (! (= (type (TSet arg0@@14)) TyType)
                :pattern ((TSet arg0@@14))
                :qid |funType:TSet|)))
      (a!2 (forall ((arg0@@15 T@U))
             (! (= (type (Inv0_TSet arg0@@15)) TyType)
                :pattern ((Inv0_TSet arg0@@15))
                :qid |funType:Inv0_TSet|))))
  (and a!1 a!2)))
(assert (forall ((t T@U))
  (! (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t))
     :pattern ((TSet t))
     :skolemid |348|
     :qid |DafnyPreludebpl.36:15|)))
(assert (let ((a!1 (forall ((arg0@@16 T@U))
             (! (= (type (TISet arg0@@16)) TyType)
                :pattern ((TISet arg0@@16))
                :qid |funType:TISet|)))
      (a!2 (forall ((arg0@@17 T@U))
             (! (= (type (Inv0_TISet arg0@@17)) TyType)
                :pattern ((Inv0_TISet arg0@@17))
                :qid |funType:Inv0_TISet|))))
  (and a!1 a!2)))
(assert (forall ((t@@0 T@U))
  (! (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0))
     :pattern ((TISet t@@0))
     :skolemid |349|
     :qid |DafnyPreludebpl.38:15|)))
(assert (let ((a!1 (forall ((arg0@@18 T@U))
             (! (= (type (TSeq arg0@@18)) TyType)
                :pattern ((TSeq arg0@@18))
                :qid |funType:TSeq|)))
      (a!2 (forall ((arg0@@19 T@U))
             (! (= (type (Inv0_TSeq arg0@@19)) TyType)
                :pattern ((Inv0_TSeq arg0@@19))
                :qid |funType:Inv0_TSeq|))))
  (and a!1 a!2)))
(assert (forall ((t@@1 T@U))
  (! (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1))
     :pattern ((TSeq t@@1))
     :skolemid |350|
     :qid |DafnyPreludebpl.40:15|)))
(assert (let ((a!1 (forall ((arg0@@20 T@U))
             (! (= (type (TMultiSet arg0@@20)) TyType)
                :pattern ((TMultiSet arg0@@20))
                :qid |funType:TMultiSet|)))
      (a!2 (forall ((arg0@@21 T@U))
             (! (= (type (Inv0_TMultiSet arg0@@21)) TyType)
                :pattern ((Inv0_TMultiSet arg0@@21))
                :qid |funType:Inv0_TMultiSet|))))
  (and a!1 a!2)))
(assert (forall ((t@@2 T@U))
  (! (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2))
     :pattern ((TMultiSet t@@2))
     :skolemid |351|
     :qid |DafnyPreludebpl.42:15|)))
(assert (let ((a!1 (forall ((arg0@@22 T@U) (arg1 T@U))
             (! (= (type (TMap arg0@@22 arg1)) TyType)
                :pattern ((TMap arg0@@22 arg1))
                :qid |funType:TMap|)))
      (a!2 (forall ((arg0@@23 T@U))
             (! (= (type (Inv0_TMap arg0@@23)) TyType)
                :pattern ((Inv0_TMap arg0@@23))
                :qid |funType:Inv0_TMap|))))
  (and a!1 a!2)))
(assert (forall ((t@@3 T@U) (u T@U))
  (! (=> (and (= (type t@@3) TyType) (= (type u) TyType))
         (= (Inv0_TMap (TMap t@@3 u)) t@@3))
     :pattern ((TMap t@@3 u))
     :skolemid |352|
     :qid |DafnyPreludebpl.45:15|)))
(assert (forall ((arg0@@24 T@U))
  (! (= (type (Inv1_TMap arg0@@24)) TyType)
     :pattern ((Inv1_TMap arg0@@24))
     :qid |funType:Inv1_TMap|)))
(assert (forall ((t@@4 T@U) (u@@0 T@U))
  (! (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType))
         (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0))
     :pattern ((TMap t@@4 u@@0))
     :skolemid |353|
     :qid |DafnyPreludebpl.46:15|)))
(assert (let ((a!1 (forall ((arg0@@25 T@U) (arg1@@0 T@U))
             (! (= (type (TIMap arg0@@25 arg1@@0)) TyType)
                :pattern ((TIMap arg0@@25 arg1@@0))
                :qid |funType:TIMap|)))
      (a!2 (forall ((arg0@@26 T@U))
             (! (= (type (Inv0_TIMap arg0@@26)) TyType)
                :pattern ((Inv0_TIMap arg0@@26))
                :qid |funType:Inv0_TIMap|))))
  (and a!1 a!2)))
(assert (forall ((t@@5 T@U) (u@@1 T@U))
  (! (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType))
         (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5))
     :pattern ((TIMap t@@5 u@@1))
     :skolemid |354|
     :qid |DafnyPreludebpl.49:15|)))
(assert (forall ((arg0@@27 T@U))
  (! (= (type (Inv1_TIMap arg0@@27)) TyType)
     :pattern ((Inv1_TIMap arg0@@27))
     :qid |funType:Inv1_TIMap|)))
(assert (forall ((t@@6 T@U) (u@@2 T@U))
  (! (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType))
         (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2))
     :pattern ((TIMap t@@6 u@@2))
     :skolemid |355|
     :qid |DafnyPreludebpl.50:15|)))
(assert (forall ((arg0@@28 T@U))
  (! (= (type (Tag arg0@@28)) TyTagType)
     :pattern ((Tag arg0@@28))
     :qid |funType:Tag|)))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TReal) TagReal))
(assert (= (Tag TORDINAL) TagORDINAL))
(assert (forall ((t@@7 T@U))
  (! (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet))
     :pattern ((TSet t@@7))
     :skolemid |356|
     :qid |DafnyPreludebpl.76:15|)))
(assert (forall ((t@@8 T@U))
  (! (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet))
     :pattern ((TISet t@@8))
     :skolemid |357|
     :qid |DafnyPreludebpl.77:15|)))
(assert (forall ((t@@9 T@U))
  (! (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet))
     :pattern ((TMultiSet t@@9))
     :skolemid |358|
     :qid |DafnyPreludebpl.78:15|)))
(assert (forall ((t@@10 T@U))
  (! (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq))
     :pattern ((TSeq t@@10))
     :skolemid |359|
     :qid |DafnyPreludebpl.79:15|)))
(assert (forall ((t@@11 T@U) (u@@3 T@U))
  (! (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType))
         (= (Tag (TMap t@@11 u@@3)) TagMap))
     :pattern ((TMap t@@11 u@@3))
     :skolemid |360|
     :qid |DafnyPreludebpl.80:15|)))
(assert (forall ((t@@12 T@U) (u@@4 T@U))
  (! (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType))
         (= (Tag (TIMap t@@12 u@@4)) TagIMap))
     :pattern ((TIMap t@@12 u@@4))
     :skolemid |361|
     :qid |DafnyPreludebpl.81:15|)))
(assert (forall ((arg0@@29 T@U))
  (! (= (type (Lit arg0@@29)) (type arg0@@29))
     :pattern ((Lit arg0@@29))
     :qid |funType:Lit|)))
(assert (forall ((x@@8 T@U))
  (! (= (Lit x@@8) x@@8)
     :pattern ((Lit x@@8))
     :skolemid |362|
     :qid |DafnyPreludebpl.89:29|)))
(assert (let ((a!1 (forall ((arg0@@30 T@U))
             (! (= (type ($Box arg0@@30)) BoxType)
                :pattern (($Box arg0@@30))
                :qid |funType:$Box|))))
  (and (= (Ctor BoxType) 13) a!1)))
(assert (forall ((x@@9 T@U))
  (! (= ($Box (Lit x@@9)) (Lit ($Box x@@9)))
     :pattern (($Box (Lit x@@9)))
     :skolemid |363|
     :qid |DafnyPreludebpl.90:18|)))
(assert (forall ((x@@10 Int))
  (! (= (LitInt x@@10) x@@10)
     :pattern ((LitInt x@@10))
     :skolemid |364|
     :qid |DafnyPreludebpl.95:29|)))
(assert (forall ((x@@11 Int))
  (! (= ($Box (int_2_U (LitInt x@@11))) (Lit ($Box (int_2_U x@@11))))
     :pattern (($Box (int_2_U (LitInt x@@11))))
     :skolemid |365|
     :qid |DafnyPreludebpl.96:15|)))
(assert (forall ((x@@12 Real))
  (! (= (LitReal x@@12) x@@12)
     :pattern ((LitReal x@@12))
     :skolemid |366|
     :qid |DafnyPreludebpl.97:30|)))
(assert (forall ((x@@13 Real))
  (! (= ($Box (real_2_U (LitReal x@@13))) (Lit ($Box (real_2_U x@@13))))
     :pattern (($Box (real_2_U (LitReal x@@13))))
     :skolemid |367|
     :qid |DafnyPreludebpl.98:15|)))
(assert (let ((a!1 (forall ((arg0@@31 Int))
             (! (= (type (|char#FromInt| arg0@@31)) charType)
                :pattern ((|char#FromInt| arg0@@31))
                :qid |funType:char#FromInt|))))
  (and (= (Ctor charType) 14) a!1)))
(assert (forall ((ch T@U))
  (! (let ((a!1 (and (= (|char#FromInt| (|char#ToInt| ch)) ch)
                     (<= 0 (|char#ToInt| ch))
                     (< (|char#ToInt| ch) 65536))))
       (=> (= (type ch) charType) a!1))
     :pattern ((|char#ToInt| ch))
     :skolemid |368|
     :qid |DafnyPreludebpl.107:15|)))
(assert (forall ((n Int))
  (! (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n))
     :pattern ((|char#FromInt| n))
     :skolemid |369|
     :qid |DafnyPreludebpl.111:15|)))
(assert (forall ((arg0@@32 T@U) (arg1@@1 T@U))
  (! (= (type (|char#Plus| arg0@@32 arg1@@1)) charType)
     :pattern ((|char#Plus| arg0@@32 arg1@@1))
     :qid |funType:char#Plus|)))
(assert (forall ((a T@U) (b T@U))
  (! (let ((a!1 (= (|char#Plus| a b)
                   (|char#FromInt| (+ (|char#ToInt| a) (|char#ToInt| b))))))
       (=> (and (= (type a) charType) (= (type b) charType)) a!1))
     :pattern ((|char#Plus| a b))
     :skolemid |370|
     :qid |DafnyPreludebpl.117:15|)))
(assert (forall ((arg0@@33 T@U) (arg1@@2 T@U))
  (! (= (type (|char#Minus| arg0@@33 arg1@@2)) charType)
     :pattern ((|char#Minus| arg0@@33 arg1@@2))
     :qid |funType:char#Minus|)))
(assert (forall ((a@@0 T@U) (b@@0 T@U))
  (! (let ((a!1 (= (|char#Minus| a@@0 b@@0)
                   (|char#FromInt| (- (|char#ToInt| a@@0) (|char#ToInt| b@@0))))))
       (=> (and (= (type a@@0) charType) (= (type b@@0) charType)) a!1))
     :pattern ((|char#Minus| a@@0 b@@0))
     :skolemid |371|
     :qid |DafnyPreludebpl.120:15|)))
(assert (forall ((T@@0 T@T) (arg0@@34 T@U))
  (! (= (type ($Unbox T@@0 arg0@@34)) T@@0)
     :pattern (($Unbox T@@0 arg0@@34))
     :qid |funType:$Unbox|)))
(assert (forall ((x@@14 T@U))
  (! (= ($Unbox (type x@@14) ($Box x@@14)) x@@14)
     :pattern (($Box x@@14))
     :skolemid |372|
     :qid |DafnyPreludebpl.141:18|)))
(assert (forall ((bx T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx)) bx)
                     ($Is ($Unbox intType bx) TInt))))
       (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) a!1))
     :pattern (($IsBox bx TInt))
     :skolemid |373|
     :qid |DafnyPreludebpl.143:15|)))
(assert (forall ((bx@@0 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox realType bx@@0)) bx@@0)
                     ($Is ($Unbox realType bx@@0) TReal))))
       (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TReal)) a!1))
     :pattern (($IsBox bx@@0 TReal))
     :skolemid |374|
     :qid |DafnyPreludebpl.146:15|)))
(assert (forall ((bx@@1 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox boolType bx@@1)) bx@@1)
                     ($Is ($Unbox boolType bx@@1) TBool))))
       (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TBool)) a!1))
     :pattern (($IsBox bx@@1 TBool))
     :skolemid |375|
     :qid |DafnyPreludebpl.149:15|)))
(assert (forall ((bx@@2 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox charType bx@@2)) bx@@2)
                     ($Is ($Unbox charType bx@@2) TChar))))
       (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TChar)) a!1))
     :pattern (($IsBox bx@@2 TChar))
     :skolemid |376|
     :qid |DafnyPreludebpl.152:15|)))
(assert (let ((a!1 (forall ((arg0@@35 T@T) (arg1@@3 T@T))
             (! (= (Ctor (MapType0Type arg0@@35 arg1@@3)) 15)
                :qid |ctor:MapType0Type|)))
      (a!2 (forall ((arg0@@36 T@T) (arg1@@4 T@T))
             (! (= (MapType0TypeInv0 (MapType0Type arg0@@36 arg1@@4)) arg0@@36)
                :pattern ((MapType0Type arg0@@36 arg1@@4))
                :qid |typeInv:MapType0TypeInv0|)))
      (a!3 (forall ((arg0@@37 T@T) (arg1@@5 T@T))
             (! (= (MapType0TypeInv1 (MapType0Type arg0@@37 arg1@@5)) arg1@@5)
                :pattern ((MapType0Type arg0@@37 arg1@@5))
                :qid |typeInv:MapType0TypeInv1|)))
      (a!4 (forall ((arg0@@38 T@U) (arg1@@6 T@U))
             (! (= (type (MapType0Select arg0@@38 arg1@@6))
                   (MapType0TypeInv1 (type arg0@@38)))
                :pattern ((MapType0Select arg0@@38 arg1@@6))
                :qid |funType:MapType0Select|)))
      (a!5 (forall ((arg0@@39 T@U) (arg1@@7 T@U) (arg2 T@U))
             (! (= (type (MapType0Store arg0@@39 arg1@@7 arg2))
                   (MapType0Type (type arg1@@7) (type arg2)))
                :pattern ((MapType0Store arg0@@39 arg1@@7 arg2))
                :qid |funType:MapType0Store|)))
      (a!6 (forall ((m T@U) (x0 T@U) (val T@U))
             (! (=> (= (type val) (MapType0TypeInv1 (type m)))
                    (= (MapType0Select (MapType0Store m x0 val) x0) val))
                :weight 0
                :qid |mapAx0:MapType0Select|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U))
         (! (let ((a!1 (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0)
                          (MapType0Select m@@0 y0))))
              (or (= x0@@0 y0) a!1))
            :weight 0
            :qid |mapAx1:MapType0Select:0|))
       (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U))
         (! (let ((a!1 (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1)
                                          y0@@0)
                          (MapType0Select m@@1 y0@@0))))
              (or true a!1))
            :weight 0
            :qid |mapAx2:MapType0Select|)))))
(assert (forall ((bx@@3 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@3)) bx@@3)
                     ($Is ($Unbox (MapType0Type BoxType boolType) bx@@3)
                          (TBitvector 0)))))
       (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 (TBitvector 0))) a!1))
     :pattern (($IsBox bx@@3 (TBitvector 0)))
     :skolemid |377|
     :qid |DafnyPreludebpl.158:15|)))
(assert (forall ((bx@@4 T@U) (t@@13 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4)
                          (TSet t@@13)))))
       (=> (and (= (type bx@@4) BoxType)
                (= (type t@@13) TyType)
                ($IsBox bx@@4 (TSet t@@13)))
           a!2)))
     :pattern (($IsBox bx@@4 (TSet t@@13)))
     :skolemid |378|
     :qid |DafnyPreludebpl.162:15|)))
(assert (forall ((bx@@5 T@U) (t@@14 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5)
                          (TISet t@@14)))))
       (=> (and (= (type bx@@5) BoxType)
                (= (type t@@14) TyType)
                ($IsBox bx@@5 (TISet t@@14)))
           a!2)))
     :pattern (($IsBox bx@@5 (TISet t@@14)))
     :skolemid |379|
     :qid |DafnyPreludebpl.165:15|)))
(assert (forall ((bx@@6 T@U) (t@@15 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (MapType0Type BoxType intType) bx@@6)
                          (TMultiSet t@@15)))))
       (=> (and (= (type bx@@6) BoxType)
                (= (type t@@15) TyType)
                ($IsBox bx@@6 (TMultiSet t@@15)))
           a!2)))
     :pattern (($IsBox bx@@6 (TMultiSet t@@15)))
     :skolemid |380|
     :qid |DafnyPreludebpl.168:15|)))
(assert (let ((a!1 (forall ((arg0@@40 T@T))
             (! (= (Ctor (SeqType arg0@@40)) 16) :qid |ctor:SeqType|)))
      (a!2 (forall ((arg0@@41 T@T))
             (! (= (SeqTypeInv0 (SeqType arg0@@41)) arg0@@41)
                :pattern ((SeqType arg0@@41))
                :qid |typeInv:SeqTypeInv0|))))
  (and a!1 a!2)))
(assert (forall ((bx@@7 T@U) (t@@16 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7)))
     (let ((a!2 (and a!1 ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16)))))
       (=> (and (= (type bx@@7) BoxType)
                (= (type t@@16) TyType)
                ($IsBox bx@@7 (TSeq t@@16)))
           a!2)))
     :pattern (($IsBox bx@@7 (TSeq t@@16)))
     :skolemid |381|
     :qid |DafnyPreludebpl.171:15|)))
(assert (let ((a!1 (forall ((arg0@@42 T@T) (arg1@@8 T@T))
             (! (= (Ctor (MapType arg0@@42 arg1@@8)) 17) :qid |ctor:MapType|)))
      (a!2 (forall ((arg0@@43 T@T) (arg1@@9 T@T))
             (! (= (MapTypeInv0 (MapType arg0@@43 arg1@@9)) arg0@@43)
                :pattern ((MapType arg0@@43 arg1@@9))
                :qid |typeInv:MapTypeInv0|)))
      (a!3 (forall ((arg0@@44 T@T) (arg1@@10 T@T))
             (! (= (MapTypeInv1 (MapType arg0@@44 arg1@@10)) arg1@@10)
                :pattern ((MapType arg0@@44 arg1@@10))
                :qid |typeInv:MapTypeInv1|))))
  (and a!1 a!2 a!3)))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (MapType BoxType BoxType) bx@@8)
                          (TMap s t@@17)))))
       (=> (and (= (type bx@@8) BoxType)
                (= (type s) TyType)
                (= (type t@@17) TyType)
                ($IsBox bx@@8 (TMap s t@@17)))
           a!2)))
     :pattern (($IsBox bx@@8 (TMap s t@@17)))
     :skolemid |382|
     :qid |DafnyPreludebpl.174:15|)))
(assert (let ((a!1 (forall ((arg0@@45 T@T) (arg1@@11 T@T))
             (! (= (Ctor (IMapType arg0@@45 arg1@@11)) 18) :qid |ctor:IMapType|)))
      (a!2 (forall ((arg0@@46 T@T) (arg1@@12 T@T))
             (! (= (IMapTypeInv0 (IMapType arg0@@46 arg1@@12)) arg0@@46)
                :pattern ((IMapType arg0@@46 arg1@@12))
                :qid |typeInv:IMapTypeInv0|)))
      (a!3 (forall ((arg0@@47 T@T) (arg1@@13 T@T))
             (! (= (IMapTypeInv1 (IMapType arg0@@47 arg1@@13)) arg1@@13)
                :pattern ((IMapType arg0@@47 arg1@@13))
                :qid |typeInv:IMapTypeInv1|))))
  (and a!1 a!2 a!3)))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (IMapType BoxType BoxType) bx@@9)
                          (TIMap s@@0 t@@18)))))
       (=> (and (= (type bx@@9) BoxType)
                (= (type s@@0) TyType)
                (= (type t@@18) TyType)
                ($IsBox bx@@9 (TIMap s@@0 t@@18)))
           a!2)))
     :pattern (($IsBox bx@@9 (TIMap s@@0 t@@18)))
     :skolemid |383|
     :qid |DafnyPreludebpl.177:15|)))
(assert (forall ((v T@U) (t@@19 T@U))
  (! (=> (= (type t@@19) TyType) (= ($IsBox ($Box v) t@@19) ($Is v t@@19)))
     :pattern (($IsBox ($Box v) t@@19))
     :skolemid |384|
     :qid |DafnyPreludebpl.181:18|)))
(assert (let ((a!1 (forall ((arg0@@48 T@U) (arg1@@14 T@U))
             (! (= (type (MapType1Select arg0@@48 arg1@@14))
                   (FieldTypeInv0 (type arg1@@14)))
                :pattern ((MapType1Select arg0@@48 arg1@@14))
                :qid |funType:MapType1Select|)))
      (a!2 (forall ((arg0@@49 T@U) (arg1@@15 T@U) (arg2@@0 T@U))
             (! (= (type (MapType1Store arg0@@49 arg1@@15 arg2@@0))
                   MapType1Type)
                :pattern ((MapType1Store arg0@@49 arg1@@15 arg2@@0))
                :qid |funType:MapType1Store|)))
      (a!3 (forall ((m@@2 T@U) (x0@@2 T@U) (val@@2 T@U))
             (! (=> (= (type val@@2) (FieldTypeInv0 (type x0@@2)))
                    (= (MapType1Select (MapType1Store m@@2 x0@@2 val@@2) x0@@2)
                       val@@2))
                :weight 0
                :qid |mapAx0:MapType1Select|))))
  (and a!1
       (= (Ctor MapType1Type) 19)
       a!2
       a!3
       (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (y0@@1 T@U))
         (! (let ((a!1 (= (MapType1Select (MapType1Store m@@3 x0@@3 val@@3)
                                          y0@@1)
                          (MapType1Select m@@3 y0@@1))))
              (or (= x0@@3 y0@@1) a!1))
            :weight 0
            :qid |mapAx1:MapType1Select:0|))
       (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (y0@@2 T@U))
         (! (let ((a!1 (= (MapType1Select (MapType1Store m@@4 x0@@4 val@@4)
                                          y0@@2)
                          (MapType1Select m@@4 y0@@2))))
              (or true a!1))
            :weight 0
            :qid |mapAx2:MapType1Select|))
       (= (Ctor refType) 20))))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U))
  (! (=> (and (= (type t@@20) TyType)
              (= (type h) (MapType0Type refType MapType1Type)))
         (= ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)))
     :pattern (($IsAllocBox ($Box v@@0) t@@20 h))
     :skolemid |385|
     :qid |DafnyPreludebpl.184:18|)))
(assert (forall ((v@@1 T@U))
  (! (=> (= (type v@@1) intType) ($Is v@@1 TInt))
     :pattern (($Is v@@1 TInt))
     :skolemid |386|
     :qid |DafnyPreludebpl.202:14|)))
(assert (forall ((v@@2 T@U))
  (! (=> (= (type v@@2) realType) ($Is v@@2 TReal))
     :pattern (($Is v@@2 TReal))
     :skolemid |387|
     :qid |DafnyPreludebpl.203:14|)))
(assert (forall ((v@@3 T@U))
  (! (=> (= (type v@@3) boolType) ($Is v@@3 TBool))
     :pattern (($Is v@@3 TBool))
     :skolemid |388|
     :qid |DafnyPreludebpl.204:14|)))
(assert (forall ((v@@4 T@U))
  (! (=> (= (type v@@4) charType) ($Is v@@4 TChar))
     :pattern (($Is v@@4 TChar))
     :skolemid |389|
     :qid |DafnyPreludebpl.205:14|)))
(assert (forall ((v@@5 T@U))
  (! (=> (= (type v@@5) BoxType) ($Is v@@5 TORDINAL))
     :pattern (($Is v@@5 TORDINAL))
     :skolemid |390|
     :qid |DafnyPreludebpl.206:14|)))
(assert (forall ((h@@0 T@U) (v@@6 T@U))
  (! (=> (and (= (type h@@0) (MapType0Type refType MapType1Type))
              (= (type v@@6) intType))
         ($IsAlloc v@@6 TInt h@@0))
     :pattern (($IsAlloc v@@6 TInt h@@0))
     :skolemid |391|
     :qid |DafnyPreludebpl.208:14|)))
(assert (forall ((h@@1 T@U) (v@@7 T@U))
  (! (=> (and (= (type h@@1) (MapType0Type refType MapType1Type))
              (= (type v@@7) realType))
         ($IsAlloc v@@7 TReal h@@1))
     :pattern (($IsAlloc v@@7 TReal h@@1))
     :skolemid |392|
     :qid |DafnyPreludebpl.209:14|)))
(assert (forall ((h@@2 T@U) (v@@8 T@U))
  (! (=> (and (= (type h@@2) (MapType0Type refType MapType1Type))
              (= (type v@@8) boolType))
         ($IsAlloc v@@8 TBool h@@2))
     :pattern (($IsAlloc v@@8 TBool h@@2))
     :skolemid |393|
     :qid |DafnyPreludebpl.210:14|)))
(assert (forall ((h@@3 T@U) (v@@9 T@U))
  (! (=> (and (= (type h@@3) (MapType0Type refType MapType1Type))
              (= (type v@@9) charType))
         ($IsAlloc v@@9 TChar h@@3))
     :pattern (($IsAlloc v@@9 TChar h@@3))
     :skolemid |394|
     :qid |DafnyPreludebpl.211:14|)))
(assert (forall ((h@@4 T@U) (v@@10 T@U))
  (! (=> (and (= (type h@@4) (MapType0Type refType MapType1Type))
              (= (type v@@10) BoxType))
         ($IsAlloc v@@10 TORDINAL h@@4))
     :pattern (($IsAlloc v@@10 TORDINAL h@@4))
     :skolemid |395|
     :qid |DafnyPreludebpl.212:14|)))
(assert (forall ((v@@11 T@U))
  (! (=> (= (type v@@11) intType) ($Is v@@11 (TBitvector 0)))
     :pattern (($Is v@@11 (TBitvector 0)))
     :skolemid |396|
     :qid |DafnyPreludebpl.216:15|)))
(assert (forall ((v@@12 T@U) (h@@5 T@U))
  (! (=> (and (= (type v@@12) intType)
              (= (type h@@5) (MapType0Type refType MapType1Type)))
         ($IsAlloc v@@12 (TBitvector 0) h@@5))
     :pattern (($IsAlloc v@@12 (TBitvector 0) h@@5))
     :skolemid |397|
     :qid |DafnyPreludebpl.217:15|)))
(assert (forall ((v@@13 T@U) (t0 T@U))
  (! (let ((a!1 (forall ((bx@@10 T@U))
                  (! (=> (and (= (type bx@@10) BoxType)
                              (U_2_bool (MapType0Select v@@13 bx@@10)))
                         ($IsBox bx@@10 t0))
                     :pattern ((MapType0Select v@@13 bx@@10))
                     :skolemid |398|
                     :qid |DafnyPreludebpl.221:11|))))
       (=> (and (= (type v@@13) (MapType0Type BoxType boolType))
                (= (type t0) TyType))
           (= ($Is v@@13 (TSet t0)) a!1)))
     :pattern (($Is v@@13 (TSet t0)))
     :skolemid |399|
     :qid |DafnyPreludebpl.219:15|)))
(assert (forall ((v@@14 T@U) (t0@@0 T@U))
  (! (let ((a!1 (forall ((bx@@11 T@U))
                  (! (=> (and (= (type bx@@11) BoxType)
                              (U_2_bool (MapType0Select v@@14 bx@@11)))
                         ($IsBox bx@@11 t0@@0))
                     :pattern ((MapType0Select v@@14 bx@@11))
                     :skolemid |400|
                     :qid |DafnyPreludebpl.225:11|))))
       (=> (and (= (type v@@14) (MapType0Type BoxType boolType))
                (= (type t0@@0) TyType))
           (= ($Is v@@14 (TISet t0@@0)) a!1)))
     :pattern (($Is v@@14 (TISet t0@@0)))
     :skolemid |401|
     :qid |DafnyPreludebpl.223:15|)))
(assert (forall ((v@@15 T@U) (t0@@1 T@U))
  (! (let ((a!1 (= ($Is v@@15 (TMultiSet t0@@1))
                   (forall ((bx@@12 T@U))
                     (! (let ((a!1 (and (= (type bx@@12) BoxType)
                                        (< 0
                                           (U_2_int (MapType0Select v@@15
                                                                    bx@@12))))))
                          (=> a!1 ($IsBox bx@@12 t0@@1)))
                        :pattern ((MapType0Select v@@15 bx@@12))
                        :skolemid |402|
                        :qid |DafnyPreludebpl.229:11|)))))
       (=> (and (= (type v@@15) (MapType0Type BoxType intType))
                (= (type t0@@1) TyType))
           a!1))
     :pattern (($Is v@@15 (TMultiSet t0@@1)))
     :skolemid |403|
     :qid |DafnyPreludebpl.227:15|)))
(assert (forall ((v@@16 T@U) (t0@@2 T@U))
  (! (=> (and (= (type v@@16) (MapType0Type BoxType intType))
              (= (type t0@@2) TyType)
              ($Is v@@16 (TMultiSet t0@@2)))
         ($IsGoodMultiSet v@@16))
     :pattern (($Is v@@16 (TMultiSet t0@@2)))
     :skolemid |404|
     :qid |DafnyPreludebpl.231:15|)))
(assert (forall ((arg0@@50 T@U) (arg1@@16 Int))
  (! (= (type (|Seq#Index| arg0@@50 arg1@@16)) (SeqTypeInv0 (type arg0@@50)))
     :pattern ((|Seq#Index| arg0@@50 arg1@@16))
     :qid |funType:Seq#Index|)))
(assert (forall ((v@@17 T@U) (t0@@3 T@U))
  (! (let ((a!1 (forall ((i Int))
                  (! (=> (and (<= 0 i) (< i (|Seq#Length| v@@17)))
                         ($IsBox (|Seq#Index| v@@17 i) t0@@3))
                     :pattern ((|Seq#Index| v@@17 i))
                     :skolemid |405|
                     :qid |DafnyPreludebpl.235:11|))))
       (=> (and (= (type v@@17) (SeqType BoxType)) (= (type t0@@3) TyType))
           (= ($Is v@@17 (TSeq t0@@3)) a!1)))
     :pattern (($Is v@@17 (TSeq t0@@3)))
     :skolemid |406|
     :qid |DafnyPreludebpl.233:15|)))
(assert (forall ((v@@18 T@U) (t0@@4 T@U) (h@@6 T@U))
  (! (let ((a!1 (forall ((bx@@13 T@U))
                  (! (=> (and (= (type bx@@13) BoxType)
                              (U_2_bool (MapType0Select v@@18 bx@@13)))
                         ($IsAllocBox bx@@13 t0@@4 h@@6))
                     :pattern ((MapType0Select v@@18 bx@@13))
                     :skolemid |407|
                     :qid |DafnyPreludebpl.240:11|))))
       (=> (and (= (type v@@18) (MapType0Type BoxType boolType))
                (= (type t0@@4) TyType)
                (= (type h@@6) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc v@@18 (TSet t0@@4) h@@6) a!1)))
     :pattern (($IsAlloc v@@18 (TSet t0@@4) h@@6))
     :skolemid |408|
     :qid |DafnyPreludebpl.238:15|)))
(assert (forall ((v@@19 T@U) (t0@@5 T@U) (h@@7 T@U))
  (! (let ((a!1 (forall ((bx@@14 T@U))
                  (! (=> (and (= (type bx@@14) BoxType)
                              (U_2_bool (MapType0Select v@@19 bx@@14)))
                         ($IsAllocBox bx@@14 t0@@5 h@@7))
                     :pattern ((MapType0Select v@@19 bx@@14))
                     :skolemid |409|
                     :qid |DafnyPreludebpl.244:11|))))
       (=> (and (= (type v@@19) (MapType0Type BoxType boolType))
                (= (type t0@@5) TyType)
                (= (type h@@7) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc v@@19 (TISet t0@@5) h@@7) a!1)))
     :pattern (($IsAlloc v@@19 (TISet t0@@5) h@@7))
     :skolemid |410|
     :qid |DafnyPreludebpl.242:15|)))
(assert (forall ((v@@20 T@U) (t0@@6 T@U) (h@@8 T@U))
  (! (let ((a!1 (= ($IsAlloc v@@20 (TMultiSet t0@@6) h@@8)
                   (forall ((bx@@15 T@U))
                     (! (let ((a!1 (and (= (type bx@@15) BoxType)
                                        (< 0
                                           (U_2_int (MapType0Select v@@20
                                                                    bx@@15))))))
                          (=> a!1 ($IsAllocBox bx@@15 t0@@6 h@@8)))
                        :pattern ((MapType0Select v@@20 bx@@15))
                        :skolemid |411|
                        :qid |DafnyPreludebpl.248:11|)))))
       (=> (and (= (type v@@20) (MapType0Type BoxType intType))
                (= (type t0@@6) TyType)
                (= (type h@@8) (MapType0Type refType MapType1Type)))
           a!1))
     :pattern (($IsAlloc v@@20 (TMultiSet t0@@6) h@@8))
     :skolemid |412|
     :qid |DafnyPreludebpl.246:15|)))
(assert (forall ((v@@21 T@U) (t0@@7 T@U) (h@@9 T@U))
  (! (let ((a!1 (forall ((i@@0 Int))
                  (! (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@21)))
                         ($IsAllocBox (|Seq#Index| v@@21 i@@0) t0@@7 h@@9))
                     :pattern ((|Seq#Index| v@@21 i@@0))
                     :skolemid |413|
                     :qid |DafnyPreludebpl.252:11|))))
       (=> (and (= (type v@@21) (SeqType BoxType))
                (= (type t0@@7) TyType)
                (= (type h@@9) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc v@@21 (TSeq t0@@7) h@@9) a!1)))
     :pattern (($IsAlloc v@@21 (TSeq t0@@7) h@@9))
     :skolemid |414|
     :qid |DafnyPreludebpl.250:15|)))
(assert (let ((a!1 (forall ((arg0@@51 T@U))
             (! (= (type (|Map#Elements| arg0@@51))
                   (MapType0Type (MapTypeInv0 (type arg0@@51))
                                 (MapTypeInv1 (type arg0@@51))))
                :pattern ((|Map#Elements| arg0@@51))
                :qid |funType:Map#Elements|)))
      (a!2 (forall ((arg0@@52 T@U))
             (! (= (type (|Map#Domain| arg0@@52))
                   (MapType0Type (MapTypeInv0 (type arg0@@52)) boolType))
                :pattern ((|Map#Domain| arg0@@52))
                :qid |funType:Map#Domain|))))
  (and a!1 a!2)))
(assert (forall ((v@@22 T@U) (t0@@8 T@U) (t1 T@U))
  (! (=> (and (= (type v@@22) (MapType BoxType BoxType))
              (= (type t0@@8) TyType)
              (= (type t1) TyType))
         (= ($Is v@@22 (TMap t0@@8 t1))
            (forall ((bx@@16 T@U))
              (! (let ((a!1 (and (= (type bx@@16) BoxType)
                                 (U_2_bool (MapType0Select (|Map#Domain| v@@22)
                                                           bx@@16))))
                       (a!2 (and ($IsBox (MapType0Select (|Map#Elements| v@@22)
                                                         bx@@16)
                                         t1)
                                 ($IsBox bx@@16 t0@@8))))
                   (=> a!1 a!2))
                 :pattern ((MapType0Select (|Map#Elements| v@@22) bx@@16))
                 :pattern ((MapType0Select (|Map#Domain| v@@22) bx@@16))
                 :skolemid |415|
                 :qid |DafnyPreludebpl.259:19|))))
     :pattern (($Is v@@22 (TMap t0@@8 t1)))
     :skolemid |416|
     :qid |DafnyPreludebpl.256:15|)))
(assert (forall ((v@@23 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@10 T@U))
  (! (=> (and (= (type v@@23) (MapType BoxType BoxType))
              (= (type t0@@9) TyType)
              (= (type t1@@0) TyType)
              (= (type h@@10) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc v@@23 (TMap t0@@9 t1@@0) h@@10)
            (forall ((bx@@17 T@U))
              (! (let ((a!1 (and (= (type bx@@17) BoxType)
                                 (U_2_bool (MapType0Select (|Map#Domain| v@@23)
                                                           bx@@17))))
                       (a!2 (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@23)
                                                              bx@@17)
                                              t1@@0
                                              h@@10)
                                 ($IsAllocBox bx@@17 t0@@9 h@@10))))
                   (=> a!1 a!2))
                 :pattern ((MapType0Select (|Map#Elements| v@@23) bx@@17))
                 :pattern ((MapType0Select (|Map#Domain| v@@23) bx@@17))
                 :skolemid |417|
                 :qid |DafnyPreludebpl.267:19|))))
     :pattern (($IsAlloc v@@23 (TMap t0@@9 t1@@0) h@@10))
     :skolemid |418|
     :qid |DafnyPreludebpl.264:15|)))
(assert (let ((a!1 (forall ((arg0@@53 T@U))
             (! (= (type (|Map#Values| arg0@@53))
                   (MapType0Type (MapTypeInv1 (type arg0@@53)) boolType))
                :pattern ((|Map#Values| arg0@@53))
                :qid |funType:Map#Values|)))
      (a!2 (forall ((arg0@@54 T@U))
             (! (= (type (|Map#Items| arg0@@54))
                   (MapType0Type BoxType boolType))
                :pattern ((|Map#Items| arg0@@54))
                :qid |funType:Map#Items|)))
      (a!3 (forall ((arg0@@55 T@U) (arg1@@17 T@U))
             (! (= (type (Tclass._System.Tuple2 arg0@@55 arg1@@17)) TyType)
                :pattern ((Tclass._System.Tuple2 arg0@@55 arg1@@17))
                :qid |funType:Tclass._System.Tuple2|))))
  (and a!1 a!2 a!3)))
(assert (forall ((v@@24 T@U) (t0@@10 T@U) (t1@@1 T@U))
  (! (let ((a!1 (and ($Is (|Map#Domain| v@@24) (TSet t0@@10))
                     ($Is (|Map#Values| v@@24) (TSet t1@@1))
                     ($Is (|Map#Items| v@@24)
                          (TSet (Tclass._System.Tuple2 t0@@10 t1@@1))))))
       (=> (and (= (type v@@24) (MapType BoxType BoxType))
                (= (type t0@@10) TyType)
                (= (type t1@@1) TyType)
                ($Is v@@24 (TMap t0@@10 t1@@1)))
           a!1))
     :pattern (($Is v@@24 (TMap t0@@10 t1@@1)))
     :skolemid |419|
     :qid |DafnyPreludebpl.272:15|)))
(assert (let ((a!1 (forall ((arg0@@56 T@U))
             (! (= (type (|IMap#Elements| arg0@@56))
                   (MapType0Type (IMapTypeInv0 (type arg0@@56))
                                 (IMapTypeInv1 (type arg0@@56))))
                :pattern ((|IMap#Elements| arg0@@56))
                :qid |funType:IMap#Elements|)))
      (a!2 (forall ((arg0@@57 T@U))
             (! (= (type (|IMap#Domain| arg0@@57))
                   (MapType0Type (IMapTypeInv0 (type arg0@@57)) boolType))
                :pattern ((|IMap#Domain| arg0@@57))
                :qid |funType:IMap#Domain|))))
  (and a!1 a!2)))
(assert (forall ((v@@25 T@U) (t0@@11 T@U) (t1@@2 T@U))
  (! (=> (and (= (type v@@25) (IMapType BoxType BoxType))
              (= (type t0@@11) TyType)
              (= (type t1@@2) TyType))
         (= ($Is v@@25 (TIMap t0@@11 t1@@2))
            (forall ((bx@@18 T@U))
              (! (let ((a!1 (and (= (type bx@@18) BoxType)
                                 (U_2_bool (MapType0Select (|IMap#Domain| v@@25)
                                                           bx@@18))))
                       (a!2 (and ($IsBox (MapType0Select (|IMap#Elements| v@@25)
                                                         bx@@18)
                                         t1@@2)
                                 ($IsBox bx@@18 t0@@11))))
                   (=> a!1 a!2))
                 :pattern ((MapType0Select (|IMap#Elements| v@@25) bx@@18))
                 :pattern ((MapType0Select (|IMap#Domain| v@@25) bx@@18))
                 :skolemid |420|
                 :qid |DafnyPreludebpl.282:19|))))
     :pattern (($Is v@@25 (TIMap t0@@11 t1@@2)))
     :skolemid |421|
     :qid |DafnyPreludebpl.279:15|)))
(assert (forall ((v@@26 T@U) (t0@@12 T@U) (t1@@3 T@U) (h@@11 T@U))
  (! (=> (and (= (type v@@26) (IMapType BoxType BoxType))
              (= (type t0@@12) TyType)
              (= (type t1@@3) TyType)
              (= (type h@@11) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc v@@26 (TIMap t0@@12 t1@@3) h@@11)
            (forall ((bx@@19 T@U))
              (! (let ((a!1 (and (= (type bx@@19) BoxType)
                                 (U_2_bool (MapType0Select (|IMap#Domain| v@@26)
                                                           bx@@19))))
                       (a!2 (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@26)
                                                              bx@@19)
                                              t1@@3
                                              h@@11)
                                 ($IsAllocBox bx@@19 t0@@12 h@@11))))
                   (=> a!1 a!2))
                 :pattern ((MapType0Select (|IMap#Elements| v@@26) bx@@19))
                 :pattern ((MapType0Select (|IMap#Domain| v@@26) bx@@19))
                 :skolemid |422|
                 :qid |DafnyPreludebpl.290:19|))))
     :pattern (($IsAlloc v@@26 (TIMap t0@@12 t1@@3) h@@11))
     :skolemid |423|
     :qid |DafnyPreludebpl.287:15|)))
(assert (let ((a!1 (forall ((arg0@@58 T@U))
             (! (= (type (|IMap#Values| arg0@@58))
                   (MapType0Type (IMapTypeInv1 (type arg0@@58)) boolType))
                :pattern ((|IMap#Values| arg0@@58))
                :qid |funType:IMap#Values|)))
      (a!2 (forall ((arg0@@59 T@U))
             (! (= (type (|IMap#Items| arg0@@59))
                   (MapType0Type BoxType boolType))
                :pattern ((|IMap#Items| arg0@@59))
                :qid |funType:IMap#Items|))))
  (and a!1 a!2)))
(assert (forall ((v@@27 T@U) (t0@@13 T@U) (t1@@4 T@U))
  (! (let ((a!1 (and ($Is (|IMap#Domain| v@@27) (TISet t0@@13))
                     ($Is (|IMap#Values| v@@27) (TISet t1@@4))
                     ($Is (|IMap#Items| v@@27)
                          (TISet (Tclass._System.Tuple2 t0@@13 t1@@4))))))
       (=> (and (= (type v@@27) (IMapType BoxType BoxType))
                (= (type t0@@13) TyType)
                (= (type t1@@4) TyType)
                ($Is v@@27 (TIMap t0@@13 t1@@4)))
           a!1))
     :pattern (($Is v@@27 (TIMap t0@@13 t1@@4)))
     :skolemid |424|
     :qid |DafnyPreludebpl.295:15|)))
(assert (let ((a!1 (forall ((arg0@@60 T@U) (arg1@@18 T@U))
             (! (= (type (TypeTuple arg0@@60 arg1@@18)) ClassNameType)
                :pattern ((TypeTuple arg0@@60 arg1@@18))
                :qid |funType:TypeTuple|)))
      (a!2 (forall ((arg0@@61 T@U))
             (! (= (type (TypeTupleCar arg0@@61)) ClassNameType)
                :pattern ((TypeTupleCar arg0@@61))
                :qid |funType:TypeTupleCar|)))
      (a!3 (forall ((arg0@@62 T@U))
             (! (= (type (TypeTupleCdr arg0@@62)) ClassNameType)
                :pattern ((TypeTupleCdr arg0@@62))
                :qid |funType:TypeTupleCdr|))))
  (and a!1 a!2 a!3)))
(assert (forall ((a@@1 T@U) (b@@1 T@U))
  (! (let ((a!1 (and (= (TypeTupleCar (TypeTuple a@@1 b@@1)) a@@1)
                     (= (TypeTupleCdr (TypeTuple a@@1 b@@1)) b@@1))))
       (=> (and (= (type a@@1) ClassNameType) (= (type b@@1) ClassNameType))
           a!1))
     :pattern ((TypeTuple a@@1 b@@1))
     :skolemid |425|
     :qid |DafnyPreludebpl.322:15|)))
(assert (forall ((arg0@@63 T@U))
  (! (= (type (SetRef_to_SetBox arg0@@63)) (MapType0Type BoxType boolType))
     :pattern ((SetRef_to_SetBox arg0@@63))
     :qid |funType:SetRef_to_SetBox|)))
(assert (forall ((s@@1 T@U) (bx@@20 T@U))
  (! (let ((a!1 (= (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@20))
                   (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@20))))))
       (=> (and (= (type s@@1) (MapType0Type refType boolType))
                (= (type bx@@20) BoxType))
           a!1))
     :pattern ((MapType0Select (SetRef_to_SetBox s@@1) bx@@20))
     :skolemid |426|
     :qid |DafnyPreludebpl.331:15|)))
(assert (= (type Tclass._System.object?) TyType))
(assert (forall ((s@@2 T@U))
  (! (=> (= (type s@@2) (MapType0Type refType boolType))
         ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object?)))
     :pattern ((SetRef_to_SetBox s@@2))
     :skolemid |427|
     :qid |DafnyPreludebpl.333:15|)))
(assert (= (Ctor DatatypeTypeType) 21))
(assert (forall ((d T@U))
  (! (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d)))
     :pattern ((BoxRank ($Box d)))
     :skolemid |428|
     :qid |DafnyPreludebpl.352:15|)))
(assert (forall ((o T@U))
  (! (=> (= (type o) BoxType) (<= 0 (|ORD#Offset| o)))
     :pattern ((|ORD#Offset| o))
     :skolemid |429|
     :qid |DafnyPreludebpl.367:15|)))
(assert (forall ((arg0@@64 Int))
  (! (= (type (|ORD#FromNat| arg0@@64)) BoxType)
     :pattern ((|ORD#FromNat| arg0@@64))
     :qid |funType:ORD#FromNat|)))
(assert (forall ((n@@0 Int))
  (! (let ((a!1 (and (|ORD#IsNat| (|ORD#FromNat| n@@0))
                     (= (|ORD#Offset| (|ORD#FromNat| n@@0)) n@@0))))
       (=> (<= 0 n@@0) a!1))
     :pattern ((|ORD#FromNat| n@@0))
     :skolemid |430|
     :qid |DafnyPreludebpl.373:15|)))
(assert (forall ((o@@0 T@U))
  (! (=> (and (= (type o@@0) BoxType) (|ORD#IsNat| o@@0))
         (= o@@0 (|ORD#FromNat| (|ORD#Offset| o@@0))))
     :pattern ((|ORD#Offset| o@@0))
     :pattern ((|ORD#IsNat| o@@0))
     :skolemid |431|
     :qid |DafnyPreludebpl.375:15|)))
(assert (forall ((o@@1 T@U) (p T@U))
  (! (let ((a!1 (=> (and (|ORD#IsNat| o@@1) (not (|ORD#IsNat| p)))
                    (|ORD#Less| o@@1 p)))
           (a!2 (=> (and (|ORD#IsNat| o@@1) (|ORD#IsNat| p))
                    (= (|ORD#Less| o@@1 p)
                       (< (|ORD#Offset| o@@1) (|ORD#Offset| p))))))
     (let ((a!3 (and (=> (|ORD#Less| o@@1 p) (not (= o@@1 p)))
                     a!1
                     a!2
                     (=> (and (|ORD#Less| o@@1 p) (|ORD#IsNat| p))
                         (|ORD#IsNat| o@@1)))))
       (=> (and (= (type o@@1) BoxType) (= (type p) BoxType)) a!3)))
     :pattern ((|ORD#Less| o@@1 p))
     :skolemid |432|
     :qid |DafnyPreludebpl.379:15|)))
(assert (forall ((o@@2 T@U) (p@@0 T@U))
  (! (=> (and (= (type o@@2) BoxType) (= (type p@@0) BoxType))
         (or (|ORD#Less| o@@2 p@@0) (= o@@2 p@@0) (|ORD#Less| p@@0 o@@2)))
     :pattern ((|ORD#Less| o@@2 p@@0) (|ORD#Less| p@@0 o@@2))
     :skolemid |433|
     :qid |DafnyPreludebpl.385:15|)))
(assert (forall ((o@@3 T@U) (p@@1 T@U) (r T@U))
  (! (=> (and (= (type o@@3) BoxType)
              (= (type p@@1) BoxType)
              (= (type r) BoxType)
              (|ORD#Less| o@@3 p@@1)
              (|ORD#Less| p@@1 r))
         (|ORD#Less| o@@3 r))
     :pattern ((|ORD#Less| o@@3 p@@1) (|ORD#Less| p@@1 r))
     :pattern ((|ORD#Less| o@@3 p@@1) (|ORD#Less| o@@3 r))
     :skolemid |434|
     :qid |DafnyPreludebpl.388:15|)))
(assert (forall ((o@@4 T@U) (p@@2 T@U))
  (! (=> (and (= (type o@@4) BoxType) (= (type p@@2) BoxType))
         (= (|ORD#LessThanLimit| o@@4 p@@2) (|ORD#Less| o@@4 p@@2)))
     :pattern ((|ORD#LessThanLimit| o@@4 p@@2))
     :skolemid |435|
     :qid |DafnyPreludebpl.395:15|)))
(assert (forall ((arg0@@65 T@U) (arg1@@19 T@U))
  (! (= (type (|ORD#Plus| arg0@@65 arg1@@19)) BoxType)
     :pattern ((|ORD#Plus| arg0@@65 arg1@@19))
     :qid |funType:ORD#Plus|)))
(assert (forall ((o@@5 T@U) (p@@3 T@U))
  (! (let ((a!1 (and (= (|ORD#IsNat| (|ORD#Plus| o@@5 p@@3)) (|ORD#IsNat| o@@5))
                     (= (|ORD#Offset| (|ORD#Plus| o@@5 p@@3))
                        (+ (|ORD#Offset| o@@5) (|ORD#Offset| p@@3))))))
     (let ((a!2 (and (=> (|ORD#IsNat| (|ORD#Plus| o@@5 p@@3))
                         (and (|ORD#IsNat| o@@5) (|ORD#IsNat| p@@3)))
                     (=> (|ORD#IsNat| p@@3) a!1))))
       (=> (and (= (type o@@5) BoxType) (= (type p@@3) BoxType)) a!2)))
     :pattern ((|ORD#Plus| o@@5 p@@3))
     :skolemid |436|
     :qid |DafnyPreludebpl.399:15|)))
(assert (forall ((o@@6 T@U) (p@@4 T@U))
  (! (let ((a!1 (and (or (= o@@6 (|ORD#Plus| o@@6 p@@4))
                         (|ORD#Less| o@@6 (|ORD#Plus| o@@6 p@@4)))
                     (or (= p@@4 (|ORD#Plus| o@@6 p@@4))
                         (|ORD#Less| p@@4 (|ORD#Plus| o@@6 p@@4))))))
       (=> (and (= (type o@@6) BoxType) (= (type p@@4) BoxType)) a!1))
     :pattern ((|ORD#Plus| o@@6 p@@4))
     :skolemid |437|
     :qid |DafnyPreludebpl.404:15|)))
(assert (forall ((o@@7 T@U) (p@@5 T@U))
  (! (let ((a!1 (and (=> (= o@@7 (|ORD#FromNat| 0))
                         (= (|ORD#Plus| o@@7 p@@5) p@@5))
                     (=> (= p@@5 (|ORD#FromNat| 0))
                         (= (|ORD#Plus| o@@7 p@@5) o@@7)))))
       (=> (and (= (type o@@7) BoxType) (= (type p@@5) BoxType)) a!1))
     :pattern ((|ORD#Plus| o@@7 p@@5))
     :skolemid |438|
     :qid |DafnyPreludebpl.407:15|)))
(assert (forall ((arg0@@66 T@U) (arg1@@20 T@U))
  (! (= (type (|ORD#Minus| arg0@@66 arg1@@20)) BoxType)
     :pattern ((|ORD#Minus| arg0@@66 arg1@@20))
     :qid |funType:ORD#Minus|)))
(assert (forall ((o@@8 T@U) (p@@6 T@U))
  (! (let ((a!1 (and (= (|ORD#IsNat| (|ORD#Minus| o@@8 p@@6))
                        (|ORD#IsNat| o@@8))
                     (= (|ORD#Offset| (|ORD#Minus| o@@8 p@@6))
                        (- (|ORD#Offset| o@@8) (|ORD#Offset| p@@6))))))
       (=> (and (= (type o@@8) BoxType)
                (= (type p@@6) BoxType)
                (|ORD#IsNat| p@@6)
                (<= (|ORD#Offset| p@@6) (|ORD#Offset| o@@8)))
           a!1))
     :pattern ((|ORD#Minus| o@@8 p@@6))
     :skolemid |439|
     :qid |DafnyPreludebpl.412:15|)))
(assert (forall ((o@@9 T@U) (p@@7 T@U))
  (! (let ((a!1 (and (not (= p@@7 (|ORD#FromNat| 0)))
                     (|ORD#Less| (|ORD#Minus| o@@9 p@@7) o@@9))))
     (let ((a!2 (or (and (= p@@7 (|ORD#FromNat| 0))
                         (= (|ORD#Minus| o@@9 p@@7) o@@9))
                    a!1)))
       (=> (and (= (type o@@9) BoxType)
                (= (type p@@7) BoxType)
                (|ORD#IsNat| p@@7)
                (<= (|ORD#Offset| p@@7) (|ORD#Offset| o@@9)))
           a!2)))
     :pattern ((|ORD#Minus| o@@9 p@@7))
     :skolemid |440|
     :qid |DafnyPreludebpl.416:15|)))
(assert (forall ((o@@10 T@U) (m@@5 Int) (n@@1 Int))
  (! (let ((a!1 (= (|ORD#Plus| (|ORD#Plus| o@@10 (|ORD#FromNat| m@@5))
                               (|ORD#FromNat| n@@1))
                   (|ORD#Plus| o@@10 (|ORD#FromNat| (+ m@@5 n@@1))))))
       (=> (= (type o@@10) BoxType) (=> (and (<= 0 m@@5) (<= 0 n@@1)) a!1)))
     :pattern ((|ORD#Plus| (|ORD#Plus| o@@10 (|ORD#FromNat| m@@5))
                           (|ORD#FromNat| n@@1)))
     :skolemid |441|
     :qid |DafnyPreludebpl.422:15|)))
(assert (forall ((o@@11 T@U) (m@@6 Int) (n@@2 Int))
  (! (let ((a!1 (= (|ORD#Minus| (|ORD#Minus| o@@11 (|ORD#FromNat| m@@6))
                                (|ORD#FromNat| n@@2))
                   (|ORD#Minus| o@@11 (|ORD#FromNat| (+ m@@6 n@@2))))))
     (let ((a!2 (=> (and (<= 0 m@@6)
                         (<= 0 n@@2)
                         (<= (+ m@@6 n@@2) (|ORD#Offset| o@@11)))
                    a!1)))
       (=> (= (type o@@11) BoxType) a!2)))
     :pattern ((|ORD#Minus| (|ORD#Minus| o@@11 (|ORD#FromNat| m@@6))
                            (|ORD#FromNat| n@@2)))
     :skolemid |442|
     :qid |DafnyPreludebpl.427:15|)))
(assert (forall ((o@@12 T@U) (m@@7 Int) (n@@3 Int))
  (! (let ((a!1 (and (<= 0 m@@7)
                     (<= 0 n@@3)
                     (<= n@@3 (+ (|ORD#Offset| o@@12) m@@7))))
           (a!2 (= (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7))
                                (|ORD#FromNat| n@@3))
                   (|ORD#Plus| o@@12 (|ORD#FromNat| (- m@@7 n@@3)))))
           (a!3 (= (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7))
                                (|ORD#FromNat| n@@3))
                   (|ORD#Minus| o@@12 (|ORD#FromNat| (- n@@3 m@@7))))))
     (let ((a!4 (and (=> (<= 0 (- m@@7 n@@3)) a!2)
                     (=> (<= (- m@@7 n@@3) 0) a!3))))
       (=> (= (type o@@12) BoxType) (=> a!1 a!4))))
     :pattern ((|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7))
                            (|ORD#FromNat| n@@3)))
     :skolemid |443|
     :qid |DafnyPreludebpl.432:15|)))
(assert (forall ((o@@13 T@U) (m@@8 Int) (n@@4 Int))
  (! (let ((a!1 (and (<= 0 m@@8)
                     (<= 0 n@@4)
                     (<= n@@4 (+ (|ORD#Offset| o@@13) m@@8))))
           (a!2 (= (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8))
                               (|ORD#FromNat| n@@4))
                   (|ORD#Minus| o@@13 (|ORD#FromNat| (- m@@8 n@@4)))))
           (a!3 (= (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8))
                               (|ORD#FromNat| n@@4))
                   (|ORD#Plus| o@@13 (|ORD#FromNat| (- n@@4 m@@8))))))
     (let ((a!4 (and (=> (<= 0 (- m@@8 n@@4)) a!2)
                     (=> (<= (- m@@8 n@@4) 0) a!3))))
       (=> (= (type o@@13) BoxType) (=> a!1 a!4))))
     :pattern ((|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8))
                           (|ORD#FromNat| n@@4)))
     :skolemid |444|
     :qid |DafnyPreludebpl.438:15|)))
(assert (let ((a!1 (forall ((arg0@@67 T@U) (arg1@@21 T@U))
             (! (= (type (AtLayer arg0@@67 arg1@@21))
                   (MapType0TypeInv1 (type arg0@@67)))
                :pattern ((AtLayer arg0@@67 arg1@@21))
                :qid |funType:AtLayer|))))
  (and (= (Ctor LayerTypeType) 22) a!1)))
(assert (forall ((f T@U) (ly T@U))
  (! (let ((a!1 (= (type f)
                   (MapType0Type LayerTypeType (MapType0TypeInv1 (type f))))))
       (=> (and a!1 (= (type ly) LayerTypeType))
           (= (AtLayer f ly) (MapType0Select f ly))))
     :pattern ((AtLayer f ly))
     :skolemid |445|
     :qid |DafnyPreludebpl.462:18|)))
(assert (forall ((arg0@@68 T@U))
  (! (= (type ($LS arg0@@68)) LayerTypeType)
     :pattern (($LS arg0@@68))
     :qid |funType:$LS|)))
(assert (forall ((f@@0 T@U) (ly@@0 T@U))
  (! (let ((a!1 (= (type f@@0)
                   (MapType0Type LayerTypeType (MapType0TypeInv1 (type f@@0))))))
       (=> (and a!1 (= (type ly@@0) LayerTypeType))
           (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0))))
     :pattern ((AtLayer f@@0 ($LS ly@@0)))
     :skolemid |446|
     :qid |DafnyPreludebpl.463:18|)))
(assert (forall ((arg0@@69 Int))
  (! (= (type (IndexField arg0@@69)) (FieldType BoxType))
     :pattern ((IndexField arg0@@69))
     :qid |funType:IndexField|)))
(assert (forall ((i@@1 Int))
  (! (= (FDim (IndexField i@@1)) 1)
     :pattern ((IndexField i@@1))
     :skolemid |447|
     :qid |DafnyPreludebpl.474:15|)))
(assert (forall ((i@@2 Int))
  (! (= (IndexField_Inverse (IndexField i@@2)) i@@2)
     :pattern ((IndexField i@@2))
     :skolemid |448|
     :qid |DafnyPreludebpl.476:15|)))
(assert (forall ((arg0@@70 T@U) (arg1@@22 Int))
  (! (= (type (MultiIndexField arg0@@70 arg1@@22)) (FieldType BoxType))
     :pattern ((MultiIndexField arg0@@70 arg1@@22))
     :qid |funType:MultiIndexField|)))
(assert (forall ((f@@1 T@U) (i@@3 Int))
  (! (=> (= (type f@@1) (FieldType BoxType))
         (= (FDim (MultiIndexField f@@1 i@@3)) (+ (FDim f@@1) 1)))
     :pattern ((MultiIndexField f@@1 i@@3))
     :skolemid |449|
     :qid |DafnyPreludebpl.479:15|)))
(assert (forall ((arg0@@71 T@U))
  (! (= (type (MultiIndexField_Inverse0 arg0@@71))
        (FieldType (FieldTypeInv0 (type arg0@@71))))
     :pattern ((MultiIndexField_Inverse0 arg0@@71))
     :qid |funType:MultiIndexField_Inverse0|)))
(assert (forall ((f@@2 T@U) (i@@4 Int))
  (! (let ((a!1 (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@4))
                        f@@2)
                     (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@4))
                        i@@4))))
       (=> (= (type f@@2) (FieldType BoxType)) a!1))
     :pattern ((MultiIndexField f@@2 i@@4))
     :skolemid |450|
     :qid |DafnyPreludebpl.482:15|)))
(assert (let ((a!1 (forall ((alpha@@3 T@T) (arg0@@72 T@U) (arg1@@23 T@U))
             (! (= (type (FieldOfDecl alpha@@3 arg0@@72 arg1@@23))
                   (FieldType alpha@@3))
                :pattern ((FieldOfDecl alpha@@3 arg0@@72 arg1@@23))
                :qid |funType:FieldOfDecl|)))
      (a!2 (forall ((arg0@@73 T@U))
             (! (= (type (DeclType arg0@@73)) ClassNameType)
                :pattern ((DeclType arg0@@73))
                :qid |funType:DeclType|)))
      (a!3 (forall ((arg0@@74 T@U))
             (! (= (type (DeclName arg0@@74)) NameFamilyType)
                :pattern ((DeclName arg0@@74))
                :qid |funType:DeclName|))))
  (and a!1 a!2 a!3)))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T))
  (! (let ((a!1 (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl)
                     (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))))
       (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) a!1))
     :pattern ((FieldOfDecl T@@4 cl nm))
     :skolemid |451|
     :qid |DafnyPreludebpl.491:18|)))
(assert (forall ((h@@12 T@U) (k T@U) (v@@28 T@U) (t@@21 T@U))
  (! (=> (and (= (type h@@12) (MapType0Type refType MapType1Type))
              (= (type k) (MapType0Type refType MapType1Type))
              (= (type t@@21) TyType)
              ($HeapSucc h@@12 k)
              ($IsAlloc v@@28 t@@21 h@@12))
         ($IsAlloc v@@28 t@@21 k))
     :pattern (($HeapSucc h@@12 k) ($IsAlloc v@@28 t@@21 h@@12))
     :skolemid |452|
     :qid |DafnyPreludebpl.504:17|)))
(assert (forall ((h@@13 T@U) (k@@0 T@U) (bx@@21 T@U) (t@@22 T@U))
  (! (=> (and (= (type h@@13) (MapType0Type refType MapType1Type))
              (= (type k@@0) (MapType0Type refType MapType1Type))
              (= (type bx@@21) BoxType)
              (= (type t@@22) TyType)
              ($HeapSucc h@@13 k@@0)
              ($IsAllocBox bx@@21 t@@22 h@@13))
         ($IsAllocBox bx@@21 t@@22 k@@0))
     :pattern (($HeapSucc h@@13 k@@0) ($IsAllocBox bx@@21 t@@22 h@@13))
     :skolemid |453|
     :qid |DafnyPreludebpl.507:14|)))
(assert (= (FDim alloc) 0))
(assert (= (DeclName alloc) allocName))
(assert (not ($IsGhostField alloc)))
(assert (forall ((o@@14 T@U))
  (! (=> (= (type o@@14) refType) (<= 0 (_System.array.Length o@@14)))
     :no-pattern (type o@@14)
     :no-pattern (U_2_int o@@14)
     :no-pattern (U_2_bool o@@14)
     :skolemid |454|
     :qid |DafnyPreludebpl.524:15|)))
(assert (forall ((x@@16 Int))
  (! (= (q@Real x@@16) (to_real x@@16))
     :pattern ((q@Real x@@16))
     :skolemid |456|
     :qid |DafnyPreludebpl.531:15|)))
(assert (forall ((i@@5 Int))
  (! (= (q@Int (q@Real i@@5)) i@@5)
     :pattern ((q@Int (q@Real i@@5)))
     :skolemid |457|
     :qid |DafnyPreludebpl.532:15|)))
(assert (= (type $OneHeap) (MapType0Type refType MapType1Type)))
(assert ($IsGoodHeap $OneHeap))
(assert (forall ((h@@14 T@U) (r@@0 T@U) (f@@3 T@U) (x@@17 T@U))
  (! (let ((a!1 ($IsGoodHeap (MapType0Store h@@14
                                            r@@0
                                            (MapType1Store (MapType0Select h@@14
                                                                           r@@0)
                                                           f@@3
                                                           x@@17))))
           (a!3 ($HeapSucc h@@14
                           (MapType0Store h@@14
                                          r@@0
                                          (MapType1Store (MapType0Select h@@14
                                                                         r@@0)
                                                         f@@3
                                                         x@@17)))))
     (let ((a!2 (and (= (type h@@14) (MapType0Type refType MapType1Type))
                     (= (type r@@0) refType)
                     (= (type f@@3) (FieldType (type x@@17)))
                     a!1)))
       (=> a!2 a!3)))
     :pattern ((MapType0Store h@@14
                              r@@0
                              (MapType1Store (MapType0Select h@@14 r@@0)
                                             f@@3
                                             x@@17)))
     :skolemid |458|
     :qid |DafnyPreludebpl.554:22|)))
(assert (forall ((a@@2 T@U) (b@@2 T@U) (c T@U))
  (! (=> (and (= (type a@@2) (MapType0Type refType MapType1Type))
              (= (type b@@2) (MapType0Type refType MapType1Type))
              (= (type c) (MapType0Type refType MapType1Type))
              (not (= a@@2 c))
              ($HeapSucc a@@2 b@@2)
              ($HeapSucc b@@2 c))
         ($HeapSucc a@@2 c))
     :pattern (($HeapSucc a@@2 b@@2) ($HeapSucc b@@2 c))
     :skolemid |459|
     :qid |DafnyPreludebpl.557:15|)))
(assert (forall ((h@@15 T@U) (k@@1 T@U))
  (! (let ((a!1 (forall ((o@@15 T@U))
                  (! (let ((a!1 (and (= (type o@@15) refType)
                                     (U_2_bool (MapType1Select (MapType0Select h@@15
                                                                               o@@15)
                                                               alloc)))))
                       (=> a!1
                           (U_2_bool (MapType1Select (MapType0Select k@@1 o@@15)
                                                     alloc))))
                     :pattern ((MapType1Select (MapType0Select k@@1 o@@15)
                                               alloc))
                     :skolemid |460|
                     :qid |DafnyPreludebpl.560:30|))))
       (=> (and (= (type h@@15) (MapType0Type refType MapType1Type))
                (= (type k@@1) (MapType0Type refType MapType1Type))
                ($HeapSucc h@@15 k@@1))
           a!1))
     :pattern (($HeapSucc h@@15 k@@1))
     :skolemid |461|
     :qid |DafnyPreludebpl.559:15|)))
(assert (forall ((h@@16 T@U) (k@@2 T@U))
  (! (let ((a!1 (forall ((o@@16 T@U) (f@@4 T@U))
                  (! (let ((a!1 (= (type f@@4)
                                   (FieldType (FieldTypeInv0 (type f@@4))))))
                       (=> (and (= (type o@@16) refType)
                                a!1
                                (not ($IsGhostField f@@4)))
                           (= (MapType1Select (MapType0Select h@@16 o@@16) f@@4)
                              (MapType1Select (MapType0Select k@@2 o@@16) f@@4))))
                     :pattern ((MapType1Select (MapType0Select k@@2 o@@16) f@@4))
                     :skolemid |462|
                     :qid |DafnyPreludebpl.566:20|))))
       (=> (and (= (type h@@16) (MapType0Type refType MapType1Type))
                (= (type k@@2) (MapType0Type refType MapType1Type))
                ($HeapSuccGhost h@@16 k@@2))
           (and ($HeapSucc h@@16 k@@2) a!1)))
     :pattern (($HeapSuccGhost h@@16 k@@2))
     :skolemid |463|
     :qid |DafnyPreludebpl.563:15|)))
(assert (forall ((s@@3 T@U))
  (! (let ((a!1 (= (type s@@3)
                   (MapType0Type (MapType0TypeInv0 (type s@@3)) boolType))))
       (=> a!1 (<= 0 (|Set#Card| s@@3))))
     :pattern ((|Set#Card| s@@3))
     :skolemid |468|
     :qid |DafnyPreludebpl.624:18|)))
(assert (forall ((T@@6 T@T))
  (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType))
     :pattern ((|Set#Empty| T@@6))
     :qid |funType:Set#Empty|)))
(assert (forall ((o@@17 T@U))
  (! (let ((a!1 (U_2_bool (MapType0Select (|Set#Empty| (type o@@17)) o@@17))))
       (not a!1))
     :pattern ((MapType0Select (|Set#Empty| (type o@@17)) o@@17))
     :skolemid |469|
     :qid |DafnyPreludebpl.627:18|)))
(assert (forall ((s@@4 T@U))
  (! (let ((a!1 (= (type s@@4)
                   (MapType0Type (MapType0TypeInv0 (type s@@4)) boolType)))
           (a!2 (= s@@4 (|Set#Empty| (MapType0TypeInv0 (type s@@4)))))
           (a!3 (exists ((x@@18 T@U))
                  (! (and (= (type x@@18) (MapType0TypeInv0 (type s@@4)))
                          (U_2_bool (MapType0Select s@@4 x@@18)))
                     :no-pattern (type x@@18)
                     :no-pattern (U_2_int x@@18)
                     :no-pattern (U_2_bool x@@18)
                     :skolemid |470|
                     :qid |DafnyPreludebpl.630:33|))))
     (let ((a!4 (=> (not (= (|Set#Card| s@@4) 0)) a!3)))
     (let ((a!5 (and (= (= (|Set#Card| s@@4) 0) a!2) a!4)))
       (=> a!1 a!5))))
     :pattern ((|Set#Card| s@@4))
     :skolemid |471|
     :qid |DafnyPreludebpl.628:18|)))
(assert (forall ((arg0@@75 T@U))
  (! (= (type (|Set#Singleton| arg0@@75))
        (MapType0Type (type arg0@@75) boolType))
     :pattern ((|Set#Singleton| arg0@@75))
     :qid |funType:Set#Singleton|)))
(assert (forall ((r@@1 T@U))
  (! (U_2_bool (MapType0Select (|Set#Singleton| r@@1) r@@1))
     :pattern ((|Set#Singleton| r@@1))
     :skolemid |472|
     :qid |DafnyPreludebpl.636:18|)))
(assert (forall ((r@@2 T@U) (o@@18 T@U))
  (! (let ((a!1 (= (U_2_bool (MapType0Select (|Set#Singleton| r@@2) o@@18))
                   (= r@@2 o@@18))))
       (=> (= (type o@@18) (type r@@2)) a!1))
     :pattern ((MapType0Select (|Set#Singleton| r@@2) o@@18))
     :skolemid |473|
     :qid |DafnyPreludebpl.637:18|)))
(assert (forall ((r@@3 T@U))
  (! (= (|Set#Card| (|Set#Singleton| r@@3)) 1)
     :pattern ((|Set#Card| (|Set#Singleton| r@@3)))
     :skolemid |474|
     :qid |DafnyPreludebpl.638:18|)))
(assert (forall ((arg0@@76 T@U) (arg1@@24 T@U))
  (! (= (type (|Set#UnionOne| arg0@@76 arg1@@24))
        (MapType0Type (type arg1@@24) boolType))
     :pattern ((|Set#UnionOne| arg0@@76 arg1@@24))
     :qid |funType:Set#UnionOne|)))
(assert (forall ((a@@3 T@U) (x@@19 T@U) (o@@19 T@U))
  (! (let ((a!1 (and (= (type a@@3) (MapType0Type (type x@@19) boolType))
                     (= (type o@@19) (type x@@19))))
           (a!2 (= (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))
                   (or (= o@@19 x@@19) (U_2_bool (MapType0Select a@@3 o@@19))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))
     :skolemid |475|
     :qid |DafnyPreludebpl.641:18|)))
(assert (forall ((a@@4 T@U) (x@@20 T@U))
  (! (=> (= (type a@@4) (MapType0Type (type x@@20) boolType))
         (U_2_bool (MapType0Select (|Set#UnionOne| a@@4 x@@20) x@@20)))
     :pattern ((|Set#UnionOne| a@@4 x@@20))
     :skolemid |476|
     :qid |DafnyPreludebpl.643:18|)))
(assert (forall ((a@@5 T@U) (x@@21 T@U) (y@@1 T@U))
  (! (let ((a!1 (and (= (type a@@5) (MapType0Type (type x@@21) boolType))
                     (= (type y@@1) (type x@@21))
                     (U_2_bool (MapType0Select a@@5 y@@1)))))
       (=> a!1 (U_2_bool (MapType0Select (|Set#UnionOne| a@@5 x@@21) y@@1))))
     :pattern ((|Set#UnionOne| a@@5 x@@21) (MapType0Select a@@5 y@@1))
     :skolemid |477|
     :qid |DafnyPreludebpl.645:18|)))
(assert (forall ((a@@6 T@U) (x@@22 T@U))
  (! (let ((a!1 (and (= (type a@@6) (MapType0Type (type x@@22) boolType))
                     (U_2_bool (MapType0Select a@@6 x@@22)))))
       (=> a!1 (= (|Set#Card| (|Set#UnionOne| a@@6 x@@22)) (|Set#Card| a@@6))))
     :pattern ((|Set#Card| (|Set#UnionOne| a@@6 x@@22)))
     :skolemid |478|
     :qid |DafnyPreludebpl.647:18|)))
(assert (forall ((a@@7 T@U) (x@@23 T@U))
  (! (let ((a!1 (and (= (type a@@7) (MapType0Type (type x@@23) boolType))
                     (not (U_2_bool (MapType0Select a@@7 x@@23))))))
       (=> a!1
           (= (|Set#Card| (|Set#UnionOne| a@@7 x@@23)) (+ (|Set#Card| a@@7) 1))))
     :pattern ((|Set#Card| (|Set#UnionOne| a@@7 x@@23)))
     :skolemid |479|
     :qid |DafnyPreludebpl.649:18|)))
(assert (forall ((arg0@@77 T@U) (arg1@@25 T@U))
  (! (= (type (|Set#Union| arg0@@77 arg1@@25))
        (MapType0Type (MapType0TypeInv0 (type arg0@@77)) boolType))
     :pattern ((|Set#Union| arg0@@77 arg1@@25))
     :qid |funType:Set#Union|)))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (o@@20 T@U))
  (! (let ((a!1 (and (= (type a@@8) (MapType0Type (type o@@20) boolType))
                     (= (type b@@3) (MapType0Type (type o@@20) boolType))))
           (a!2 (= (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) o@@20))
                   (or (U_2_bool (MapType0Select a@@8 o@@20))
                       (U_2_bool (MapType0Select b@@3 o@@20))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|Set#Union| a@@8 b@@3) o@@20))
     :skolemid |480|
     :qid |DafnyPreludebpl.653:18|)))
(assert (forall ((a@@9 T@U) (b@@4 T@U) (y@@2 T@U))
  (! (let ((a!1 (and (= (type a@@9) (MapType0Type (type y@@2) boolType))
                     (= (type b@@4) (MapType0Type (type y@@2) boolType))
                     (U_2_bool (MapType0Select a@@9 y@@2)))))
       (=> a!1 (U_2_bool (MapType0Select (|Set#Union| a@@9 b@@4) y@@2))))
     :pattern ((|Set#Union| a@@9 b@@4) (MapType0Select a@@9 y@@2))
     :skolemid |481|
     :qid |DafnyPreludebpl.655:18|)))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (y@@3 T@U))
  (! (let ((a!1 (and (= (type a@@10) (MapType0Type (type y@@3) boolType))
                     (= (type b@@5) (MapType0Type (type y@@3) boolType))
                     (U_2_bool (MapType0Select b@@5 y@@3)))))
       (=> a!1 (U_2_bool (MapType0Select (|Set#Union| a@@10 b@@5) y@@3))))
     :pattern ((|Set#Union| a@@10 b@@5) (MapType0Select b@@5 y@@3))
     :skolemid |482|
     :qid |DafnyPreludebpl.657:18|)))
(assert (forall ((arg0@@78 T@U) (arg1@@26 T@U))
  (! (= (type (|Set#Difference| arg0@@78 arg1@@26))
        (MapType0Type (MapType0TypeInv0 (type arg0@@78)) boolType))
     :pattern ((|Set#Difference| arg0@@78 arg1@@26))
     :qid |funType:Set#Difference|)))
(assert (forall ((a@@11 T@U) (b@@6 T@U))
  (! (let ((a!1 (= (type a@@11)
                   (MapType0Type (MapType0TypeInv0 (type a@@11)) boolType)))
           (a!2 (= (type b@@6)
                   (MapType0Type (MapType0TypeInv0 (type a@@11)) boolType)))
           (a!3 (and (= (|Set#Difference| (|Set#Union| a@@11 b@@6) a@@11) b@@6)
                     (= (|Set#Difference| (|Set#Union| a@@11 b@@6) b@@6) a@@11))))
       (=> (and a!1 a!2 (|Set#Disjoint| a@@11 b@@6)) a!3))
     :pattern ((|Set#Union| a@@11 b@@6))
     :skolemid |483|
     :qid |DafnyPreludebpl.659:18|)))
(assert (forall ((arg0@@79 T@U) (arg1@@27 T@U))
  (! (= (type (|Set#Intersection| arg0@@79 arg1@@27))
        (MapType0Type (MapType0TypeInv0 (type arg0@@79)) boolType))
     :pattern ((|Set#Intersection| arg0@@79 arg1@@27))
     :qid |funType:Set#Intersection|)))
(assert (forall ((a@@12 T@U) (b@@7 T@U) (o@@21 T@U))
  (! (let ((a!1 (and (= (type a@@12) (MapType0Type (type o@@21) boolType))
                     (= (type b@@7) (MapType0Type (type o@@21) boolType))))
           (a!2 (= (U_2_bool (MapType0Select (|Set#Intersection| a@@12 b@@7)
                                             o@@21))
                   (and (U_2_bool (MapType0Select a@@12 o@@21))
                        (U_2_bool (MapType0Select b@@7 o@@21))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21))
     :skolemid |484|
     :qid |DafnyPreludebpl.669:18|)))
(assert (forall ((a@@13 T@U) (b@@8 T@U))
  (! (let ((a!1 (= (type a@@13)
                   (MapType0Type (MapType0TypeInv0 (type a@@13)) boolType)))
           (a!2 (= (type b@@8)
                   (MapType0Type (MapType0TypeInv0 (type a@@13)) boolType))))
       (=> (and a!1 a!2)
           (= (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8)
              (|Set#Union| a@@13 b@@8))))
     :pattern ((|Set#Union| (|Set#Union| a@@13 b@@8) b@@8))
     :skolemid |485|
     :qid |DafnyPreludebpl.672:18|)))
(assert (forall ((a@@14 T@U) (b@@9 T@U))
  (! (let ((a!1 (= (type a@@14)
                   (MapType0Type (MapType0TypeInv0 (type a@@14)) boolType)))
           (a!2 (= (type b@@9)
                   (MapType0Type (MapType0TypeInv0 (type a@@14)) boolType))))
       (=> (and a!1 a!2)
           (= (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9))
              (|Set#Union| a@@14 b@@9))))
     :pattern ((|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)))
     :skolemid |486|
     :qid |DafnyPreludebpl.674:18|)))
(assert (forall ((a@@15 T@U) (b@@10 T@U))
  (! (let ((a!1 (= (type a@@15)
                   (MapType0Type (MapType0TypeInv0 (type a@@15)) boolType)))
           (a!2 (= (type b@@10)
                   (MapType0Type (MapType0TypeInv0 (type a@@15)) boolType))))
       (=> (and a!1 a!2)
           (= (|Set#Intersection| (|Set#Intersection| a@@15 b@@10) b@@10)
              (|Set#Intersection| a@@15 b@@10))))
     :pattern ((|Set#Intersection| (|Set#Intersection| a@@15 b@@10) b@@10))
     :skolemid |487|
     :qid |DafnyPreludebpl.676:18|)))
(assert (forall ((a@@16 T@U) (b@@11 T@U))
  (! (let ((a!1 (= (type a@@16)
                   (MapType0Type (MapType0TypeInv0 (type a@@16)) boolType)))
           (a!2 (= (type b@@11)
                   (MapType0Type (MapType0TypeInv0 (type a@@16)) boolType))))
       (=> (and a!1 a!2)
           (= (|Set#Intersection| a@@16 (|Set#Intersection| a@@16 b@@11))
              (|Set#Intersection| a@@16 b@@11))))
     :pattern ((|Set#Intersection| a@@16 (|Set#Intersection| a@@16 b@@11)))
     :skolemid |488|
     :qid |DafnyPreludebpl.678:18|)))
(assert (forall ((a@@17 T@U) (b@@12 T@U))
  (! (let ((a!1 (= (type a@@17)
                   (MapType0Type (MapType0TypeInv0 (type a@@17)) boolType)))
           (a!2 (= (type b@@12)
                   (MapType0Type (MapType0TypeInv0 (type a@@17)) boolType)))
           (a!3 (= (+ (|Set#Card| (|Set#Union| a@@17 b@@12))
                      (|Set#Card| (|Set#Intersection| a@@17 b@@12)))
                   (+ (|Set#Card| a@@17) (|Set#Card| b@@12)))))
       (=> (and a!1 a!2) a!3))
     :pattern ((|Set#Card| (|Set#Union| a@@17 b@@12)))
     :pattern ((|Set#Card| (|Set#Intersection| a@@17 b@@12)))
     :skolemid |489|
     :qid |DafnyPreludebpl.680:18|)))
(assert (forall ((a@@18 T@U) (b@@13 T@U) (o@@22 T@U))
  (! (let ((a!1 (and (= (type a@@18) (MapType0Type (type o@@22) boolType))
                     (= (type b@@13) (MapType0Type (type o@@22) boolType))))
           (a!2 (and (U_2_bool (MapType0Select a@@18 o@@22))
                     (not (U_2_bool (MapType0Select b@@13 o@@22))))))
     (let ((a!3 (= (U_2_bool (MapType0Select (|Set#Difference| a@@18 b@@13)
                                             o@@22))
                   a!2)))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (|Set#Difference| a@@18 b@@13) o@@22))
     :skolemid |490|
     :qid |DafnyPreludebpl.684:18|)))
(assert (forall ((a@@19 T@U) (b@@14 T@U) (y@@4 T@U))
  (! (let ((a!1 (and (= (type a@@19) (MapType0Type (type y@@4) boolType))
                     (= (type b@@14) (MapType0Type (type y@@4) boolType))
                     (U_2_bool (MapType0Select b@@14 y@@4))))
           (a!2 (not (U_2_bool (MapType0Select (|Set#Difference| a@@19 b@@14)
                                               y@@4)))))
       (=> a!1 a!2))
     :pattern ((|Set#Difference| a@@19 b@@14) (MapType0Select b@@14 y@@4))
     :skolemid |491|
     :qid |DafnyPreludebpl.686:18|)))
(assert (forall ((a@@20 T@U) (b@@15 T@U))
  (! (let ((a!1 (= (type a@@20)
                   (MapType0Type (MapType0TypeInv0 (type a@@20)) boolType)))
           (a!2 (= (type b@@15)
                   (MapType0Type (MapType0TypeInv0 (type a@@20)) boolType)))
           (a!3 (= (+ (|Set#Card| (|Set#Difference| a@@20 b@@15))
                      (|Set#Card| (|Set#Difference| b@@15 a@@20))
                      (|Set#Card| (|Set#Intersection| a@@20 b@@15)))
                   (|Set#Card| (|Set#Union| a@@20 b@@15))))
           (a!4 (= (|Set#Card| (|Set#Difference| a@@20 b@@15))
                   (- (|Set#Card| a@@20)
                      (|Set#Card| (|Set#Intersection| a@@20 b@@15))))))
       (=> (and a!1 a!2) (and a!3 a!4)))
     :pattern ((|Set#Card| (|Set#Difference| a@@20 b@@15)))
     :skolemid |492|
     :qid |DafnyPreludebpl.688:18|)))
(assert (forall ((a@@21 T@U) (b@@16 T@U))
  (! (let ((a!1 (= (type a@@21)
                   (MapType0Type (MapType0TypeInv0 (type a@@21)) boolType)))
           (a!2 (= (type b@@16)
                   (MapType0Type (MapType0TypeInv0 (type a@@21)) boolType)))
           (a!3 (forall ((o@@23 T@U))
                  (! (let ((a!1 (and (= (type o@@23)
                                        (MapType0TypeInv0 (type a@@21)))
                                     (U_2_bool (MapType0Select a@@21 o@@23)))))
                       (=> a!1 (U_2_bool (MapType0Select b@@16 o@@23))))
                     :pattern ((MapType0Select a@@21 o@@23))
                     :pattern ((MapType0Select b@@16 o@@23))
                     :skolemid |493|
                     :qid |DafnyPreludebpl.697:32|))))
       (=> (and a!1 a!2) (= (|Set#Subset| a@@21 b@@16) a!3)))
     :pattern ((|Set#Subset| a@@21 b@@16))
     :skolemid |494|
     :qid |DafnyPreludebpl.696:17|)))
(assert (forall ((a@@22 T@U) (b@@17 T@U))
  (! (let ((a!1 (= (type a@@22)
                   (MapType0Type (MapType0TypeInv0 (type a@@22)) boolType)))
           (a!2 (= (type b@@17)
                   (MapType0Type (MapType0TypeInv0 (type a@@22)) boolType)))
           (a!3 (forall ((o@@24 T@U))
                  (! (=> (= (type o@@24) (MapType0TypeInv0 (type a@@22)))
                         (= (U_2_bool (MapType0Select a@@22 o@@24))
                            (U_2_bool (MapType0Select b@@17 o@@24))))
                     :pattern ((MapType0Select a@@22 o@@24))
                     :pattern ((MapType0Select b@@17 o@@24))
                     :skolemid |495|
                     :qid |DafnyPreludebpl.705:31|))))
       (=> (and a!1 a!2) (= (|Set#Equal| a@@22 b@@17) a!3)))
     :pattern ((|Set#Equal| a@@22 b@@17))
     :skolemid |496|
     :qid |DafnyPreludebpl.704:17|)))
(assert (forall ((a@@23 T@U) (b@@18 T@U))
  (! (let ((a!1 (= (type a@@23)
                   (MapType0Type (MapType0TypeInv0 (type a@@23)) boolType)))
           (a!2 (= (type b@@18)
                   (MapType0Type (MapType0TypeInv0 (type a@@23)) boolType))))
       (=> (and a!1 a!2 (|Set#Equal| a@@23 b@@18)) (= a@@23 b@@18)))
     :pattern ((|Set#Equal| a@@23 b@@18))
     :skolemid |497|
     :qid |DafnyPreludebpl.706:17|)))
(assert (forall ((a@@24 T@U) (b@@19 T@U))
  (! (let ((a!1 (= (type a@@24)
                   (MapType0Type (MapType0TypeInv0 (type a@@24)) boolType)))
           (a!2 (= (type b@@19)
                   (MapType0Type (MapType0TypeInv0 (type a@@24)) boolType)))
           (a!3 (forall ((o@@25 T@U))
                  (! (let ((a!1 (or (not (U_2_bool (MapType0Select a@@24 o@@25)))
                                    (not (U_2_bool (MapType0Select b@@19 o@@25))))))
                       (=> (= (type o@@25) (MapType0TypeInv0 (type a@@24))) a!1))
                     :pattern ((MapType0Select a@@24 o@@25))
                     :pattern ((MapType0Select b@@19 o@@25))
                     :skolemid |498|
                     :qid |DafnyPreludebpl.711:34|))))
       (=> (and a!1 a!2) (= (|Set#Disjoint| a@@24 b@@19) a!3)))
     :pattern ((|Set#Disjoint| a@@24 b@@19))
     :skolemid |499|
     :qid |DafnyPreludebpl.710:18|)))
(assert (forall ((T@@37 T@T))
  (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType))
     :pattern ((|ISet#Empty| T@@37))
     :qid |funType:ISet#Empty|)))
(assert (forall ((o@@26 T@U))
  (! (let ((a!1 (U_2_bool (MapType0Select (|ISet#Empty| (type o@@26)) o@@26))))
       (not a!1))
     :pattern ((MapType0Select (|ISet#Empty| (type o@@26)) o@@26))
     :skolemid |500|
     :qid |DafnyPreludebpl.720:18|)))
(assert (forall ((arg0@@80 T@U) (arg1@@28 T@U))
  (! (= (type (|ISet#UnionOne| arg0@@80 arg1@@28))
        (MapType0Type (type arg1@@28) boolType))
     :pattern ((|ISet#UnionOne| arg0@@80 arg1@@28))
     :qid |funType:ISet#UnionOne|)))
(assert (forall ((a@@25 T@U) (x@@24 T@U) (o@@27 T@U))
  (! (let ((a!1 (and (= (type a@@25) (MapType0Type (type x@@24) boolType))
                     (= (type o@@27) (type x@@24))))
           (a!2 (= (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@24)
                                             o@@27))
                   (or (= o@@27 x@@24) (U_2_bool (MapType0Select a@@25 o@@27))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|ISet#UnionOne| a@@25 x@@24) o@@27))
     :skolemid |501|
     :qid |DafnyPreludebpl.727:18|)))
(assert (forall ((a@@26 T@U) (x@@25 T@U))
  (! (=> (= (type a@@26) (MapType0Type (type x@@25) boolType))
         (U_2_bool (MapType0Select (|ISet#UnionOne| a@@26 x@@25) x@@25)))
     :pattern ((|ISet#UnionOne| a@@26 x@@25))
     :skolemid |502|
     :qid |DafnyPreludebpl.729:18|)))
(assert (forall ((a@@27 T@U) (x@@26 T@U) (y@@5 T@U))
  (! (let ((a!1 (and (= (type a@@27) (MapType0Type (type x@@26) boolType))
                     (= (type y@@5) (type x@@26))
                     (U_2_bool (MapType0Select a@@27 y@@5)))))
       (=> a!1 (U_2_bool (MapType0Select (|ISet#UnionOne| a@@27 x@@26) y@@5))))
     :pattern ((|ISet#UnionOne| a@@27 x@@26) (MapType0Select a@@27 y@@5))
     :skolemid |503|
     :qid |DafnyPreludebpl.731:18|)))
(assert (forall ((arg0@@81 T@U) (arg1@@29 T@U))
  (! (= (type (|ISet#Union| arg0@@81 arg1@@29))
        (MapType0Type (MapType0TypeInv0 (type arg0@@81)) boolType))
     :pattern ((|ISet#Union| arg0@@81 arg1@@29))
     :qid |funType:ISet#Union|)))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (o@@28 T@U))
  (! (let ((a!1 (and (= (type a@@28) (MapType0Type (type o@@28) boolType))
                     (= (type b@@20) (MapType0Type (type o@@28) boolType))))
           (a!2 (= (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) o@@28))
                   (or (U_2_bool (MapType0Select a@@28 o@@28))
                       (U_2_bool (MapType0Select b@@20 o@@28))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|ISet#Union| a@@28 b@@20) o@@28))
     :skolemid |504|
     :qid |DafnyPreludebpl.735:18|)))
(assert (forall ((a@@29 T@U) (b@@21 T@U) (y@@6 T@U))
  (! (let ((a!1 (and (= (type a@@29) (MapType0Type (type y@@6) boolType))
                     (= (type b@@21) (MapType0Type (type y@@6) boolType))
                     (U_2_bool (MapType0Select a@@29 y@@6)))))
       (=> a!1 (U_2_bool (MapType0Select (|ISet#Union| a@@29 b@@21) y@@6))))
     :pattern ((|ISet#Union| a@@29 b@@21) (MapType0Select a@@29 y@@6))
     :skolemid |505|
     :qid |DafnyPreludebpl.737:18|)))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (y@@7 T@U))
  (! (let ((a!1 (and (= (type a@@30) (MapType0Type (type y@@7) boolType))
                     (= (type b@@22) (MapType0Type (type y@@7) boolType))
                     (U_2_bool (MapType0Select b@@22 y@@7)))))
       (=> a!1 (U_2_bool (MapType0Select (|ISet#Union| a@@30 b@@22) y@@7))))
     :pattern ((|ISet#Union| a@@30 b@@22) (MapType0Select b@@22 y@@7))
     :skolemid |506|
     :qid |DafnyPreludebpl.739:18|)))
(assert (forall ((arg0@@82 T@U) (arg1@@30 T@U))
  (! (= (type (|ISet#Difference| arg0@@82 arg1@@30))
        (MapType0Type (MapType0TypeInv0 (type arg0@@82)) boolType))
     :pattern ((|ISet#Difference| arg0@@82 arg1@@30))
     :qid |funType:ISet#Difference|)))
(assert (forall ((a@@31 T@U) (b@@23 T@U))
  (! (let ((a!1 (= (type a@@31)
                   (MapType0Type (MapType0TypeInv0 (type a@@31)) boolType)))
           (a!2 (= (type b@@23)
                   (MapType0Type (MapType0TypeInv0 (type a@@31)) boolType)))
           (a!3 (and (= (|ISet#Difference| (|ISet#Union| a@@31 b@@23) a@@31)
                        b@@23)
                     (= (|ISet#Difference| (|ISet#Union| a@@31 b@@23) b@@23)
                        a@@31))))
       (=> (and a!1 a!2 (|ISet#Disjoint| a@@31 b@@23)) a!3))
     :pattern ((|ISet#Union| a@@31 b@@23))
     :skolemid |507|
     :qid |DafnyPreludebpl.741:18|)))
(assert (forall ((arg0@@83 T@U) (arg1@@31 T@U))
  (! (= (type (|ISet#Intersection| arg0@@83 arg1@@31))
        (MapType0Type (MapType0TypeInv0 (type arg0@@83)) boolType))
     :pattern ((|ISet#Intersection| arg0@@83 arg1@@31))
     :qid |funType:ISet#Intersection|)))
(assert (forall ((a@@32 T@U) (b@@24 T@U) (o@@29 T@U))
  (! (let ((a!1 (and (= (type a@@32) (MapType0Type (type o@@29) boolType))
                     (= (type b@@24) (MapType0Type (type o@@29) boolType))))
           (a!2 (= (U_2_bool (MapType0Select (|ISet#Intersection| a@@32 b@@24)
                                             o@@29))
                   (and (U_2_bool (MapType0Select a@@32 o@@29))
                        (U_2_bool (MapType0Select b@@24 o@@29))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|ISet#Intersection| a@@32 b@@24) o@@29))
     :skolemid |508|
     :qid |DafnyPreludebpl.747:18|)))
(assert (forall ((a@@33 T@U) (b@@25 T@U))
  (! (let ((a!1 (= (type a@@33)
                   (MapType0Type (MapType0TypeInv0 (type a@@33)) boolType)))
           (a!2 (= (type b@@25)
                   (MapType0Type (MapType0TypeInv0 (type a@@33)) boolType))))
       (=> (and a!1 a!2)
           (= (|ISet#Union| (|ISet#Union| a@@33 b@@25) b@@25)
              (|ISet#Union| a@@33 b@@25))))
     :pattern ((|ISet#Union| (|ISet#Union| a@@33 b@@25) b@@25))
     :skolemid |509|
     :qid |DafnyPreludebpl.750:18|)))
(assert (forall ((a@@34 T@U) (b@@26 T@U))
  (! (let ((a!1 (= (type a@@34)
                   (MapType0Type (MapType0TypeInv0 (type a@@34)) boolType)))
           (a!2 (= (type b@@26)
                   (MapType0Type (MapType0TypeInv0 (type a@@34)) boolType))))
       (=> (and a!1 a!2)
           (= (|ISet#Union| a@@34 (|ISet#Union| a@@34 b@@26))
              (|ISet#Union| a@@34 b@@26))))
     :pattern ((|ISet#Union| a@@34 (|ISet#Union| a@@34 b@@26)))
     :skolemid |510|
     :qid |DafnyPreludebpl.752:18|)))
(assert (forall ((a@@35 T@U) (b@@27 T@U))
  (! (let ((a!1 (= (type a@@35)
                   (MapType0Type (MapType0TypeInv0 (type a@@35)) boolType)))
           (a!2 (= (type b@@27)
                   (MapType0Type (MapType0TypeInv0 (type a@@35)) boolType))))
       (=> (and a!1 a!2)
           (= (|ISet#Intersection| (|ISet#Intersection| a@@35 b@@27) b@@27)
              (|ISet#Intersection| a@@35 b@@27))))
     :pattern ((|ISet#Intersection| (|ISet#Intersection| a@@35 b@@27) b@@27))
     :skolemid |511|
     :qid |DafnyPreludebpl.754:18|)))
(assert (forall ((a@@36 T@U) (b@@28 T@U))
  (! (let ((a!1 (= (type a@@36)
                   (MapType0Type (MapType0TypeInv0 (type a@@36)) boolType)))
           (a!2 (= (type b@@28)
                   (MapType0Type (MapType0TypeInv0 (type a@@36)) boolType))))
       (=> (and a!1 a!2)
           (= (|ISet#Intersection| a@@36 (|ISet#Intersection| a@@36 b@@28))
              (|ISet#Intersection| a@@36 b@@28))))
     :pattern ((|ISet#Intersection| a@@36 (|ISet#Intersection| a@@36 b@@28)))
     :skolemid |512|
     :qid |DafnyPreludebpl.756:18|)))
(assert (forall ((a@@37 T@U) (b@@29 T@U) (o@@30 T@U))
  (! (let ((a!1 (and (= (type a@@37) (MapType0Type (type o@@30) boolType))
                     (= (type b@@29) (MapType0Type (type o@@30) boolType))))
           (a!2 (and (U_2_bool (MapType0Select a@@37 o@@30))
                     (not (U_2_bool (MapType0Select b@@29 o@@30))))))
     (let ((a!3 (= (U_2_bool (MapType0Select (|ISet#Difference| a@@37 b@@29)
                                             o@@30))
                   a!2)))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (|ISet#Difference| a@@37 b@@29) o@@30))
     :skolemid |513|
     :qid |DafnyPreludebpl.761:18|)))
(assert (forall ((a@@38 T@U) (b@@30 T@U) (y@@8 T@U))
  (! (let ((a!1 (and (= (type a@@38) (MapType0Type (type y@@8) boolType))
                     (= (type b@@30) (MapType0Type (type y@@8) boolType))
                     (U_2_bool (MapType0Select b@@30 y@@8))))
           (a!2 (not (U_2_bool (MapType0Select (|ISet#Difference| a@@38 b@@30)
                                               y@@8)))))
       (=> a!1 a!2))
     :pattern ((|ISet#Difference| a@@38 b@@30) (MapType0Select b@@30 y@@8))
     :skolemid |514|
     :qid |DafnyPreludebpl.763:18|)))
(assert (forall ((a@@39 T@U) (b@@31 T@U))
  (! (let ((a!1 (= (type a@@39)
                   (MapType0Type (MapType0TypeInv0 (type a@@39)) boolType)))
           (a!2 (= (type b@@31)
                   (MapType0Type (MapType0TypeInv0 (type a@@39)) boolType)))
           (a!3 (forall ((o@@31 T@U))
                  (! (let ((a!1 (and (= (type o@@31)
                                        (MapType0TypeInv0 (type a@@39)))
                                     (U_2_bool (MapType0Select a@@39 o@@31)))))
                       (=> a!1 (U_2_bool (MapType0Select b@@31 o@@31))))
                     :pattern ((MapType0Select a@@39 o@@31))
                     :pattern ((MapType0Select b@@31 o@@31))
                     :skolemid |515|
                     :qid |DafnyPreludebpl.768:33|))))
       (=> (and a!1 a!2) (= (|ISet#Subset| a@@39 b@@31) a!3)))
     :pattern ((|ISet#Subset| a@@39 b@@31))
     :skolemid |516|
     :qid |DafnyPreludebpl.767:17|)))
(assert (forall ((a@@40 T@U) (b@@32 T@U))
  (! (let ((a!1 (= (type a@@40)
                   (MapType0Type (MapType0TypeInv0 (type a@@40)) boolType)))
           (a!2 (= (type b@@32)
                   (MapType0Type (MapType0TypeInv0 (type a@@40)) boolType)))
           (a!3 (forall ((o@@32 T@U))
                  (! (=> (= (type o@@32) (MapType0TypeInv0 (type a@@40)))
                         (= (U_2_bool (MapType0Select a@@40 o@@32))
                            (U_2_bool (MapType0Select b@@32 o@@32))))
                     :pattern ((MapType0Select a@@40 o@@32))
                     :pattern ((MapType0Select b@@32 o@@32))
                     :skolemid |517|
                     :qid |DafnyPreludebpl.772:32|))))
       (=> (and a!1 a!2) (= (|ISet#Equal| a@@40 b@@32) a!3)))
     :pattern ((|ISet#Equal| a@@40 b@@32))
     :skolemid |518|
     :qid |DafnyPreludebpl.771:17|)))
(assert (forall ((a@@41 T@U) (b@@33 T@U))
  (! (let ((a!1 (= (type a@@41)
                   (MapType0Type (MapType0TypeInv0 (type a@@41)) boolType)))
           (a!2 (= (type b@@33)
                   (MapType0Type (MapType0TypeInv0 (type a@@41)) boolType))))
       (=> (and a!1 a!2 (|ISet#Equal| a@@41 b@@33)) (= a@@41 b@@33)))
     :pattern ((|ISet#Equal| a@@41 b@@33))
     :skolemid |519|
     :qid |DafnyPreludebpl.773:17|)))
(assert (forall ((a@@42 T@U) (b@@34 T@U))
  (! (let ((a!1 (= (type a@@42)
                   (MapType0Type (MapType0TypeInv0 (type a@@42)) boolType)))
           (a!2 (= (type b@@34)
                   (MapType0Type (MapType0TypeInv0 (type a@@42)) boolType)))
           (a!3 (forall ((o@@33 T@U))
                  (! (let ((a!1 (or (not (U_2_bool (MapType0Select a@@42 o@@33)))
                                    (not (U_2_bool (MapType0Select b@@34 o@@33))))))
                       (=> (= (type o@@33) (MapType0TypeInv0 (type a@@42))) a!1))
                     :pattern ((MapType0Select a@@42 o@@33))
                     :pattern ((MapType0Select b@@34 o@@33))
                     :skolemid |520|
                     :qid |DafnyPreludebpl.778:35|))))
       (=> (and a!1 a!2) (= (|ISet#Disjoint| a@@42 b@@34) a!3)))
     :pattern ((|ISet#Disjoint| a@@42 b@@34))
     :skolemid |521|
     :qid |DafnyPreludebpl.777:18|)))
(assert (forall ((a@@43 Int) (b@@35 Int))
  (! (= (<= a@@43 b@@35) (= (|Math#min| a@@43 b@@35) a@@43))
     :pattern ((|Math#min| a@@43 b@@35))
     :skolemid |522|
     :qid |DafnyPreludebpl.785:15|)))
(assert (forall ((a@@44 Int) (b@@36 Int))
  (! (= (<= b@@36 a@@44) (= (|Math#min| a@@44 b@@36) b@@36))
     :pattern ((|Math#min| a@@44 b@@36))
     :skolemid |523|
     :qid |DafnyPreludebpl.786:15|)))
(assert (forall ((a@@45 Int) (b@@37 Int))
  (! (or (= (|Math#min| a@@45 b@@37) a@@45) (= (|Math#min| a@@45 b@@37) b@@37))
     :pattern ((|Math#min| a@@45 b@@37))
     :skolemid |524|
     :qid |DafnyPreludebpl.787:15|)))
(assert (forall ((a@@46 Int))
  (! (=> (<= 0 a@@46) (= (|Math#clip| a@@46) a@@46))
     :pattern ((|Math#clip| a@@46))
     :skolemid |525|
     :qid |DafnyPreludebpl.790:15|)))
(assert (forall ((a@@47 Int))
  (! (=> (< a@@47 0) (= (|Math#clip| a@@47) 0))
     :pattern ((|Math#clip| a@@47))
     :skolemid |526|
     :qid |DafnyPreludebpl.791:15|)))
(assert (forall ((ms T@U))
  (! (let ((a!1 (= (type ms)
                   (MapType0Type (MapType0TypeInv0 (type ms)) intType)))
           (a!2 (forall ((bx@@22 T@U))
                  (! (let ((a!1 (and (<= 0 (U_2_int (MapType0Select ms bx@@22)))
                                     (<= (U_2_int (MapType0Select ms bx@@22))
                                         (|MultiSet#Card| ms)))))
                       (=> (= (type bx@@22) (MapType0TypeInv0 (type ms))) a!1))
                     :pattern ((MapType0Select ms bx@@22))
                     :skolemid |527|
                     :qid |DafnyPreludebpl.799:11|))))
       (=> a!1 (= ($IsGoodMultiSet ms) a!2)))
     :pattern (($IsGoodMultiSet ms))
     :skolemid |528|
     :qid |DafnyPreludebpl.797:18|)))
(assert (forall ((s@@5 T@U))
  (! (let ((a!1 (= (type s@@5)
                   (MapType0Type (MapType0TypeInv0 (type s@@5)) intType))))
       (=> a!1 (<= 0 (|MultiSet#Card| s@@5))))
     :pattern ((|MultiSet#Card| s@@5))
     :skolemid |529|
     :qid |DafnyPreludebpl.802:18|)))
(assert (forall ((s@@6 T@U) (x@@27 T@U) (n@@5 T@U))
  (! (let ((a!1 (and (= (type s@@6) (MapType0Type (type x@@27) intType))
                     (= (type n@@5) intType)
                     (<= 0 (U_2_int n@@5))))
           (a!2 (+ (- (|MultiSet#Card| s@@6)
                      (U_2_int (MapType0Select s@@6 x@@27)))
                   (U_2_int n@@5))))
       (=> a!1 (= (|MultiSet#Card| (MapType0Store s@@6 x@@27 n@@5)) a!2)))
     :pattern ((|MultiSet#Card| (MapType0Store s@@6 x@@27 n@@5)))
     :skolemid |530|
     :qid |DafnyPreludebpl.803:18|)))
(assert (forall ((T@@64 T@T))
  (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType))
     :pattern ((|MultiSet#Empty| T@@64))
     :qid |funType:MultiSet#Empty|)))
(assert (forall ((o@@34 T@U))
  (! (let ((a!1 (U_2_int (MapType0Select (|MultiSet#Empty| (type o@@34)) o@@34))))
       (= a!1 0))
     :pattern ((MapType0Select (|MultiSet#Empty| (type o@@34)) o@@34))
     :skolemid |531|
     :qid |DafnyPreludebpl.807:18|)))
(assert (forall ((s@@7 T@U))
  (! (let ((a!1 (= (type s@@7)
                   (MapType0Type (MapType0TypeInv0 (type s@@7)) intType)))
           (a!2 (= s@@7 (|MultiSet#Empty| (MapType0TypeInv0 (type s@@7)))))
           (a!3 (exists ((x@@28 T@U))
                  (! (and (= (type x@@28) (MapType0TypeInv0 (type s@@7)))
                          (< 0 (U_2_int (MapType0Select s@@7 x@@28))))
                     :no-pattern (type x@@28)
                     :no-pattern (U_2_int x@@28)
                     :no-pattern (U_2_bool x@@28)
                     :skolemid |532|
                     :qid |DafnyPreludebpl.810:38|))))
     (let ((a!4 (=> (not (= (|MultiSet#Card| s@@7) 0)) a!3)))
     (let ((a!5 (and (= (= (|MultiSet#Card| s@@7) 0) a!2) a!4)))
       (=> a!1 a!5))))
     :pattern ((|MultiSet#Card| s@@7))
     :skolemid |533|
     :qid |DafnyPreludebpl.808:18|)))
(assert (forall ((arg0@@84 T@U))
  (! (= (type (|MultiSet#Singleton| arg0@@84))
        (MapType0Type (type arg0@@84) intType))
     :pattern ((|MultiSet#Singleton| arg0@@84))
     :qid |funType:MultiSet#Singleton|)))
(assert (forall ((r@@4 T@U) (o@@35 T@U))
  (! (let ((a!1 (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@4) o@@35))
                   1))
           (a!2 (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@4) o@@35))
                   0)))
     (let ((a!3 (and (= a!1 (= r@@4 o@@35)) (= a!2 (not (= r@@4 o@@35))))))
       (=> (= (type o@@35) (type r@@4)) a!3)))
     :pattern ((MapType0Select (|MultiSet#Singleton| r@@4) o@@35))
     :skolemid |534|
     :qid |DafnyPreludebpl.813:18|)))
(assert (forall ((arg0@@85 T@U) (arg1@@32 T@U))
  (! (= (type (|MultiSet#UnionOne| arg0@@85 arg1@@32))
        (MapType0Type (type arg1@@32) intType))
     :pattern ((|MultiSet#UnionOne| arg0@@85 arg1@@32))
     :qid |funType:MultiSet#UnionOne|)))
(assert (forall ((r@@5 T@U))
  (! (= (|MultiSet#Singleton| r@@5)
        (|MultiSet#UnionOne| (|MultiSet#Empty| (type r@@5)) r@@5))
     :pattern ((|MultiSet#Singleton| r@@5))
     :skolemid |535|
     :qid |DafnyPreludebpl.815:18|)))
(assert (forall ((a@@48 T@U) (x@@29 T@U) (o@@36 T@U))
  (! (let ((a!1 (and (= (type a@@48) (MapType0Type (type x@@29) intType))
                     (= (type o@@36) (type x@@29))))
           (a!2 (< 0
                   (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@29)
                                            o@@36))))
           (a!3 (or (= o@@36 x@@29)
                    (< 0 (U_2_int (MapType0Select a@@48 o@@36))))))
       (=> a!1 (= a!2 a!3)))
     :pattern ((MapType0Select (|MultiSet#UnionOne| a@@48 x@@29) o@@36))
     :skolemid |536|
     :qid |DafnyPreludebpl.819:18|)))
(assert (forall ((a@@49 T@U) (x@@30 T@U))
  (! (let ((a!1 (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@30)
                                            x@@30))
                   (+ (U_2_int (MapType0Select a@@49 x@@30)) 1))))
       (=> (= (type a@@49) (MapType0Type (type x@@30) intType)) a!1))
     :pattern ((|MultiSet#UnionOne| a@@49 x@@30))
     :skolemid |537|
     :qid |DafnyPreludebpl.822:18|)))
(assert (forall ((a@@50 T@U) (x@@31 T@U) (y@@9 T@U))
  (! (let ((a!1 (and (= (type a@@50) (MapType0Type (type x@@31) intType))
                     (= (type y@@9) (type x@@31))
                     (< 0 (U_2_int (MapType0Select a@@50 y@@9)))))
           (a!2 (< 0
                   (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@50 x@@31)
                                            y@@9)))))
       (=> a!1 a!2))
     :pattern ((|MultiSet#UnionOne| a@@50 x@@31) (MapType0Select a@@50 y@@9))
     :skolemid |538|
     :qid |DafnyPreludebpl.825:18|)))
(assert (forall ((a@@51 T@U) (x@@32 T@U) (y@@10 T@U))
  (! (let ((a!1 (and (= (type a@@51) (MapType0Type (type x@@32) intType))
                     (= (type y@@10) (type x@@32))
                     (not (= x@@32 y@@10))))
           (a!2 (= (U_2_int (MapType0Select a@@51 y@@10))
                   (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@51 x@@32)
                                            y@@10)))))
       (=> a!1 a!2))
     :pattern ((|MultiSet#UnionOne| a@@51 x@@32) (MapType0Select a@@51 y@@10))
     :skolemid |539|
     :qid |DafnyPreludebpl.828:18|)))
(assert (forall ((a@@52 T@U) (x@@33 T@U))
  (! (=> (= (type a@@52) (MapType0Type (type x@@33) intType))
         (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@52 x@@33))
            (+ (|MultiSet#Card| a@@52) 1)))
     :pattern ((|MultiSet#Card| (|MultiSet#UnionOne| a@@52 x@@33)))
     :skolemid |540|
     :qid |DafnyPreludebpl.830:18|)))
(assert (forall ((arg0@@86 T@U) (arg1@@33 T@U))
  (! (= (type (|MultiSet#Union| arg0@@86 arg1@@33))
        (MapType0Type (MapType0TypeInv0 (type arg0@@86)) intType))
     :pattern ((|MultiSet#Union| arg0@@86 arg1@@33))
     :qid |funType:MultiSet#Union|)))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@37 T@U))
  (! (let ((a!1 (and (= (type a@@53) (MapType0Type (type o@@37) intType))
                     (= (type b@@38) (MapType0Type (type o@@37) intType))))
           (a!2 (= (U_2_int (MapType0Select (|MultiSet#Union| a@@53 b@@38)
                                            o@@37))
                   (+ (U_2_int (MapType0Select a@@53 o@@37))
                      (U_2_int (MapType0Select b@@38 o@@37))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|MultiSet#Union| a@@53 b@@38) o@@37))
     :skolemid |541|
     :qid |DafnyPreludebpl.836:18|)))
(assert (forall ((a@@54 T@U) (b@@39 T@U))
  (! (let ((a!1 (= (type a@@54)
                   (MapType0Type (MapType0TypeInv0 (type a@@54)) intType)))
           (a!2 (= (type b@@39)
                   (MapType0Type (MapType0TypeInv0 (type a@@54)) intType))))
       (=> (and a!1 a!2)
           (= (|MultiSet#Card| (|MultiSet#Union| a@@54 b@@39))
              (+ (|MultiSet#Card| a@@54) (|MultiSet#Card| b@@39)))))
     :pattern ((|MultiSet#Card| (|MultiSet#Union| a@@54 b@@39)))
     :skolemid |542|
     :qid |DafnyPreludebpl.838:18|)))
(assert (forall ((arg0@@87 T@U) (arg1@@34 T@U))
  (! (= (type (|MultiSet#Intersection| arg0@@87 arg1@@34))
        (MapType0Type (MapType0TypeInv0 (type arg0@@87)) intType))
     :pattern ((|MultiSet#Intersection| arg0@@87 arg1@@34))
     :qid |funType:MultiSet#Intersection|)))
(assert (forall ((a@@55 T@U) (b@@40 T@U) (o@@38 T@U))
  (! (let ((a!1 (and (= (type a@@55) (MapType0Type (type o@@38) intType))
                     (= (type b@@40) (MapType0Type (type o@@38) intType))))
           (a!2 (= (U_2_int (MapType0Select (|MultiSet#Intersection|
                                              a@@55
                                              b@@40)
                                            o@@38))
                   (|Math#min| (U_2_int (MapType0Select a@@55 o@@38))
                               (U_2_int (MapType0Select b@@40 o@@38))))))
       (=> a!1 a!2))
     :pattern ((MapType0Select (|MultiSet#Intersection| a@@55 b@@40) o@@38))
     :skolemid |543|
     :qid |DafnyPreludebpl.842:18|)))
(assert (forall ((a@@56 T@U) (b@@41 T@U))
  (! (let ((a!1 (= (type a@@56)
                   (MapType0Type (MapType0TypeInv0 (type a@@56)) intType)))
           (a!2 (= (type b@@41)
                   (MapType0Type (MapType0TypeInv0 (type a@@56)) intType))))
       (=> (and a!1 a!2)
           (= (|MultiSet#Intersection|
                (|MultiSet#Intersection| a@@56 b@@41)
                b@@41)
              (|MultiSet#Intersection| a@@56 b@@41))))
     :pattern ((|MultiSet#Intersection|
                 (|MultiSet#Intersection| a@@56 b@@41)
                 b@@41))
     :skolemid |544|
     :qid |DafnyPreludebpl.846:18|)))
(assert (forall ((a@@57 T@U) (b@@42 T@U))
  (! (let ((a!1 (= (type a@@57)
                   (MapType0Type (MapType0TypeInv0 (type a@@57)) intType)))
           (a!2 (= (type b@@42)
                   (MapType0Type (MapType0TypeInv0 (type a@@57)) intType))))
       (=> (and a!1 a!2)
           (= (|MultiSet#Intersection|
                a@@57
                (|MultiSet#Intersection| a@@57 b@@42))
              (|MultiSet#Intersection| a@@57 b@@42))))
     :pattern ((|MultiSet#Intersection|
                 a@@57
                 (|MultiSet#Intersection| a@@57 b@@42)))
     :skolemid |545|
     :qid |DafnyPreludebpl.848:18|)))
(assert (forall ((arg0@@88 T@U) (arg1@@35 T@U))
  (! (= (type (|MultiSet#Difference| arg0@@88 arg1@@35))
        (MapType0Type (MapType0TypeInv0 (type arg0@@88)) intType))
     :pattern ((|MultiSet#Difference| arg0@@88 arg1@@35))
     :qid |funType:MultiSet#Difference|)))
(assert (forall ((a@@58 T@U) (b@@43 T@U) (o@@39 T@U))
  (! (let ((a!1 (and (= (type a@@58) (MapType0Type (type o@@39) intType))
                     (= (type b@@43) (MapType0Type (type o@@39) intType))))
           (a!2 (|Math#clip| (- (U_2_int (MapType0Select a@@58 o@@39))
                                (U_2_int (MapType0Select b@@43 o@@39))))))
     (let ((a!3 (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@58 b@@43)
                                            o@@39))
                   a!2)))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (|MultiSet#Difference| a@@58 b@@43) o@@39))
     :skolemid |546|
     :qid |DafnyPreludebpl.853:18|)))
(assert (forall ((a@@59 T@U) (b@@44 T@U) (y@@11 T@U))
  (! (let ((a!1 (and (= (type a@@59) (MapType0Type (type y@@11) intType))
                     (= (type b@@44) (MapType0Type (type y@@11) intType))
                     (<= (U_2_int (MapType0Select a@@59 y@@11))
                         (U_2_int (MapType0Select b@@44 y@@11)))))
           (a!2 (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@59 b@@44)
                                            y@@11))
                   0)))
       (=> a!1 a!2))
     :pattern ((|MultiSet#Difference| a@@59 b@@44)
               (MapType0Select b@@44 y@@11)
               (MapType0Select a@@59 y@@11))
     :skolemid |547|
     :qid |DafnyPreludebpl.855:18|)))
(assert (forall ((a@@60 T@U) (b@@45 T@U))
  (! (let ((a!1 (= (type a@@60)
                   (MapType0Type (MapType0TypeInv0 (type a@@60)) intType)))
           (a!2 (= (type b@@45)
                   (MapType0Type (MapType0TypeInv0 (type a@@60)) intType)))
           (a!3 (+ (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45))
                   (|MultiSet#Card| (|MultiSet#Difference| b@@45 a@@60))
                   (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@60 b@@45)))))
           (a!4 (= (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45))
                   (- (|MultiSet#Card| a@@60)
                      (|MultiSet#Card| (|MultiSet#Intersection| a@@60 b@@45))))))
     (let ((a!5 (and (= a!3 (|MultiSet#Card| (|MultiSet#Union| a@@60 b@@45)))
                     a!4)))
       (=> (and a!1 a!2) a!5)))
     :pattern ((|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45)))
     :skolemid |548|
     :qid |DafnyPreludebpl.857:18|)))
(assert (forall ((a@@61 T@U) (b@@46 T@U))
  (! (let ((a!1 (= (type a@@61)
                   (MapType0Type (MapType0TypeInv0 (type a@@61)) intType)))
           (a!2 (= (type b@@46)
                   (MapType0Type (MapType0TypeInv0 (type a@@61)) intType)))
           (a!3 (forall ((o@@40 T@U))
                  (! (=> (= (type o@@40) (MapType0TypeInv0 (type a@@61)))
                         (<= (U_2_int (MapType0Select a@@61 o@@40))
                             (U_2_int (MapType0Select b@@46 o@@40))))
                     :pattern ((MapType0Select a@@61 o@@40))
                     :pattern ((MapType0Select b@@46 o@@40))
                     :skolemid |549|
                     :qid |DafnyPreludebpl.867:37|))))
       (=> (and a!1 a!2) (= (|MultiSet#Subset| a@@61 b@@46) a!3)))
     :pattern ((|MultiSet#Subset| a@@61 b@@46))
     :skolemid |550|
     :qid |DafnyPreludebpl.866:17|)))
(assert (forall ((a@@62 T@U) (b@@47 T@U))
  (! (let ((a!1 (= (type a@@62)
                   (MapType0Type (MapType0TypeInv0 (type a@@62)) intType)))
           (a!2 (= (type b@@47)
                   (MapType0Type (MapType0TypeInv0 (type a@@62)) intType)))
           (a!3 (forall ((o@@41 T@U))
                  (! (=> (= (type o@@41) (MapType0TypeInv0 (type a@@62)))
                         (= (U_2_int (MapType0Select a@@62 o@@41))
                            (U_2_int (MapType0Select b@@47 o@@41))))
                     :pattern ((MapType0Select a@@62 o@@41))
                     :pattern ((MapType0Select b@@47 o@@41))
                     :skolemid |551|
                     :qid |DafnyPreludebpl.871:36|))))
       (=> (and a!1 a!2) (= (|MultiSet#Equal| a@@62 b@@47) a!3)))
     :pattern ((|MultiSet#Equal| a@@62 b@@47))
     :skolemid |552|
     :qid |DafnyPreludebpl.870:17|)))
(assert (forall ((a@@63 T@U) (b@@48 T@U))
  (! (let ((a!1 (= (type a@@63)
                   (MapType0Type (MapType0TypeInv0 (type a@@63)) intType)))
           (a!2 (= (type b@@48)
                   (MapType0Type (MapType0TypeInv0 (type a@@63)) intType))))
       (=> (and a!1 a!2 (|MultiSet#Equal| a@@63 b@@48)) (= a@@63 b@@48)))
     :pattern ((|MultiSet#Equal| a@@63 b@@48))
     :skolemid |553|
     :qid |DafnyPreludebpl.873:17|)))
(assert (forall ((a@@64 T@U) (b@@49 T@U))
  (! (let ((a!1 (= (type a@@64)
                   (MapType0Type (MapType0TypeInv0 (type a@@64)) intType)))
           (a!2 (= (type b@@49)
                   (MapType0Type (MapType0TypeInv0 (type a@@64)) intType)))
           (a!3 (forall ((o@@42 T@U))
                  (! (let ((a!1 (or (= (U_2_int (MapType0Select a@@64 o@@42)) 0)
                                    (= (U_2_int (MapType0Select b@@49 o@@42)) 0))))
                       (=> (= (type o@@42) (MapType0TypeInv0 (type a@@64))) a!1))
                     :pattern ((MapType0Select a@@64 o@@42))
                     :pattern ((MapType0Select b@@49 o@@42))
                     :skolemid |554|
                     :qid |DafnyPreludebpl.878:39|))))
       (=> (and a!1 a!2) (= (|MultiSet#Disjoint| a@@64 b@@49) a!3)))
     :pattern ((|MultiSet#Disjoint| a@@64 b@@49))
     :skolemid |555|
     :qid |DafnyPreludebpl.877:18|)))
(assert (forall ((arg0@@89 T@U))
  (! (= (type (|MultiSet#FromSet| arg0@@89))
        (MapType0Type (MapType0TypeInv0 (type arg0@@89)) intType))
     :pattern ((|MultiSet#FromSet| arg0@@89))
     :qid |funType:MultiSet#FromSet|)))
(assert (forall ((s@@8 T@U) (a@@65 T@U))
  (! (let ((a!1 (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@65)) 0))
           (a!3 (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@65)) 1)))
     (let ((a!2 (= a!1 (not (U_2_bool (MapType0Select s@@8 a@@65))))))
     (let ((a!4 (and a!2 (= a!3 (U_2_bool (MapType0Select s@@8 a@@65))))))
       (=> (= (type s@@8) (MapType0Type (type a@@65) boolType)) a!4))))
     :pattern ((MapType0Select (|MultiSet#FromSet| s@@8) a@@65))
     :skolemid |556|
     :qid |DafnyPreludebpl.882:18|)))
(assert (forall ((s@@9 T@U))
  (! (let ((a!1 (= (type s@@9)
                   (MapType0Type (MapType0TypeInv0 (type s@@9)) boolType))))
       (=> a!1
           (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9))))
     :pattern ((|MultiSet#Card| (|MultiSet#FromSet| s@@9)))
     :skolemid |557|
     :qid |DafnyPreludebpl.885:18|)))
(assert (forall ((arg0@@90 T@U))
  (! (= (type (|MultiSet#FromSeq| arg0@@90))
        (MapType0Type (SeqTypeInv0 (type arg0@@90)) intType))
     :pattern ((|MultiSet#FromSeq| arg0@@90))
     :qid |funType:MultiSet#FromSeq|)))
(assert (forall ((s@@10 T@U))
  (! (let ((a!1 (= (type s@@10) (SeqType (SeqTypeInv0 (type s@@10))))))
       (=> a!1 ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10))))
     :pattern ((|MultiSet#FromSeq| s@@10))
     :skolemid |558|
     :qid |DafnyPreludebpl.891:18|)))
(assert (forall ((s@@11 T@U))
  (! (let ((a!1 (= (type s@@11) (SeqType (SeqTypeInv0 (type s@@11))))))
       (=> a!1
           (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11))))
     :pattern ((|MultiSet#Card| (|MultiSet#FromSeq| s@@11)))
     :skolemid |559|
     :qid |DafnyPreludebpl.893:18|)))
(assert (forall ((arg0@@91 T@U) (arg1@@36 T@U))
  (! (= (type (|Seq#Build| arg0@@91 arg1@@36)) (SeqType (type arg1@@36)))
     :pattern ((|Seq#Build| arg0@@91 arg1@@36))
     :qid |funType:Seq#Build|)))
(assert (forall ((s@@12 T@U) (v@@29 T@U))
  (! (=> (= (type s@@12) (SeqType (type v@@29)))
         (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@29))
            (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@29)))
     :pattern ((|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@29)))
     :skolemid |560|
     :qid |DafnyPreludebpl.897:18|)))
(assert (forall ((T@@99 T@T))
  (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99))
     :pattern ((|Seq#Empty| T@@99))
     :qid |funType:Seq#Empty|)))
(assert (forall ((T@@100 T@T))
  (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100))
     :skolemid |561|)))
(assert (forall ((arg0@@92 T@U) (arg1@@37 T@U))
  (! (= (type (|Seq#Append| arg0@@92 arg1@@37))
        (SeqType (SeqTypeInv0 (type arg0@@92))))
     :pattern ((|Seq#Append| arg0@@92 arg1@@37))
     :qid |funType:Seq#Append|)))
(assert (forall ((a@@66 T@U) (b@@50 T@U))
  (! (let ((a!1 (= (type a@@66) (SeqType (SeqTypeInv0 (type a@@66)))))
           (a!2 (= (type b@@50) (SeqType (SeqTypeInv0 (type a@@66))))))
       (=> (and a!1 a!2)
           (= (|MultiSet#FromSeq| (|Seq#Append| a@@66 b@@50))
              (|MultiSet#Union| (|MultiSet#FromSeq| a@@66)
                                (|MultiSet#FromSeq| b@@50)))))
     :pattern ((|MultiSet#FromSeq| (|Seq#Append| a@@66 b@@50)))
     :skolemid |562|
     :qid |DafnyPreludebpl.904:18|)))
(assert (forall ((arg0@@93 T@U) (arg1@@38 Int) (arg2@@1 T@U))
  (! (= (type (|Seq#Update| arg0@@93 arg1@@38 arg2@@1))
        (SeqType (type arg2@@1)))
     :pattern ((|Seq#Update| arg0@@93 arg1@@38 arg2@@1))
     :qid |funType:Seq#Update|)))
(assert (forall ((s@@13 T@U) (i@@6 Int) (v@@30 T@U) (x@@34 T@U))
  (! (let ((a!1 (and (= (type s@@13) (SeqType (type v@@30)))
                     (= (type x@@34) (type v@@30))
                     (<= 0 i@@6)
                     (< i@@6 (|Seq#Length| s@@13))))
           (a!2 (U_2_int (MapType0Select (|MultiSet#FromSeq|
                                           (|Seq#Update| s@@13 i@@6 v@@30))
                                         x@@34)))
           (a!3 (|MultiSet#Union| (|MultiSet#Difference|
                                    (|MultiSet#FromSeq| s@@13)
                                    (|MultiSet#Singleton|
                                      (|Seq#Index| s@@13 i@@6)))
                                  (|MultiSet#Singleton| v@@30))))
       (=> a!1 (= a!2 (U_2_int (MapType0Select a!3 x@@34)))))
     :pattern ((MapType0Select (|MultiSet#FromSeq|
                                 (|Seq#Update| s@@13 i@@6 v@@30))
                               x@@34))
     :skolemid |563|
     :qid |DafnyPreludebpl.909:18|)))
(assert (forall ((s@@14 T@U) (x@@35 T@U))
  (! (let ((a!1 (exists ((i@@7 Int))
                  (! (and (<= 0 i@@7)
                          (< i@@7 (|Seq#Length| s@@14))
                          (= x@@35 (|Seq#Index| s@@14 i@@7)))
                     :pattern ((|Seq#Index| s@@14 i@@7))
                     :skolemid |564|
                     :qid |DafnyPreludebpl.916:11|)))
           (a!2 (< 0
                   (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@35)))))
       (=> (= (type s@@14) (SeqType (type x@@35))) (= a!1 a!2)))
     :pattern ((MapType0Select (|MultiSet#FromSeq| s@@14) x@@35))
     :skolemid |565|
     :qid |DafnyPreludebpl.915:18|)))
(assert (forall ((s@@15 T@U))
  (! (let ((a!1 (= (type s@@15) (SeqType (SeqTypeInv0 (type s@@15))))))
       (=> a!1 (<= 0 (|Seq#Length| s@@15))))
     :pattern ((|Seq#Length| s@@15))
     :skolemid |566|
     :qid |DafnyPreludebpl.925:18|)))
(assert (forall ((T@@107 T@T))
  (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0)
     :pattern ((|Seq#Empty| T@@107))
     :skolemid |567|)))
(assert (forall ((s@@16 T@U))
  (! (let ((a!1 (= (type s@@16) (SeqType (SeqTypeInv0 (type s@@16)))))
           (a!2 (= s@@16 (|Seq#Empty| (SeqTypeInv0 (type s@@16))))))
       (=> (and a!1 (= (|Seq#Length| s@@16) 0)) a!2))
     :pattern ((|Seq#Length| s@@16))
     :skolemid |568|
     :qid |DafnyPreludebpl.929:18|)))
(assert (forall ((arg0@@94 T@U))
  (! (= (type (|Seq#Singleton| arg0@@94)) (SeqType (type arg0@@94)))
     :pattern ((|Seq#Singleton| arg0@@94))
     :qid |funType:Seq#Singleton|)))
(assert (forall ((t@@23 T@U))
  (! (= (|Seq#Length| (|Seq#Singleton| t@@23)) 1)
     :pattern ((|Seq#Length| (|Seq#Singleton| t@@23)))
     :skolemid |569|
     :qid |DafnyPreludebpl.942:18|)))
(assert (let ((a!1 (forall ((arg0@@95 T@U))
             (! (= (type (|Seq#Build_inv0| arg0@@95))
                   (SeqType (SeqTypeInv0 (type arg0@@95))))
                :pattern ((|Seq#Build_inv0| arg0@@95))
                :qid |funType:Seq#Build_inv0|)))
      (a!2 (forall ((arg0@@96 T@U))
             (! (= (type (|Seq#Build_inv1| arg0@@96))
                   (SeqTypeInv0 (type arg0@@96)))
                :pattern ((|Seq#Build_inv1| arg0@@96))
                :qid |funType:Seq#Build_inv1|))))
  (and a!1 a!2)))
(assert (forall ((s@@17 T@U) (val@@5 T@U))
  (! (let ((a!1 (and (= (|Seq#Build_inv0| (|Seq#Build| s@@17 val@@5)) s@@17)
                     (= (|Seq#Build_inv1| (|Seq#Build| s@@17 val@@5)) val@@5))))
       (=> (= (type s@@17) (SeqType (type val@@5))) a!1))
     :pattern ((|Seq#Build| s@@17 val@@5))
     :skolemid |570|
     :qid |DafnyPreludebpl.947:18|)))
(assert (forall ((s@@18 T@U) (v@@31 T@U))
  (! (=> (= (type s@@18) (SeqType (type v@@31)))
         (= (|Seq#Length| (|Seq#Build| s@@18 v@@31)) (+ 1 (|Seq#Length| s@@18))))
     :pattern ((|Seq#Build| s@@18 v@@31))
     :skolemid |571|
     :qid |DafnyPreludebpl.952:18|)))
(assert (forall ((s@@19 T@U) (i@@8 Int) (v@@32 T@U))
  (! (let ((a!1 (=> (= i@@8 (|Seq#Length| s@@19))
                    (= (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8) v@@32)))
           (a!2 (=> (not (= i@@8 (|Seq#Length| s@@19)))
                    (= (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8)
                       (|Seq#Index| s@@19 i@@8)))))
       (=> (= (type s@@19) (SeqType (type v@@32))) (and a!1 a!2)))
     :pattern ((|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8))
     :skolemid |572|
     :qid |DafnyPreludebpl.955:18|)))
(assert (forall ((s@@20 T@U) (bx@@23 T@U) (t@@24 T@U))
  (! (=> (and (= (type s@@20) (SeqType BoxType))
              (= (type bx@@23) BoxType)
              (= (type t@@24) TyType)
              ($Is s@@20 (TSeq t@@24))
              ($IsBox bx@@23 t@@24))
         ($Is (|Seq#Build| s@@20 bx@@23) (TSeq t@@24)))
     :pattern (($Is (|Seq#Build| s@@20 bx@@23) (TSeq t@@24)))
     :skolemid |573|
     :qid |DafnyPreludebpl.960:15|)))
(assert (let ((a!1 (forall ((arg0@@97 T@U) (arg1@@39 T@U) (arg2@@2 Int) (arg3 T@U))
             (! (= (type (|Seq#Create| arg0@@97 arg1@@39 arg2@@2 arg3))
                   (SeqType BoxType))
                :pattern ((|Seq#Create| arg0@@97 arg1@@39 arg2@@2 arg3))
                :qid |funType:Seq#Create|))))
  (and (= (Ctor HandleTypeType) 23) a!1)))
(assert (forall ((ty T@U) (heap T@U) (len Int) (init T@U))
  (! (=> (and (= (type ty) TyType)
              (= (type heap) (MapType0Type refType MapType1Type))
              (= (type init) HandleTypeType)
              ($IsGoodHeap heap)
              (<= 0 len))
         (= (|Seq#Length| (|Seq#Create| ty heap len init)) len))
     :pattern ((|Seq#Length| (|Seq#Create| ty heap len init)))
     :skolemid |574|
     :qid |DafnyPreludebpl.964:15|)))
(assert (forall ((arg0@@98 T@U) (arg1@@40 T@U) (arg2@@3 T@U) (arg3@@0 T@U) (arg4 T@U))
  (! (= (type (Apply1 arg0@@98 arg1@@40 arg2@@3 arg3@@0 arg4)) BoxType)
     :pattern ((Apply1 arg0@@98 arg1@@40 arg2@@3 arg3@@0 arg4))
     :qid |funType:Apply1|)))
(assert (forall ((ty@@0 T@U) (heap@@0 T@U) (len@@0 Int) (init@@0 T@U) (i@@9 Int))
  (! (let ((a!1 (= (|Seq#Index| (|Seq#Create| ty@@0 heap@@0 len@@0 init@@0)
                                i@@9)
                   (Apply1 TInt
                           (TSeq ty@@0)
                           heap@@0
                           init@@0
                           ($Box (int_2_U i@@9))))))
       (=> (and (= (type ty@@0) TyType)
                (= (type heap@@0) (MapType0Type refType MapType1Type))
                (= (type init@@0) HandleTypeType)
                ($IsGoodHeap heap@@0)
                (<= 0 i@@9)
                (< i@@9 len@@0))
           a!1))
     :pattern ((|Seq#Index| (|Seq#Create| ty@@0 heap@@0 len@@0 init@@0) i@@9))
     :skolemid |575|
     :qid |DafnyPreludebpl.968:15|)))
(assert (forall ((s0 T@U) (s1 T@U))
  (! (let ((a!1 (= (type s0) (SeqType (SeqTypeInv0 (type s0)))))
           (a!2 (= (type s1) (SeqType (SeqTypeInv0 (type s0))))))
       (=> (and a!1 a!2)
           (= (|Seq#Length| (|Seq#Append| s0 s1))
              (+ (|Seq#Length| s0) (|Seq#Length| s1)))))
     :pattern ((|Seq#Length| (|Seq#Append| s0 s1)))
     :skolemid |576|
     :qid |DafnyPreludebpl.974:18|)))
(assert (forall ((t@@25 T@U))
  (! (= (|Seq#Index| (|Seq#Singleton| t@@25) 0) t@@25)
     :pattern ((|Seq#Index| (|Seq#Singleton| t@@25) 0))
     :skolemid |577|
     :qid |DafnyPreludebpl.978:18|)))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (n@@6 Int))
  (! (let ((a!1 (= (type s0@@0) (SeqType (SeqTypeInv0 (type s0@@0)))))
           (a!2 (= (type s1@@0) (SeqType (SeqTypeInv0 (type s0@@0)))))
           (a!3 (=> (< n@@6 (|Seq#Length| s0@@0))
                    (= (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6)
                       (|Seq#Index| s0@@0 n@@6))))
           (a!4 (= (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6)
                   (|Seq#Index| s1@@0 (- n@@6 (|Seq#Length| s0@@0))))))
     (let ((a!5 (and a!3 (=> (<= (|Seq#Length| s0@@0) n@@6) a!4))))
       (=> (and a!1 a!2) a!5)))
     :pattern ((|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6))
     :skolemid |578|
     :qid |DafnyPreludebpl.979:18|)))
(assert (forall ((s@@21 T@U) (i@@10 Int) (v@@33 T@U))
  (! (let ((a!1 (=> (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@21)))
                    (= (|Seq#Length| (|Seq#Update| s@@21 i@@10 v@@33))
                       (|Seq#Length| s@@21)))))
       (=> (= (type s@@21) (SeqType (type v@@33))) a!1))
     :pattern ((|Seq#Length| (|Seq#Update| s@@21 i@@10 v@@33)))
     :skolemid |579|
     :qid |DafnyPreludebpl.984:18|)))
(assert (forall ((s@@22 T@U) (i@@11 Int) (v@@34 T@U) (n@@7 Int))
  (! (let ((a!1 (=> (= i@@11 n@@7)
                    (= (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7)
                       v@@34)))
           (a!2 (=> (not (= i@@11 n@@7))
                    (= (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7)
                       (|Seq#Index| s@@22 n@@7)))))
     (let ((a!3 (=> (and (<= 0 n@@7) (< n@@7 (|Seq#Length| s@@22)))
                    (and a!1 a!2))))
       (=> (= (type s@@22) (SeqType (type v@@34))) a!3)))
     :pattern ((|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7))
     :skolemid |580|
     :qid |DafnyPreludebpl.986:18|)))
(assert (forall ((s@@23 T@U) (x@@36 T@U))
  (! (let ((a!1 (exists ((i@@12 Int))
                  (! (and (<= 0 i@@12)
                          (< i@@12 (|Seq#Length| s@@23))
                          (= (|Seq#Index| s@@23 i@@12) x@@36))
                     :pattern ((|Seq#Index| s@@23 i@@12))
                     :skolemid |581|
                     :qid |DafnyPreludebpl.994:13|))))
       (=> (= (type s@@23) (SeqType (type x@@36)))
           (= (|Seq#Contains| s@@23 x@@36) a!1)))
     :pattern ((|Seq#Contains| s@@23 x@@36))
     :skolemid |582|
     :qid |DafnyPreludebpl.992:18|)))
(assert (forall ((x@@37 T@U))
  (! (not (|Seq#Contains| (|Seq#Empty| (type x@@37)) x@@37))
     :pattern ((|Seq#Contains| (|Seq#Empty| (type x@@37)) x@@37))
     :skolemid |583|
     :qid |DafnyPreludebpl.995:18|)))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (x@@38 T@U))
  (! (let ((a!1 (and (= (type s0@@1) (SeqType (type x@@38)))
                     (= (type s1@@1) (SeqType (type x@@38))))))
       (=> a!1
           (= (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38)
              (or (|Seq#Contains| s0@@1 x@@38) (|Seq#Contains| s1@@1 x@@38)))))
     :pattern ((|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38))
     :skolemid |584|
     :qid |DafnyPreludebpl.999:18|)))
(assert (forall ((s@@24 T@U) (v@@35 T@U) (x@@39 T@U))
  (! (let ((a!1 (and (= (type s@@24) (SeqType (type v@@35)))
                     (= (type x@@39) (type v@@35)))))
       (=> a!1
           (= (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39)
              (or (= v@@35 x@@39) (|Seq#Contains| s@@24 x@@39)))))
     :pattern ((|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39))
     :skolemid |585|
     :qid |DafnyPreludebpl.1004:18|)))
(assert (forall ((arg0@@99 T@U) (arg1@@41 Int))
  (! (= (type (|Seq#Take| arg0@@99 arg1@@41))
        (SeqType (SeqTypeInv0 (type arg0@@99))))
     :pattern ((|Seq#Take| arg0@@99 arg1@@41))
     :qid |funType:Seq#Take|)))
(assert (forall ((s@@25 T@U) (n@@8 Int) (x@@40 T@U))
  (! (let ((a!1 (exists ((i@@13 Int))
                  (! (and (<= 0 i@@13)
                          (< i@@13 n@@8)
                          (< i@@13 (|Seq#Length| s@@25))
                          (= (|Seq#Index| s@@25 i@@13) x@@40))
                     :pattern ((|Seq#Index| s@@25 i@@13))
                     :skolemid |586|
                     :qid |DafnyPreludebpl.1011:13|))))
       (=> (= (type s@@25) (SeqType (type x@@40)))
           (= (|Seq#Contains| (|Seq#Take| s@@25 n@@8) x@@40) a!1)))
     :pattern ((|Seq#Contains| (|Seq#Take| s@@25 n@@8) x@@40))
     :skolemid |587|
     :qid |DafnyPreludebpl.1008:18|)))
(assert (forall ((arg0@@100 T@U) (arg1@@42 Int))
  (! (= (type (|Seq#Drop| arg0@@100 arg1@@42))
        (SeqType (SeqTypeInv0 (type arg0@@100))))
     :pattern ((|Seq#Drop| arg0@@100 arg1@@42))
     :qid |funType:Seq#Drop|)))
(assert (forall ((s@@26 T@U) (n@@9 Int) (x@@41 T@U))
  (! (let ((a!1 (exists ((i@@14 Int))
                  (! (and (<= 0 n@@9)
                          (<= n@@9 i@@14)
                          (< i@@14 (|Seq#Length| s@@26))
                          (= (|Seq#Index| s@@26 i@@14) x@@41))
                     :pattern ((|Seq#Index| s@@26 i@@14))
                     :skolemid |588|
                     :qid |DafnyPreludebpl.1016:13|))))
       (=> (= (type s@@26) (SeqType (type x@@41)))
           (= (|Seq#Contains| (|Seq#Drop| s@@26 n@@9) x@@41) a!1)))
     :pattern ((|Seq#Contains| (|Seq#Drop| s@@26 n@@9) x@@41))
     :skolemid |589|
     :qid |DafnyPreludebpl.1013:18|)))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U))
  (! (let ((a!1 (= (type s0@@2) (SeqType (SeqTypeInv0 (type s0@@2)))))
           (a!2 (= (type s1@@2) (SeqType (SeqTypeInv0 (type s0@@2)))))
           (a!3 (forall ((j Int))
                  (! (=> (and (<= 0 j) (< j (|Seq#Length| s0@@2)))
                         (= (|Seq#Index| s0@@2 j) (|Seq#Index| s1@@2 j)))
                     :pattern ((|Seq#Index| s0@@2 j))
                     :pattern ((|Seq#Index| s1@@2 j))
                     :skolemid |590|
                     :qid |DafnyPreludebpl.1023:13|))))
     (let ((a!4 (= (|Seq#Equal| s0@@2 s1@@2)
                   (and (= (|Seq#Length| s0@@2) (|Seq#Length| s1@@2)) a!3))))
       (=> (and a!1 a!2) a!4)))
     :pattern ((|Seq#Equal| s0@@2 s1@@2))
     :skolemid |591|
     :qid |DafnyPreludebpl.1020:18|)))
(assert (forall ((a@@67 T@U) (b@@51 T@U))
  (! (let ((a!1 (= (type a@@67) (SeqType (SeqTypeInv0 (type a@@67)))))
           (a!2 (= (type b@@51) (SeqType (SeqTypeInv0 (type a@@67))))))
       (=> (and a!1 a!2 (|Seq#Equal| a@@67 b@@51)) (= a@@67 b@@51)))
     :pattern ((|Seq#Equal| a@@67 b@@51))
     :skolemid |592|
     :qid |DafnyPreludebpl.1025:18|)))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U) (n@@10 Int))
  (! (let ((a!1 (= (type s0@@3) (SeqType (SeqTypeInv0 (type s0@@3)))))
           (a!2 (= (type s1@@3) (SeqType (SeqTypeInv0 (type s0@@3)))))
           (a!3 (forall ((j@@0 Int))
                  (! (=> (and (<= 0 j@@0) (< j@@0 n@@10))
                         (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0)))
                     :pattern ((|Seq#Index| s0@@3 j@@0))
                     :pattern ((|Seq#Index| s1@@3 j@@0))
                     :skolemid |593|
                     :qid |DafnyPreludebpl.1031:13|))))
       (=> (and a!1 a!2) (= (|Seq#SameUntil| s0@@3 s1@@3 n@@10) a!3)))
     :pattern ((|Seq#SameUntil| s0@@3 s1@@3 n@@10))
     :skolemid |594|
     :qid |DafnyPreludebpl.1029:18|)))
(assert (forall ((s@@27 T@U) (n@@11 Int))
  (! (let ((a!1 (= (type s@@27) (SeqType (SeqTypeInv0 (type s@@27)))))
           (a!2 (=> (and (<= 0 n@@11) (<= n@@11 (|Seq#Length| s@@27)))
                    (= (|Seq#Length| (|Seq#Take| s@@27 n@@11)) n@@11))))
       (=> a!1 a!2))
     :pattern ((|Seq#Length| (|Seq#Take| s@@27 n@@11)))
     :skolemid |595|
     :qid |DafnyPreludebpl.1035:18|)))
(assert (forall ((s@@28 T@U) (n@@12 Int) (j@@1 Int))
  (! (let ((a!1 (= (type s@@28) (SeqType (SeqTypeInv0 (type s@@28)))))
           (a!2 (=> (and (<= 0 j@@1)
                         (< j@@1 n@@12)
                         (< j@@1 (|Seq#Length| s@@28)))
                    (= (|Seq#Index| (|Seq#Take| s@@28 n@@12) j@@1)
                       (|Seq#Index| s@@28 j@@1)))))
       (=> a!1 a!2))
     :pattern ((|Seq#Index| (|Seq#Take| s@@28 n@@12) j@@1))
     :pattern ((|Seq#Index| s@@28 j@@1) (|Seq#Take| s@@28 n@@12))
     :weight 25
     :skolemid |596|
     :qid |DafnyPreludebpl.1037:18|)))
(assert (forall ((s@@29 T@U) (n@@13 Int))
  (! (let ((a!1 (= (type s@@29) (SeqType (SeqTypeInv0 (type s@@29)))))
           (a!2 (=> (and (<= 0 n@@13) (<= n@@13 (|Seq#Length| s@@29)))
                    (= (|Seq#Length| (|Seq#Drop| s@@29 n@@13))
                       (- (|Seq#Length| s@@29) n@@13)))))
       (=> a!1 a!2))
     :pattern ((|Seq#Length| (|Seq#Drop| s@@29 n@@13)))
     :skolemid |597|
     :qid |DafnyPreludebpl.1045:18|)))
(assert (forall ((s@@30 T@U) (n@@14 Int) (j@@2 Int))
  (! (let ((a!1 (= (type s@@30) (SeqType (SeqTypeInv0 (type s@@30)))))
           (a!2 (and (<= 0 n@@14)
                     (<= 0 j@@2)
                     (< j@@2 (- (|Seq#Length| s@@30) n@@14)))))
     (let ((a!3 (=> a!2
                    (= (|Seq#Index| (|Seq#Drop| s@@30 n@@14) j@@2)
                       (|Seq#Index| s@@30 (+ j@@2 n@@14))))))
       (=> a!1 a!3)))
     :pattern ((|Seq#Index| (|Seq#Drop| s@@30 n@@14) j@@2))
     :weight 25
     :skolemid |598|
     :qid |DafnyPreludebpl.1047:18|)))
(assert (forall ((s@@31 T@U) (n@@15 Int) (k@@3 Int))
  (! (let ((a!1 (= (type s@@31) (SeqType (SeqTypeInv0 (type s@@31)))))
           (a!2 (=> (and (<= 0 n@@15)
                         (<= n@@15 k@@3)
                         (< k@@3 (|Seq#Length| s@@31)))
                    (= (|Seq#Index| (|Seq#Drop| s@@31 n@@15) (- k@@3 n@@15))
                       (|Seq#Index| s@@31 k@@3)))))
       (=> a!1 a!2))
     :pattern ((|Seq#Index| s@@31 k@@3) (|Seq#Drop| s@@31 n@@15))
     :weight 25
     :skolemid |599|
     :qid |DafnyPreludebpl.1052:18|)))
(assert (forall ((s@@32 T@U) (t@@26 T@U) (n@@16 Int))
  (! (let ((a!1 (= (type s@@32) (SeqType (SeqTypeInv0 (type s@@32)))))
           (a!2 (= (type t@@26) (SeqType (SeqTypeInv0 (type s@@32)))))
           (a!3 (and (= (|Seq#Take| (|Seq#Append| s@@32 t@@26) n@@16) s@@32)
                     (= (|Seq#Drop| (|Seq#Append| s@@32 t@@26) n@@16) t@@26))))
       (=> (and a!1 a!2 (= n@@16 (|Seq#Length| s@@32))) a!3))
     :pattern ((|Seq#Take| (|Seq#Append| s@@32 t@@26) n@@16))
     :pattern ((|Seq#Drop| (|Seq#Append| s@@32 t@@26) n@@16))
     :skolemid |600|
     :qid |DafnyPreludebpl.1058:18|)))
(assert (forall ((arg0@@101 T@U) (arg1@@43 T@U))
  (! (= (type (|Seq#FromArray| arg0@@101 arg1@@43)) (SeqType BoxType))
     :pattern ((|Seq#FromArray| arg0@@101 arg1@@43))
     :qid |funType:Seq#FromArray|)))
(assert (forall ((h@@17 T@U) (a@@68 T@U))
  (! (=> (and (= (type h@@17) (MapType0Type refType MapType1Type))
              (= (type a@@68) refType))
         (= (|Seq#Length| (|Seq#FromArray| h@@17 a@@68))
            (_System.array.Length a@@68)))
     :pattern ((|Seq#Length| (|Seq#FromArray| h@@17 a@@68)))
     :skolemid |601|
     :qid |DafnyPreludebpl.1067:15|)))
(assert (forall ((h@@18 T@U) (a@@69 T@U))
  (! (let ((a!1 (forall ((i@@15 Int))
                  (! (let ((a!1 (and (<= 0 i@@15)
                                     (< i@@15
                                        (|Seq#Length| (|Seq#FromArray| h@@18
                                                                       a@@69))))))
                       (=> a!1
                           (= (|Seq#Index| (|Seq#FromArray| h@@18 a@@69) i@@15)
                              (MapType1Select (MapType0Select h@@18 a@@69)
                                              (IndexField i@@15)))))
                     :pattern ((MapType1Select (MapType0Select h@@18 a@@69)
                                               (IndexField i@@15)))
                     :pattern ((|Seq#Index| (|Seq#FromArray| h@@18 a@@69) i@@15))
                     :skolemid |602|
                     :qid |DafnyPreludebpl.1072:11|))))
       (=> (and (= (type h@@18) (MapType0Type refType MapType1Type))
                (= (type a@@69) refType))
           a!1))
     :pattern ((|Seq#FromArray| h@@18 a@@69))
     :skolemid |603|
     :qid |DafnyPreludebpl.1070:15|)))
(assert (forall ((h0 T@U) (h1 T@U) (a@@70 T@U))
  (! (let ((a!1 (=> (and ($IsGoodHeap h0)
                         ($IsGoodHeap h1)
                         ($HeapSucc h0 h1)
                         (= (MapType0Select h0 a@@70) (MapType0Select h1 a@@70)))
                    (= (|Seq#FromArray| h0 a@@70) (|Seq#FromArray| h1 a@@70)))))
       (=> (and (= (type h0) (MapType0Type refType MapType1Type))
                (= (type h1) (MapType0Type refType MapType1Type))
                (= (type a@@70) refType))
           a!1))
     :pattern ((|Seq#FromArray| h1 a@@70) ($HeapSucc h0 h1))
     :skolemid |604|
     :qid |DafnyPreludebpl.1082:15|)))
(assert (forall ((h@@19 T@U) (i@@16 Int) (v@@36 T@U) (a@@71 T@U))
  (! (let ((a!1 (|Seq#FromArray| (MapType0Store h@@19
                                                a@@71
                                                (MapType1Store (MapType0Select h@@19
                                                                               a@@71)
                                                               (IndexField i@@16)
                                                               v@@36))
                                 a@@71)))
       (=> (and (= (type h@@19) (MapType0Type refType MapType1Type))
                (= (type v@@36) BoxType)
                (= (type a@@71) refType)
                (<= 0 i@@16)
                (< i@@16 (_System.array.Length a@@71)))
           (= a!1 (|Seq#Update| (|Seq#FromArray| h@@19 a@@71) i@@16 v@@36))))
     :pattern ((|Seq#FromArray| (MapType0Store h@@19
                                               a@@71
                                               (MapType1Store (MapType0Select h@@19
                                                                              a@@71)
                                                              (IndexField i@@16)
                                                              v@@36))
                                a@@71))
     :skolemid |605|
     :qid |DafnyPreludebpl.1087:15|)))
(assert (forall ((s@@33 T@U) (i@@17 Int) (v@@37 T@U) (n@@17 Int))
  (! (let ((a!1 (=> (and (<= 0 i@@17)
                         (< i@@17 n@@17)
                         (<= n@@17 (|Seq#Length| s@@33)))
                    (= (|Seq#Take| (|Seq#Update| s@@33 i@@17 v@@37) n@@17)
                       (|Seq#Update| (|Seq#Take| s@@33 n@@17) i@@17 v@@37)))))
       (=> (= (type s@@33) (SeqType (type v@@37))) a!1))
     :pattern ((|Seq#Take| (|Seq#Update| s@@33 i@@17 v@@37) n@@17))
     :skolemid |606|
     :qid |DafnyPreludebpl.1092:18|)))
(assert (forall ((s@@34 T@U) (i@@18 Int) (v@@38 T@U) (n@@18 Int))
  (! (let ((a!1 (=> (and (<= n@@18 i@@18) (< i@@18 (|Seq#Length| s@@34)))
                    (= (|Seq#Take| (|Seq#Update| s@@34 i@@18 v@@38) n@@18)
                       (|Seq#Take| s@@34 n@@18)))))
       (=> (= (type s@@34) (SeqType (type v@@38))) a!1))
     :pattern ((|Seq#Take| (|Seq#Update| s@@34 i@@18 v@@38) n@@18))
     :skolemid |607|
     :qid |DafnyPreludebpl.1095:18|)))
(assert (forall ((s@@35 T@U) (i@@19 Int) (v@@39 T@U) (n@@19 Int))
  (! (let ((a!1 (=> (and (<= 0 n@@19)
                         (<= n@@19 i@@19)
                         (< i@@19 (|Seq#Length| s@@35)))
                    (= (|Seq#Drop| (|Seq#Update| s@@35 i@@19 v@@39) n@@19)
                       (|Seq#Update| (|Seq#Drop| s@@35 n@@19)
                                     (- i@@19 n@@19)
                                     v@@39)))))
       (=> (= (type s@@35) (SeqType (type v@@39))) a!1))
     :pattern ((|Seq#Drop| (|Seq#Update| s@@35 i@@19 v@@39) n@@19))
     :skolemid |608|
     :qid |DafnyPreludebpl.1098:18|)))
(assert (forall ((s@@36 T@U) (i@@20 Int) (v@@40 T@U) (n@@20 Int))
  (! (let ((a!1 (=> (and (<= 0 i@@20)
                         (< i@@20 n@@20)
                         (< n@@20 (|Seq#Length| s@@36)))
                    (= (|Seq#Drop| (|Seq#Update| s@@36 i@@20 v@@40) n@@20)
                       (|Seq#Drop| s@@36 n@@20)))))
       (=> (= (type s@@36) (SeqType (type v@@40))) a!1))
     :pattern ((|Seq#Drop| (|Seq#Update| s@@36 i@@20 v@@40) n@@20))
     :skolemid |609|
     :qid |DafnyPreludebpl.1101:18|)))
(assert (forall ((h@@20 T@U) (a@@72 T@U) (n0 Int) (n1 Int))
  (! (let ((a!1 (= (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n1)
                   (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n0)
                                (MapType1Select (MapType0Select h@@20 a@@72)
                                                (IndexField n0))))))
     (let ((a!2 (=> (and (= (+ n0 1) n1)
                         (<= 0 n0)
                         (<= n1 (_System.array.Length a@@72)))
                    a!1)))
       (=> (and (= (type h@@20) (MapType0Type refType MapType1Type))
                (= (type a@@72) refType))
           a!2)))
     :pattern ((|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n0)
               (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n1))
     :skolemid |610|
     :qid |DafnyPreludebpl.1105:15|)))
(assert (forall ((s@@37 T@U) (v@@41 T@U) (n@@21 Int))
  (! (let ((a!1 (=> (and (<= 0 n@@21) (<= n@@21 (|Seq#Length| s@@37)))
                    (= (|Seq#Drop| (|Seq#Build| s@@37 v@@41) n@@21)
                       (|Seq#Build| (|Seq#Drop| s@@37 n@@21) v@@41)))))
       (=> (= (type s@@37) (SeqType (type v@@41))) a!1))
     :pattern ((|Seq#Drop| (|Seq#Build| s@@37 v@@41) n@@21))
     :skolemid |611|
     :qid |DafnyPreludebpl.1109:18|)))
(assert (forall ((s@@38 T@U) (i@@21 Int))
  (! (let ((a!1 (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@21)))
                   (|Seq#Rank| s@@38))))
     (let ((a!2 (=> (and (<= 0 i@@21) (< i@@21 (|Seq#Length| s@@38))) a!1)))
       (=> (= (type s@@38) (SeqType BoxType)) a!2)))
     :pattern ((DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@21))))
     :skolemid |612|
     :qid |DafnyPreludebpl.1114:15|)))
(assert (forall ((s@@39 T@U) (i@@22 Int))
  (! (let ((a!1 (= (type s@@39) (SeqType (SeqTypeInv0 (type s@@39)))))
           (a!2 (=> (and (< 0 i@@22) (<= i@@22 (|Seq#Length| s@@39)))
                    (< (|Seq#Rank| (|Seq#Drop| s@@39 i@@22)) (|Seq#Rank| s@@39)))))
       (=> a!1 a!2))
     :pattern ((|Seq#Rank| (|Seq#Drop| s@@39 i@@22)))
     :skolemid |613|
     :qid |DafnyPreludebpl.1117:18|)))
(assert (forall ((s@@40 T@U) (i@@23 Int))
  (! (let ((a!1 (= (type s@@40) (SeqType (SeqTypeInv0 (type s@@40)))))
           (a!2 (=> (and (<= 0 i@@23) (< i@@23 (|Seq#Length| s@@40)))
                    (< (|Seq#Rank| (|Seq#Take| s@@40 i@@23)) (|Seq#Rank| s@@40)))))
       (=> a!1 a!2))
     :pattern ((|Seq#Rank| (|Seq#Take| s@@40 i@@23)))
     :skolemid |614|
     :qid |DafnyPreludebpl.1120:18|)))
(assert (forall ((s@@41 T@U) (i@@24 Int) (j@@3 Int))
  (! (let ((a!1 (= (type s@@41) (SeqType (SeqTypeInv0 (type s@@41)))))
           (a!2 (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@24)
                                             (|Seq#Drop| s@@41 j@@3)))
                   (|Seq#Rank| s@@41))))
     (let ((a!3 (=> (and (<= 0 i@@24)
                         (< i@@24 j@@3)
                         (<= j@@3 (|Seq#Length| s@@41)))
                    a!2)))
       (=> a!1 a!3)))
     :pattern ((|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@24)
                                         (|Seq#Drop| s@@41 j@@3))))
     :skolemid |615|
     :qid |DafnyPreludebpl.1123:18|)))
(assert (forall ((s@@42 T@U) (n@@22 Int))
  (! (let ((a!1 (= (type s@@42) (SeqType (SeqTypeInv0 (type s@@42))))))
       (=> (and a!1 (= n@@22 0)) (= (|Seq#Drop| s@@42 n@@22) s@@42)))
     :pattern ((|Seq#Drop| s@@42 n@@22))
     :skolemid |616|
     :qid |DafnyPreludebpl.1128:18|)))
(assert (forall ((s@@43 T@U) (n@@23 Int))
  (! (let ((a!1 (= (type s@@43) (SeqType (SeqTypeInv0 (type s@@43)))))
           (a!2 (= (|Seq#Take| s@@43 n@@23)
                   (|Seq#Empty| (SeqTypeInv0 (type s@@43))))))
       (=> (and a!1 (= n@@23 0)) a!2))
     :pattern ((|Seq#Take| s@@43 n@@23))
     :skolemid |617|
     :qid |DafnyPreludebpl.1130:18|)))
(assert (forall ((s@@44 T@U) (m@@9 Int) (n@@24 Int))
  (! (let ((a!1 (= (type s@@44) (SeqType (SeqTypeInv0 (type s@@44)))))
           (a!2 (=> (and (<= 0 m@@9)
                         (<= 0 n@@24)
                         (<= (+ m@@9 n@@24) (|Seq#Length| s@@44)))
                    (= (|Seq#Drop| (|Seq#Drop| s@@44 m@@9) n@@24)
                       (|Seq#Drop| s@@44 (+ m@@9 n@@24))))))
       (=> a!1 a!2))
     :pattern ((|Seq#Drop| (|Seq#Drop| s@@44 m@@9) n@@24))
     :skolemid |618|
     :qid |DafnyPreludebpl.1132:18|)))
(assert (forall ((m@@10 T@U))
  (! (let ((a!1 (= (type m@@10)
                   (MapType (MapTypeInv0 (type m@@10))
                            (MapTypeInv1 (type m@@10))))))
       (=> a!1 (<= 0 (|Map#Card| m@@10))))
     :pattern ((|Map#Card| m@@10))
     :skolemid |619|
     :qid |DafnyPreludebpl.1150:20|)))
(assert (forall ((U@@4 T@T) (V@@4 T@T))
  (! (= (type (|Map#Empty| U@@4 V@@4)) (MapType U@@4 V@@4))
     :pattern ((|Map#Empty| U@@4 V@@4))
     :qid |funType:Map#Empty|)))
(assert (forall ((m@@11 T@U))
  (! (let ((a!1 (= (type m@@11)
                   (MapType (MapTypeInv0 (type m@@11))
                            (MapTypeInv1 (type m@@11)))))
           (a!2 (= m@@11
                   (|Map#Empty| (MapTypeInv0 (type m@@11))
                                (MapTypeInv1 (type m@@11))))))
       (=> a!1 (= (= (|Map#Card| m@@11) 0) a!2)))
     :pattern ((|Map#Card| m@@11))
     :skolemid |620|
     :qid |DafnyPreludebpl.1152:21|)))
(assert (forall ((m@@12 T@U))
  (! (let ((a!1 (= (type m@@12)
                   (MapType (MapTypeInv0 (type m@@12))
                            (MapTypeInv1 (type m@@12)))))
           (a!2 (= m@@12
                   (|Map#Empty| (MapTypeInv0 (type m@@12))
                                (MapTypeInv1 (type m@@12)))))
           (a!3 (exists ((k@@4 T@U))
                  (! (and (= (type k@@4) (MapTypeInv0 (type m@@12)))
                          (U_2_bool (MapType0Select (|Map#Domain| m@@12) k@@4)))
                     :no-pattern (type k@@4)
                     :no-pattern (U_2_int k@@4)
                     :no-pattern (U_2_bool k@@4)
                     :skolemid |621|
                     :qid |DafnyPreludebpl.1158:31|))))
       (=> a!1 (or a!2 a!3)))
     :pattern ((|Map#Domain| m@@12))
     :skolemid |622|
     :qid |DafnyPreludebpl.1156:21|)))
(assert (forall ((m@@13 T@U))
  (! (let ((a!1 (= (type m@@13)
                   (MapType (MapTypeInv0 (type m@@13))
                            (MapTypeInv1 (type m@@13)))))
           (a!2 (= m@@13
                   (|Map#Empty| (MapTypeInv0 (type m@@13))
                                (MapTypeInv1 (type m@@13)))))
           (a!3 (exists ((v@@42 T@U))
                  (! (and (= (type v@@42) (MapTypeInv1 (type m@@13)))
                          (U_2_bool (MapType0Select (|Map#Values| m@@13) v@@42)))
                     :no-pattern (type v@@42)
                     :no-pattern (U_2_int v@@42)
                     :no-pattern (U_2_bool v@@42)
                     :skolemid |623|
                     :qid |DafnyPreludebpl.1161:31|))))
       (=> a!1 (or a!2 a!3)))
     :pattern ((|Map#Values| m@@13))
     :skolemid |624|
     :qid |DafnyPreludebpl.1159:21|)))
(assert (forall ((arg0@@102 T@U) (arg1@@44 T@U))
  (! (= (type (|#_System._tuple#2._#Make2| arg0@@102 arg1@@44))
        DatatypeTypeType)
     :pattern ((|#_System._tuple#2._#Make2| arg0@@102 arg1@@44))
     :qid |funType:#_System._tuple#2._#Make2|)))
(assert (forall ((m@@14 T@U))
  (! (let ((a!1 (= (type m@@14)
                   (MapType (MapTypeInv0 (type m@@14))
                            (MapTypeInv1 (type m@@14)))))
           (a!2 (= m@@14
                   (|Map#Empty| (MapTypeInv0 (type m@@14))
                                (MapTypeInv1 (type m@@14)))))
           (a!3 (exists ((k@@5 T@U) (v@@43 T@U))
                  (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Items| m@@14)
                                                          ($Box (|#_System._tuple#2._#Make2|
                                                                  k@@5
                                                                  v@@43))))))
                       (and (= (type k@@5) BoxType)
                            (= (type v@@43) BoxType)
                            a!1))
                     :no-pattern (type k@@5)
                     :no-pattern (type v@@43)
                     :no-pattern (U_2_int k@@5)
                     :no-pattern (U_2_bool k@@5)
                     :no-pattern (U_2_int v@@43)
                     :no-pattern (U_2_bool v@@43)
                     :skolemid |625|
                     :qid |DafnyPreludebpl.1164:31|))))
       (=> a!1 (or a!2 a!3)))
     :pattern ((|Map#Items| m@@14))
     :skolemid |626|
     :qid |DafnyPreludebpl.1162:21|)))
(assert (forall ((m@@15 T@U))
  (! (let ((a!1 (= (type m@@15)
                   (MapType (MapTypeInv0 (type m@@15))
                            (MapTypeInv1 (type m@@15))))))
       (=> a!1 (= (|Set#Card| (|Map#Domain| m@@15)) (|Map#Card| m@@15))))
     :pattern ((|Set#Card| (|Map#Domain| m@@15)))
     :skolemid |627|
     :qid |DafnyPreludebpl.1166:21|)))
(assert (forall ((m@@16 T@U))
  (! (let ((a!1 (= (type m@@16)
                   (MapType (MapTypeInv0 (type m@@16))
                            (MapTypeInv1 (type m@@16))))))
       (=> a!1 (<= (|Set#Card| (|Map#Values| m@@16)) (|Map#Card| m@@16))))
     :pattern ((|Set#Card| (|Map#Values| m@@16)))
     :skolemid |628|
     :qid |DafnyPreludebpl.1169:21|)))
(assert (forall ((m@@17 T@U))
  (! (let ((a!1 (= (type m@@17)
                   (MapType (MapTypeInv0 (type m@@17))
                            (MapTypeInv1 (type m@@17))))))
       (=> a!1 (= (|Set#Card| (|Map#Items| m@@17)) (|Map#Card| m@@17))))
     :pattern ((|Set#Card| (|Map#Items| m@@17)))
     :skolemid |629|
     :qid |DafnyPreludebpl.1172:21|)))
(assert (forall ((m@@18 T@U) (v@@44 T@U))
  (! (let ((a!1 (= (type m@@18)
                   (MapType (MapTypeInv0 (type m@@18)) (type v@@44))))
           (a!2 (exists ((u@@5 T@U))
                  (! (and (= (type u@@5) (MapTypeInv0 (type m@@18)))
                          (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@5))
                          (= v@@44 (MapType0Select (|Map#Elements| m@@18) u@@5)))
                     :pattern ((MapType0Select (|Map#Domain| m@@18) u@@5))
                     :pattern ((MapType0Select (|Map#Elements| m@@18) u@@5))
                     :skolemid |630|
                     :qid |DafnyPreludebpl.1185:10|))))
     (let ((a!3 (= (U_2_bool (MapType0Select (|Map#Values| m@@18) v@@44)) a!2)))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (|Map#Values| m@@18) v@@44))
     :skolemid |631|
     :qid |DafnyPreludebpl.1183:20|)))
(assert (let ((a!1 (forall ((arg0@@103 T@U))
             (! (= (type (_System.Tuple2._0 arg0@@103)) BoxType)
                :pattern ((_System.Tuple2._0 arg0@@103))
                :qid |funType:_System.Tuple2._0|)))
      (a!2 (forall ((arg0@@104 T@U))
             (! (= (type (_System.Tuple2._1 arg0@@104)) BoxType)
                :pattern ((_System.Tuple2._1 arg0@@104))
                :qid |funType:_System.Tuple2._1|))))
  (and a!1 a!2)))
(assert (forall ((m@@19 T@U) (item T@U))
  (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| m@@19)
                                          (_System.Tuple2._0
                                            ($Unbox DatatypeTypeType item)))))
           (a!2 (= (MapType0Select (|Map#Elements| m@@19)
                                   (_System.Tuple2._0
                                     ($Unbox DatatypeTypeType item)))
                   (_System.Tuple2._1 ($Unbox DatatypeTypeType item)))))
     (let ((a!3 (= (U_2_bool (MapType0Select (|Map#Items| m@@19) item))
                   (and a!1 a!2))))
       (=> (and (= (type m@@19) (MapType BoxType BoxType))
                (= (type item) BoxType))
           a!3)))
     :pattern ((MapType0Select (|Map#Items| m@@19) item))
     :skolemid |632|
     :qid |DafnyPreludebpl.1204:15|)))
(assert (forall ((u@@6 T@U) (V@@13 T@T))
  (! (let ((a!1 (MapType0Select (|Map#Domain| (|Map#Empty| (type u@@6) V@@13))
                                u@@6)))
       (not (U_2_bool a!1)))
     :pattern ((MapType0Select (|Map#Domain| (|Map#Empty| (type u@@6) V@@13))
                               u@@6))
     :skolemid |633|
     :qid |DafnyPreludebpl.1212:21|)))
(assert (forall ((arg0@@105 T@U) (arg1@@45 T@U) (arg2@@4 T@U))
  (! (= (type (|Map#Glue| arg0@@105 arg1@@45 arg2@@4))
        (MapType (MapType0TypeInv0 (type arg0@@105))
                 (MapType0TypeInv1 (type arg1@@45))))
     :pattern ((|Map#Glue| arg0@@105 arg1@@45 arg2@@4))
     :qid |funType:Map#Glue|)))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@27 T@U))
  (! (let ((a!1 (= (type a@@73)
                   (MapType0Type (MapType0TypeInv0 (type a@@73)) boolType)))
           (a!2 (= (type b@@52)
                   (MapType0Type (MapType0TypeInv0 (type a@@73))
                                 (MapType0TypeInv1 (type b@@52))))))
       (=> (and a!1 a!2 (= (type t@@27) TyType))
           (= (|Map#Domain| (|Map#Glue| a@@73 b@@52 t@@27)) a@@73)))
     :pattern ((|Map#Domain| (|Map#Glue| a@@73 b@@52 t@@27)))
     :skolemid |634|
     :qid |DafnyPreludebpl.1217:21|)))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@28 T@U))
  (! (let ((a!1 (= (type a@@74)
                   (MapType0Type (MapType0TypeInv0 (type a@@74)) boolType)))
           (a!2 (= (type b@@53)
                   (MapType0Type (MapType0TypeInv0 (type a@@74))
                                 (MapType0TypeInv1 (type b@@53))))))
       (=> (and a!1 a!2 (= (type t@@28) TyType))
           (= (|Map#Elements| (|Map#Glue| a@@74 b@@53 t@@28)) b@@53)))
     :pattern ((|Map#Elements| (|Map#Glue| a@@74 b@@53 t@@28)))
     :skolemid |635|
     :qid |DafnyPreludebpl.1220:21|)))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t0@@14 T@U) (t1@@5 T@U))
  (! (let ((a!1 (forall ((bx@@24 T@U))
                  (! (=> (and (= (type bx@@24) BoxType)
                              (U_2_bool (MapType0Select a@@75 bx@@24)))
                         (and ($IsBox bx@@24 t0@@14)
                              ($IsBox (MapType0Select b@@54 bx@@24) t1@@5)))
                     :no-pattern (type bx@@24)
                     :no-pattern (U_2_int bx@@24)
                     :no-pattern (U_2_bool bx@@24)
                     :skolemid |636|
                     :qid |DafnyPreludebpl.1226:11|))))
       (=> (and (= (type a@@75) (MapType0Type BoxType boolType))
                (= (type b@@54) (MapType0Type BoxType BoxType))
                (= (type t0@@14) TyType)
                (= (type t1@@5) TyType)
                a!1)
           ($Is (|Map#Glue| a@@75 b@@54 (TMap t0@@14 t1@@5))
                (TMap t0@@14 t1@@5))))
     :pattern ((|Map#Glue| a@@75 b@@54 (TMap t0@@14 t1@@5)))
     :skolemid |637|
     :qid |DafnyPreludebpl.1223:15|)))
(assert (forall ((arg0@@106 T@U) (arg1@@46 T@U) (arg2@@5 T@U))
  (! (= (type (|Map#Build| arg0@@106 arg1@@46 arg2@@5))
        (MapType (type arg1@@46) (type arg2@@5)))
     :pattern ((|Map#Build| arg0@@106 arg1@@46 arg2@@5))
     :qid |funType:Map#Build|)))
(assert (forall ((m@@20 T@U) (u@@7 T@U) (|u'| T@U) (v@@45 T@U))
  (! (let ((a!1 (and (= (type m@@20) (MapType (type u@@7) (type v@@45)))
                     (= (type |u'|) (type u@@7))))
           (a!2 (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@20
                                                                     u@@7
                                                                     v@@45))
                                          |u'|)))
           (a!3 (= (MapType0Select (|Map#Elements| (|Map#Build| m@@20
                                                                u@@7
                                                                v@@45))
                                   |u'|)
                   v@@45))
           (a!5 (= (MapType0Select (|Map#Elements| (|Map#Build| m@@20
                                                                u@@7
                                                                v@@45))
                                   |u'|)
                   (MapType0Select (|Map#Elements| m@@20) |u'|))))
     (let ((a!4 (= a!2 (U_2_bool (MapType0Select (|Map#Domain| m@@20) |u'|)))))
     (let ((a!6 (and (=> (= |u'| u@@7) (and a!2 a!3))
                     (=> (not (= |u'| u@@7)) (and a!4 a!5)))))
       (=> a!1 a!6))))
     :pattern ((MapType0Select (|Map#Domain| (|Map#Build| m@@20 u@@7 v@@45))
                               |u'|))
     :pattern ((MapType0Select (|Map#Elements| (|Map#Build| m@@20 u@@7 v@@45))
                               |u'|))
     :skolemid |638|
     :qid |DafnyPreludebpl.1237:21|)))
(assert (forall ((m@@21 T@U) (u@@8 T@U) (v@@46 T@U))
  (! (let ((a!1 (and (= (type m@@21) (MapType (type u@@8) (type v@@46)))
                     (U_2_bool (MapType0Select (|Map#Domain| m@@21) u@@8)))))
       (=> a!1
           (= (|Map#Card| (|Map#Build| m@@21 u@@8 v@@46)) (|Map#Card| m@@21))))
     :pattern ((|Map#Card| (|Map#Build| m@@21 u@@8 v@@46)))
     :skolemid |639|
     :qid |DafnyPreludebpl.1243:21|)))
(assert (forall ((m@@22 T@U) (u@@9 T@U) (v@@47 T@U))
  (! (let ((a!1 (not (U_2_bool (MapType0Select (|Map#Domain| m@@22) u@@9)))))
     (let ((a!2 (and (= (type m@@22) (MapType (type u@@9) (type v@@47))) a!1)))
       (=> a!2
           (= (|Map#Card| (|Map#Build| m@@22 u@@9 v@@47))
              (+ (|Map#Card| m@@22) 1)))))
     :pattern ((|Map#Card| (|Map#Build| m@@22 u@@9 v@@47)))
     :skolemid |640|
     :qid |DafnyPreludebpl.1245:21|)))
(assert (forall ((arg0@@107 T@U) (arg1@@47 T@U))
  (! (= (type (|Map#Merge| arg0@@107 arg1@@47))
        (MapType (MapTypeInv0 (type arg0@@107)) (MapTypeInv1 (type arg0@@107))))
     :pattern ((|Map#Merge| arg0@@107 arg1@@47))
     :qid |funType:Map#Merge|)))
(assert (forall ((m@@23 T@U) (n@@25 T@U))
  (! (let ((a!1 (= (type m@@23)
                   (MapType (MapTypeInv0 (type m@@23))
                            (MapTypeInv1 (type m@@23)))))
           (a!2 (= (type n@@25)
                   (MapType (MapTypeInv0 (type m@@23))
                            (MapTypeInv1 (type m@@23))))))
       (=> (and a!1 a!2)
           (= (|Map#Domain| (|Map#Merge| m@@23 n@@25))
              (|Set#Union| (|Map#Domain| m@@23) (|Map#Domain| n@@25)))))
     :pattern ((|Map#Domain| (|Map#Merge| m@@23 n@@25)))
     :skolemid |641|
     :qid |DafnyPreludebpl.1250:21|)))
(assert (forall ((m@@24 T@U) (n@@26 T@U) (u@@10 T@U))
  (! (let ((a!1 (= (type m@@24)
                   (MapType (type u@@10) (MapTypeInv1 (type m@@24)))))
           (a!2 (= (type n@@26)
                   (MapType (type u@@10) (MapTypeInv1 (type m@@24)))))
           (a!3 (U_2_bool (MapType0Select (|Map#Domain| (|Map#Merge| m@@24
                                                                     n@@26))
                                          u@@10)))
           (a!4 (not (U_2_bool (MapType0Select (|Map#Domain| n@@26) u@@10))))
           (a!5 (= (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26))
                                   u@@10)
                   (MapType0Select (|Map#Elements| m@@24) u@@10)))
           (a!6 (= (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26))
                                   u@@10)
                   (MapType0Select (|Map#Elements| n@@26) u@@10))))
     (let ((a!7 (=> (U_2_bool (MapType0Select (|Map#Domain| n@@26) u@@10)) a!6)))
       (=> (and a!1 a!2 a!3) (and (=> a!4 a!5) a!7))))
     :pattern ((MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26)) u@@10))
     :skolemid |642|
     :qid |DafnyPreludebpl.1253:21|)))
(assert (forall ((arg0@@108 T@U) (arg1@@48 T@U))
  (! (= (type (|Map#Subtract| arg0@@108 arg1@@48))
        (MapType (MapTypeInv0 (type arg0@@108)) (MapTypeInv1 (type arg0@@108))))
     :pattern ((|Map#Subtract| arg0@@108 arg1@@48))
     :qid |funType:Map#Subtract|)))
(assert (forall ((m@@25 T@U) (s@@45 T@U))
  (! (let ((a!1 (= (type m@@25)
                   (MapType (MapTypeInv0 (type m@@25))
                            (MapTypeInv1 (type m@@25)))))
           (a!2 (= (type s@@45)
                   (MapType0Type (MapTypeInv0 (type m@@25)) boolType))))
       (=> (and a!1 a!2)
           (= (|Map#Domain| (|Map#Subtract| m@@25 s@@45))
              (|Set#Difference| (|Map#Domain| m@@25) s@@45))))
     :pattern ((|Map#Domain| (|Map#Subtract| m@@25 s@@45)))
     :skolemid |643|
     :qid |DafnyPreludebpl.1260:21|)))
(assert (forall ((m@@26 T@U) (s@@46 T@U) (u@@11 T@U))
  (! (let ((a!1 (= (type m@@26)
                   (MapType (type u@@11) (MapTypeInv1 (type m@@26)))))
           (a!2 (U_2_bool (MapType0Select (|Map#Domain| (|Map#Subtract| m@@26
                                                                        s@@46))
                                          u@@11)))
           (a!4 (= (MapType0Select (|Map#Elements| (|Map#Subtract| m@@26 s@@46))
                                   u@@11)
                   (MapType0Select (|Map#Elements| m@@26) u@@11))))
     (let ((a!3 (and a!1
                     (= (type s@@46) (MapType0Type (type u@@11) boolType))
                     a!2)))
       (=> a!3 a!4)))
     :pattern ((MapType0Select (|Map#Elements| (|Map#Subtract| m@@26 s@@46))
                               u@@11))
     :skolemid |644|
     :qid |DafnyPreludebpl.1263:21|)))
(assert (forall ((m@@27 T@U) (|m'| T@U))
  (! (let ((a!1 (= (type m@@27)
                   (MapType (MapTypeInv0 (type m@@27))
                            (MapTypeInv1 (type m@@27)))))
           (a!2 (= (type |m'|)
                   (MapType (MapTypeInv0 (type m@@27))
                            (MapTypeInv1 (type m@@27)))))
           (a!3 (forall ((u@@12 T@U))
                  (! (let ((a!1 (= (U_2_bool (MapType0Select (|Map#Domain| m@@27)
                                                             u@@12))
                                   (U_2_bool (MapType0Select (|Map#Domain| |m'|)
                                                             u@@12)))))
                       (=> (= (type u@@12) (MapTypeInv0 (type m@@27))) a!1))
                     :no-pattern (type u@@12)
                     :no-pattern (U_2_int u@@12)
                     :no-pattern (U_2_bool u@@12)
                     :skolemid |645|
                     :qid |DafnyPreludebpl.1272:35|)))
           (a!4 (forall ((u@@13 T@U))
                  (! (let ((a!1 (and (= (type u@@13) (MapTypeInv0 (type m@@27)))
                                     (U_2_bool (MapType0Select (|Map#Domain| m@@27)
                                                               u@@13)))))
                       (=> a!1
                           (= (MapType0Select (|Map#Elements| m@@27) u@@13)
                              (MapType0Select (|Map#Elements| |m'|) u@@13))))
                     :no-pattern (type u@@13)
                     :no-pattern (U_2_int u@@13)
                     :no-pattern (U_2_bool u@@13)
                     :skolemid |646|
                     :qid |DafnyPreludebpl.1273:35|))))
       (=> (and a!1 a!2) (= (|Map#Equal| m@@27 |m'|) (and a!3 a!4))))
     :pattern ((|Map#Equal| m@@27 |m'|))
     :skolemid |647|
     :qid |DafnyPreludebpl.1270:21|)))
(assert (forall ((m@@28 T@U) (|m'@@0| T@U))
  (! (let ((a!1 (= (type m@@28)
                   (MapType (MapTypeInv0 (type m@@28))
                            (MapTypeInv1 (type m@@28)))))
           (a!2 (= (type |m'@@0|)
                   (MapType (MapTypeInv0 (type m@@28))
                            (MapTypeInv1 (type m@@28))))))
       (=> (and a!1 a!2 (|Map#Equal| m@@28 |m'@@0|)) (= m@@28 |m'@@0|)))
     :pattern ((|Map#Equal| m@@28 |m'@@0|))
     :skolemid |648|
     :qid |DafnyPreludebpl.1275:21|)))
(assert (forall ((m@@29 T@U) (|m'@@1| T@U))
  (! (let ((a!1 (= (type m@@29)
                   (MapType (MapTypeInv0 (type m@@29))
                            (MapTypeInv1 (type m@@29)))))
           (a!2 (= (type |m'@@1|)
                   (MapType (MapTypeInv0 (type m@@29))
                            (MapTypeInv1 (type m@@29)))))
           (a!3 (forall ((o@@43 T@U))
                  (! (let ((a!1 (not (U_2_bool (MapType0Select (|Map#Domain| m@@29)
                                                               o@@43))))
                           (a!2 (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|)
                                                               o@@43)))))
                       (=> (= (type o@@43) (MapTypeInv0 (type m@@29)))
                           (or a!1 a!2)))
                     :pattern ((MapType0Select (|Map#Domain| m@@29) o@@43))
                     :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@43))
                     :skolemid |649|
                     :qid |DafnyPreludebpl.1282:38|))))
       (=> (and a!1 a!2) (= (|Map#Disjoint| m@@29 |m'@@1|) a!3)))
     :pattern ((|Map#Disjoint| m@@29 |m'@@1|))
     :skolemid |650|
     :qid |DafnyPreludebpl.1280:21|)))
(assert (forall ((U@@30 T@T) (V@@30 T@T))
  (! (= (type (|IMap#Empty| U@@30 V@@30)) (IMapType U@@30 V@@30))
     :pattern ((|IMap#Empty| U@@30 V@@30))
     :qid |funType:IMap#Empty|)))
(assert (forall ((m@@30 T@U))
  (! (let ((a!1 (= (type m@@30)
                   (IMapType (IMapTypeInv0 (type m@@30))
                             (IMapTypeInv1 (type m@@30)))))
           (a!2 (= m@@30
                   (|IMap#Empty| (IMapTypeInv0 (type m@@30))
                                 (IMapTypeInv1 (type m@@30)))))
           (a!3 (exists ((k@@6 T@U))
                  (! (and (= (type k@@6) (IMapTypeInv0 (type m@@30)))
                          (U_2_bool (MapType0Select (|IMap#Domain| m@@30) k@@6)))
                     :no-pattern (type k@@6)
                     :no-pattern (U_2_int k@@6)
                     :no-pattern (U_2_bool k@@6)
                     :skolemid |651|
                     :qid |DafnyPreludebpl.1298:32|))))
       (=> a!1 (or a!2 a!3)))
     :pattern ((|IMap#Domain| m@@30))
     :skolemid |652|
     :qid |DafnyPreludebpl.1296:21|)))
(assert (forall ((m@@31 T@U))
  (! (let ((a!1 (= (type m@@31)
                   (IMapType (IMapTypeInv0 (type m@@31))
                             (IMapTypeInv1 (type m@@31)))))
           (a!2 (= m@@31
                   (|IMap#Empty| (IMapTypeInv0 (type m@@31))
                                 (IMapTypeInv1 (type m@@31)))))
           (a!3 (exists ((v@@48 T@U))
                  (! (and (= (type v@@48) (IMapTypeInv1 (type m@@31)))
                          (U_2_bool (MapType0Select (|IMap#Values| m@@31) v@@48)))
                     :no-pattern (type v@@48)
                     :no-pattern (U_2_int v@@48)
                     :no-pattern (U_2_bool v@@48)
                     :skolemid |653|
                     :qid |DafnyPreludebpl.1301:32|))))
       (=> a!1 (or a!2 a!3)))
     :pattern ((|IMap#Values| m@@31))
     :skolemid |654|
     :qid |DafnyPreludebpl.1299:21|)))
(assert (forall ((m@@32 T@U))
  (! (let ((a!1 (= (type m@@32)
                   (IMapType (IMapTypeInv0 (type m@@32))
                             (IMapTypeInv1 (type m@@32)))))
           (a!2 (= m@@32
                   (|IMap#Empty| (IMapTypeInv0 (type m@@32))
                                 (IMapTypeInv1 (type m@@32)))))
           (a!3 (exists ((k@@7 T@U) (v@@49 T@U))
                  (! (let ((a!1 (U_2_bool (MapType0Select (|IMap#Items| m@@32)
                                                          ($Box (|#_System._tuple#2._#Make2|
                                                                  k@@7
                                                                  v@@49))))))
                       (and (= (type k@@7) BoxType)
                            (= (type v@@49) BoxType)
                            a!1))
                     :no-pattern (type k@@7)
                     :no-pattern (type v@@49)
                     :no-pattern (U_2_int k@@7)
                     :no-pattern (U_2_bool k@@7)
                     :no-pattern (U_2_int v@@49)
                     :no-pattern (U_2_bool v@@49)
                     :skolemid |655|
                     :qid |DafnyPreludebpl.1304:32|))))
       (=> a!1 (or a!2 a!3)))
     :pattern ((|IMap#Items| m@@32))
     :skolemid |656|
     :qid |DafnyPreludebpl.1302:21|)))
(assert (forall ((m@@33 T@U))
  (! (let ((a!1 (= (type m@@33)
                   (IMapType (IMapTypeInv0 (type m@@33))
                             (IMapTypeInv1 (type m@@33)))))
           (a!2 (= m@@33
                   (|IMap#Empty| (IMapTypeInv0 (type m@@33))
                                 (IMapTypeInv1 (type m@@33)))))
           (a!3 (= (|IMap#Domain| m@@33)
                   (|ISet#Empty| (IMapTypeInv0 (type m@@33))))))
       (=> a!1 (= a!2 a!3)))
     :pattern ((|IMap#Domain| m@@33))
     :skolemid |657|
     :qid |DafnyPreludebpl.1306:21|)))
(assert (forall ((m@@34 T@U))
  (! (let ((a!1 (= (type m@@34)
                   (IMapType (IMapTypeInv0 (type m@@34))
                             (IMapTypeInv1 (type m@@34)))))
           (a!2 (= m@@34
                   (|IMap#Empty| (IMapTypeInv0 (type m@@34))
                                 (IMapTypeInv1 (type m@@34)))))
           (a!3 (= (|IMap#Values| m@@34)
                   (|ISet#Empty| (IMapTypeInv1 (type m@@34))))))
       (=> a!1 (= a!2 a!3)))
     :pattern ((|IMap#Values| m@@34))
     :skolemid |658|
     :qid |DafnyPreludebpl.1309:21|)))
(assert (forall ((m@@35 T@U))
  (! (let ((a!1 (= (type m@@35)
                   (IMapType (IMapTypeInv0 (type m@@35))
                             (IMapTypeInv1 (type m@@35)))))
           (a!2 (= m@@35
                   (|IMap#Empty| (IMapTypeInv0 (type m@@35))
                                 (IMapTypeInv1 (type m@@35))))))
       (=> a!1 (= a!2 (= (|IMap#Items| m@@35) (|ISet#Empty| BoxType)))))
     :pattern ((|IMap#Items| m@@35))
     :skolemid |659|
     :qid |DafnyPreludebpl.1312:21|)))
(assert (forall ((m@@36 T@U) (v@@50 T@U))
  (! (let ((a!1 (= (type m@@36)
                   (IMapType (IMapTypeInv0 (type m@@36)) (type v@@50))))
           (a!2 (exists ((u@@14 T@U))
                  (! (and (= (type u@@14) (IMapTypeInv0 (type m@@36)))
                          (U_2_bool (MapType0Select (|IMap#Domain| m@@36) u@@14))
                          (= v@@50
                             (MapType0Select (|IMap#Elements| m@@36) u@@14)))
                     :pattern ((MapType0Select (|IMap#Domain| m@@36) u@@14))
                     :pattern ((MapType0Select (|IMap#Elements| m@@36) u@@14))
                     :skolemid |660|
                     :qid |DafnyPreludebpl.1325:10|))))
     (let ((a!3 (= (U_2_bool (MapType0Select (|IMap#Values| m@@36) v@@50)) a!2)))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (|IMap#Values| m@@36) v@@50))
     :skolemid |661|
     :qid |DafnyPreludebpl.1323:20|)))
(assert (forall ((m@@37 T@U) (item@@0 T@U))
  (! (let ((a!1 (U_2_bool (MapType0Select (|IMap#Domain| m@@37)
                                          (_System.Tuple2._0
                                            ($Unbox DatatypeTypeType item@@0)))))
           (a!2 (= (MapType0Select (|IMap#Elements| m@@37)
                                   (_System.Tuple2._0
                                     ($Unbox DatatypeTypeType item@@0)))
                   (_System.Tuple2._1 ($Unbox DatatypeTypeType item@@0)))))
     (let ((a!3 (= (U_2_bool (MapType0Select (|IMap#Items| m@@37) item@@0))
                   (and a!1 a!2))))
       (=> (and (= (type m@@37) (IMapType BoxType BoxType))
                (= (type item@@0) BoxType))
           a!3)))
     :pattern ((MapType0Select (|IMap#Items| m@@37) item@@0))
     :skolemid |662|
     :qid |DafnyPreludebpl.1340:15|)))
(assert (forall ((u@@15 T@U) (V@@38 T@T))
  (! (let ((a!1 (MapType0Select (|IMap#Domain| (|IMap#Empty| (type u@@15) V@@38))
                                u@@15)))
       (not (U_2_bool a!1)))
     :pattern ((MapType0Select (|IMap#Domain| (|IMap#Empty| (type u@@15) V@@38))
                               u@@15))
     :skolemid |663|
     :qid |DafnyPreludebpl.1347:21|)))
(assert (forall ((arg0@@109 T@U) (arg1@@49 T@U) (arg2@@6 T@U))
  (! (= (type (|IMap#Glue| arg0@@109 arg1@@49 arg2@@6))
        (IMapType (MapType0TypeInv0 (type arg0@@109))
                  (MapType0TypeInv1 (type arg1@@49))))
     :pattern ((|IMap#Glue| arg0@@109 arg1@@49 arg2@@6))
     :qid |funType:IMap#Glue|)))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@29 T@U))
  (! (let ((a!1 (= (type a@@76)
                   (MapType0Type (MapType0TypeInv0 (type a@@76)) boolType)))
           (a!2 (= (type b@@55)
                   (MapType0Type (MapType0TypeInv0 (type a@@76))
                                 (MapType0TypeInv1 (type b@@55))))))
       (=> (and a!1 a!2 (= (type t@@29) TyType))
           (= (|IMap#Domain| (|IMap#Glue| a@@76 b@@55 t@@29)) a@@76)))
     :pattern ((|IMap#Domain| (|IMap#Glue| a@@76 b@@55 t@@29)))
     :skolemid |664|
     :qid |DafnyPreludebpl.1352:21|)))
(assert (forall ((a@@77 T@U) (b@@56 T@U) (t@@30 T@U))
  (! (let ((a!1 (= (type a@@77)
                   (MapType0Type (MapType0TypeInv0 (type a@@77)) boolType)))
           (a!2 (= (type b@@56)
                   (MapType0Type (MapType0TypeInv0 (type a@@77))
                                 (MapType0TypeInv1 (type b@@56))))))
       (=> (and a!1 a!2 (= (type t@@30) TyType))
           (= (|IMap#Elements| (|IMap#Glue| a@@77 b@@56 t@@30)) b@@56)))
     :pattern ((|IMap#Elements| (|IMap#Glue| a@@77 b@@56 t@@30)))
     :skolemid |665|
     :qid |DafnyPreludebpl.1355:21|)))
(assert (forall ((a@@78 T@U) (b@@57 T@U) (t0@@15 T@U) (t1@@6 T@U))
  (! (let ((a!1 (forall ((bx@@25 T@U))
                  (! (=> (and (= (type bx@@25) BoxType)
                              (U_2_bool (MapType0Select a@@78 bx@@25)))
                         (and ($IsBox bx@@25 t0@@15)
                              ($IsBox (MapType0Select b@@57 bx@@25) t1@@6)))
                     :no-pattern (type bx@@25)
                     :no-pattern (U_2_int bx@@25)
                     :no-pattern (U_2_bool bx@@25)
                     :skolemid |666|
                     :qid |DafnyPreludebpl.1361:11|))))
       (=> (and (= (type a@@78) (MapType0Type BoxType boolType))
                (= (type b@@57) (MapType0Type BoxType BoxType))
                (= (type t0@@15) TyType)
                (= (type t1@@6) TyType)
                a!1)
           ($Is (|Map#Glue| a@@78 b@@57 (TIMap t0@@15 t1@@6))
                (TIMap t0@@15 t1@@6))))
     :pattern ((|IMap#Glue| a@@78 b@@57 (TIMap t0@@15 t1@@6)))
     :skolemid |667|
     :qid |DafnyPreludebpl.1358:15|)))
(assert (forall ((arg0@@110 T@U) (arg1@@50 T@U) (arg2@@7 T@U))
  (! (= (type (|IMap#Build| arg0@@110 arg1@@50 arg2@@7))
        (IMapType (type arg1@@50) (type arg2@@7)))
     :pattern ((|IMap#Build| arg0@@110 arg1@@50 arg2@@7))
     :qid |funType:IMap#Build|)))
(assert (forall ((m@@38 T@U) (u@@16 T@U) (|u'@@0| T@U) (v@@51 T@U))
  (! (let ((a!1 (and (= (type m@@38) (IMapType (type u@@16) (type v@@51)))
                     (= (type |u'@@0|) (type u@@16))))
           (a!2 (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@38
                                                                       u@@16
                                                                       v@@51))
                                          |u'@@0|)))
           (a!3 (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38
                                                                  u@@16
                                                                  v@@51))
                                   |u'@@0|)
                   v@@51))
           (a!5 (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38
                                                                  u@@16
                                                                  v@@51))
                                   |u'@@0|)
                   (MapType0Select (|IMap#Elements| m@@38) |u'@@0|))))
     (let ((a!4 (= a!2
                   (U_2_bool (MapType0Select (|IMap#Domain| m@@38) |u'@@0|)))))
     (let ((a!6 (and (=> (= |u'@@0| u@@16) (and a!2 a!3))
                     (=> (not (= |u'@@0| u@@16)) (and a!4 a!5)))))
       (=> a!1 a!6))))
     :pattern ((MapType0Select (|IMap#Domain| (|IMap#Build| m@@38 u@@16 v@@51))
                               |u'@@0|))
     :pattern ((MapType0Select (|IMap#Elements| (|IMap#Build| m@@38 u@@16 v@@51))
                               |u'@@0|))
     :skolemid |668|
     :qid |DafnyPreludebpl.1371:21|)))
(assert (forall ((m@@39 T@U) (|m'@@2| T@U))
  (! (let ((a!1 (= (type m@@39)
                   (IMapType (IMapTypeInv0 (type m@@39))
                             (IMapTypeInv1 (type m@@39)))))
           (a!2 (= (type |m'@@2|)
                   (IMapType (IMapTypeInv0 (type m@@39))
                             (IMapTypeInv1 (type m@@39)))))
           (a!3 (forall ((u@@17 T@U))
                  (! (let ((a!1 (= (U_2_bool (MapType0Select (|IMap#Domain| m@@39)
                                                             u@@17))
                                   (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|)
                                                             u@@17)))))
                       (=> (= (type u@@17) (IMapTypeInv0 (type m@@39))) a!1))
                     :no-pattern (type u@@17)
                     :no-pattern (U_2_int u@@17)
                     :no-pattern (U_2_bool u@@17)
                     :skolemid |669|
                     :qid |DafnyPreludebpl.1382:36|)))
           (a!4 (forall ((u@@18 T@U))
                  (! (let ((a!1 (and (= (type u@@18)
                                        (IMapTypeInv0 (type m@@39)))
                                     (U_2_bool (MapType0Select (|IMap#Domain| m@@39)
                                                               u@@18)))))
                       (=> a!1
                           (= (MapType0Select (|IMap#Elements| m@@39) u@@18)
                              (MapType0Select (|IMap#Elements| |m'@@2|) u@@18))))
                     :no-pattern (type u@@18)
                     :no-pattern (U_2_int u@@18)
                     :no-pattern (U_2_bool u@@18)
                     :skolemid |670|
                     :qid |DafnyPreludebpl.1383:35|))))
       (=> (and a!1 a!2) (= (|IMap#Equal| m@@39 |m'@@2|) (and a!3 a!4))))
     :pattern ((|IMap#Equal| m@@39 |m'@@2|))
     :skolemid |671|
     :qid |DafnyPreludebpl.1380:21|)))
(assert (forall ((m@@40 T@U) (|m'@@3| T@U))
  (! (let ((a!1 (= (type m@@40)
                   (IMapType (IMapTypeInv0 (type m@@40))
                             (IMapTypeInv1 (type m@@40)))))
           (a!2 (= (type |m'@@3|)
                   (IMapType (IMapTypeInv0 (type m@@40))
                             (IMapTypeInv1 (type m@@40))))))
       (=> (and a!1 a!2 (|IMap#Equal| m@@40 |m'@@3|)) (= m@@40 |m'@@3|)))
     :pattern ((|IMap#Equal| m@@40 |m'@@3|))
     :skolemid |672|
     :qid |DafnyPreludebpl.1385:21|)))
(assert (forall ((arg0@@111 T@U) (arg1@@51 T@U))
  (! (= (type (|IMap#Merge| arg0@@111 arg1@@51))
        (IMapType (IMapTypeInv0 (type arg0@@111))
                  (IMapTypeInv1 (type arg0@@111))))
     :pattern ((|IMap#Merge| arg0@@111 arg1@@51))
     :qid |funType:IMap#Merge|)))
(assert (forall ((m@@41 T@U) (n@@27 T@U))
  (! (let ((a!1 (= (type m@@41)
                   (IMapType (IMapTypeInv0 (type m@@41))
                             (IMapTypeInv1 (type m@@41)))))
           (a!2 (= (type n@@27)
                   (IMapType (IMapTypeInv0 (type m@@41))
                             (IMapTypeInv1 (type m@@41))))))
       (=> (and a!1 a!2)
           (= (|IMap#Domain| (|IMap#Merge| m@@41 n@@27))
              (|Set#Union| (|IMap#Domain| m@@41) (|IMap#Domain| n@@27)))))
     :pattern ((|IMap#Domain| (|IMap#Merge| m@@41 n@@27)))
     :skolemid |673|
     :qid |DafnyPreludebpl.1391:21|)))
(assert (forall ((m@@42 T@U) (n@@28 T@U) (u@@19 T@U))
  (! (let ((a!1 (= (type m@@42)
                   (IMapType (type u@@19) (IMapTypeInv1 (type m@@42)))))
           (a!2 (= (type n@@28)
                   (IMapType (type u@@19) (IMapTypeInv1 (type m@@42)))))
           (a!3 (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Merge| m@@42
                                                                       n@@28))
                                          u@@19)))
           (a!4 (not (U_2_bool (MapType0Select (|IMap#Domain| n@@28) u@@19))))
           (a!5 (= (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28))
                                   u@@19)
                   (MapType0Select (|IMap#Elements| m@@42) u@@19)))
           (a!6 (= (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28))
                                   u@@19)
                   (MapType0Select (|IMap#Elements| n@@28) u@@19))))
     (let ((a!7 (=> (U_2_bool (MapType0Select (|IMap#Domain| n@@28) u@@19)) a!6)))
       (=> (and a!1 a!2 a!3) (and (=> a!4 a!5) a!7))))
     :pattern ((MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28))
                               u@@19))
     :skolemid |674|
     :qid |DafnyPreludebpl.1394:21|)))
(assert (forall ((arg0@@112 T@U) (arg1@@52 T@U))
  (! (= (type (|IMap#Subtract| arg0@@112 arg1@@52))
        (IMapType (IMapTypeInv0 (type arg0@@112))
                  (IMapTypeInv1 (type arg0@@112))))
     :pattern ((|IMap#Subtract| arg0@@112 arg1@@52))
     :qid |funType:IMap#Subtract|)))
(assert (forall ((m@@43 T@U) (s@@47 T@U))
  (! (let ((a!1 (= (type m@@43)
                   (IMapType (IMapTypeInv0 (type m@@43))
                             (IMapTypeInv1 (type m@@43)))))
           (a!2 (= (type s@@47)
                   (MapType0Type (IMapTypeInv0 (type m@@43)) boolType))))
       (=> (and a!1 a!2)
           (= (|IMap#Domain| (|IMap#Subtract| m@@43 s@@47))
              (|Set#Difference| (|IMap#Domain| m@@43) s@@47))))
     :pattern ((|IMap#Domain| (|IMap#Subtract| m@@43 s@@47)))
     :skolemid |675|
     :qid |DafnyPreludebpl.1401:21|)))
(assert (forall ((m@@44 T@U) (s@@48 T@U) (u@@20 T@U))
  (! (let ((a!1 (= (type m@@44)
                   (IMapType (type u@@20) (IMapTypeInv1 (type m@@44)))))
           (a!2 (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Subtract| m@@44
                                                                          s@@48))
                                          u@@20)))
           (a!4 (= (MapType0Select (|IMap#Elements| (|IMap#Subtract| m@@44
                                                                     s@@48))
                                   u@@20)
                   (MapType0Select (|IMap#Elements| m@@44) u@@20))))
     (let ((a!3 (and a!1
                     (= (type s@@48) (MapType0Type (type u@@20) boolType))
                     a!2)))
       (=> a!3 a!4)))
     :pattern ((MapType0Select (|IMap#Elements| (|IMap#Subtract| m@@44 s@@48))
                               u@@20))
     :skolemid |676|
     :qid |DafnyPreludebpl.1404:21|)))
(assert (forall ((x@@42 Int) (y@@12 Int))
  (! (= (INTERNAL_add_boogie x@@42 y@@12) (+ x@@42 y@@12))
     :pattern ((INTERNAL_add_boogie x@@42 y@@12))
     :skolemid |677|
     :qid |DafnyPreludebpl.1413:30|)))
(assert (forall ((x@@43 Int) (y@@13 Int))
  (! (= (INTERNAL_sub_boogie x@@43 y@@13) (- x@@43 y@@13))
     :pattern ((INTERNAL_sub_boogie x@@43 y@@13))
     :skolemid |678|
     :qid |DafnyPreludebpl.1414:30|)))
(assert (forall ((x@@44 Int) (y@@14 Int))
  (! (= (INTERNAL_mul_boogie x@@44 y@@14) (* x@@44 y@@14))
     :pattern ((INTERNAL_mul_boogie x@@44 y@@14))
     :skolemid |679|
     :qid |DafnyPreludebpl.1415:30|)))
(assert (forall ((x@@47 Int) (y@@17 Int))
  (! (= (INTERNAL_lt_boogie x@@47 y@@17) (< x@@47 y@@17))
     :pattern ((INTERNAL_lt_boogie x@@47 y@@17))
     :skolemid |682|
     :qid |DafnyPreludebpl.1418:51|)))
(assert (forall ((x@@48 Int) (y@@18 Int))
  (! (= (INTERNAL_le_boogie x@@48 y@@18) (<= x@@48 y@@18))
     :pattern ((INTERNAL_le_boogie x@@48 y@@18))
     :skolemid |683|
     :qid |DafnyPreludebpl.1419:51|)))
(assert (forall ((x@@49 Int) (y@@19 Int))
  (! (= (INTERNAL_gt_boogie x@@49 y@@19) (> x@@49 y@@19))
     :pattern ((INTERNAL_gt_boogie x@@49 y@@19))
     :skolemid |684|
     :qid |DafnyPreludebpl.1420:51|)))
(assert (forall ((x@@50 Int) (y@@20 Int))
  (! (= (INTERNAL_ge_boogie x@@50 y@@20) (>= x@@50 y@@20))
     :pattern ((INTERNAL_ge_boogie x@@50 y@@20))
     :skolemid |685|
     :qid |DafnyPreludebpl.1421:51|)))
(assert (forall ((x@@51 Int) (y@@21 Int))
  (! (= (Mul x@@51 y@@21) (* x@@51 y@@21))
     :pattern ((Mul x@@51 y@@21))
     :skolemid |686|
     :qid |DafnyPreludebpl.1423:14|)))
(assert (forall ((x@@54 Int) (y@@24 Int))
  (! (= (Add x@@54 y@@24) (+ x@@54 y@@24))
     :pattern ((Add x@@54 y@@24))
     :skolemid |689|
     :qid |DafnyPreludebpl.1426:14|)))
(assert (forall ((x@@55 Int) (y@@25 Int))
  (! (= (Sub x@@55 y@@25) (- x@@55 y@@25))
     :pattern ((Sub x@@55 y@@25))
     :skolemid |690|
     :qid |DafnyPreludebpl.1427:14|)))
(assert (forall ((A@@2 T@U) (B T@U) (a@@79 T@U) (b@@58 T@U))
  (! (=> (and (= (type A@@2) TyType)
              (= (type B) TyType)
              (= (type a@@79) BoxType)
              (= (type b@@58) BoxType)
              (_System.__default.rank__is__less__than A@@2 B a@@79 b@@58))
         (< (BoxRank a@@79) (BoxRank b@@58)))
     :pattern ((_System.__default.rank__is__less__than A@@2 B a@@79 b@@58)
               (BoxRank a@@79))
     :pattern ((_System.__default.rank__is__less__than A@@2 B a@@79 b@@58)
               (BoxRank b@@58))
     :skolemid |691|
     :qid |DafnyPreludebpl.1468:15|)))
(assert (forall ((A@@3 T@U) (B@@0 T@U) (a@@80 T@U) (b@@59 T@U))
  (! (=> (and (= (type A@@3) TyType)
              (= (type B@@0) TyType)
              (= (type a@@80) BoxType)
              (= (type b@@59) (SeqType BoxType))
              (_System.__default.rank__is__less__than
                A@@3
                B@@0
                a@@80
                ($Box b@@59)))
         (< (BoxRank a@@80) (|Seq#Rank| b@@59)))
     :pattern ((_System.__default.rank__is__less__than
                 A@@3
                 B@@0
                 a@@80
                 ($Box b@@59))
               (BoxRank a@@80))
     :pattern ((_System.__default.rank__is__less__than
                 A@@3
                 B@@0
                 a@@80
                 ($Box b@@59))
               (|Seq#Rank| b@@59))
     :skolemid |692|
     :qid |DafnyPreludebpl.1473:15|)))
(assert (forall ((A@@4 T@U) (B@@1 T@U) (a@@81 T@U) (b@@60 T@U))
  (! (=> (and (= (type A@@4) TyType)
              (= (type B@@1) TyType)
              (= (type a@@81) (SeqType BoxType))
              (= (type b@@60) BoxType)
              (_System.__default.rank__is__less__than
                A@@4
                B@@1
                ($Box a@@81)
                b@@60))
         (< (|Seq#Rank| a@@81) (BoxRank b@@60)))
     :pattern ((_System.__default.rank__is__less__than
                 A@@4
                 B@@1
                 ($Box a@@81)
                 b@@60)
               (|Seq#Rank| a@@81))
     :pattern ((_System.__default.rank__is__less__than
                 A@@4
                 B@@1
                 ($Box a@@81)
                 b@@60)
               (BoxRank b@@60))
     :skolemid |693|
     :qid |DafnyPreludebpl.1478:15|)))
(assert (= (type Tclass._System.nat) TyType))
(assert (= (Tag Tclass._System.nat) Tagclass._System.nat))
(assert (forall ((arg0@@113 T@U))
  (! (= (type (TagFamily arg0@@113)) TyTagFamilyType)
     :pattern ((TagFamily arg0@@113))
     :qid |funType:TagFamily|)))
(assert (= (TagFamily Tclass._System.nat) tytagFamily$nat))
(assert (forall ((bx@@26 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@26)) bx@@26)
                     ($Is ($Unbox intType bx@@26) Tclass._System.nat))))
       (=> (and (= (type bx@@26) BoxType) ($IsBox bx@@26 Tclass._System.nat))
           a!1))
     :pattern (($IsBox bx@@26 Tclass._System.nat))
     :skolemid |694|
     :qid |unknown.0:0|)))
(assert (forall ((|x#0| T@U))
  (! (=> (= (type |x#0|) intType)
         (= ($Is |x#0| Tclass._System.nat)
            (INTERNAL_le_boogie 0 (U_2_int |x#0|))))
     :pattern (($Is |x#0| Tclass._System.nat))
     :skolemid |695|
     :qid |unknown.0:0|)))
(assert (forall ((|x#0@@0| T@U) ($h T@U))
  (! (=> (and (= (type |x#0@@0|) intType)
              (= (type $h) (MapType0Type refType MapType1Type)))
         ($IsAlloc |x#0@@0| Tclass._System.nat $h))
     :pattern (($IsAlloc |x#0@@0| Tclass._System.nat $h))
     :skolemid |696|
     :qid |unknown.0:0|)))
(assert (= (Tag Tclass._System.object?) Tagclass._System.object?))
(assert (= (TagFamily Tclass._System.object?) tytagFamily$object))
(assert (forall ((bx@@27 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@27)) bx@@27)
                     ($Is ($Unbox refType bx@@27) Tclass._System.object?))))
       (=> (and (= (type bx@@27) BoxType)
                ($IsBox bx@@27 Tclass._System.object?))
           a!1))
     :pattern (($IsBox bx@@27 Tclass._System.object?))
     :skolemid |697|
     :qid |unknown.0:0|)))
(assert (forall (($o T@U))
  (! (=> (= (type $o) refType) ($Is $o Tclass._System.object?))
     :pattern (($Is $o Tclass._System.object?))
     :skolemid |698|
     :qid |unknown.0:0|)))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h@@0 T@U))
  (! (let ((a!1 (or (= $o@@0 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@0 $o@@0)
                                              alloc)))))
       (=> (and (= (type $o@@0) refType)
                (= (type $h@@0) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@0 Tclass._System.object? $h@@0) a!1)))
     :pattern (($IsAlloc $o@@0 Tclass._System.object? $h@@0))
     :skolemid |699|
     :qid |unknown.0:0|)))
(assert (= (type Tclass._System.object) TyType))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (= (TagFamily Tclass._System.object) tytagFamily$object))
(assert (forall ((bx@@28 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@28)) bx@@28)
                     ($Is ($Unbox refType bx@@28) Tclass._System.object))))
       (=> (and (= (type bx@@28) BoxType) ($IsBox bx@@28 Tclass._System.object))
           a!1))
     :pattern (($IsBox bx@@28 Tclass._System.object))
     :skolemid |700|
     :qid |unknown.0:0|)))
(assert (forall ((|c#0| T@U))
  (! (let ((a!1 (= ($Is |c#0| Tclass._System.object)
                   (and ($Is |c#0| Tclass._System.object?) (not (= |c#0| null))))))
       (=> (= (type |c#0|) refType) a!1))
     :pattern (($Is |c#0| Tclass._System.object))
     :skolemid |701|
     :qid |unknown.0:0|)))
(assert (forall ((|c#0@@0| T@U) ($h@@1 T@U))
  (! (=> (and (= (type |c#0@@0|) refType)
              (= (type $h@@1) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |c#0@@0| Tclass._System.object $h@@1)
            ($IsAlloc |c#0@@0| Tclass._System.object? $h@@1)))
     :pattern (($IsAlloc |c#0@@0| Tclass._System.object $h@@1))
     :skolemid |702|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@114 T@U))
  (! (= (type (Tclass._System.array? arg0@@114)) TyType)
     :pattern ((Tclass._System.array? arg0@@114))
     :qid |funType:Tclass._System.array?|)))
(assert (forall ((_System.array$arg T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.array? _System.array$arg))
                        Tagclass._System.array?)
                     (= (TagFamily (Tclass._System.array? _System.array$arg))
                        tytagFamily$array))))
       (=> (= (type _System.array$arg) TyType) a!1))
     :pattern ((Tclass._System.array? _System.array$arg))
     :skolemid |703|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@115 T@U))
  (! (= (type (Tclass._System.array?_0 arg0@@115)) TyType)
     :pattern ((Tclass._System.array?_0 arg0@@115))
     :qid |funType:Tclass._System.array?_0|)))
(assert (forall ((_System.array$arg@@0 T@U))
  (! (=> (= (type _System.array$arg@@0) TyType)
         (= (Tclass._System.array?_0
              (Tclass._System.array? _System.array$arg@@0))
            _System.array$arg@@0))
     :pattern ((Tclass._System.array? _System.array$arg@@0))
     :skolemid |704|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@1 T@U) (bx@@29 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@29)) bx@@29)
                     ($Is ($Unbox refType bx@@29)
                          (Tclass._System.array? _System.array$arg@@1)))))
       (=> (and (= (type _System.array$arg@@1) TyType)
                (= (type bx@@29) BoxType)
                ($IsBox bx@@29 (Tclass._System.array? _System.array$arg@@1)))
           a!1))
     :pattern (($IsBox bx@@29 (Tclass._System.array? _System.array$arg@@1)))
     :skolemid |705|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@116 T@U))
  (! (= (type (dtype arg0@@116)) TyType)
     :pattern ((dtype arg0@@116))
     :qid |funType:dtype|)))
(assert (forall ((_System.array$arg@@2 T@U) ($h@@2 T@U) ($o@@1 T@U) ($i0 Int))
  (! (=> (and (= (type _System.array$arg@@2) TyType)
              (= (type $h@@2) (MapType0Type refType MapType1Type))
              (= (type $o@@1) refType)
              ($IsGoodHeap $h@@2)
              (not (= $o@@1 null))
              (= (dtype $o@@1) (Tclass._System.array? _System.array$arg@@2))
              (<= 0 $i0)
              (< $i0 (_System.array.Length $o@@1)))
         ($IsBox (MapType1Select (MapType0Select $h@@2 $o@@1) (IndexField $i0))
                 _System.array$arg@@2))
     :pattern ((MapType1Select (MapType0Select $h@@2 $o@@1) (IndexField $i0))
               (Tclass._System.array? _System.array$arg@@2))
     :skolemid |706|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@3 T@U) ($h@@3 T@U) ($o@@2 T@U) ($i0@@0 Int))
  (! (let ((a!1 (and ($IsGoodHeap $h@@3)
                     (not (= $o@@2 null))
                     (= (dtype $o@@2)
                        (Tclass._System.array? _System.array$arg@@3))
                     (<= 0 $i0@@0)
                     (< $i0@@0 (_System.array.Length $o@@2))
                     (U_2_bool (MapType1Select (MapType0Select $h@@3 $o@@2)
                                               alloc)))))
     (let ((a!2 (=> a!1
                    ($IsAllocBox (MapType1Select (MapType0Select $h@@3 $o@@2)
                                                 (IndexField $i0@@0))
                                 _System.array$arg@@3
                                 $h@@3))))
       (=> (and (= (type _System.array$arg@@3) TyType)
                (= (type $h@@3) (MapType0Type refType MapType1Type))
                (= (type $o@@2) refType))
           a!2)))
     :pattern ((MapType1Select (MapType0Select $h@@3 $o@@2) (IndexField $i0@@0))
               (Tclass._System.array? _System.array$arg@@3))
     :skolemid |707|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@4 T@U) ($o@@3 T@U))
  (! (let ((a!1 (= ($Is $o@@3 (Tclass._System.array? _System.array$arg@@4))
                   (or (= $o@@3 null)
                       (= (dtype $o@@3)
                          (Tclass._System.array? _System.array$arg@@4))))))
       (=> (and (= (type _System.array$arg@@4) TyType) (= (type $o@@3) refType))
           a!1))
     :pattern (($Is $o@@3 (Tclass._System.array? _System.array$arg@@4)))
     :skolemid |708|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@5 T@U) ($o@@4 T@U) ($h@@4 T@U))
  (! (let ((a!1 (or (= $o@@4 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@4 $o@@4)
                                              alloc)))))
       (=> (and (= (type _System.array$arg@@5) TyType)
                (= (type $o@@4) refType)
                (= (type $h@@4) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@4
                        (Tclass._System.array? _System.array$arg@@5)
                        $h@@4)
              a!1)))
     :pattern (($IsAlloc $o@@4
                         (Tclass._System.array? _System.array$arg@@5)
                         $h@@4))
     :skolemid |709|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@6 T@U) ($o@@5 T@U))
  (! (=> (and (= (type _System.array$arg@@6) TyType)
              (= (type $o@@5) refType)
              (not (= $o@@5 null))
              (= (dtype $o@@5) (Tclass._System.array? _System.array$arg@@6)))
         ($Is (int_2_U (_System.array.Length $o@@5)) TInt))
     :pattern ((_System.array.Length $o@@5)
               (Tclass._System.array? _System.array$arg@@6))
     :skolemid |710|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@7 T@U) ($h@@5 T@U) ($o@@6 T@U))
  (! (let ((a!1 (and (= (type _System.array$arg@@7) TyType)
                     (= (type $h@@5) (MapType0Type refType MapType1Type))
                     (= (type $o@@6) refType)
                     ($IsGoodHeap $h@@5)
                     (not (= $o@@6 null))
                     (= (dtype $o@@6)
                        (Tclass._System.array? _System.array$arg@@7))
                     (U_2_bool (MapType1Select (MapType0Select $h@@5 $o@@6)
                                               alloc)))))
       (=> a!1 ($IsAlloc (int_2_U (_System.array.Length $o@@6)) TInt $h@@5)))
     :pattern ((_System.array.Length $o@@6)
               (MapType1Select (MapType0Select $h@@5 $o@@6) alloc)
               (Tclass._System.array? _System.array$arg@@7))
     :skolemid |711|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@117 T@U))
  (! (= (type (Tclass._System.array arg0@@117)) TyType)
     :pattern ((Tclass._System.array arg0@@117))
     :qid |funType:Tclass._System.array|)))
(assert (forall ((_System.array$arg@@8 T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.array _System.array$arg@@8))
                        Tagclass._System.array)
                     (= (TagFamily (Tclass._System.array _System.array$arg@@8))
                        tytagFamily$array))))
       (=> (= (type _System.array$arg@@8) TyType) a!1))
     :pattern ((Tclass._System.array _System.array$arg@@8))
     :skolemid |712|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@118 T@U))
  (! (= (type (Tclass._System.array_0 arg0@@118)) TyType)
     :pattern ((Tclass._System.array_0 arg0@@118))
     :qid |funType:Tclass._System.array_0|)))
(assert (forall ((_System.array$arg@@9 T@U))
  (! (=> (= (type _System.array$arg@@9) TyType)
         (= (Tclass._System.array_0 (Tclass._System.array _System.array$arg@@9))
            _System.array$arg@@9))
     :pattern ((Tclass._System.array _System.array$arg@@9))
     :skolemid |713|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@10 T@U) (bx@@30 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@30)) bx@@30)
                     ($Is ($Unbox refType bx@@30)
                          (Tclass._System.array _System.array$arg@@10)))))
       (=> (and (= (type _System.array$arg@@10) TyType)
                (= (type bx@@30) BoxType)
                ($IsBox bx@@30 (Tclass._System.array _System.array$arg@@10)))
           a!1))
     :pattern (($IsBox bx@@30 (Tclass._System.array _System.array$arg@@10)))
     :skolemid |714|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@11 T@U) (|c#0@@1| T@U))
  (! (let ((a!1 (= ($Is |c#0@@1| (Tclass._System.array _System.array$arg@@11))
                   (and ($Is |c#0@@1|
                             (Tclass._System.array? _System.array$arg@@11))
                        (not (= |c#0@@1| null))))))
       (=> (and (= (type _System.array$arg@@11) TyType)
                (= (type |c#0@@1|) refType))
           a!1))
     :pattern (($Is |c#0@@1| (Tclass._System.array _System.array$arg@@11)))
     :skolemid |715|
     :qid |unknown.0:0|)))
(assert (forall ((_System.array$arg@@12 T@U) (|c#0@@2| T@U) ($h@@6 T@U))
  (! (=> (and (= (type _System.array$arg@@12) TyType)
              (= (type |c#0@@2|) refType)
              (= (type $h@@6) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |c#0@@2|
                      (Tclass._System.array _System.array$arg@@12)
                      $h@@6)
            ($IsAlloc |c#0@@2|
                      (Tclass._System.array? _System.array$arg@@12)
                      $h@@6)))
     :pattern (($IsAlloc |c#0@@2|
                         (Tclass._System.array _System.array$arg@@12)
                         $h@@6))
     :skolemid |716|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@119 T@U) (arg1@@53 T@U))
  (! (= (type (Tclass._System.___hFunc1 arg0@@119 arg1@@53)) TyType)
     :pattern ((Tclass._System.___hFunc1 arg0@@119 arg1@@53))
     :qid |funType:Tclass._System.___hFunc1|)))
(assert (forall ((|#$T0| T@U) (|#$R| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc1 |#$T0| |#$R|))
                        Tagclass._System.___hFunc1)
                     (= (TagFamily (Tclass._System.___hFunc1 |#$T0| |#$R|))
                        |tytagFamily$_#Func1|))))
       (=> (and (= (type |#$T0|) TyType) (= (type |#$R|) TyType)) a!1))
     :pattern ((Tclass._System.___hFunc1 |#$T0| |#$R|))
     :skolemid |717|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@120 T@U))
  (! (= (type (Tclass._System.___hFunc1_0 arg0@@120)) TyType)
     :pattern ((Tclass._System.___hFunc1_0 arg0@@120))
     :qid |funType:Tclass._System.___hFunc1_0|)))
(assert (forall ((|#$T0@@0| T@U) (|#$R@@0| T@U))
  (! (=> (and (= (type |#$T0@@0|) TyType) (= (type |#$R@@0|) TyType))
         (= (Tclass._System.___hFunc1_0
              (Tclass._System.___hFunc1 |#$T0@@0| |#$R@@0|))
            |#$T0@@0|))
     :pattern ((Tclass._System.___hFunc1 |#$T0@@0| |#$R@@0|))
     :skolemid |718|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@121 T@U))
  (! (= (type (Tclass._System.___hFunc1_1 arg0@@121)) TyType)
     :pattern ((Tclass._System.___hFunc1_1 arg0@@121))
     :qid |funType:Tclass._System.___hFunc1_1|)))
(assert (forall ((|#$T0@@1| T@U) (|#$R@@1| T@U))
  (! (=> (and (= (type |#$T0@@1|) TyType) (= (type |#$R@@1|) TyType))
         (= (Tclass._System.___hFunc1_1
              (Tclass._System.___hFunc1 |#$T0@@1| |#$R@@1|))
            |#$R@@1|))
     :pattern ((Tclass._System.___hFunc1 |#$T0@@1| |#$R@@1|))
     :skolemid |719|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@2| T@U) (|#$R@@2| T@U) (bx@@31 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@31)) bx@@31)
                     ($Is ($Unbox HandleTypeType bx@@31)
                          (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|)))))
       (=> (and (= (type |#$T0@@2|) TyType)
                (= (type |#$R@@2|) TyType)
                (= (type bx@@31) BoxType)
                ($IsBox bx@@31 (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|)))
           a!1))
     :pattern (($IsBox bx@@31 (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|)))
     :skolemid |720|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@122 T@T) (arg1@@54 T@T) (arg2@@8 T@T))
             (! (= (Ctor (MapType2Type arg0@@122 arg1@@54 arg2@@8)) 24)
                :qid |ctor:MapType2Type|)))
      (a!2 (forall ((arg0@@123 T@T) (arg1@@55 T@T) (arg2@@9 T@T))
             (! (= (MapType2TypeInv0 (MapType2Type arg0@@123 arg1@@55 arg2@@9))
                   arg0@@123)
                :pattern ((MapType2Type arg0@@123 arg1@@55 arg2@@9))
                :qid |typeInv:MapType2TypeInv0|)))
      (a!3 (forall ((arg0@@124 T@T) (arg1@@56 T@T) (arg2@@10 T@T))
             (! (= (MapType2TypeInv1 (MapType2Type arg0@@124 arg1@@56 arg2@@10))
                   arg1@@56)
                :pattern ((MapType2Type arg0@@124 arg1@@56 arg2@@10))
                :qid |typeInv:MapType2TypeInv1|)))
      (a!4 (forall ((arg0@@125 T@T) (arg1@@57 T@T) (arg2@@11 T@T))
             (! (= (MapType2TypeInv2 (MapType2Type arg0@@125 arg1@@57 arg2@@11))
                   arg2@@11)
                :pattern ((MapType2Type arg0@@125 arg1@@57 arg2@@11))
                :qid |typeInv:MapType2TypeInv2|)))
      (a!5 (forall ((arg0@@126 T@U) (arg1@@58 T@U) (arg2@@12 T@U))
             (! (= (type (MapType2Select arg0@@126 arg1@@58 arg2@@12))
                   (MapType2TypeInv2 (type arg0@@126)))
                :pattern ((MapType2Select arg0@@126 arg1@@58 arg2@@12))
                :qid |funType:MapType2Select|)))
      (a!6 (forall ((arg0@@127 T@U) (arg1@@59 T@U) (arg2@@13 T@U) (arg3@@1 T@U))
             (! (= (type (MapType2Store arg0@@127 arg1@@59 arg2@@13 arg3@@1))
                   (MapType2Type (type arg1@@59) (type arg2@@13) (type arg3@@1)))
                :pattern ((MapType2Store arg0@@127 arg1@@59 arg2@@13 arg3@@1))
                :qid |funType:MapType2Store|)))
      (a!7 (forall ((m@@45 T@U) (x0@@5 T@U) (x1 T@U) (val@@6 T@U))
             (! (=> (= (type val@@6) (MapType2TypeInv2 (type m@@45)))
                    (= (MapType2Select (MapType2Store m@@45 x0@@5 x1 val@@6)
                                       x0@@5
                                       x1)
                       val@@6))
                :weight 0
                :qid |mapAx0:MapType2Select|)))
      (a!8 (forall ((arg0@@128 T@U) (arg1@@60 T@U) (arg2@@14 T@U))
             (! (= (type (Handle1 arg0@@128 arg1@@60 arg2@@14)) HandleTypeType)
                :pattern ((Handle1 arg0@@128 arg1@@60 arg2@@14))
                :qid |funType:Handle1|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       (forall ((val@@7 T@U)
                (m@@46 T@U)
                (x0@@6 T@U)
                (x1@@0 T@U)
                (y0@@3 T@U)
                (y1 T@U))
         (! (let ((a!1 (= (MapType2Select (MapType2Store m@@46
                                                         x0@@6
                                                         x1@@0
                                                         val@@7)
                                          y0@@3
                                          y1)
                          (MapType2Select m@@46 y0@@3 y1))))
              (or (= x0@@6 y0@@3) a!1))
            :weight 0
            :qid |mapAx1:MapType2Select:0|))
       (forall ((val@@8 T@U)
                (m@@47 T@U)
                (x0@@7 T@U)
                (x1@@1 T@U)
                (y0@@4 T@U)
                (y1@@0 T@U))
         (! (let ((a!1 (= (MapType2Select (MapType2Store m@@47
                                                         x0@@7
                                                         x1@@1
                                                         val@@8)
                                          y0@@4
                                          y1@@0)
                          (MapType2Select m@@47 y0@@4 y1@@0))))
              (or (= x1@@1 y1@@0) a!1))
            :weight 0
            :qid |mapAx1:MapType2Select:1|))
       (forall ((val@@9 T@U)
                (m@@48 T@U)
                (x0@@8 T@U)
                (x1@@2 T@U)
                (y0@@5 T@U)
                (y1@@1 T@U))
         (! (let ((a!1 (= (MapType2Select (MapType2Store m@@48
                                                         x0@@8
                                                         x1@@2
                                                         val@@9)
                                          y0@@5
                                          y1@@1)
                          (MapType2Select m@@48 y0@@5 y1@@1))))
              (or true a!1))
            :weight 0
            :qid |mapAx2:MapType2Select|))
       a!8)))
(assert (forall ((t0@@16 T@U)
         (t1@@7 T@U)
         (heap@@1 T@U)
         (h@@21 T@U)
         (r@@6 T@U)
         (rd T@U)
         (bx0 T@U))
  (! (let ((a!1 (and (= (type t0@@16) TyType)
                     (= (type t1@@7) TyType)
                     (= (type heap@@1) (MapType0Type refType MapType1Type))
                     (= (type h@@21)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType))
                     (= (type r@@6)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      boolType))
                     (= (type rd)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0) BoxType))))
       (=> a!1
           (= (Apply1 t0@@16 t1@@7 heap@@1 (Handle1 h@@21 r@@6 rd) bx0)
              (MapType2Select h@@21 heap@@1 bx0))))
     :pattern ((Apply1 t0@@16 t1@@7 heap@@1 (Handle1 h@@21 r@@6 rd) bx0))
     :skolemid |721|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@17 T@U)
         (t1@@8 T@U)
         (heap@@2 T@U)
         (h@@22 T@U)
         (r@@7 T@U)
         (rd@@0 T@U)
         (bx0@@0 T@U))
  (! (let ((a!1 (and (= (type t0@@17) TyType)
                     (= (type t1@@8) TyType)
                     (= (type heap@@2) (MapType0Type refType MapType1Type))
                     (= (type h@@22)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType))
                     (= (type r@@7)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      boolType))
                     (= (type rd@@0)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@0) BoxType)
                     (U_2_bool (MapType2Select r@@7 heap@@2 bx0@@0)))))
       (=> a!1
           (Requires1 t0@@17 t1@@8 heap@@2 (Handle1 h@@22 r@@7 rd@@0) bx0@@0)))
     :pattern ((Requires1 t0@@17
                          t1@@8
                          heap@@2
                          (Handle1 h@@22 r@@7 rd@@0)
                          bx0@@0))
     :skolemid |722|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@129 T@U)
         (arg1@@61 T@U)
         (arg2@@15 T@U)
         (arg3@@2 T@U)
         (arg4@@0 T@U))
  (! (= (type (Reads1 arg0@@129 arg1@@61 arg2@@15 arg3@@2 arg4@@0))
        (MapType0Type BoxType boolType))
     :pattern ((Reads1 arg0@@129 arg1@@61 arg2@@15 arg3@@2 arg4@@0))
     :qid |funType:Reads1|)))
(assert (forall ((t0@@18 T@U)
         (t1@@9 T@U)
         (heap@@3 T@U)
         (h@@23 T@U)
         (r@@8 T@U)
         (rd@@1 T@U)
         (bx0@@1 T@U)
         (bx@@32 T@U))
  (! (let ((a!1 (and (= (type t0@@18) TyType)
                     (= (type t1@@9) TyType)
                     (= (type heap@@3) (MapType0Type refType MapType1Type))
                     (= (type h@@23)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType))
                     (= (type r@@8)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      boolType))
                     (= (type rd@@1)
                        (MapType2Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@1) BoxType)
                     (= (type bx@@32) BoxType)))
           (a!2 (U_2_bool (MapType0Select (Reads1 t0@@18
                                                  t1@@9
                                                  heap@@3
                                                  (Handle1 h@@23 r@@8 rd@@1)
                                                  bx0@@1)
                                          bx@@32))))
     (let ((a!3 (= a!2
                   (U_2_bool (MapType0Select (MapType2Select rd@@1
                                                             heap@@3
                                                             bx0@@1)
                                             bx@@32)))))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (Reads1 t0@@18
                                       t1@@9
                                       heap@@3
                                       (Handle1 h@@23 r@@8 rd@@1)
                                       bx0@@1)
                               bx@@32))
     :skolemid |723|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@19 T@U)
         (t1@@10 T@U)
         (h0@@0 T@U)
         (h1@@0 T@U)
         (f@@5 T@U)
         (bx0@@2 T@U))
  (! (let ((a!1 (forall ((o@@44 T@U) (fld T@U))
                  (! (let ((a!1 (= (type fld)
                                   (FieldType (FieldTypeInv0 (type fld))))))
                     (let ((a!2 (and (= (type o@@44) refType)
                                     a!1
                                     (not (= o@@44 null))
                                     (U_2_bool (MapType0Select (Reads1 t0@@19
                                                                       t1@@10
                                                                       h0@@0
                                                                       f@@5
                                                                       bx0@@2)
                                                               ($Box o@@44))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@0 o@@44) fld)
                              (MapType1Select (MapType0Select h1@@0 o@@44) fld)))))
                     :no-pattern (type o@@44)
                     :no-pattern (type fld)
                     :no-pattern (U_2_int o@@44)
                     :no-pattern (U_2_bool o@@44)
                     :no-pattern (U_2_int fld)
                     :no-pattern (U_2_bool fld)
                     :skolemid |724|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@19) TyType)
                (= (type t1@@10) TyType)
                (= (type h0@@0) (MapType0Type refType MapType1Type))
                (= (type h1@@0) (MapType0Type refType MapType1Type))
                (= (type f@@5) HandleTypeType)
                (= (type bx0@@2) BoxType)
                ($HeapSucc h0@@0 h1@@0)
                ($IsGoodHeap h0@@0)
                ($IsGoodHeap h1@@0)
                ($IsBox bx0@@2 t0@@19)
                ($Is f@@5 (Tclass._System.___hFunc1 t0@@19 t1@@10))
                a!1)
           (= (Reads1 t0@@19 t1@@10 h0@@0 f@@5 bx0@@2)
              (Reads1 t0@@19 t1@@10 h1@@0 f@@5 bx0@@2))))
     :pattern (($HeapSucc h0@@0 h1@@0) (Reads1 t0@@19 t1@@10 h1@@0 f@@5 bx0@@2))
     :skolemid |725|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@20 T@U)
         (t1@@11 T@U)
         (h0@@1 T@U)
         (h1@@1 T@U)
         (f@@6 T@U)
         (bx0@@3 T@U))
  (! (let ((a!1 (forall ((o@@45 T@U) (fld@@0 T@U))
                  (! (let ((a!1 (= (type fld@@0)
                                   (FieldType (FieldTypeInv0 (type fld@@0))))))
                     (let ((a!2 (and (= (type o@@45) refType)
                                     a!1
                                     (not (= o@@45 null))
                                     (U_2_bool (MapType0Select (Reads1 t0@@20
                                                                       t1@@11
                                                                       h1@@1
                                                                       f@@6
                                                                       bx0@@3)
                                                               ($Box o@@45))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@1 o@@45)
                                              fld@@0)
                              (MapType1Select (MapType0Select h1@@1 o@@45)
                                              fld@@0)))))
                     :no-pattern (type o@@45)
                     :no-pattern (type fld@@0)
                     :no-pattern (U_2_int o@@45)
                     :no-pattern (U_2_bool o@@45)
                     :no-pattern (U_2_int fld@@0)
                     :no-pattern (U_2_bool fld@@0)
                     :skolemid |726|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@20) TyType)
                (= (type t1@@11) TyType)
                (= (type h0@@1) (MapType0Type refType MapType1Type))
                (= (type h1@@1) (MapType0Type refType MapType1Type))
                (= (type f@@6) HandleTypeType)
                (= (type bx0@@3) BoxType)
                ($HeapSucc h0@@1 h1@@1)
                ($IsGoodHeap h0@@1)
                ($IsGoodHeap h1@@1)
                ($IsBox bx0@@3 t0@@20)
                ($Is f@@6 (Tclass._System.___hFunc1 t0@@20 t1@@11))
                a!1)
           (= (Reads1 t0@@20 t1@@11 h0@@1 f@@6 bx0@@3)
              (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3))))
     :pattern (($HeapSucc h0@@1 h1@@1) (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3))
     :skolemid |727|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@21 T@U)
         (t1@@12 T@U)
         (h0@@2 T@U)
         (h1@@2 T@U)
         (f@@7 T@U)
         (bx0@@4 T@U))
  (! (let ((a!1 (forall ((o@@46 T@U) (fld@@1 T@U))
                  (! (let ((a!1 (= (type fld@@1)
                                   (FieldType (FieldTypeInv0 (type fld@@1))))))
                     (let ((a!2 (and (= (type o@@46) refType)
                                     a!1
                                     (not (= o@@46 null))
                                     (U_2_bool (MapType0Select (Reads1 t0@@21
                                                                       t1@@12
                                                                       h0@@2
                                                                       f@@7
                                                                       bx0@@4)
                                                               ($Box o@@46))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@2 o@@46)
                                              fld@@1)
                              (MapType1Select (MapType0Select h1@@2 o@@46)
                                              fld@@1)))))
                     :no-pattern (type o@@46)
                     :no-pattern (type fld@@1)
                     :no-pattern (U_2_int o@@46)
                     :no-pattern (U_2_bool o@@46)
                     :no-pattern (U_2_int fld@@1)
                     :no-pattern (U_2_bool fld@@1)
                     :skolemid |728|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@21) TyType)
                (= (type t1@@12) TyType)
                (= (type h0@@2) (MapType0Type refType MapType1Type))
                (= (type h1@@2) (MapType0Type refType MapType1Type))
                (= (type f@@7) HandleTypeType)
                (= (type bx0@@4) BoxType)
                ($HeapSucc h0@@2 h1@@2)
                ($IsGoodHeap h0@@2)
                ($IsGoodHeap h1@@2)
                ($IsBox bx0@@4 t0@@21)
                ($Is f@@7 (Tclass._System.___hFunc1 t0@@21 t1@@12))
                a!1)
           (= (Requires1 t0@@21 t1@@12 h0@@2 f@@7 bx0@@4)
              (Requires1 t0@@21 t1@@12 h1@@2 f@@7 bx0@@4))))
     :pattern (($HeapSucc h0@@2 h1@@2)
               (Requires1 t0@@21 t1@@12 h1@@2 f@@7 bx0@@4))
     :skolemid |729|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@22 T@U)
         (t1@@13 T@U)
         (h0@@3 T@U)
         (h1@@3 T@U)
         (f@@8 T@U)
         (bx0@@5 T@U))
  (! (let ((a!1 (forall ((o@@47 T@U) (fld@@2 T@U))
                  (! (let ((a!1 (= (type fld@@2)
                                   (FieldType (FieldTypeInv0 (type fld@@2))))))
                     (let ((a!2 (and (= (type o@@47) refType)
                                     a!1
                                     (not (= o@@47 null))
                                     (U_2_bool (MapType0Select (Reads1 t0@@22
                                                                       t1@@13
                                                                       h1@@3
                                                                       f@@8
                                                                       bx0@@5)
                                                               ($Box o@@47))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@3 o@@47)
                                              fld@@2)
                              (MapType1Select (MapType0Select h1@@3 o@@47)
                                              fld@@2)))))
                     :no-pattern (type o@@47)
                     :no-pattern (type fld@@2)
                     :no-pattern (U_2_int o@@47)
                     :no-pattern (U_2_bool o@@47)
                     :no-pattern (U_2_int fld@@2)
                     :no-pattern (U_2_bool fld@@2)
                     :skolemid |730|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@22) TyType)
                (= (type t1@@13) TyType)
                (= (type h0@@3) (MapType0Type refType MapType1Type))
                (= (type h1@@3) (MapType0Type refType MapType1Type))
                (= (type f@@8) HandleTypeType)
                (= (type bx0@@5) BoxType)
                ($HeapSucc h0@@3 h1@@3)
                ($IsGoodHeap h0@@3)
                ($IsGoodHeap h1@@3)
                ($IsBox bx0@@5 t0@@22)
                ($Is f@@8 (Tclass._System.___hFunc1 t0@@22 t1@@13))
                a!1)
           (= (Requires1 t0@@22 t1@@13 h0@@3 f@@8 bx0@@5)
              (Requires1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5))))
     :pattern (($HeapSucc h0@@3 h1@@3)
               (Requires1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5))
     :skolemid |731|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@23 T@U)
         (t1@@14 T@U)
         (h0@@4 T@U)
         (h1@@4 T@U)
         (f@@9 T@U)
         (bx0@@6 T@U))
  (! (let ((a!1 (forall ((o@@48 T@U) (fld@@3 T@U))
                  (! (let ((a!1 (= (type fld@@3)
                                   (FieldType (FieldTypeInv0 (type fld@@3))))))
                     (let ((a!2 (and (= (type o@@48) refType)
                                     a!1
                                     (not (= o@@48 null))
                                     (U_2_bool (MapType0Select (Reads1 t0@@23
                                                                       t1@@14
                                                                       h0@@4
                                                                       f@@9
                                                                       bx0@@6)
                                                               ($Box o@@48))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@4 o@@48)
                                              fld@@3)
                              (MapType1Select (MapType0Select h1@@4 o@@48)
                                              fld@@3)))))
                     :no-pattern (type o@@48)
                     :no-pattern (type fld@@3)
                     :no-pattern (U_2_int o@@48)
                     :no-pattern (U_2_bool o@@48)
                     :no-pattern (U_2_int fld@@3)
                     :no-pattern (U_2_bool fld@@3)
                     :skolemid |732|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@23) TyType)
                (= (type t1@@14) TyType)
                (= (type h0@@4) (MapType0Type refType MapType1Type))
                (= (type h1@@4) (MapType0Type refType MapType1Type))
                (= (type f@@9) HandleTypeType)
                (= (type bx0@@6) BoxType)
                ($HeapSucc h0@@4 h1@@4)
                ($IsGoodHeap h0@@4)
                ($IsGoodHeap h1@@4)
                ($IsBox bx0@@6 t0@@23)
                ($Is f@@9 (Tclass._System.___hFunc1 t0@@23 t1@@14))
                a!1)
           (= (Apply1 t0@@23 t1@@14 h0@@4 f@@9 bx0@@6)
              (Apply1 t0@@23 t1@@14 h1@@4 f@@9 bx0@@6))))
     :pattern (($HeapSucc h0@@4 h1@@4) (Apply1 t0@@23 t1@@14 h1@@4 f@@9 bx0@@6))
     :skolemid |733|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@24 T@U)
         (t1@@15 T@U)
         (h0@@5 T@U)
         (h1@@5 T@U)
         (f@@10 T@U)
         (bx0@@7 T@U))
  (! (let ((a!1 (forall ((o@@49 T@U) (fld@@4 T@U))
                  (! (let ((a!1 (= (type fld@@4)
                                   (FieldType (FieldTypeInv0 (type fld@@4))))))
                     (let ((a!2 (and (= (type o@@49) refType)
                                     a!1
                                     (not (= o@@49 null))
                                     (U_2_bool (MapType0Select (Reads1 t0@@24
                                                                       t1@@15
                                                                       h1@@5
                                                                       f@@10
                                                                       bx0@@7)
                                                               ($Box o@@49))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@5 o@@49)
                                              fld@@4)
                              (MapType1Select (MapType0Select h1@@5 o@@49)
                                              fld@@4)))))
                     :no-pattern (type o@@49)
                     :no-pattern (type fld@@4)
                     :no-pattern (U_2_int o@@49)
                     :no-pattern (U_2_bool o@@49)
                     :no-pattern (U_2_int fld@@4)
                     :no-pattern (U_2_bool fld@@4)
                     :skolemid |734|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@24) TyType)
                (= (type t1@@15) TyType)
                (= (type h0@@5) (MapType0Type refType MapType1Type))
                (= (type h1@@5) (MapType0Type refType MapType1Type))
                (= (type f@@10) HandleTypeType)
                (= (type bx0@@7) BoxType)
                ($HeapSucc h0@@5 h1@@5)
                ($IsGoodHeap h0@@5)
                ($IsGoodHeap h1@@5)
                ($IsBox bx0@@7 t0@@24)
                ($Is f@@10 (Tclass._System.___hFunc1 t0@@24 t1@@15))
                a!1)
           (= (Apply1 t0@@24 t1@@15 h0@@5 f@@10 bx0@@7)
              (Apply1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7))))
     :pattern (($HeapSucc h0@@5 h1@@5)
               (Apply1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7))
     :skolemid |735|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@25 T@U) (t1@@16 T@U) (heap@@4 T@U) (f@@11 T@U) (bx0@@8 T@U))
  (! (=> (and (= (type t0@@25) TyType)
              (= (type t1@@16) TyType)
              (= (type heap@@4) (MapType0Type refType MapType1Type))
              (= (type f@@11) HandleTypeType)
              (= (type bx0@@8) BoxType)
              ($IsGoodHeap heap@@4)
              ($IsBox bx0@@8 t0@@25)
              ($Is f@@11 (Tclass._System.___hFunc1 t0@@25 t1@@16)))
         (= (|Set#Equal| (Reads1 t0@@25 t1@@16 $OneHeap f@@11 bx0@@8)
                         (|Set#Empty| BoxType))
            (|Set#Equal| (Reads1 t0@@25 t1@@16 heap@@4 f@@11 bx0@@8)
                         (|Set#Empty| BoxType))))
     :pattern ((Reads1 t0@@25 t1@@16 $OneHeap f@@11 bx0@@8)
               ($IsGoodHeap heap@@4))
     :pattern ((Reads1 t0@@25 t1@@16 heap@@4 f@@11 bx0@@8))
     :skolemid |736|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@26 T@U) (t1@@17 T@U) (heap@@5 T@U) (f@@12 T@U) (bx0@@9 T@U))
  (! (=> (and (= (type t0@@26) TyType)
              (= (type t1@@17) TyType)
              (= (type heap@@5) (MapType0Type refType MapType1Type))
              (= (type f@@12) HandleTypeType)
              (= (type bx0@@9) BoxType)
              ($IsGoodHeap heap@@5)
              ($IsBox bx0@@9 t0@@26)
              ($Is f@@12 (Tclass._System.___hFunc1 t0@@26 t1@@17))
              (|Set#Equal| (Reads1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9)
                           (|Set#Empty| BoxType)))
         (= (Requires1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9)
            (Requires1 t0@@26 t1@@17 heap@@5 f@@12 bx0@@9)))
     :pattern ((Requires1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9)
               ($IsGoodHeap heap@@5))
     :pattern ((Requires1 t0@@26 t1@@17 heap@@5 f@@12 bx0@@9))
     :skolemid |737|
     :qid |unknown.0:0|)))
(assert (forall ((f@@13 T@U) (t0@@27 T@U) (t1@@18 T@U))
  (! (let ((a!1 (forall ((h@@24 T@U) (bx0@@10 T@U))
                  (! (=> (and (= (type h@@24)
                                 (MapType0Type refType MapType1Type))
                              (= (type bx0@@10) BoxType))
                         (=> (and ($IsGoodHeap h@@24)
                                  ($IsBox bx0@@10 t0@@27)
                                  (Requires1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10))
                             ($IsBox (Apply1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10)
                                     t1@@18)))
                     :pattern ((Apply1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10))
                     :skolemid |738|
                     :qid |DafnyPreludebpl.545:12|))))
       (=> (and (= (type f@@13) HandleTypeType)
                (= (type t0@@27) TyType)
                (= (type t1@@18) TyType))
           (= ($Is f@@13 (Tclass._System.___hFunc1 t0@@27 t1@@18)) a!1)))
     :pattern (($Is f@@13 (Tclass._System.___hFunc1 t0@@27 t1@@18)))
     :skolemid |739|
     :qid |unknown.0:0|)))
(assert (forall ((f@@14 T@U) (t0@@28 T@U) (t1@@19 T@U) (u0 T@U) (u1 T@U))
  (! (let ((a!1 (forall ((bx@@33 T@U))
                  (! (=> (and (= (type bx@@33) BoxType) ($IsBox bx@@33 u0))
                         ($IsBox bx@@33 t0@@28))
                     :pattern (($IsBox bx@@33 u0))
                     :pattern (($IsBox bx@@33 t0@@28))
                     :skolemid |740|
                     :qid |unknown.0:0|)))
           (a!2 (forall ((bx@@34 T@U))
                  (! (=> (and (= (type bx@@34) BoxType) ($IsBox bx@@34 t1@@19))
                         ($IsBox bx@@34 u1))
                     :pattern (($IsBox bx@@34 t1@@19))
                     :pattern (($IsBox bx@@34 u1))
                     :skolemid |741|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@14) HandleTypeType)
                (= (type t0@@28) TyType)
                (= (type t1@@19) TyType)
                (= (type u0) TyType)
                (= (type u1) TyType)
                ($Is f@@14 (Tclass._System.___hFunc1 t0@@28 t1@@19))
                a!1
                a!2)
           ($Is f@@14 (Tclass._System.___hFunc1 u0 u1))))
     :pattern (($Is f@@14 (Tclass._System.___hFunc1 t0@@28 t1@@19))
               ($Is f@@14 (Tclass._System.___hFunc1 u0 u1)))
     :skolemid |742|
     :qid |unknown.0:0|)))
(assert (forall ((f@@15 T@U) (t0@@29 T@U) (t1@@20 T@U) (h@@25 T@U))
  (! (let ((a!1 (forall ((bx0@@11 T@U))
                  (! (let ((a!1 (forall ((r@@9 T@U))
                                  (! (let ((a!1 (and (not (= r@@9 null))
                                                     (U_2_bool (MapType0Select (Reads1 t0@@29
                                                                                       t1@@20
                                                                                       h@@25
                                                                                       f@@15
                                                                                       bx0@@11)
                                                                               ($Box r@@9))))))
                                     (let ((a!2 (=> a!1
                                                    (U_2_bool (MapType1Select (MapType0Select h@@25
                                                                                              r@@9)
                                                                              alloc)))))
                                       (=> (= (type r@@9) refType) a!2)))
                                     :pattern ((MapType0Select (Reads1 t0@@29
                                                                       t1@@20
                                                                       h@@25
                                                                       f@@15
                                                                       bx0@@11)
                                                               ($Box r@@9)))
                                     :skolemid |743|
                                     :qid |unknown.0:0|))))
                       (=> (= (type bx0@@11) BoxType)
                           (=> (and ($IsBox bx0@@11 t0@@29)
                                    ($IsAllocBox bx0@@11 t0@@29 h@@25)
                                    (Requires1 t0@@29
                                               t1@@20
                                               h@@25
                                               f@@15
                                               bx0@@11))
                               a!1)))
                     :pattern ((Apply1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11))
                     :pattern ((Reads1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11))
                     :skolemid |744|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@15) HandleTypeType)
                (= (type t0@@29) TyType)
                (= (type t1@@20) TyType)
                (= (type h@@25) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@25))
           (= ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@29 t1@@20) h@@25)
              a!1)))
     :pattern (($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@29 t1@@20) h@@25))
     :skolemid |745|
     :qid |unknown.0:0|)))
(assert (forall ((f@@16 T@U) (t0@@30 T@U) (t1@@21 T@U) (h@@26 T@U))
  (! (let ((a!1 (forall ((bx0@@12 T@U))
                  (! (=> (= (type bx0@@12) BoxType)
                         (=> (and ($IsAllocBox bx0@@12 t0@@30 h@@26)
                                  (Requires1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12))
                             ($IsAllocBox (Apply1 t0@@30
                                                  t1@@21
                                                  h@@26
                                                  f@@16
                                                  bx0@@12)
                                          t1@@21
                                          h@@26)))
                     :pattern ((Apply1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12))
                     :skolemid |746|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@16) HandleTypeType)
                (= (type t0@@30) TyType)
                (= (type t1@@21) TyType)
                (= (type h@@26) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@26)
                ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@30 t1@@21) h@@26))
           a!1))
     :pattern (($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@30 t1@@21) h@@26))
     :skolemid |747|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@130 T@U) (arg1@@62 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1 arg0@@130 arg1@@62)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1 arg0@@130 arg1@@62))
     :qid |funType:Tclass._System.___hPartialFunc1|)))
(assert (forall ((|#$T0@@3| T@U) (|#$R@@3| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc1
                               |#$T0@@3|
                               |#$R@@3|))
                        Tagclass._System.___hPartialFunc1)
                     (= (TagFamily (Tclass._System.___hPartialFunc1
                                     |#$T0@@3|
                                     |#$R@@3|))
                        |tytagFamily$_#PartialFunc1|))))
       (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$R@@3|) TyType)) a!1))
     :pattern ((Tclass._System.___hPartialFunc1 |#$T0@@3| |#$R@@3|))
     :skolemid |748|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@131 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1_0 arg0@@131)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1_0 arg0@@131))
     :qid |funType:Tclass._System.___hPartialFunc1_0|)))
(assert (forall ((|#$T0@@4| T@U) (|#$R@@4| T@U))
  (! (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$R@@4|) TyType))
         (= (Tclass._System.___hPartialFunc1_0
              (Tclass._System.___hPartialFunc1 |#$T0@@4| |#$R@@4|))
            |#$T0@@4|))
     :pattern ((Tclass._System.___hPartialFunc1 |#$T0@@4| |#$R@@4|))
     :skolemid |749|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@132 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1_1 arg0@@132)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1_1 arg0@@132))
     :qid |funType:Tclass._System.___hPartialFunc1_1|)))
(assert (forall ((|#$T0@@5| T@U) (|#$R@@5| T@U))
  (! (=> (and (= (type |#$T0@@5|) TyType) (= (type |#$R@@5|) TyType))
         (= (Tclass._System.___hPartialFunc1_1
              (Tclass._System.___hPartialFunc1 |#$T0@@5| |#$R@@5|))
            |#$R@@5|))
     :pattern ((Tclass._System.___hPartialFunc1 |#$T0@@5| |#$R@@5|))
     :skolemid |750|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@6| T@U) (|#$R@@6| T@U) (bx@@35 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@35)) bx@@35)
                     ($Is ($Unbox HandleTypeType bx@@35)
                          (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|)))))
       (=> (and (= (type |#$T0@@6|) TyType)
                (= (type |#$R@@6|) TyType)
                (= (type bx@@35) BoxType)
                ($IsBox bx@@35
                        (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|)))
           a!1))
     :pattern (($IsBox bx@@35
                       (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|)))
     :skolemid |751|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@7| T@U) (|#$R@@7| T@U) (|f#0| T@U))
  (! (let ((a!1 (forall ((|x0#0| T@U))
                  (! (=> (and (= (type |x0#0|) BoxType)
                              ($IsBox |x0#0| |#$T0@@7|))
                         (|Set#Equal| (Reads1 |#$T0@@7|
                                              |#$R@@7|
                                              $OneHeap
                                              |f#0|
                                              |x0#0|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0|)
                     :no-pattern (U_2_int |x0#0|)
                     :no-pattern (U_2_bool |x0#0|)
                     :skolemid |752|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0|
                        (Tclass._System.___hPartialFunc1 |#$T0@@7| |#$R@@7|))
                   (and ($Is |f#0|
                             (Tclass._System.___hFunc1 |#$T0@@7| |#$R@@7|))
                        a!1))))
       (=> (and (= (type |#$T0@@7|) TyType)
                (= (type |#$R@@7|) TyType)
                (= (type |f#0|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0| (Tclass._System.___hPartialFunc1 |#$T0@@7| |#$R@@7|)))
     :skolemid |753|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@8| T@U) (|#$R@@8| T@U) (|f#0@@0| T@U) ($h@@7 T@U))
  (! (=> (and (= (type |#$T0@@8|) TyType)
              (= (type |#$R@@8|) TyType)
              (= (type |f#0@@0|) HandleTypeType)
              (= (type $h@@7) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@0|
                      (Tclass._System.___hPartialFunc1 |#$T0@@8| |#$R@@8|)
                      $h@@7)
            ($IsAlloc |f#0@@0|
                      (Tclass._System.___hFunc1 |#$T0@@8| |#$R@@8|)
                      $h@@7)))
     :pattern (($IsAlloc |f#0@@0|
                         (Tclass._System.___hPartialFunc1 |#$T0@@8| |#$R@@8|)
                         $h@@7))
     :skolemid |754|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@133 T@U) (arg1@@63 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1 arg0@@133 arg1@@63)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1 arg0@@133 arg1@@63))
     :qid |funType:Tclass._System.___hTotalFunc1|)))
(assert (forall ((|#$T0@@9| T@U) (|#$R@@9| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|))
                        Tagclass._System.___hTotalFunc1)
                     (= (TagFamily (Tclass._System.___hTotalFunc1
                                     |#$T0@@9|
                                     |#$R@@9|))
                        |tytagFamily$_#TotalFunc1|))))
       (=> (and (= (type |#$T0@@9|) TyType) (= (type |#$R@@9|) TyType)) a!1))
     :pattern ((Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|))
     :skolemid |755|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@134 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1_0 arg0@@134)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1_0 arg0@@134))
     :qid |funType:Tclass._System.___hTotalFunc1_0|)))
(assert (forall ((|#$T0@@10| T@U) (|#$R@@10| T@U))
  (! (=> (and (= (type |#$T0@@10|) TyType) (= (type |#$R@@10|) TyType))
         (= (Tclass._System.___hTotalFunc1_0
              (Tclass._System.___hTotalFunc1 |#$T0@@10| |#$R@@10|))
            |#$T0@@10|))
     :pattern ((Tclass._System.___hTotalFunc1 |#$T0@@10| |#$R@@10|))
     :skolemid |756|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@135 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1_1 arg0@@135)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1_1 arg0@@135))
     :qid |funType:Tclass._System.___hTotalFunc1_1|)))
(assert (forall ((|#$T0@@11| T@U) (|#$R@@11| T@U))
  (! (=> (and (= (type |#$T0@@11|) TyType) (= (type |#$R@@11|) TyType))
         (= (Tclass._System.___hTotalFunc1_1
              (Tclass._System.___hTotalFunc1 |#$T0@@11| |#$R@@11|))
            |#$R@@11|))
     :pattern ((Tclass._System.___hTotalFunc1 |#$T0@@11| |#$R@@11|))
     :skolemid |757|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@12| T@U) (|#$R@@12| T@U) (bx@@36 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@36)) bx@@36)
                     ($Is ($Unbox HandleTypeType bx@@36)
                          (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|)))))
       (=> (and (= (type |#$T0@@12|) TyType)
                (= (type |#$R@@12|) TyType)
                (= (type bx@@36) BoxType)
                ($IsBox bx@@36
                        (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|)))
           a!1))
     :pattern (($IsBox bx@@36
                       (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|)))
     :skolemid |758|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@13| T@U) (|#$R@@13| T@U) (|f#0@@1| T@U))
  (! (let ((a!1 (forall ((|x0#0@@0| T@U))
                  (! (=> (and (= (type |x0#0@@0|) BoxType)
                              ($IsBox |x0#0@@0| |#$T0@@13|))
                         (Requires1 |#$T0@@13|
                                    |#$R@@13|
                                    $OneHeap
                                    |f#0@@1|
                                    |x0#0@@0|))
                     :no-pattern (type |x0#0@@0|)
                     :no-pattern (U_2_int |x0#0@@0|)
                     :no-pattern (U_2_bool |x0#0@@0|)
                     :skolemid |759|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@1|
                        (Tclass._System.___hTotalFunc1 |#$T0@@13| |#$R@@13|))
                   (and ($Is |f#0@@1|
                             (Tclass._System.___hPartialFunc1
                               |#$T0@@13|
                               |#$R@@13|))
                        a!1))))
       (=> (and (= (type |#$T0@@13|) TyType)
                (= (type |#$R@@13|) TyType)
                (= (type |f#0@@1|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@1|
                    (Tclass._System.___hTotalFunc1 |#$T0@@13| |#$R@@13|)))
     :skolemid |760|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@14| T@U) (|#$R@@14| T@U) (|f#0@@2| T@U) ($h@@8 T@U))
  (! (=> (and (= (type |#$T0@@14|) TyType)
              (= (type |#$R@@14|) TyType)
              (= (type |f#0@@2|) HandleTypeType)
              (= (type $h@@8) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@2|
                      (Tclass._System.___hTotalFunc1 |#$T0@@14| |#$R@@14|)
                      $h@@8)
            ($IsAlloc |f#0@@2|
                      (Tclass._System.___hPartialFunc1 |#$T0@@14| |#$R@@14|)
                      $h@@8)))
     :pattern (($IsAlloc |f#0@@2|
                         (Tclass._System.___hTotalFunc1 |#$T0@@14| |#$R@@14|)
                         $h@@8))
     :skolemid |761|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@136 T@U))
  (! (= (type (Tclass._System.___hFunc0 arg0@@136)) TyType)
     :pattern ((Tclass._System.___hFunc0 arg0@@136))
     :qid |funType:Tclass._System.___hFunc0|)))
(assert (forall ((|#$R@@15| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc0 |#$R@@15|))
                        Tagclass._System.___hFunc0)
                     (= (TagFamily (Tclass._System.___hFunc0 |#$R@@15|))
                        |tytagFamily$_#Func0|))))
       (=> (= (type |#$R@@15|) TyType) a!1))
     :pattern ((Tclass._System.___hFunc0 |#$R@@15|))
     :skolemid |762|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@137 T@U))
  (! (= (type (Tclass._System.___hFunc0_0 arg0@@137)) TyType)
     :pattern ((Tclass._System.___hFunc0_0 arg0@@137))
     :qid |funType:Tclass._System.___hFunc0_0|)))
(assert (forall ((|#$R@@16| T@U))
  (! (=> (= (type |#$R@@16|) TyType)
         (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$R@@16|))
            |#$R@@16|))
     :pattern ((Tclass._System.___hFunc0 |#$R@@16|))
     :skolemid |763|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@17| T@U) (bx@@37 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37)
                     ($Is ($Unbox HandleTypeType bx@@37)
                          (Tclass._System.___hFunc0 |#$R@@17|)))))
       (=> (and (= (type |#$R@@17|) TyType)
                (= (type bx@@37) BoxType)
                ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$R@@17|)))
           a!1))
     :pattern (($IsBox bx@@37 (Tclass._System.___hFunc0 |#$R@@17|)))
     :skolemid |764|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@138 T@U) (arg1@@64 T@U) (arg2@@16 T@U))
             (! (= (type (Apply0 arg0@@138 arg1@@64 arg2@@16)) BoxType)
                :pattern ((Apply0 arg0@@138 arg1@@64 arg2@@16))
                :qid |funType:Apply0|)))
      (a!2 (forall ((arg0@@139 T@U) (arg1@@65 T@U) (arg2@@17 T@U))
             (! (= (type (Handle0 arg0@@139 arg1@@65 arg2@@17)) HandleTypeType)
                :pattern ((Handle0 arg0@@139 arg1@@65 arg2@@17))
                :qid |funType:Handle0|))))
  (and a!1 a!2)))
(assert (forall ((t0@@31 T@U) (heap@@6 T@U) (h@@27 T@U) (r@@10 T@U) (rd@@2 T@U))
  (! (let ((a!1 (and (= (type t0@@31) TyType)
                     (= (type heap@@6) (MapType0Type refType MapType1Type))
                     (= (type h@@27)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      BoxType))
                     (= (type r@@10)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      boolType))
                     (= (type rd@@2)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      (MapType0Type BoxType boolType))))))
       (=> a!1
           (= (Apply0 t0@@31 heap@@6 (Handle0 h@@27 r@@10 rd@@2))
              (MapType0Select h@@27 heap@@6))))
     :pattern ((Apply0 t0@@31 heap@@6 (Handle0 h@@27 r@@10 rd@@2)))
     :skolemid |765|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@32 T@U) (heap@@7 T@U) (h@@28 T@U) (r@@11 T@U) (rd@@3 T@U))
  (! (let ((a!1 (and (= (type t0@@32) TyType)
                     (= (type heap@@7) (MapType0Type refType MapType1Type))
                     (= (type h@@28)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      BoxType))
                     (= (type r@@11)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      boolType))
                     (= (type rd@@3)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      (MapType0Type BoxType boolType)))
                     (U_2_bool (MapType0Select r@@11 heap@@7)))))
       (=> a!1 (Requires0 t0@@32 heap@@7 (Handle0 h@@28 r@@11 rd@@3))))
     :pattern ((Requires0 t0@@32 heap@@7 (Handle0 h@@28 r@@11 rd@@3)))
     :skolemid |766|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@140 T@U) (arg1@@66 T@U) (arg2@@18 T@U))
  (! (= (type (Reads0 arg0@@140 arg1@@66 arg2@@18))
        (MapType0Type BoxType boolType))
     :pattern ((Reads0 arg0@@140 arg1@@66 arg2@@18))
     :qid |funType:Reads0|)))
(assert (forall ((t0@@33 T@U)
         (heap@@8 T@U)
         (h@@29 T@U)
         (r@@12 T@U)
         (rd@@4 T@U)
         (bx@@38 T@U))
  (! (let ((a!1 (and (= (type t0@@33) TyType)
                     (= (type heap@@8) (MapType0Type refType MapType1Type))
                     (= (type h@@29)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      BoxType))
                     (= (type r@@12)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      boolType))
                     (= (type rd@@4)
                        (MapType0Type (MapType0Type refType MapType1Type)
                                      (MapType0Type BoxType boolType)))
                     (= (type bx@@38) BoxType)))
           (a!2 (U_2_bool (MapType0Select (Reads0 t0@@33
                                                  heap@@8
                                                  (Handle0 h@@29 r@@12 rd@@4))
                                          bx@@38))))
     (let ((a!3 (= a!2
                   (U_2_bool (MapType0Select (MapType0Select rd@@4 heap@@8)
                                             bx@@38)))))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (Reads0 t0@@33
                                       heap@@8
                                       (Handle0 h@@29 r@@12 rd@@4))
                               bx@@38))
     :skolemid |767|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@34 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@17 T@U))
  (! (let ((a!1 (forall ((o@@50 T@U) (fld@@5 T@U))
                  (! (let ((a!1 (= (type fld@@5)
                                   (FieldType (FieldTypeInv0 (type fld@@5))))))
                     (let ((a!2 (and (= (type o@@50) refType)
                                     a!1
                                     (not (= o@@50 null))
                                     (U_2_bool (MapType0Select (Reads0 t0@@34
                                                                       h0@@6
                                                                       f@@17)
                                                               ($Box o@@50))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@6 o@@50)
                                              fld@@5)
                              (MapType1Select (MapType0Select h1@@6 o@@50)
                                              fld@@5)))))
                     :no-pattern (type o@@50)
                     :no-pattern (type fld@@5)
                     :no-pattern (U_2_int o@@50)
                     :no-pattern (U_2_bool o@@50)
                     :no-pattern (U_2_int fld@@5)
                     :no-pattern (U_2_bool fld@@5)
                     :skolemid |768|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@34) TyType)
                (= (type h0@@6) (MapType0Type refType MapType1Type))
                (= (type h1@@6) (MapType0Type refType MapType1Type))
                (= (type f@@17) HandleTypeType)
                ($HeapSucc h0@@6 h1@@6)
                ($IsGoodHeap h0@@6)
                ($IsGoodHeap h1@@6)
                ($Is f@@17 (Tclass._System.___hFunc0 t0@@34))
                a!1)
           (= (Reads0 t0@@34 h0@@6 f@@17) (Reads0 t0@@34 h1@@6 f@@17))))
     :pattern (($HeapSucc h0@@6 h1@@6) (Reads0 t0@@34 h1@@6 f@@17))
     :skolemid |769|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@35 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@18 T@U))
  (! (let ((a!1 (forall ((o@@51 T@U) (fld@@6 T@U))
                  (! (let ((a!1 (= (type fld@@6)
                                   (FieldType (FieldTypeInv0 (type fld@@6))))))
                     (let ((a!2 (and (= (type o@@51) refType)
                                     a!1
                                     (not (= o@@51 null))
                                     (U_2_bool (MapType0Select (Reads0 t0@@35
                                                                       h1@@7
                                                                       f@@18)
                                                               ($Box o@@51))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@7 o@@51)
                                              fld@@6)
                              (MapType1Select (MapType0Select h1@@7 o@@51)
                                              fld@@6)))))
                     :no-pattern (type o@@51)
                     :no-pattern (type fld@@6)
                     :no-pattern (U_2_int o@@51)
                     :no-pattern (U_2_bool o@@51)
                     :no-pattern (U_2_int fld@@6)
                     :no-pattern (U_2_bool fld@@6)
                     :skolemid |770|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@35) TyType)
                (= (type h0@@7) (MapType0Type refType MapType1Type))
                (= (type h1@@7) (MapType0Type refType MapType1Type))
                (= (type f@@18) HandleTypeType)
                ($HeapSucc h0@@7 h1@@7)
                ($IsGoodHeap h0@@7)
                ($IsGoodHeap h1@@7)
                ($Is f@@18 (Tclass._System.___hFunc0 t0@@35))
                a!1)
           (= (Reads0 t0@@35 h0@@7 f@@18) (Reads0 t0@@35 h1@@7 f@@18))))
     :pattern (($HeapSucc h0@@7 h1@@7) (Reads0 t0@@35 h1@@7 f@@18))
     :skolemid |771|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@36 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@19 T@U))
  (! (let ((a!1 (forall ((o@@52 T@U) (fld@@7 T@U))
                  (! (let ((a!1 (= (type fld@@7)
                                   (FieldType (FieldTypeInv0 (type fld@@7))))))
                     (let ((a!2 (and (= (type o@@52) refType)
                                     a!1
                                     (not (= o@@52 null))
                                     (U_2_bool (MapType0Select (Reads0 t0@@36
                                                                       h0@@8
                                                                       f@@19)
                                                               ($Box o@@52))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@8 o@@52)
                                              fld@@7)
                              (MapType1Select (MapType0Select h1@@8 o@@52)
                                              fld@@7)))))
                     :no-pattern (type o@@52)
                     :no-pattern (type fld@@7)
                     :no-pattern (U_2_int o@@52)
                     :no-pattern (U_2_bool o@@52)
                     :no-pattern (U_2_int fld@@7)
                     :no-pattern (U_2_bool fld@@7)
                     :skolemid |772|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@36) TyType)
                (= (type h0@@8) (MapType0Type refType MapType1Type))
                (= (type h1@@8) (MapType0Type refType MapType1Type))
                (= (type f@@19) HandleTypeType)
                ($HeapSucc h0@@8 h1@@8)
                ($IsGoodHeap h0@@8)
                ($IsGoodHeap h1@@8)
                ($Is f@@19 (Tclass._System.___hFunc0 t0@@36))
                a!1)
           (= (Requires0 t0@@36 h0@@8 f@@19) (Requires0 t0@@36 h1@@8 f@@19))))
     :pattern (($HeapSucc h0@@8 h1@@8) (Requires0 t0@@36 h1@@8 f@@19))
     :skolemid |773|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@37 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@20 T@U))
  (! (let ((a!1 (forall ((o@@53 T@U) (fld@@8 T@U))
                  (! (let ((a!1 (= (type fld@@8)
                                   (FieldType (FieldTypeInv0 (type fld@@8))))))
                     (let ((a!2 (and (= (type o@@53) refType)
                                     a!1
                                     (not (= o@@53 null))
                                     (U_2_bool (MapType0Select (Reads0 t0@@37
                                                                       h1@@9
                                                                       f@@20)
                                                               ($Box o@@53))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@9 o@@53)
                                              fld@@8)
                              (MapType1Select (MapType0Select h1@@9 o@@53)
                                              fld@@8)))))
                     :no-pattern (type o@@53)
                     :no-pattern (type fld@@8)
                     :no-pattern (U_2_int o@@53)
                     :no-pattern (U_2_bool o@@53)
                     :no-pattern (U_2_int fld@@8)
                     :no-pattern (U_2_bool fld@@8)
                     :skolemid |774|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@37) TyType)
                (= (type h0@@9) (MapType0Type refType MapType1Type))
                (= (type h1@@9) (MapType0Type refType MapType1Type))
                (= (type f@@20) HandleTypeType)
                ($HeapSucc h0@@9 h1@@9)
                ($IsGoodHeap h0@@9)
                ($IsGoodHeap h1@@9)
                ($Is f@@20 (Tclass._System.___hFunc0 t0@@37))
                a!1)
           (= (Requires0 t0@@37 h0@@9 f@@20) (Requires0 t0@@37 h1@@9 f@@20))))
     :pattern (($HeapSucc h0@@9 h1@@9) (Requires0 t0@@37 h1@@9 f@@20))
     :skolemid |775|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@38 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@21 T@U))
  (! (let ((a!1 (forall ((o@@54 T@U) (fld@@9 T@U))
                  (! (let ((a!1 (= (type fld@@9)
                                   (FieldType (FieldTypeInv0 (type fld@@9))))))
                     (let ((a!2 (and (= (type o@@54) refType)
                                     a!1
                                     (not (= o@@54 null))
                                     (U_2_bool (MapType0Select (Reads0 t0@@38
                                                                       h0@@10
                                                                       f@@21)
                                                               ($Box o@@54))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@10 o@@54)
                                              fld@@9)
                              (MapType1Select (MapType0Select h1@@10 o@@54)
                                              fld@@9)))))
                     :no-pattern (type o@@54)
                     :no-pattern (type fld@@9)
                     :no-pattern (U_2_int o@@54)
                     :no-pattern (U_2_bool o@@54)
                     :no-pattern (U_2_int fld@@9)
                     :no-pattern (U_2_bool fld@@9)
                     :skolemid |776|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@38) TyType)
                (= (type h0@@10) (MapType0Type refType MapType1Type))
                (= (type h1@@10) (MapType0Type refType MapType1Type))
                (= (type f@@21) HandleTypeType)
                ($HeapSucc h0@@10 h1@@10)
                ($IsGoodHeap h0@@10)
                ($IsGoodHeap h1@@10)
                ($Is f@@21 (Tclass._System.___hFunc0 t0@@38))
                a!1)
           (= (Apply0 t0@@38 h0@@10 f@@21) (Apply0 t0@@38 h1@@10 f@@21))))
     :pattern (($HeapSucc h0@@10 h1@@10) (Apply0 t0@@38 h1@@10 f@@21))
     :skolemid |777|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@39 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@22 T@U))
  (! (let ((a!1 (forall ((o@@55 T@U) (fld@@10 T@U))
                  (! (let ((a!1 (= (type fld@@10)
                                   (FieldType (FieldTypeInv0 (type fld@@10))))))
                     (let ((a!2 (and (= (type o@@55) refType)
                                     a!1
                                     (not (= o@@55 null))
                                     (U_2_bool (MapType0Select (Reads0 t0@@39
                                                                       h1@@11
                                                                       f@@22)
                                                               ($Box o@@55))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@11 o@@55)
                                              fld@@10)
                              (MapType1Select (MapType0Select h1@@11 o@@55)
                                              fld@@10)))))
                     :no-pattern (type o@@55)
                     :no-pattern (type fld@@10)
                     :no-pattern (U_2_int o@@55)
                     :no-pattern (U_2_bool o@@55)
                     :no-pattern (U_2_int fld@@10)
                     :no-pattern (U_2_bool fld@@10)
                     :skolemid |778|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@39) TyType)
                (= (type h0@@11) (MapType0Type refType MapType1Type))
                (= (type h1@@11) (MapType0Type refType MapType1Type))
                (= (type f@@22) HandleTypeType)
                ($HeapSucc h0@@11 h1@@11)
                ($IsGoodHeap h0@@11)
                ($IsGoodHeap h1@@11)
                ($Is f@@22 (Tclass._System.___hFunc0 t0@@39))
                a!1)
           (= (Apply0 t0@@39 h0@@11 f@@22) (Apply0 t0@@39 h1@@11 f@@22))))
     :pattern (($HeapSucc h0@@11 h1@@11) (Apply0 t0@@39 h1@@11 f@@22))
     :skolemid |779|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@40 T@U) (heap@@9 T@U) (f@@23 T@U))
  (! (=> (and (= (type t0@@40) TyType)
              (= (type heap@@9) (MapType0Type refType MapType1Type))
              (= (type f@@23) HandleTypeType)
              ($IsGoodHeap heap@@9)
              ($Is f@@23 (Tclass._System.___hFunc0 t0@@40)))
         (= (|Set#Equal| (Reads0 t0@@40 $OneHeap f@@23) (|Set#Empty| BoxType))
            (|Set#Equal| (Reads0 t0@@40 heap@@9 f@@23) (|Set#Empty| BoxType))))
     :pattern ((Reads0 t0@@40 $OneHeap f@@23) ($IsGoodHeap heap@@9))
     :pattern ((Reads0 t0@@40 heap@@9 f@@23))
     :skolemid |780|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@41 T@U) (heap@@10 T@U) (f@@24 T@U))
  (! (=> (and (= (type t0@@41) TyType)
              (= (type heap@@10) (MapType0Type refType MapType1Type))
              (= (type f@@24) HandleTypeType)
              ($IsGoodHeap heap@@10)
              ($Is f@@24 (Tclass._System.___hFunc0 t0@@41))
              (|Set#Equal| (Reads0 t0@@41 $OneHeap f@@24) (|Set#Empty| BoxType)))
         (= (Requires0 t0@@41 $OneHeap f@@24) (Requires0 t0@@41 heap@@10 f@@24)))
     :pattern ((Requires0 t0@@41 $OneHeap f@@24) ($IsGoodHeap heap@@10))
     :pattern ((Requires0 t0@@41 heap@@10 f@@24))
     :skolemid |781|
     :qid |unknown.0:0|)))
(assert (forall ((f@@25 T@U) (t0@@42 T@U))
  (! (let ((a!1 (forall ((h@@30 T@U))
                  (! (=> (= (type h@@30) (MapType0Type refType MapType1Type))
                         (=> (and ($IsGoodHeap h@@30)
                                  (Requires0 t0@@42 h@@30 f@@25))
                             ($IsBox (Apply0 t0@@42 h@@30 f@@25) t0@@42)))
                     :pattern ((Apply0 t0@@42 h@@30 f@@25))
                     :skolemid |782|
                     :qid |DafnyPreludebpl.545:12|))))
       (=> (and (= (type f@@25) HandleTypeType) (= (type t0@@42) TyType))
           (= ($Is f@@25 (Tclass._System.___hFunc0 t0@@42)) a!1)))
     :pattern (($Is f@@25 (Tclass._System.___hFunc0 t0@@42)))
     :skolemid |783|
     :qid |unknown.0:0|)))
(assert (forall ((f@@26 T@U) (t0@@43 T@U) (u0@@0 T@U))
  (! (let ((a!1 (forall ((bx@@39 T@U))
                  (! (=> (and (= (type bx@@39) BoxType) ($IsBox bx@@39 t0@@43))
                         ($IsBox bx@@39 u0@@0))
                     :pattern (($IsBox bx@@39 t0@@43))
                     :pattern (($IsBox bx@@39 u0@@0))
                     :skolemid |784|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@26) HandleTypeType)
                (= (type t0@@43) TyType)
                (= (type u0@@0) TyType)
                ($Is f@@26 (Tclass._System.___hFunc0 t0@@43))
                a!1)
           ($Is f@@26 (Tclass._System.___hFunc0 u0@@0))))
     :pattern (($Is f@@26 (Tclass._System.___hFunc0 t0@@43))
               ($Is f@@26 (Tclass._System.___hFunc0 u0@@0)))
     :skolemid |785|
     :qid |unknown.0:0|)))
(assert (forall ((f@@27 T@U) (t0@@44 T@U) (h@@31 T@U))
  (! (let ((a!1 (forall ((r@@13 T@U))
                  (! (let ((a!1 (and (not (= r@@13 null))
                                     (U_2_bool (MapType0Select (Reads0 t0@@44
                                                                       h@@31
                                                                       f@@27)
                                                               ($Box r@@13))))))
                     (let ((a!2 (=> a!1
                                    (U_2_bool (MapType1Select (MapType0Select h@@31
                                                                              r@@13)
                                                              alloc)))))
                       (=> (= (type r@@13) refType) a!2)))
                     :pattern ((MapType0Select (Reads0 t0@@44 h@@31 f@@27)
                                               ($Box r@@13)))
                     :skolemid |786|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@27) HandleTypeType)
                (= (type t0@@44) TyType)
                (= (type h@@31) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@31))
           (= ($IsAlloc f@@27 (Tclass._System.___hFunc0 t0@@44) h@@31)
              (=> (Requires0 t0@@44 h@@31 f@@27) a!1))))
     :pattern (($IsAlloc f@@27 (Tclass._System.___hFunc0 t0@@44) h@@31))
     :skolemid |787|
     :qid |unknown.0:0|)))
(assert (forall ((f@@28 T@U) (t0@@45 T@U) (h@@32 T@U))
  (! (=> (and (= (type f@@28) HandleTypeType)
              (= (type t0@@45) TyType)
              (= (type h@@32) (MapType0Type refType MapType1Type))
              ($IsGoodHeap h@@32)
              ($IsAlloc f@@28 (Tclass._System.___hFunc0 t0@@45) h@@32)
              (Requires0 t0@@45 h@@32 f@@28))
         ($IsAllocBox (Apply0 t0@@45 h@@32 f@@28) t0@@45 h@@32))
     :pattern (($IsAlloc f@@28 (Tclass._System.___hFunc0 t0@@45) h@@32))
     :skolemid |788|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@141 T@U))
  (! (= (type (Tclass._System.___hPartialFunc0 arg0@@141)) TyType)
     :pattern ((Tclass._System.___hPartialFunc0 arg0@@141))
     :qid |funType:Tclass._System.___hPartialFunc0|)))
(assert (forall ((|#$R@@18| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc0 |#$R@@18|))
                        Tagclass._System.___hPartialFunc0)
                     (= (TagFamily (Tclass._System.___hPartialFunc0 |#$R@@18|))
                        |tytagFamily$_#PartialFunc0|))))
       (=> (= (type |#$R@@18|) TyType) a!1))
     :pattern ((Tclass._System.___hPartialFunc0 |#$R@@18|))
     :skolemid |789|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@142 T@U))
  (! (= (type (Tclass._System.___hPartialFunc0_0 arg0@@142)) TyType)
     :pattern ((Tclass._System.___hPartialFunc0_0 arg0@@142))
     :qid |funType:Tclass._System.___hPartialFunc0_0|)))
(assert (forall ((|#$R@@19| T@U))
  (! (=> (= (type |#$R@@19|) TyType)
         (= (Tclass._System.___hPartialFunc0_0
              (Tclass._System.___hPartialFunc0 |#$R@@19|))
            |#$R@@19|))
     :pattern ((Tclass._System.___hPartialFunc0 |#$R@@19|))
     :skolemid |790|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@20| T@U) (bx@@40 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@40)) bx@@40)
                     ($Is ($Unbox HandleTypeType bx@@40)
                          (Tclass._System.___hPartialFunc0 |#$R@@20|)))))
       (=> (and (= (type |#$R@@20|) TyType)
                (= (type bx@@40) BoxType)
                ($IsBox bx@@40 (Tclass._System.___hPartialFunc0 |#$R@@20|)))
           a!1))
     :pattern (($IsBox bx@@40 (Tclass._System.___hPartialFunc0 |#$R@@20|)))
     :skolemid |791|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@21| T@U) (|f#0@@3| T@U))
  (! (let ((a!1 (= ($Is |f#0@@3| (Tclass._System.___hPartialFunc0 |#$R@@21|))
                   (and ($Is |f#0@@3| (Tclass._System.___hFunc0 |#$R@@21|))
                        (|Set#Equal| (Reads0 |#$R@@21| $OneHeap |f#0@@3|)
                                     (|Set#Empty| BoxType))))))
       (=> (and (= (type |#$R@@21|) TyType) (= (type |f#0@@3|) HandleTypeType))
           a!1))
     :pattern (($Is |f#0@@3| (Tclass._System.___hPartialFunc0 |#$R@@21|)))
     :skolemid |792|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@22| T@U) (|f#0@@4| T@U) ($h@@9 T@U))
  (! (=> (and (= (type |#$R@@22|) TyType)
              (= (type |f#0@@4|) HandleTypeType)
              (= (type $h@@9) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@4|
                      (Tclass._System.___hPartialFunc0 |#$R@@22|)
                      $h@@9)
            ($IsAlloc |f#0@@4| (Tclass._System.___hFunc0 |#$R@@22|) $h@@9)))
     :pattern (($IsAlloc |f#0@@4|
                         (Tclass._System.___hPartialFunc0 |#$R@@22|)
                         $h@@9))
     :skolemid |793|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@143 T@U))
  (! (= (type (Tclass._System.___hTotalFunc0 arg0@@143)) TyType)
     :pattern ((Tclass._System.___hTotalFunc0 arg0@@143))
     :qid |funType:Tclass._System.___hTotalFunc0|)))
(assert (forall ((|#$R@@23| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc0 |#$R@@23|))
                        Tagclass._System.___hTotalFunc0)
                     (= (TagFamily (Tclass._System.___hTotalFunc0 |#$R@@23|))
                        |tytagFamily$_#TotalFunc0|))))
       (=> (= (type |#$R@@23|) TyType) a!1))
     :pattern ((Tclass._System.___hTotalFunc0 |#$R@@23|))
     :skolemid |794|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@144 T@U))
  (! (= (type (Tclass._System.___hTotalFunc0_0 arg0@@144)) TyType)
     :pattern ((Tclass._System.___hTotalFunc0_0 arg0@@144))
     :qid |funType:Tclass._System.___hTotalFunc0_0|)))
(assert (forall ((|#$R@@24| T@U))
  (! (=> (= (type |#$R@@24|) TyType)
         (= (Tclass._System.___hTotalFunc0_0
              (Tclass._System.___hTotalFunc0 |#$R@@24|))
            |#$R@@24|))
     :pattern ((Tclass._System.___hTotalFunc0 |#$R@@24|))
     :skolemid |795|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@25| T@U) (bx@@41 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@41)) bx@@41)
                     ($Is ($Unbox HandleTypeType bx@@41)
                          (Tclass._System.___hTotalFunc0 |#$R@@25|)))))
       (=> (and (= (type |#$R@@25|) TyType)
                (= (type bx@@41) BoxType)
                ($IsBox bx@@41 (Tclass._System.___hTotalFunc0 |#$R@@25|)))
           a!1))
     :pattern (($IsBox bx@@41 (Tclass._System.___hTotalFunc0 |#$R@@25|)))
     :skolemid |796|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@26| T@U) (|f#0@@5| T@U))
  (! (let ((a!1 (= ($Is |f#0@@5| (Tclass._System.___hTotalFunc0 |#$R@@26|))
                   (and ($Is |f#0@@5|
                             (Tclass._System.___hPartialFunc0 |#$R@@26|))
                        (Requires0 |#$R@@26| $OneHeap |f#0@@5|)))))
       (=> (and (= (type |#$R@@26|) TyType) (= (type |f#0@@5|) HandleTypeType))
           a!1))
     :pattern (($Is |f#0@@5| (Tclass._System.___hTotalFunc0 |#$R@@26|)))
     :skolemid |797|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@27| T@U) (|f#0@@6| T@U) ($h@@10 T@U))
  (! (=> (and (= (type |#$R@@27|) TyType)
              (= (type |f#0@@6|) HandleTypeType)
              (= (type $h@@10) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@6| (Tclass._System.___hTotalFunc0 |#$R@@27|) $h@@10)
            ($IsAlloc |f#0@@6|
                      (Tclass._System.___hPartialFunc0 |#$R@@27|)
                      $h@@10)))
     :pattern (($IsAlloc |f#0@@6|
                         (Tclass._System.___hTotalFunc0 |#$R@@27|)
                         $h@@10))
     :skolemid |798|
     :qid |unknown.0:0|)))
(assert (= (type Tclass._System.__default) TyType))
(assert (= (Tag Tclass._System.__default) Tagclass._System.__default))
(assert (= (TagFamily Tclass._System.__default) tytagFamily$_default))
(assert (forall ((bx@@42 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@42)) bx@@42)
                     ($Is ($Unbox refType bx@@42) Tclass._System.__default))))
       (=> (and (= (type bx@@42) BoxType)
                ($IsBox bx@@42 Tclass._System.__default))
           a!1))
     :pattern (($IsBox bx@@42 Tclass._System.__default))
     :skolemid |799|
     :qid |unknown.0:0|)))
(assert (forall (($o@@7 T@U))
  (! (let ((a!1 (= ($Is $o@@7 Tclass._System.__default)
                   (or (= $o@@7 null)
                       (= (dtype $o@@7) Tclass._System.__default)))))
       (=> (= (type $o@@7) refType) a!1))
     :pattern (($Is $o@@7 Tclass._System.__default))
     :skolemid |800|
     :qid |unknown.0:0|)))
(assert (forall (($o@@8 T@U) ($h@@11 T@U))
  (! (let ((a!1 (or (= $o@@8 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@11 $o@@8)
                                              alloc)))))
       (=> (and (= (type $o@@8) refType)
                (= (type $h@@11) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@8 Tclass._System.__default $h@@11) a!1)))
     :pattern (($IsAlloc $o@@8 Tclass._System.__default $h@@11))
     :skolemid |801|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((|#$A| T@U) (|#$B| T@U) (|a#0| T@U) (|b#0| T@U))
      (! (let ((a!1 (and (= (type |#$A|) TyType)
                         (= (type |#$B|) TyType)
                         (= (type |a#0|) BoxType)
                         (= (type |b#0|) BoxType)
                         (or (|_System.__default.rank__is__less__than#canCall|
                               |#$A|
                               |#$B|
                               |a#0|
                               |b#0|)
                             (and ($IsBox |a#0| |#$A|) ($IsBox |b#0| |#$B|))))))
           (=> a!1 true))
         :pattern ((_System.__default.rank__is__less__than
                     |#$A|
                     |#$B|
                     |a#0|
                     |b#0|))
         :skolemid |802|
         :qid |unknown.0:0|))))
(assert (forall ((|#$A@@0| T@U) (|#$B@@0| T@U) (|a#0@@0| T@U) (|b#0@@0| T@U))
  (! (=> (and (= (type |#$A@@0|) TyType)
              (= (type |#$B@@0|) TyType)
              (= (type |a#0@@0|) BoxType)
              (= (type |b#0@@0|) BoxType)
              ($IsBox |a#0@@0| |#$A@@0|)
              ($IsBox |b#0@@0| |#$B@@0|))
         (= (|_System.__default.rank__is__less__than#requires|
              |#$A@@0|
              |#$B@@0|
              |a#0@@0|
              |b#0@@0|)
            true))
     :pattern ((|_System.__default.rank__is__less__than#requires|
                 |#$A@@0|
                 |#$B@@0|
                 |a#0@@0|
                 |b#0@@0|))
     :skolemid |803|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@145 T@U) (arg1@@67 T@U) (arg2@@19 T@U))
  (! (= (type (Tclass._System.___hFunc2 arg0@@145 arg1@@67 arg2@@19)) TyType)
     :pattern ((Tclass._System.___hFunc2 arg0@@145 arg1@@67 arg2@@19))
     :qid |funType:Tclass._System.___hFunc2|)))
(assert (forall ((|#$T0@@15| T@U) (|#$T1| T@U) (|#$R@@28| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc2
                               |#$T0@@15|
                               |#$T1|
                               |#$R@@28|))
                        Tagclass._System.___hFunc2)
                     (= (TagFamily (Tclass._System.___hFunc2
                                     |#$T0@@15|
                                     |#$T1|
                                     |#$R@@28|))
                        |tytagFamily$_#Func2|))))
       (=> (and (= (type |#$T0@@15|) TyType)
                (= (type |#$T1|) TyType)
                (= (type |#$R@@28|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc2 |#$T0@@15| |#$T1| |#$R@@28|))
     :skolemid |804|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@146 T@U))
  (! (= (type (Tclass._System.___hFunc2_0 arg0@@146)) TyType)
     :pattern ((Tclass._System.___hFunc2_0 arg0@@146))
     :qid |funType:Tclass._System.___hFunc2_0|)))
(assert (forall ((|#$T0@@16| T@U) (|#$T1@@0| T@U) (|#$R@@29| T@U))
  (! (=> (and (= (type |#$T0@@16|) TyType)
              (= (type |#$T1@@0|) TyType)
              (= (type |#$R@@29|) TyType))
         (= (Tclass._System.___hFunc2_0
              (Tclass._System.___hFunc2 |#$T0@@16| |#$T1@@0| |#$R@@29|))
            |#$T0@@16|))
     :pattern ((Tclass._System.___hFunc2 |#$T0@@16| |#$T1@@0| |#$R@@29|))
     :skolemid |805|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@147 T@U))
  (! (= (type (Tclass._System.___hFunc2_1 arg0@@147)) TyType)
     :pattern ((Tclass._System.___hFunc2_1 arg0@@147))
     :qid |funType:Tclass._System.___hFunc2_1|)))
(assert (forall ((|#$T0@@17| T@U) (|#$T1@@1| T@U) (|#$R@@30| T@U))
  (! (=> (and (= (type |#$T0@@17|) TyType)
              (= (type |#$T1@@1|) TyType)
              (= (type |#$R@@30|) TyType))
         (= (Tclass._System.___hFunc2_1
              (Tclass._System.___hFunc2 |#$T0@@17| |#$T1@@1| |#$R@@30|))
            |#$T1@@1|))
     :pattern ((Tclass._System.___hFunc2 |#$T0@@17| |#$T1@@1| |#$R@@30|))
     :skolemid |806|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@148 T@U))
  (! (= (type (Tclass._System.___hFunc2_2 arg0@@148)) TyType)
     :pattern ((Tclass._System.___hFunc2_2 arg0@@148))
     :qid |funType:Tclass._System.___hFunc2_2|)))
(assert (forall ((|#$T0@@18| T@U) (|#$T1@@2| T@U) (|#$R@@31| T@U))
  (! (=> (and (= (type |#$T0@@18|) TyType)
              (= (type |#$T1@@2|) TyType)
              (= (type |#$R@@31|) TyType))
         (= (Tclass._System.___hFunc2_2
              (Tclass._System.___hFunc2 |#$T0@@18| |#$T1@@2| |#$R@@31|))
            |#$R@@31|))
     :pattern ((Tclass._System.___hFunc2 |#$T0@@18| |#$T1@@2| |#$R@@31|))
     :skolemid |807|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@19| T@U) (|#$T1@@3| T@U) (|#$R@@32| T@U) (bx@@43 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@43)) bx@@43)
                     ($Is ($Unbox HandleTypeType bx@@43)
                          (Tclass._System.___hFunc2
                            |#$T0@@19|
                            |#$T1@@3|
                            |#$R@@32|)))))
       (=> (and (= (type |#$T0@@19|) TyType)
                (= (type |#$T1@@3|) TyType)
                (= (type |#$R@@32|) TyType)
                (= (type bx@@43) BoxType)
                ($IsBox bx@@43
                        (Tclass._System.___hFunc2
                          |#$T0@@19|
                          |#$T1@@3|
                          |#$R@@32|)))
           a!1))
     :pattern (($IsBox bx@@43
                       (Tclass._System.___hFunc2 |#$T0@@19| |#$T1@@3| |#$R@@32|)))
     :skolemid |808|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@149 T@T) (arg1@@68 T@T) (arg2@@20 T@T) (arg3@@3 T@T))
             (! (= (Ctor (MapType3Type arg0@@149 arg1@@68 arg2@@20 arg3@@3)) 25)
                :qid |ctor:MapType3Type|)))
      (a!2 (forall ((arg0@@150 T@T) (arg1@@69 T@T) (arg2@@21 T@T) (arg3@@4 T@T))
             (! (= (MapType3TypeInv0 (MapType3Type arg0@@150
                                                   arg1@@69
                                                   arg2@@21
                                                   arg3@@4))
                   arg0@@150)
                :pattern ((MapType3Type arg0@@150 arg1@@69 arg2@@21 arg3@@4))
                :qid |typeInv:MapType3TypeInv0|)))
      (a!3 (forall ((arg0@@151 T@T) (arg1@@70 T@T) (arg2@@22 T@T) (arg3@@5 T@T))
             (! (= (MapType3TypeInv1 (MapType3Type arg0@@151
                                                   arg1@@70
                                                   arg2@@22
                                                   arg3@@5))
                   arg1@@70)
                :pattern ((MapType3Type arg0@@151 arg1@@70 arg2@@22 arg3@@5))
                :qid |typeInv:MapType3TypeInv1|)))
      (a!4 (forall ((arg0@@152 T@T) (arg1@@71 T@T) (arg2@@23 T@T) (arg3@@6 T@T))
             (! (= (MapType3TypeInv2 (MapType3Type arg0@@152
                                                   arg1@@71
                                                   arg2@@23
                                                   arg3@@6))
                   arg2@@23)
                :pattern ((MapType3Type arg0@@152 arg1@@71 arg2@@23 arg3@@6))
                :qid |typeInv:MapType3TypeInv2|)))
      (a!5 (forall ((arg0@@153 T@T) (arg1@@72 T@T) (arg2@@24 T@T) (arg3@@7 T@T))
             (! (= (MapType3TypeInv3 (MapType3Type arg0@@153
                                                   arg1@@72
                                                   arg2@@24
                                                   arg3@@7))
                   arg3@@7)
                :pattern ((MapType3Type arg0@@153 arg1@@72 arg2@@24 arg3@@7))
                :qid |typeInv:MapType3TypeInv3|)))
      (a!6 (forall ((arg0@@154 T@U) (arg1@@73 T@U) (arg2@@25 T@U) (arg3@@8 T@U))
             (! (= (type (MapType3Select arg0@@154 arg1@@73 arg2@@25 arg3@@8))
                   (MapType3TypeInv3 (type arg0@@154)))
                :pattern ((MapType3Select arg0@@154 arg1@@73 arg2@@25 arg3@@8))
                :qid |funType:MapType3Select|)))
      (a!7 (forall ((arg0@@155 T@U)
                    (arg1@@74 T@U)
                    (arg2@@26 T@U)
                    (arg3@@9 T@U)
                    (arg4@@1 T@U))
             (! (= (type (MapType3Store arg0@@155
                                        arg1@@74
                                        arg2@@26
                                        arg3@@9
                                        arg4@@1))
                   (MapType3Type (type arg1@@74)
                                 (type arg2@@26)
                                 (type arg3@@9)
                                 (type arg4@@1)))
                :pattern ((MapType3Store arg0@@155
                                         arg1@@74
                                         arg2@@26
                                         arg3@@9
                                         arg4@@1))
                :qid |funType:MapType3Store|)))
      (a!8 (forall ((m@@49 T@U) (x0@@9 T@U) (x1@@3 T@U) (x2 T@U) (val@@10 T@U))
             (! (=> (= (type val@@10) (MapType3TypeInv3 (type m@@49)))
                    (= (MapType3Select (MapType3Store m@@49
                                                      x0@@9
                                                      x1@@3
                                                      x2
                                                      val@@10)
                                       x0@@9
                                       x1@@3
                                       x2)
                       val@@10))
                :weight 0
                :qid |mapAx0:MapType3Select|)))
      (a!9 (forall ((arg0@@156 T@U)
                    (arg1@@75 T@U)
                    (arg2@@27 T@U)
                    (arg3@@10 T@U)
                    (arg4@@2 T@U)
                    (arg5 T@U)
                    (arg6 T@U))
             (! (= (type (Apply2 arg0@@156
                                 arg1@@75
                                 arg2@@27
                                 arg3@@10
                                 arg4@@2
                                 arg5
                                 arg6))
                   BoxType)
                :pattern ((Apply2 arg0@@156
                                  arg1@@75
                                  arg2@@27
                                  arg3@@10
                                  arg4@@2
                                  arg5
                                  arg6))
                :qid |funType:Apply2|)))
      (a!10 (forall ((arg0@@157 T@U) (arg1@@76 T@U) (arg2@@28 T@U))
              (! (= (type (Handle2 arg0@@157 arg1@@76 arg2@@28)) HandleTypeType)
                 :pattern ((Handle2 arg0@@157 arg1@@76 arg2@@28))
                 :qid |funType:Handle2|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((val@@11 T@U)
                (m@@50 T@U)
                (x0@@10 T@U)
                (x1@@4 T@U)
                (x2@@0 T@U)
                (y0@@6 T@U)
                (y1@@2 T@U)
                (y2 T@U))
         (! (let ((a!1 (= (MapType3Select (MapType3Store m@@50
                                                         x0@@10
                                                         x1@@4
                                                         x2@@0
                                                         val@@11)
                                          y0@@6
                                          y1@@2
                                          y2)
                          (MapType3Select m@@50 y0@@6 y1@@2 y2))))
              (or (= x0@@10 y0@@6) a!1))
            :weight 0
            :qid |mapAx1:MapType3Select:0|))
       (forall ((val@@12 T@U)
                (m@@51 T@U)
                (x0@@11 T@U)
                (x1@@5 T@U)
                (x2@@1 T@U)
                (y0@@7 T@U)
                (y1@@3 T@U)
                (y2@@0 T@U))
         (! (let ((a!1 (= (MapType3Select (MapType3Store m@@51
                                                         x0@@11
                                                         x1@@5
                                                         x2@@1
                                                         val@@12)
                                          y0@@7
                                          y1@@3
                                          y2@@0)
                          (MapType3Select m@@51 y0@@7 y1@@3 y2@@0))))
              (or (= x1@@5 y1@@3) a!1))
            :weight 0
            :qid |mapAx1:MapType3Select:1|))
       (forall ((val@@13 T@U)
                (m@@52 T@U)
                (x0@@12 T@U)
                (x1@@6 T@U)
                (x2@@2 T@U)
                (y0@@8 T@U)
                (y1@@4 T@U)
                (y2@@1 T@U))
         (! (let ((a!1 (= (MapType3Select (MapType3Store m@@52
                                                         x0@@12
                                                         x1@@6
                                                         x2@@2
                                                         val@@13)
                                          y0@@8
                                          y1@@4
                                          y2@@1)
                          (MapType3Select m@@52 y0@@8 y1@@4 y2@@1))))
              (or (= x2@@2 y2@@1) a!1))
            :weight 0
            :qid |mapAx1:MapType3Select:2|))
       (forall ((val@@14 T@U)
                (m@@53 T@U)
                (x0@@13 T@U)
                (x1@@7 T@U)
                (x2@@3 T@U)
                (y0@@9 T@U)
                (y1@@5 T@U)
                (y2@@2 T@U))
         (! (let ((a!1 (= (MapType3Select (MapType3Store m@@53
                                                         x0@@13
                                                         x1@@7
                                                         x2@@3
                                                         val@@14)
                                          y0@@9
                                          y1@@5
                                          y2@@2)
                          (MapType3Select m@@53 y0@@9 y1@@5 y2@@2))))
              (or true a!1))
            :weight 0
            :qid |mapAx2:MapType3Select|))
       a!9
       a!10)))
(assert (forall ((t0@@46 T@U)
         (t1@@22 T@U)
         (t2 T@U)
         (heap@@11 T@U)
         (h@@33 T@U)
         (r@@14 T@U)
         (rd@@5 T@U)
         (bx0@@13 T@U)
         (bx1 T@U))
  (! (let ((a!1 (and (= (type t0@@46) TyType)
                     (= (type t1@@22) TyType)
                     (= (type t2) TyType)
                     (= (type heap@@11) (MapType0Type refType MapType1Type))
                     (= (type h@@33)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@14)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@5)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@13) BoxType)
                     (= (type bx1) BoxType))))
       (=> a!1
           (= (Apply2 t0@@46
                      t1@@22
                      t2
                      heap@@11
                      (Handle2 h@@33 r@@14 rd@@5)
                      bx0@@13
                      bx1)
              (MapType3Select h@@33 heap@@11 bx0@@13 bx1))))
     :pattern ((Apply2 t0@@46
                       t1@@22
                       t2
                       heap@@11
                       (Handle2 h@@33 r@@14 rd@@5)
                       bx0@@13
                       bx1))
     :skolemid |809|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@47 T@U)
         (t1@@23 T@U)
         (t2@@0 T@U)
         (heap@@12 T@U)
         (h@@34 T@U)
         (r@@15 T@U)
         (rd@@6 T@U)
         (bx0@@14 T@U)
         (bx1@@0 T@U))
  (! (let ((a!1 (and (= (type t0@@47) TyType)
                     (= (type t1@@23) TyType)
                     (= (type t2@@0) TyType)
                     (= (type heap@@12) (MapType0Type refType MapType1Type))
                     (= (type h@@34)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@15)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@6)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@14) BoxType)
                     (= (type bx1@@0) BoxType)
                     (U_2_bool (MapType3Select r@@15 heap@@12 bx0@@14 bx1@@0)))))
       (=> a!1
           (Requires2 t0@@47
                      t1@@23
                      t2@@0
                      heap@@12
                      (Handle2 h@@34 r@@15 rd@@6)
                      bx0@@14
                      bx1@@0)))
     :pattern ((Requires2 t0@@47
                          t1@@23
                          t2@@0
                          heap@@12
                          (Handle2 h@@34 r@@15 rd@@6)
                          bx0@@14
                          bx1@@0))
     :skolemid |810|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@158 T@U)
         (arg1@@77 T@U)
         (arg2@@29 T@U)
         (arg3@@11 T@U)
         (arg4@@3 T@U)
         (arg5@@0 T@U)
         (arg6@@0 T@U))
  (! (= (type (Reads2 arg0@@158
                      arg1@@77
                      arg2@@29
                      arg3@@11
                      arg4@@3
                      arg5@@0
                      arg6@@0))
        (MapType0Type BoxType boolType))
     :pattern ((Reads2 arg0@@158
                       arg1@@77
                       arg2@@29
                       arg3@@11
                       arg4@@3
                       arg5@@0
                       arg6@@0))
     :qid |funType:Reads2|)))
(assert (forall ((t0@@48 T@U)
         (t1@@24 T@U)
         (t2@@1 T@U)
         (heap@@13 T@U)
         (h@@35 T@U)
         (r@@16 T@U)
         (rd@@7 T@U)
         (bx0@@15 T@U)
         (bx1@@1 T@U)
         (bx@@44 T@U))
  (! (let ((a!1 (and (= (type t0@@48) TyType)
                     (= (type t1@@24) TyType)
                     (= (type t2@@1) TyType)
                     (= (type heap@@13) (MapType0Type refType MapType1Type))
                     (= (type h@@35)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@16)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@7)
                        (MapType3Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@15) BoxType)
                     (= (type bx1@@1) BoxType)
                     (= (type bx@@44) BoxType)))
           (a!2 (U_2_bool (MapType0Select (Reads2 t0@@48
                                                  t1@@24
                                                  t2@@1
                                                  heap@@13
                                                  (Handle2 h@@35 r@@16 rd@@7)
                                                  bx0@@15
                                                  bx1@@1)
                                          bx@@44))))
     (let ((a!3 (= a!2
                   (U_2_bool (MapType0Select (MapType3Select rd@@7
                                                             heap@@13
                                                             bx0@@15
                                                             bx1@@1)
                                             bx@@44)))))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (Reads2 t0@@48
                                       t1@@24
                                       t2@@1
                                       heap@@13
                                       (Handle2 h@@35 r@@16 rd@@7)
                                       bx0@@15
                                       bx1@@1)
                               bx@@44))
     :skolemid |811|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@49 T@U)
         (t1@@25 T@U)
         (t2@@2 T@U)
         (h0@@12 T@U)
         (h1@@12 T@U)
         (f@@29 T@U)
         (bx0@@16 T@U)
         (bx1@@2 T@U))
  (! (let ((a!1 (forall ((o@@56 T@U) (fld@@11 T@U))
                  (! (let ((a!1 (= (type fld@@11)
                                   (FieldType (FieldTypeInv0 (type fld@@11))))))
                     (let ((a!2 (and (= (type o@@56) refType)
                                     a!1
                                     (not (= o@@56 null))
                                     (U_2_bool (MapType0Select (Reads2 t0@@49
                                                                       t1@@25
                                                                       t2@@2
                                                                       h0@@12
                                                                       f@@29
                                                                       bx0@@16
                                                                       bx1@@2)
                                                               ($Box o@@56))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@12 o@@56)
                                              fld@@11)
                              (MapType1Select (MapType0Select h1@@12 o@@56)
                                              fld@@11)))))
                     :no-pattern (type o@@56)
                     :no-pattern (type fld@@11)
                     :no-pattern (U_2_int o@@56)
                     :no-pattern (U_2_bool o@@56)
                     :no-pattern (U_2_int fld@@11)
                     :no-pattern (U_2_bool fld@@11)
                     :skolemid |812|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@49) TyType)
                (= (type t1@@25) TyType)
                (= (type t2@@2) TyType)
                (= (type h0@@12) (MapType0Type refType MapType1Type))
                (= (type h1@@12) (MapType0Type refType MapType1Type))
                (= (type f@@29) HandleTypeType)
                (= (type bx0@@16) BoxType)
                (= (type bx1@@2) BoxType)
                ($HeapSucc h0@@12 h1@@12)
                ($IsGoodHeap h0@@12)
                ($IsGoodHeap h1@@12)
                ($IsBox bx0@@16 t0@@49)
                ($IsBox bx1@@2 t1@@25)
                ($Is f@@29 (Tclass._System.___hFunc2 t0@@49 t1@@25 t2@@2))
                a!1)
           (= (Reads2 t0@@49 t1@@25 t2@@2 h0@@12 f@@29 bx0@@16 bx1@@2)
              (Reads2 t0@@49 t1@@25 t2@@2 h1@@12 f@@29 bx0@@16 bx1@@2))))
     :pattern (($HeapSucc h0@@12 h1@@12)
               (Reads2 t0@@49 t1@@25 t2@@2 h1@@12 f@@29 bx0@@16 bx1@@2))
     :skolemid |813|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@50 T@U)
         (t1@@26 T@U)
         (t2@@3 T@U)
         (h0@@13 T@U)
         (h1@@13 T@U)
         (f@@30 T@U)
         (bx0@@17 T@U)
         (bx1@@3 T@U))
  (! (let ((a!1 (forall ((o@@57 T@U) (fld@@12 T@U))
                  (! (let ((a!1 (= (type fld@@12)
                                   (FieldType (FieldTypeInv0 (type fld@@12))))))
                     (let ((a!2 (and (= (type o@@57) refType)
                                     a!1
                                     (not (= o@@57 null))
                                     (U_2_bool (MapType0Select (Reads2 t0@@50
                                                                       t1@@26
                                                                       t2@@3
                                                                       h1@@13
                                                                       f@@30
                                                                       bx0@@17
                                                                       bx1@@3)
                                                               ($Box o@@57))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@13 o@@57)
                                              fld@@12)
                              (MapType1Select (MapType0Select h1@@13 o@@57)
                                              fld@@12)))))
                     :no-pattern (type o@@57)
                     :no-pattern (type fld@@12)
                     :no-pattern (U_2_int o@@57)
                     :no-pattern (U_2_bool o@@57)
                     :no-pattern (U_2_int fld@@12)
                     :no-pattern (U_2_bool fld@@12)
                     :skolemid |814|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@50) TyType)
                (= (type t1@@26) TyType)
                (= (type t2@@3) TyType)
                (= (type h0@@13) (MapType0Type refType MapType1Type))
                (= (type h1@@13) (MapType0Type refType MapType1Type))
                (= (type f@@30) HandleTypeType)
                (= (type bx0@@17) BoxType)
                (= (type bx1@@3) BoxType)
                ($HeapSucc h0@@13 h1@@13)
                ($IsGoodHeap h0@@13)
                ($IsGoodHeap h1@@13)
                ($IsBox bx0@@17 t0@@50)
                ($IsBox bx1@@3 t1@@26)
                ($Is f@@30 (Tclass._System.___hFunc2 t0@@50 t1@@26 t2@@3))
                a!1)
           (= (Reads2 t0@@50 t1@@26 t2@@3 h0@@13 f@@30 bx0@@17 bx1@@3)
              (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3))))
     :pattern (($HeapSucc h0@@13 h1@@13)
               (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3))
     :skolemid |815|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@51 T@U)
         (t1@@27 T@U)
         (t2@@4 T@U)
         (h0@@14 T@U)
         (h1@@14 T@U)
         (f@@31 T@U)
         (bx0@@18 T@U)
         (bx1@@4 T@U))
  (! (let ((a!1 (forall ((o@@58 T@U) (fld@@13 T@U))
                  (! (let ((a!1 (= (type fld@@13)
                                   (FieldType (FieldTypeInv0 (type fld@@13))))))
                     (let ((a!2 (and (= (type o@@58) refType)
                                     a!1
                                     (not (= o@@58 null))
                                     (U_2_bool (MapType0Select (Reads2 t0@@51
                                                                       t1@@27
                                                                       t2@@4
                                                                       h0@@14
                                                                       f@@31
                                                                       bx0@@18
                                                                       bx1@@4)
                                                               ($Box o@@58))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@14 o@@58)
                                              fld@@13)
                              (MapType1Select (MapType0Select h1@@14 o@@58)
                                              fld@@13)))))
                     :no-pattern (type o@@58)
                     :no-pattern (type fld@@13)
                     :no-pattern (U_2_int o@@58)
                     :no-pattern (U_2_bool o@@58)
                     :no-pattern (U_2_int fld@@13)
                     :no-pattern (U_2_bool fld@@13)
                     :skolemid |816|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@51) TyType)
                (= (type t1@@27) TyType)
                (= (type t2@@4) TyType)
                (= (type h0@@14) (MapType0Type refType MapType1Type))
                (= (type h1@@14) (MapType0Type refType MapType1Type))
                (= (type f@@31) HandleTypeType)
                (= (type bx0@@18) BoxType)
                (= (type bx1@@4) BoxType)
                ($HeapSucc h0@@14 h1@@14)
                ($IsGoodHeap h0@@14)
                ($IsGoodHeap h1@@14)
                ($IsBox bx0@@18 t0@@51)
                ($IsBox bx1@@4 t1@@27)
                ($Is f@@31 (Tclass._System.___hFunc2 t0@@51 t1@@27 t2@@4))
                a!1)
           (= (Requires2 t0@@51 t1@@27 t2@@4 h0@@14 f@@31 bx0@@18 bx1@@4)
              (Requires2 t0@@51 t1@@27 t2@@4 h1@@14 f@@31 bx0@@18 bx1@@4))))
     :pattern (($HeapSucc h0@@14 h1@@14)
               (Requires2 t0@@51 t1@@27 t2@@4 h1@@14 f@@31 bx0@@18 bx1@@4))
     :skolemid |817|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@52 T@U)
         (t1@@28 T@U)
         (t2@@5 T@U)
         (h0@@15 T@U)
         (h1@@15 T@U)
         (f@@32 T@U)
         (bx0@@19 T@U)
         (bx1@@5 T@U))
  (! (let ((a!1 (forall ((o@@59 T@U) (fld@@14 T@U))
                  (! (let ((a!1 (= (type fld@@14)
                                   (FieldType (FieldTypeInv0 (type fld@@14))))))
                     (let ((a!2 (and (= (type o@@59) refType)
                                     a!1
                                     (not (= o@@59 null))
                                     (U_2_bool (MapType0Select (Reads2 t0@@52
                                                                       t1@@28
                                                                       t2@@5
                                                                       h1@@15
                                                                       f@@32
                                                                       bx0@@19
                                                                       bx1@@5)
                                                               ($Box o@@59))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@15 o@@59)
                                              fld@@14)
                              (MapType1Select (MapType0Select h1@@15 o@@59)
                                              fld@@14)))))
                     :no-pattern (type o@@59)
                     :no-pattern (type fld@@14)
                     :no-pattern (U_2_int o@@59)
                     :no-pattern (U_2_bool o@@59)
                     :no-pattern (U_2_int fld@@14)
                     :no-pattern (U_2_bool fld@@14)
                     :skolemid |818|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@52) TyType)
                (= (type t1@@28) TyType)
                (= (type t2@@5) TyType)
                (= (type h0@@15) (MapType0Type refType MapType1Type))
                (= (type h1@@15) (MapType0Type refType MapType1Type))
                (= (type f@@32) HandleTypeType)
                (= (type bx0@@19) BoxType)
                (= (type bx1@@5) BoxType)
                ($HeapSucc h0@@15 h1@@15)
                ($IsGoodHeap h0@@15)
                ($IsGoodHeap h1@@15)
                ($IsBox bx0@@19 t0@@52)
                ($IsBox bx1@@5 t1@@28)
                ($Is f@@32 (Tclass._System.___hFunc2 t0@@52 t1@@28 t2@@5))
                a!1)
           (= (Requires2 t0@@52 t1@@28 t2@@5 h0@@15 f@@32 bx0@@19 bx1@@5)
              (Requires2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5))))
     :pattern (($HeapSucc h0@@15 h1@@15)
               (Requires2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5))
     :skolemid |819|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@53 T@U)
         (t1@@29 T@U)
         (t2@@6 T@U)
         (h0@@16 T@U)
         (h1@@16 T@U)
         (f@@33 T@U)
         (bx0@@20 T@U)
         (bx1@@6 T@U))
  (! (let ((a!1 (forall ((o@@60 T@U) (fld@@15 T@U))
                  (! (let ((a!1 (= (type fld@@15)
                                   (FieldType (FieldTypeInv0 (type fld@@15))))))
                     (let ((a!2 (and (= (type o@@60) refType)
                                     a!1
                                     (not (= o@@60 null))
                                     (U_2_bool (MapType0Select (Reads2 t0@@53
                                                                       t1@@29
                                                                       t2@@6
                                                                       h0@@16
                                                                       f@@33
                                                                       bx0@@20
                                                                       bx1@@6)
                                                               ($Box o@@60))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@16 o@@60)
                                              fld@@15)
                              (MapType1Select (MapType0Select h1@@16 o@@60)
                                              fld@@15)))))
                     :no-pattern (type o@@60)
                     :no-pattern (type fld@@15)
                     :no-pattern (U_2_int o@@60)
                     :no-pattern (U_2_bool o@@60)
                     :no-pattern (U_2_int fld@@15)
                     :no-pattern (U_2_bool fld@@15)
                     :skolemid |820|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@53) TyType)
                (= (type t1@@29) TyType)
                (= (type t2@@6) TyType)
                (= (type h0@@16) (MapType0Type refType MapType1Type))
                (= (type h1@@16) (MapType0Type refType MapType1Type))
                (= (type f@@33) HandleTypeType)
                (= (type bx0@@20) BoxType)
                (= (type bx1@@6) BoxType)
                ($HeapSucc h0@@16 h1@@16)
                ($IsGoodHeap h0@@16)
                ($IsGoodHeap h1@@16)
                ($IsBox bx0@@20 t0@@53)
                ($IsBox bx1@@6 t1@@29)
                ($Is f@@33 (Tclass._System.___hFunc2 t0@@53 t1@@29 t2@@6))
                a!1)
           (= (Apply2 t0@@53 t1@@29 t2@@6 h0@@16 f@@33 bx0@@20 bx1@@6)
              (Apply2 t0@@53 t1@@29 t2@@6 h1@@16 f@@33 bx0@@20 bx1@@6))))
     :pattern (($HeapSucc h0@@16 h1@@16)
               (Apply2 t0@@53 t1@@29 t2@@6 h1@@16 f@@33 bx0@@20 bx1@@6))
     :skolemid |821|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@54 T@U)
         (t1@@30 T@U)
         (t2@@7 T@U)
         (h0@@17 T@U)
         (h1@@17 T@U)
         (f@@34 T@U)
         (bx0@@21 T@U)
         (bx1@@7 T@U))
  (! (let ((a!1 (forall ((o@@61 T@U) (fld@@16 T@U))
                  (! (let ((a!1 (= (type fld@@16)
                                   (FieldType (FieldTypeInv0 (type fld@@16))))))
                     (let ((a!2 (and (= (type o@@61) refType)
                                     a!1
                                     (not (= o@@61 null))
                                     (U_2_bool (MapType0Select (Reads2 t0@@54
                                                                       t1@@30
                                                                       t2@@7
                                                                       h1@@17
                                                                       f@@34
                                                                       bx0@@21
                                                                       bx1@@7)
                                                               ($Box o@@61))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@17 o@@61)
                                              fld@@16)
                              (MapType1Select (MapType0Select h1@@17 o@@61)
                                              fld@@16)))))
                     :no-pattern (type o@@61)
                     :no-pattern (type fld@@16)
                     :no-pattern (U_2_int o@@61)
                     :no-pattern (U_2_bool o@@61)
                     :no-pattern (U_2_int fld@@16)
                     :no-pattern (U_2_bool fld@@16)
                     :skolemid |822|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@54) TyType)
                (= (type t1@@30) TyType)
                (= (type t2@@7) TyType)
                (= (type h0@@17) (MapType0Type refType MapType1Type))
                (= (type h1@@17) (MapType0Type refType MapType1Type))
                (= (type f@@34) HandleTypeType)
                (= (type bx0@@21) BoxType)
                (= (type bx1@@7) BoxType)
                ($HeapSucc h0@@17 h1@@17)
                ($IsGoodHeap h0@@17)
                ($IsGoodHeap h1@@17)
                ($IsBox bx0@@21 t0@@54)
                ($IsBox bx1@@7 t1@@30)
                ($Is f@@34 (Tclass._System.___hFunc2 t0@@54 t1@@30 t2@@7))
                a!1)
           (= (Apply2 t0@@54 t1@@30 t2@@7 h0@@17 f@@34 bx0@@21 bx1@@7)
              (Apply2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7))))
     :pattern (($HeapSucc h0@@17 h1@@17)
               (Apply2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7))
     :skolemid |823|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@55 T@U)
         (t1@@31 T@U)
         (t2@@8 T@U)
         (heap@@14 T@U)
         (f@@35 T@U)
         (bx0@@22 T@U)
         (bx1@@8 T@U))
  (! (=> (and (= (type t0@@55) TyType)
              (= (type t1@@31) TyType)
              (= (type t2@@8) TyType)
              (= (type heap@@14) (MapType0Type refType MapType1Type))
              (= (type f@@35) HandleTypeType)
              (= (type bx0@@22) BoxType)
              (= (type bx1@@8) BoxType)
              ($IsGoodHeap heap@@14)
              ($IsBox bx0@@22 t0@@55)
              ($IsBox bx1@@8 t1@@31)
              ($Is f@@35 (Tclass._System.___hFunc2 t0@@55 t1@@31 t2@@8)))
         (= (|Set#Equal| (Reads2 t0@@55
                                 t1@@31
                                 t2@@8
                                 $OneHeap
                                 f@@35
                                 bx0@@22
                                 bx1@@8)
                         (|Set#Empty| BoxType))
            (|Set#Equal| (Reads2 t0@@55
                                 t1@@31
                                 t2@@8
                                 heap@@14
                                 f@@35
                                 bx0@@22
                                 bx1@@8)
                         (|Set#Empty| BoxType))))
     :pattern ((Reads2 t0@@55 t1@@31 t2@@8 $OneHeap f@@35 bx0@@22 bx1@@8)
               ($IsGoodHeap heap@@14))
     :pattern ((Reads2 t0@@55 t1@@31 t2@@8 heap@@14 f@@35 bx0@@22 bx1@@8))
     :skolemid |824|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@56 T@U)
         (t1@@32 T@U)
         (t2@@9 T@U)
         (heap@@15 T@U)
         (f@@36 T@U)
         (bx0@@23 T@U)
         (bx1@@9 T@U))
  (! (=> (and (= (type t0@@56) TyType)
              (= (type t1@@32) TyType)
              (= (type t2@@9) TyType)
              (= (type heap@@15) (MapType0Type refType MapType1Type))
              (= (type f@@36) HandleTypeType)
              (= (type bx0@@23) BoxType)
              (= (type bx1@@9) BoxType)
              ($IsGoodHeap heap@@15)
              ($IsBox bx0@@23 t0@@56)
              ($IsBox bx1@@9 t1@@32)
              ($Is f@@36 (Tclass._System.___hFunc2 t0@@56 t1@@32 t2@@9))
              (|Set#Equal| (Reads2 t0@@56
                                   t1@@32
                                   t2@@9
                                   $OneHeap
                                   f@@36
                                   bx0@@23
                                   bx1@@9)
                           (|Set#Empty| BoxType)))
         (= (Requires2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9)
            (Requires2 t0@@56 t1@@32 t2@@9 heap@@15 f@@36 bx0@@23 bx1@@9)))
     :pattern ((Requires2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9)
               ($IsGoodHeap heap@@15))
     :pattern ((Requires2 t0@@56 t1@@32 t2@@9 heap@@15 f@@36 bx0@@23 bx1@@9))
     :skolemid |825|
     :qid |unknown.0:0|)))
(assert (forall ((f@@37 T@U) (t0@@57 T@U) (t1@@33 T@U) (t2@@10 T@U))
  (! (let ((a!1 (forall ((h@@36 T@U) (bx0@@24 T@U) (bx1@@10 T@U))
                  (! (=> (and (= (type h@@36)
                                 (MapType0Type refType MapType1Type))
                              (= (type bx0@@24) BoxType)
                              (= (type bx1@@10) BoxType)
                              ($IsGoodHeap h@@36)
                              ($IsBox bx0@@24 t0@@57)
                              ($IsBox bx1@@10 t1@@33)
                              (Requires2 t0@@57
                                         t1@@33
                                         t2@@10
                                         h@@36
                                         f@@37
                                         bx0@@24
                                         bx1@@10))
                         ($IsBox (Apply2 t0@@57
                                         t1@@33
                                         t2@@10
                                         h@@36
                                         f@@37
                                         bx0@@24
                                         bx1@@10)
                                 t2@@10))
                     :pattern ((Apply2 t0@@57
                                       t1@@33
                                       t2@@10
                                       h@@36
                                       f@@37
                                       bx0@@24
                                       bx1@@10))
                     :skolemid |826|
                     :qid |DafnyPreludebpl.545:12|))))
       (=> (and (= (type f@@37) HandleTypeType)
                (= (type t0@@57) TyType)
                (= (type t1@@33) TyType)
                (= (type t2@@10) TyType))
           (= ($Is f@@37 (Tclass._System.___hFunc2 t0@@57 t1@@33 t2@@10)) a!1)))
     :pattern (($Is f@@37 (Tclass._System.___hFunc2 t0@@57 t1@@33 t2@@10)))
     :skolemid |827|
     :qid |unknown.0:0|)))
(assert (forall ((f@@38 T@U)
         (t0@@58 T@U)
         (t1@@34 T@U)
         (t2@@11 T@U)
         (u0@@1 T@U)
         (u1@@0 T@U)
         (u2 T@U))
  (! (let ((a!1 (forall ((bx@@45 T@U))
                  (! (=> (and (= (type bx@@45) BoxType) ($IsBox bx@@45 u0@@1))
                         ($IsBox bx@@45 t0@@58))
                     :pattern (($IsBox bx@@45 u0@@1))
                     :pattern (($IsBox bx@@45 t0@@58))
                     :skolemid |828|
                     :qid |unknown.0:0|)))
           (a!2 (forall ((bx@@46 T@U))
                  (! (=> (and (= (type bx@@46) BoxType) ($IsBox bx@@46 u1@@0))
                         ($IsBox bx@@46 t1@@34))
                     :pattern (($IsBox bx@@46 u1@@0))
                     :pattern (($IsBox bx@@46 t1@@34))
                     :skolemid |829|
                     :qid |unknown.0:0|)))
           (a!3 (forall ((bx@@47 T@U))
                  (! (=> (and (= (type bx@@47) BoxType) ($IsBox bx@@47 t2@@11))
                         ($IsBox bx@@47 u2))
                     :pattern (($IsBox bx@@47 t2@@11))
                     :pattern (($IsBox bx@@47 u2))
                     :skolemid |830|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@38) HandleTypeType)
                (= (type t0@@58) TyType)
                (= (type t1@@34) TyType)
                (= (type t2@@11) TyType)
                (= (type u0@@1) TyType)
                (= (type u1@@0) TyType)
                (= (type u2) TyType)
                ($Is f@@38 (Tclass._System.___hFunc2 t0@@58 t1@@34 t2@@11))
                a!1
                a!2
                a!3)
           ($Is f@@38 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2))))
     :pattern (($Is f@@38 (Tclass._System.___hFunc2 t0@@58 t1@@34 t2@@11))
               ($Is f@@38 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2)))
     :skolemid |831|
     :qid |unknown.0:0|)))
(assert (forall ((f@@39 T@U) (t0@@59 T@U) (t1@@35 T@U) (t2@@12 T@U) (h@@37 T@U))
  (! (let ((a!1 (forall ((bx0@@25 T@U) (bx1@@11 T@U))
                  (! (let ((a!1 (forall ((r@@17 T@U))
                                  (! (let ((a!1 (and (not (= r@@17 null))
                                                     (U_2_bool (MapType0Select (Reads2 t0@@59
                                                                                       t1@@35
                                                                                       t2@@12
                                                                                       h@@37
                                                                                       f@@39
                                                                                       bx0@@25
                                                                                       bx1@@11)
                                                                               ($Box r@@17))))))
                                     (let ((a!2 (=> a!1
                                                    (U_2_bool (MapType1Select (MapType0Select h@@37
                                                                                              r@@17)
                                                                              alloc)))))
                                       (=> (= (type r@@17) refType) a!2)))
                                     :pattern ((MapType0Select (Reads2 t0@@59
                                                                       t1@@35
                                                                       t2@@12
                                                                       h@@37
                                                                       f@@39
                                                                       bx0@@25
                                                                       bx1@@11)
                                                               ($Box r@@17)))
                                     :skolemid |832|
                                     :qid |unknown.0:0|))))
                       (=> (and (= (type bx0@@25) BoxType)
                                (= (type bx1@@11) BoxType))
                           (=> (and ($IsBox bx0@@25 t0@@59)
                                    ($IsAllocBox bx0@@25 t0@@59 h@@37)
                                    ($IsBox bx1@@11 t1@@35)
                                    ($IsAllocBox bx1@@11 t1@@35 h@@37)
                                    (Requires2 t0@@59
                                               t1@@35
                                               t2@@12
                                               h@@37
                                               f@@39
                                               bx0@@25
                                               bx1@@11))
                               a!1)))
                     :pattern ((Apply2 t0@@59
                                       t1@@35
                                       t2@@12
                                       h@@37
                                       f@@39
                                       bx0@@25
                                       bx1@@11))
                     :pattern ((Reads2 t0@@59
                                       t1@@35
                                       t2@@12
                                       h@@37
                                       f@@39
                                       bx0@@25
                                       bx1@@11))
                     :skolemid |833|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@39) HandleTypeType)
                (= (type t0@@59) TyType)
                (= (type t1@@35) TyType)
                (= (type t2@@12) TyType)
                (= (type h@@37) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@37))
           (= ($IsAlloc f@@39
                        (Tclass._System.___hFunc2 t0@@59 t1@@35 t2@@12)
                        h@@37)
              a!1)))
     :pattern (($IsAlloc f@@39
                         (Tclass._System.___hFunc2 t0@@59 t1@@35 t2@@12)
                         h@@37))
     :skolemid |834|
     :qid |unknown.0:0|)))
(assert (forall ((f@@40 T@U) (t0@@60 T@U) (t1@@36 T@U) (t2@@13 T@U) (h@@38 T@U))
  (! (let ((a!1 (forall ((bx0@@26 T@U) (bx1@@12 T@U))
                  (! (=> (and (= (type bx0@@26) BoxType)
                              (= (type bx1@@12) BoxType))
                         (=> (and ($IsAllocBox bx0@@26 t0@@60 h@@38)
                                  ($IsAllocBox bx1@@12 t1@@36 h@@38)
                                  (Requires2 t0@@60
                                             t1@@36
                                             t2@@13
                                             h@@38
                                             f@@40
                                             bx0@@26
                                             bx1@@12))
                             ($IsAllocBox (Apply2 t0@@60
                                                  t1@@36
                                                  t2@@13
                                                  h@@38
                                                  f@@40
                                                  bx0@@26
                                                  bx1@@12)
                                          t2@@13
                                          h@@38)))
                     :pattern ((Apply2 t0@@60
                                       t1@@36
                                       t2@@13
                                       h@@38
                                       f@@40
                                       bx0@@26
                                       bx1@@12))
                     :skolemid |835|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@40) HandleTypeType)
                (= (type t0@@60) TyType)
                (= (type t1@@36) TyType)
                (= (type t2@@13) TyType)
                (= (type h@@38) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@38)
                ($IsAlloc f@@40
                          (Tclass._System.___hFunc2 t0@@60 t1@@36 t2@@13)
                          h@@38))
           a!1))
     :pattern (($IsAlloc f@@40
                         (Tclass._System.___hFunc2 t0@@60 t1@@36 t2@@13)
                         h@@38))
     :skolemid |836|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@159 T@U) (arg1@@78 T@U) (arg2@@30 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2 arg0@@159 arg1@@78 arg2@@30))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc2 arg0@@159 arg1@@78 arg2@@30))
     :qid |funType:Tclass._System.___hPartialFunc2|)))
(assert (forall ((|#$T0@@20| T@U) (|#$T1@@4| T@U) (|#$R@@33| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc2
                               |#$T0@@20|
                               |#$T1@@4|
                               |#$R@@33|))
                        Tagclass._System.___hPartialFunc2)
                     (= (TagFamily (Tclass._System.___hPartialFunc2
                                     |#$T0@@20|
                                     |#$T1@@4|
                                     |#$R@@33|))
                        |tytagFamily$_#PartialFunc2|))))
       (=> (and (= (type |#$T0@@20|) TyType)
                (= (type |#$T1@@4|) TyType)
                (= (type |#$R@@33|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc2 |#$T0@@20| |#$T1@@4| |#$R@@33|))
     :skolemid |837|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@160 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2_0 arg0@@160)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2_0 arg0@@160))
     :qid |funType:Tclass._System.___hPartialFunc2_0|)))
(assert (forall ((|#$T0@@21| T@U) (|#$T1@@5| T@U) (|#$R@@34| T@U))
  (! (=> (and (= (type |#$T0@@21|) TyType)
              (= (type |#$T1@@5|) TyType)
              (= (type |#$R@@34|) TyType))
         (= (Tclass._System.___hPartialFunc2_0
              (Tclass._System.___hPartialFunc2 |#$T0@@21| |#$T1@@5| |#$R@@34|))
            |#$T0@@21|))
     :pattern ((Tclass._System.___hPartialFunc2 |#$T0@@21| |#$T1@@5| |#$R@@34|))
     :skolemid |838|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@161 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2_1 arg0@@161)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2_1 arg0@@161))
     :qid |funType:Tclass._System.___hPartialFunc2_1|)))
(assert (forall ((|#$T0@@22| T@U) (|#$T1@@6| T@U) (|#$R@@35| T@U))
  (! (=> (and (= (type |#$T0@@22|) TyType)
              (= (type |#$T1@@6|) TyType)
              (= (type |#$R@@35|) TyType))
         (= (Tclass._System.___hPartialFunc2_1
              (Tclass._System.___hPartialFunc2 |#$T0@@22| |#$T1@@6| |#$R@@35|))
            |#$T1@@6|))
     :pattern ((Tclass._System.___hPartialFunc2 |#$T0@@22| |#$T1@@6| |#$R@@35|))
     :skolemid |839|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@162 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2_2 arg0@@162)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2_2 arg0@@162))
     :qid |funType:Tclass._System.___hPartialFunc2_2|)))
(assert (forall ((|#$T0@@23| T@U) (|#$T1@@7| T@U) (|#$R@@36| T@U))
  (! (=> (and (= (type |#$T0@@23|) TyType)
              (= (type |#$T1@@7|) TyType)
              (= (type |#$R@@36|) TyType))
         (= (Tclass._System.___hPartialFunc2_2
              (Tclass._System.___hPartialFunc2 |#$T0@@23| |#$T1@@7| |#$R@@36|))
            |#$R@@36|))
     :pattern ((Tclass._System.___hPartialFunc2 |#$T0@@23| |#$T1@@7| |#$R@@36|))
     :skolemid |840|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@24| T@U) (|#$T1@@8| T@U) (|#$R@@37| T@U) (bx@@48 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@48)) bx@@48)
                     ($Is ($Unbox HandleTypeType bx@@48)
                          (Tclass._System.___hPartialFunc2
                            |#$T0@@24|
                            |#$T1@@8|
                            |#$R@@37|)))))
       (=> (and (= (type |#$T0@@24|) TyType)
                (= (type |#$T1@@8|) TyType)
                (= (type |#$R@@37|) TyType)
                (= (type bx@@48) BoxType)
                ($IsBox bx@@48
                        (Tclass._System.___hPartialFunc2
                          |#$T0@@24|
                          |#$T1@@8|
                          |#$R@@37|)))
           a!1))
     :pattern (($IsBox bx@@48
                       (Tclass._System.___hPartialFunc2
                         |#$T0@@24|
                         |#$T1@@8|
                         |#$R@@37|)))
     :skolemid |841|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@25| T@U) (|#$T1@@9| T@U) (|#$R@@38| T@U) (|f#0@@7| T@U))
  (! (let ((a!1 (forall ((|x0#0@@1| T@U) (|x1#0| T@U))
                  (! (=> (and (= (type |x0#0@@1|) BoxType)
                              (= (type |x1#0|) BoxType)
                              ($IsBox |x0#0@@1| |#$T0@@25|)
                              ($IsBox |x1#0| |#$T1@@9|))
                         (|Set#Equal| (Reads2 |#$T0@@25|
                                              |#$T1@@9|
                                              |#$R@@38|
                                              $OneHeap
                                              |f#0@@7|
                                              |x0#0@@1|
                                              |x1#0|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@1|)
                     :no-pattern (type |x1#0|)
                     :no-pattern (U_2_int |x0#0@@1|)
                     :no-pattern (U_2_bool |x0#0@@1|)
                     :no-pattern (U_2_int |x1#0|)
                     :no-pattern (U_2_bool |x1#0|)
                     :skolemid |842|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@7|
                        (Tclass._System.___hPartialFunc2
                          |#$T0@@25|
                          |#$T1@@9|
                          |#$R@@38|))
                   (and ($Is |f#0@@7|
                             (Tclass._System.___hFunc2
                               |#$T0@@25|
                               |#$T1@@9|
                               |#$R@@38|))
                        a!1))))
       (=> (and (= (type |#$T0@@25|) TyType)
                (= (type |#$T1@@9|) TyType)
                (= (type |#$R@@38|) TyType)
                (= (type |f#0@@7|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@7|
                    (Tclass._System.___hPartialFunc2
                      |#$T0@@25|
                      |#$T1@@9|
                      |#$R@@38|)))
     :skolemid |843|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@26| T@U)
         (|#$T1@@10| T@U)
         (|#$R@@39| T@U)
         (|f#0@@8| T@U)
         ($h@@12 T@U))
  (! (=> (and (= (type |#$T0@@26|) TyType)
              (= (type |#$T1@@10|) TyType)
              (= (type |#$R@@39|) TyType)
              (= (type |f#0@@8|) HandleTypeType)
              (= (type $h@@12) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@8|
                      (Tclass._System.___hPartialFunc2
                        |#$T0@@26|
                        |#$T1@@10|
                        |#$R@@39|)
                      $h@@12)
            ($IsAlloc |f#0@@8|
                      (Tclass._System.___hFunc2 |#$T0@@26| |#$T1@@10| |#$R@@39|)
                      $h@@12)))
     :pattern (($IsAlloc |f#0@@8|
                         (Tclass._System.___hPartialFunc2
                           |#$T0@@26|
                           |#$T1@@10|
                           |#$R@@39|)
                         $h@@12))
     :skolemid |844|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@163 T@U) (arg1@@79 T@U) (arg2@@31 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2 arg0@@163 arg1@@79 arg2@@31))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc2 arg0@@163 arg1@@79 arg2@@31))
     :qid |funType:Tclass._System.___hTotalFunc2|)))
(assert (forall ((|#$T0@@27| T@U) (|#$T1@@11| T@U) (|#$R@@40| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc2
                               |#$T0@@27|
                               |#$T1@@11|
                               |#$R@@40|))
                        Tagclass._System.___hTotalFunc2)
                     (= (TagFamily (Tclass._System.___hTotalFunc2
                                     |#$T0@@27|
                                     |#$T1@@11|
                                     |#$R@@40|))
                        |tytagFamily$_#TotalFunc2|))))
       (=> (and (= (type |#$T0@@27|) TyType)
                (= (type |#$T1@@11|) TyType)
                (= (type |#$R@@40|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc2 |#$T0@@27| |#$T1@@11| |#$R@@40|))
     :skolemid |845|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@164 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2_0 arg0@@164)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2_0 arg0@@164))
     :qid |funType:Tclass._System.___hTotalFunc2_0|)))
(assert (forall ((|#$T0@@28| T@U) (|#$T1@@12| T@U) (|#$R@@41| T@U))
  (! (=> (and (= (type |#$T0@@28|) TyType)
              (= (type |#$T1@@12|) TyType)
              (= (type |#$R@@41|) TyType))
         (= (Tclass._System.___hTotalFunc2_0
              (Tclass._System.___hTotalFunc2 |#$T0@@28| |#$T1@@12| |#$R@@41|))
            |#$T0@@28|))
     :pattern ((Tclass._System.___hTotalFunc2 |#$T0@@28| |#$T1@@12| |#$R@@41|))
     :skolemid |846|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@165 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2_1 arg0@@165)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2_1 arg0@@165))
     :qid |funType:Tclass._System.___hTotalFunc2_1|)))
(assert (forall ((|#$T0@@29| T@U) (|#$T1@@13| T@U) (|#$R@@42| T@U))
  (! (=> (and (= (type |#$T0@@29|) TyType)
              (= (type |#$T1@@13|) TyType)
              (= (type |#$R@@42|) TyType))
         (= (Tclass._System.___hTotalFunc2_1
              (Tclass._System.___hTotalFunc2 |#$T0@@29| |#$T1@@13| |#$R@@42|))
            |#$T1@@13|))
     :pattern ((Tclass._System.___hTotalFunc2 |#$T0@@29| |#$T1@@13| |#$R@@42|))
     :skolemid |847|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@166 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2_2 arg0@@166)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2_2 arg0@@166))
     :qid |funType:Tclass._System.___hTotalFunc2_2|)))
(assert (forall ((|#$T0@@30| T@U) (|#$T1@@14| T@U) (|#$R@@43| T@U))
  (! (=> (and (= (type |#$T0@@30|) TyType)
              (= (type |#$T1@@14|) TyType)
              (= (type |#$R@@43|) TyType))
         (= (Tclass._System.___hTotalFunc2_2
              (Tclass._System.___hTotalFunc2 |#$T0@@30| |#$T1@@14| |#$R@@43|))
            |#$R@@43|))
     :pattern ((Tclass._System.___hTotalFunc2 |#$T0@@30| |#$T1@@14| |#$R@@43|))
     :skolemid |848|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@31| T@U) (|#$T1@@15| T@U) (|#$R@@44| T@U) (bx@@49 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@49)) bx@@49)
                     ($Is ($Unbox HandleTypeType bx@@49)
                          (Tclass._System.___hTotalFunc2
                            |#$T0@@31|
                            |#$T1@@15|
                            |#$R@@44|)))))
       (=> (and (= (type |#$T0@@31|) TyType)
                (= (type |#$T1@@15|) TyType)
                (= (type |#$R@@44|) TyType)
                (= (type bx@@49) BoxType)
                ($IsBox bx@@49
                        (Tclass._System.___hTotalFunc2
                          |#$T0@@31|
                          |#$T1@@15|
                          |#$R@@44|)))
           a!1))
     :pattern (($IsBox bx@@49
                       (Tclass._System.___hTotalFunc2
                         |#$T0@@31|
                         |#$T1@@15|
                         |#$R@@44|)))
     :skolemid |849|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@32| T@U) (|#$T1@@16| T@U) (|#$R@@45| T@U) (|f#0@@9| T@U))
  (! (let ((a!1 (forall ((|x0#0@@2| T@U) (|x1#0@@0| T@U))
                  (! (=> (and (= (type |x0#0@@2|) BoxType)
                              (= (type |x1#0@@0|) BoxType)
                              ($IsBox |x0#0@@2| |#$T0@@32|)
                              ($IsBox |x1#0@@0| |#$T1@@16|))
                         (Requires2 |#$T0@@32|
                                    |#$T1@@16|
                                    |#$R@@45|
                                    $OneHeap
                                    |f#0@@9|
                                    |x0#0@@2|
                                    |x1#0@@0|))
                     :no-pattern (type |x0#0@@2|)
                     :no-pattern (type |x1#0@@0|)
                     :no-pattern (U_2_int |x0#0@@2|)
                     :no-pattern (U_2_bool |x0#0@@2|)
                     :no-pattern (U_2_int |x1#0@@0|)
                     :no-pattern (U_2_bool |x1#0@@0|)
                     :skolemid |850|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@9|
                        (Tclass._System.___hTotalFunc2
                          |#$T0@@32|
                          |#$T1@@16|
                          |#$R@@45|))
                   (and ($Is |f#0@@9|
                             (Tclass._System.___hPartialFunc2
                               |#$T0@@32|
                               |#$T1@@16|
                               |#$R@@45|))
                        a!1))))
       (=> (and (= (type |#$T0@@32|) TyType)
                (= (type |#$T1@@16|) TyType)
                (= (type |#$R@@45|) TyType)
                (= (type |f#0@@9|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@9|
                    (Tclass._System.___hTotalFunc2
                      |#$T0@@32|
                      |#$T1@@16|
                      |#$R@@45|)))
     :skolemid |851|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@33| T@U)
         (|#$T1@@17| T@U)
         (|#$R@@46| T@U)
         (|f#0@@10| T@U)
         ($h@@13 T@U))
  (! (=> (and (= (type |#$T0@@33|) TyType)
              (= (type |#$T1@@17|) TyType)
              (= (type |#$R@@46|) TyType)
              (= (type |f#0@@10|) HandleTypeType)
              (= (type $h@@13) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@10|
                      (Tclass._System.___hTotalFunc2
                        |#$T0@@33|
                        |#$T1@@17|
                        |#$R@@46|)
                      $h@@13)
            ($IsAlloc |f#0@@10|
                      (Tclass._System.___hPartialFunc2
                        |#$T0@@33|
                        |#$T1@@17|
                        |#$R@@46|)
                      $h@@13)))
     :pattern (($IsAlloc |f#0@@10|
                         (Tclass._System.___hTotalFunc2
                           |#$T0@@33|
                           |#$T1@@17|
                           |#$R@@46|)
                         $h@@13))
     :skolemid |852|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@167 T@U)
         (arg1@@80 T@U)
         (arg2@@32 T@U)
         (arg3@@12 T@U)
         (arg4@@4 T@U))
  (! (= (type (Tclass._System.___hFunc4
                arg0@@167
                arg1@@80
                arg2@@32
                arg3@@12
                arg4@@4))
        TyType)
     :pattern ((Tclass._System.___hFunc4
                 arg0@@167
                 arg1@@80
                 arg2@@32
                 arg3@@12
                 arg4@@4))
     :qid |funType:Tclass._System.___hFunc4|)))
(assert (forall ((|#$T0@@34| T@U)
         (|#$T1@@18| T@U)
         (|#$T2| T@U)
         (|#$T3| T@U)
         (|#$R@@47| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc4
                               |#$T0@@34|
                               |#$T1@@18|
                               |#$T2|
                               |#$T3|
                               |#$R@@47|))
                        Tagclass._System.___hFunc4)
                     (= (TagFamily (Tclass._System.___hFunc4
                                     |#$T0@@34|
                                     |#$T1@@18|
                                     |#$T2|
                                     |#$T3|
                                     |#$R@@47|))
                        |tytagFamily$_#Func4|))))
       (=> (and (= (type |#$T0@@34|) TyType)
                (= (type |#$T1@@18|) TyType)
                (= (type |#$T2|) TyType)
                (= (type |#$T3|) TyType)
                (= (type |#$R@@47|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc4
                 |#$T0@@34|
                 |#$T1@@18|
                 |#$T2|
                 |#$T3|
                 |#$R@@47|))
     :skolemid |853|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@168 T@U))
  (! (= (type (Tclass._System.___hFunc4_0 arg0@@168)) TyType)
     :pattern ((Tclass._System.___hFunc4_0 arg0@@168))
     :qid |funType:Tclass._System.___hFunc4_0|)))
(assert (forall ((|#$T0@@35| T@U)
         (|#$T1@@19| T@U)
         (|#$T2@@0| T@U)
         (|#$T3@@0| T@U)
         (|#$R@@48| T@U))
  (! (=> (and (= (type |#$T0@@35|) TyType)
              (= (type |#$T1@@19|) TyType)
              (= (type |#$T2@@0|) TyType)
              (= (type |#$T3@@0|) TyType)
              (= (type |#$R@@48|) TyType))
         (= (Tclass._System.___hFunc4_0
              (Tclass._System.___hFunc4
                |#$T0@@35|
                |#$T1@@19|
                |#$T2@@0|
                |#$T3@@0|
                |#$R@@48|))
            |#$T0@@35|))
     :pattern ((Tclass._System.___hFunc4
                 |#$T0@@35|
                 |#$T1@@19|
                 |#$T2@@0|
                 |#$T3@@0|
                 |#$R@@48|))
     :skolemid |854|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@169 T@U))
  (! (= (type (Tclass._System.___hFunc4_1 arg0@@169)) TyType)
     :pattern ((Tclass._System.___hFunc4_1 arg0@@169))
     :qid |funType:Tclass._System.___hFunc4_1|)))
(assert (forall ((|#$T0@@36| T@U)
         (|#$T1@@20| T@U)
         (|#$T2@@1| T@U)
         (|#$T3@@1| T@U)
         (|#$R@@49| T@U))
  (! (=> (and (= (type |#$T0@@36|) TyType)
              (= (type |#$T1@@20|) TyType)
              (= (type |#$T2@@1|) TyType)
              (= (type |#$T3@@1|) TyType)
              (= (type |#$R@@49|) TyType))
         (= (Tclass._System.___hFunc4_1
              (Tclass._System.___hFunc4
                |#$T0@@36|
                |#$T1@@20|
                |#$T2@@1|
                |#$T3@@1|
                |#$R@@49|))
            |#$T1@@20|))
     :pattern ((Tclass._System.___hFunc4
                 |#$T0@@36|
                 |#$T1@@20|
                 |#$T2@@1|
                 |#$T3@@1|
                 |#$R@@49|))
     :skolemid |855|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@170 T@U))
  (! (= (type (Tclass._System.___hFunc4_2 arg0@@170)) TyType)
     :pattern ((Tclass._System.___hFunc4_2 arg0@@170))
     :qid |funType:Tclass._System.___hFunc4_2|)))
(assert (forall ((|#$T0@@37| T@U)
         (|#$T1@@21| T@U)
         (|#$T2@@2| T@U)
         (|#$T3@@2| T@U)
         (|#$R@@50| T@U))
  (! (=> (and (= (type |#$T0@@37|) TyType)
              (= (type |#$T1@@21|) TyType)
              (= (type |#$T2@@2|) TyType)
              (= (type |#$T3@@2|) TyType)
              (= (type |#$R@@50|) TyType))
         (= (Tclass._System.___hFunc4_2
              (Tclass._System.___hFunc4
                |#$T0@@37|
                |#$T1@@21|
                |#$T2@@2|
                |#$T3@@2|
                |#$R@@50|))
            |#$T2@@2|))
     :pattern ((Tclass._System.___hFunc4
                 |#$T0@@37|
                 |#$T1@@21|
                 |#$T2@@2|
                 |#$T3@@2|
                 |#$R@@50|))
     :skolemid |856|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@171 T@U))
  (! (= (type (Tclass._System.___hFunc4_3 arg0@@171)) TyType)
     :pattern ((Tclass._System.___hFunc4_3 arg0@@171))
     :qid |funType:Tclass._System.___hFunc4_3|)))
(assert (forall ((|#$T0@@38| T@U)
         (|#$T1@@22| T@U)
         (|#$T2@@3| T@U)
         (|#$T3@@3| T@U)
         (|#$R@@51| T@U))
  (! (=> (and (= (type |#$T0@@38|) TyType)
              (= (type |#$T1@@22|) TyType)
              (= (type |#$T2@@3|) TyType)
              (= (type |#$T3@@3|) TyType)
              (= (type |#$R@@51|) TyType))
         (= (Tclass._System.___hFunc4_3
              (Tclass._System.___hFunc4
                |#$T0@@38|
                |#$T1@@22|
                |#$T2@@3|
                |#$T3@@3|
                |#$R@@51|))
            |#$T3@@3|))
     :pattern ((Tclass._System.___hFunc4
                 |#$T0@@38|
                 |#$T1@@22|
                 |#$T2@@3|
                 |#$T3@@3|
                 |#$R@@51|))
     :skolemid |857|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@172 T@U))
  (! (= (type (Tclass._System.___hFunc4_4 arg0@@172)) TyType)
     :pattern ((Tclass._System.___hFunc4_4 arg0@@172))
     :qid |funType:Tclass._System.___hFunc4_4|)))
(assert (forall ((|#$T0@@39| T@U)
         (|#$T1@@23| T@U)
         (|#$T2@@4| T@U)
         (|#$T3@@4| T@U)
         (|#$R@@52| T@U))
  (! (=> (and (= (type |#$T0@@39|) TyType)
              (= (type |#$T1@@23|) TyType)
              (= (type |#$T2@@4|) TyType)
              (= (type |#$T3@@4|) TyType)
              (= (type |#$R@@52|) TyType))
         (= (Tclass._System.___hFunc4_4
              (Tclass._System.___hFunc4
                |#$T0@@39|
                |#$T1@@23|
                |#$T2@@4|
                |#$T3@@4|
                |#$R@@52|))
            |#$R@@52|))
     :pattern ((Tclass._System.___hFunc4
                 |#$T0@@39|
                 |#$T1@@23|
                 |#$T2@@4|
                 |#$T3@@4|
                 |#$R@@52|))
     :skolemid |858|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@40| T@U)
         (|#$T1@@24| T@U)
         (|#$T2@@5| T@U)
         (|#$T3@@5| T@U)
         (|#$R@@53| T@U)
         (bx@@50 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@50)) bx@@50)
                     ($Is ($Unbox HandleTypeType bx@@50)
                          (Tclass._System.___hFunc4
                            |#$T0@@40|
                            |#$T1@@24|
                            |#$T2@@5|
                            |#$T3@@5|
                            |#$R@@53|)))))
       (=> (and (= (type |#$T0@@40|) TyType)
                (= (type |#$T1@@24|) TyType)
                (= (type |#$T2@@5|) TyType)
                (= (type |#$T3@@5|) TyType)
                (= (type |#$R@@53|) TyType)
                (= (type bx@@50) BoxType)
                ($IsBox bx@@50
                        (Tclass._System.___hFunc4
                          |#$T0@@40|
                          |#$T1@@24|
                          |#$T2@@5|
                          |#$T3@@5|
                          |#$R@@53|)))
           a!1))
     :pattern (($IsBox bx@@50
                       (Tclass._System.___hFunc4
                         |#$T0@@40|
                         |#$T1@@24|
                         |#$T2@@5|
                         |#$T3@@5|
                         |#$R@@53|)))
     :skolemid |859|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@173 T@T)
                    (arg1@@81 T@T)
                    (arg2@@33 T@T)
                    (arg3@@13 T@T)
                    (arg4@@5 T@T)
                    (arg5@@1 T@T))
             (! (= (Ctor (MapType4Type arg0@@173
                                       arg1@@81
                                       arg2@@33
                                       arg3@@13
                                       arg4@@5
                                       arg5@@1))
                   26)
                :qid |ctor:MapType4Type|)))
      (a!2 (forall ((arg0@@174 T@T)
                    (arg1@@82 T@T)
                    (arg2@@34 T@T)
                    (arg3@@14 T@T)
                    (arg4@@6 T@T)
                    (arg5@@2 T@T))
             (! (= (MapType4TypeInv0 (MapType4Type arg0@@174
                                                   arg1@@82
                                                   arg2@@34
                                                   arg3@@14
                                                   arg4@@6
                                                   arg5@@2))
                   arg0@@174)
                :pattern ((MapType4Type arg0@@174
                                        arg1@@82
                                        arg2@@34
                                        arg3@@14
                                        arg4@@6
                                        arg5@@2))
                :qid |typeInv:MapType4TypeInv0|)))
      (a!3 (forall ((arg0@@175 T@T)
                    (arg1@@83 T@T)
                    (arg2@@35 T@T)
                    (arg3@@15 T@T)
                    (arg4@@7 T@T)
                    (arg5@@3 T@T))
             (! (= (MapType4TypeInv1 (MapType4Type arg0@@175
                                                   arg1@@83
                                                   arg2@@35
                                                   arg3@@15
                                                   arg4@@7
                                                   arg5@@3))
                   arg1@@83)
                :pattern ((MapType4Type arg0@@175
                                        arg1@@83
                                        arg2@@35
                                        arg3@@15
                                        arg4@@7
                                        arg5@@3))
                :qid |typeInv:MapType4TypeInv1|)))
      (a!4 (forall ((arg0@@176 T@T)
                    (arg1@@84 T@T)
                    (arg2@@36 T@T)
                    (arg3@@16 T@T)
                    (arg4@@8 T@T)
                    (arg5@@4 T@T))
             (! (= (MapType4TypeInv2 (MapType4Type arg0@@176
                                                   arg1@@84
                                                   arg2@@36
                                                   arg3@@16
                                                   arg4@@8
                                                   arg5@@4))
                   arg2@@36)
                :pattern ((MapType4Type arg0@@176
                                        arg1@@84
                                        arg2@@36
                                        arg3@@16
                                        arg4@@8
                                        arg5@@4))
                :qid |typeInv:MapType4TypeInv2|)))
      (a!5 (forall ((arg0@@177 T@T)
                    (arg1@@85 T@T)
                    (arg2@@37 T@T)
                    (arg3@@17 T@T)
                    (arg4@@9 T@T)
                    (arg5@@5 T@T))
             (! (= (MapType4TypeInv3 (MapType4Type arg0@@177
                                                   arg1@@85
                                                   arg2@@37
                                                   arg3@@17
                                                   arg4@@9
                                                   arg5@@5))
                   arg3@@17)
                :pattern ((MapType4Type arg0@@177
                                        arg1@@85
                                        arg2@@37
                                        arg3@@17
                                        arg4@@9
                                        arg5@@5))
                :qid |typeInv:MapType4TypeInv3|)))
      (a!6 (forall ((arg0@@178 T@T)
                    (arg1@@86 T@T)
                    (arg2@@38 T@T)
                    (arg3@@18 T@T)
                    (arg4@@10 T@T)
                    (arg5@@6 T@T))
             (! (= (MapType4TypeInv4 (MapType4Type arg0@@178
                                                   arg1@@86
                                                   arg2@@38
                                                   arg3@@18
                                                   arg4@@10
                                                   arg5@@6))
                   arg4@@10)
                :pattern ((MapType4Type arg0@@178
                                        arg1@@86
                                        arg2@@38
                                        arg3@@18
                                        arg4@@10
                                        arg5@@6))
                :qid |typeInv:MapType4TypeInv4|)))
      (a!7 (forall ((arg0@@179 T@T)
                    (arg1@@87 T@T)
                    (arg2@@39 T@T)
                    (arg3@@19 T@T)
                    (arg4@@11 T@T)
                    (arg5@@7 T@T))
             (! (= (MapType4TypeInv5 (MapType4Type arg0@@179
                                                   arg1@@87
                                                   arg2@@39
                                                   arg3@@19
                                                   arg4@@11
                                                   arg5@@7))
                   arg5@@7)
                :pattern ((MapType4Type arg0@@179
                                        arg1@@87
                                        arg2@@39
                                        arg3@@19
                                        arg4@@11
                                        arg5@@7))
                :qid |typeInv:MapType4TypeInv5|)))
      (a!8 (forall ((arg0@@180 T@U)
                    (arg1@@88 T@U)
                    (arg2@@40 T@U)
                    (arg3@@20 T@U)
                    (arg4@@12 T@U)
                    (arg5@@8 T@U))
             (! (= (type (MapType4Select arg0@@180
                                         arg1@@88
                                         arg2@@40
                                         arg3@@20
                                         arg4@@12
                                         arg5@@8))
                   (MapType4TypeInv5 (type arg0@@180)))
                :pattern ((MapType4Select arg0@@180
                                          arg1@@88
                                          arg2@@40
                                          arg3@@20
                                          arg4@@12
                                          arg5@@8))
                :qid |funType:MapType4Select|)))
      (a!9 (forall ((arg0@@181 T@U)
                    (arg1@@89 T@U)
                    (arg2@@41 T@U)
                    (arg3@@21 T@U)
                    (arg4@@13 T@U)
                    (arg5@@9 T@U)
                    (arg6@@1 T@U))
             (! (= (type (MapType4Store arg0@@181
                                        arg1@@89
                                        arg2@@41
                                        arg3@@21
                                        arg4@@13
                                        arg5@@9
                                        arg6@@1))
                   (MapType4Type (type arg1@@89)
                                 (type arg2@@41)
                                 (type arg3@@21)
                                 (type arg4@@13)
                                 (type arg5@@9)
                                 (type arg6@@1)))
                :pattern ((MapType4Store arg0@@181
                                         arg1@@89
                                         arg2@@41
                                         arg3@@21
                                         arg4@@13
                                         arg5@@9
                                         arg6@@1))
                :qid |funType:MapType4Store|)))
      (a!10 (forall ((m@@54 T@U)
                     (x0@@14 T@U)
                     (x1@@8 T@U)
                     (x2@@4 T@U)
                     (x3 T@U)
                     (x4 T@U)
                     (val@@15 T@U))
              (! (=> (= (type val@@15) (MapType4TypeInv5 (type m@@54)))
                     (= (MapType4Select (MapType4Store m@@54
                                                       x0@@14
                                                       x1@@8
                                                       x2@@4
                                                       x3
                                                       x4
                                                       val@@15)
                                        x0@@14
                                        x1@@8
                                        x2@@4
                                        x3
                                        x4)
                        val@@15))
                 :weight 0
                 :qid |mapAx0:MapType4Select|)))
      (a!11 (forall ((arg0@@182 T@U)
                     (arg1@@90 T@U)
                     (arg2@@42 T@U)
                     (arg3@@22 T@U)
                     (arg4@@14 T@U)
                     (arg5@@10 T@U)
                     (arg6@@2 T@U)
                     (arg7 T@U)
                     (arg8 T@U)
                     (arg9 T@U)
                     (arg10 T@U))
              (! (= (type (Apply4 arg0@@182
                                  arg1@@90
                                  arg2@@42
                                  arg3@@22
                                  arg4@@14
                                  arg5@@10
                                  arg6@@2
                                  arg7
                                  arg8
                                  arg9
                                  arg10))
                    BoxType)
                 :pattern ((Apply4 arg0@@182
                                   arg1@@90
                                   arg2@@42
                                   arg3@@22
                                   arg4@@14
                                   arg5@@10
                                   arg6@@2
                                   arg7
                                   arg8
                                   arg9
                                   arg10))
                 :qid |funType:Apply4|)))
      (a!12 (forall ((arg0@@183 T@U) (arg1@@91 T@U) (arg2@@43 T@U))
              (! (= (type (Handle4 arg0@@183 arg1@@91 arg2@@43)) HandleTypeType)
                 :pattern ((Handle4 arg0@@183 arg1@@91 arg2@@43))
                 :qid |funType:Handle4|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       a!9
       a!10
       (forall ((val@@16 T@U)
                (m@@55 T@U)
                (x0@@15 T@U)
                (x1@@9 T@U)
                (x2@@5 T@U)
                (x3@@0 T@U)
                (x4@@0 T@U)
                (y0@@10 T@U)
                (y1@@6 T@U)
                (y2@@3 T@U)
                (y3 T@U)
                (y4 T@U))
         (! (let ((a!1 (= (MapType4Select (MapType4Store m@@55
                                                         x0@@15
                                                         x1@@9
                                                         x2@@5
                                                         x3@@0
                                                         x4@@0
                                                         val@@16)
                                          y0@@10
                                          y1@@6
                                          y2@@3
                                          y3
                                          y4)
                          (MapType4Select m@@55 y0@@10 y1@@6 y2@@3 y3 y4))))
              (or (= x0@@15 y0@@10) a!1))
            :weight 0
            :qid |mapAx1:MapType4Select:0|))
       (forall ((val@@17 T@U)
                (m@@56 T@U)
                (x0@@16 T@U)
                (x1@@10 T@U)
                (x2@@6 T@U)
                (x3@@1 T@U)
                (x4@@1 T@U)
                (y0@@11 T@U)
                (y1@@7 T@U)
                (y2@@4 T@U)
                (y3@@0 T@U)
                (y4@@0 T@U))
         (! (let ((a!1 (= (MapType4Select (MapType4Store m@@56
                                                         x0@@16
                                                         x1@@10
                                                         x2@@6
                                                         x3@@1
                                                         x4@@1
                                                         val@@17)
                                          y0@@11
                                          y1@@7
                                          y2@@4
                                          y3@@0
                                          y4@@0)
                          (MapType4Select m@@56 y0@@11 y1@@7 y2@@4 y3@@0 y4@@0))))
              (or (= x1@@10 y1@@7) a!1))
            :weight 0
            :qid |mapAx1:MapType4Select:1|))
       (forall ((val@@18 T@U)
                (m@@57 T@U)
                (x0@@17 T@U)
                (x1@@11 T@U)
                (x2@@7 T@U)
                (x3@@2 T@U)
                (x4@@2 T@U)
                (y0@@12 T@U)
                (y1@@8 T@U)
                (y2@@5 T@U)
                (y3@@1 T@U)
                (y4@@1 T@U))
         (! (let ((a!1 (= (MapType4Select (MapType4Store m@@57
                                                         x0@@17
                                                         x1@@11
                                                         x2@@7
                                                         x3@@2
                                                         x4@@2
                                                         val@@18)
                                          y0@@12
                                          y1@@8
                                          y2@@5
                                          y3@@1
                                          y4@@1)
                          (MapType4Select m@@57 y0@@12 y1@@8 y2@@5 y3@@1 y4@@1))))
              (or (= x2@@7 y2@@5) a!1))
            :weight 0
            :qid |mapAx1:MapType4Select:2|))
       (forall ((val@@19 T@U)
                (m@@58 T@U)
                (x0@@18 T@U)
                (x1@@12 T@U)
                (x2@@8 T@U)
                (x3@@3 T@U)
                (x4@@3 T@U)
                (y0@@13 T@U)
                (y1@@9 T@U)
                (y2@@6 T@U)
                (y3@@2 T@U)
                (y4@@2 T@U))
         (! (let ((a!1 (= (MapType4Select (MapType4Store m@@58
                                                         x0@@18
                                                         x1@@12
                                                         x2@@8
                                                         x3@@3
                                                         x4@@3
                                                         val@@19)
                                          y0@@13
                                          y1@@9
                                          y2@@6
                                          y3@@2
                                          y4@@2)
                          (MapType4Select m@@58 y0@@13 y1@@9 y2@@6 y3@@2 y4@@2))))
              (or (= x3@@3 y3@@2) a!1))
            :weight 0
            :qid |mapAx1:MapType4Select:3|))
       (forall ((val@@20 T@U)
                (m@@59 T@U)
                (x0@@19 T@U)
                (x1@@13 T@U)
                (x2@@9 T@U)
                (x3@@4 T@U)
                (x4@@4 T@U)
                (y0@@14 T@U)
                (y1@@10 T@U)
                (y2@@7 T@U)
                (y3@@3 T@U)
                (y4@@3 T@U))
         (! (let ((a!1 (= (MapType4Select (MapType4Store m@@59
                                                         x0@@19
                                                         x1@@13
                                                         x2@@9
                                                         x3@@4
                                                         x4@@4
                                                         val@@20)
                                          y0@@14
                                          y1@@10
                                          y2@@7
                                          y3@@3
                                          y4@@3)
                          (MapType4Select m@@59 y0@@14 y1@@10 y2@@7 y3@@3 y4@@3))))
              (or (= x4@@4 y4@@3) a!1))
            :weight 0
            :qid |mapAx1:MapType4Select:4|))
       (forall ((val@@21 T@U)
                (m@@60 T@U)
                (x0@@20 T@U)
                (x1@@14 T@U)
                (x2@@10 T@U)
                (x3@@5 T@U)
                (x4@@5 T@U)
                (y0@@15 T@U)
                (y1@@11 T@U)
                (y2@@8 T@U)
                (y3@@4 T@U)
                (y4@@4 T@U))
         (! (let ((a!1 (= (MapType4Select (MapType4Store m@@60
                                                         x0@@20
                                                         x1@@14
                                                         x2@@10
                                                         x3@@5
                                                         x4@@5
                                                         val@@21)
                                          y0@@15
                                          y1@@11
                                          y2@@8
                                          y3@@4
                                          y4@@4)
                          (MapType4Select m@@60 y0@@15 y1@@11 y2@@8 y3@@4 y4@@4))))
              (or true a!1))
            :weight 0
            :qid |mapAx2:MapType4Select|))
       a!11
       a!12)))
(assert (forall ((t0@@61 T@U)
         (t1@@37 T@U)
         (t2@@14 T@U)
         (t3 T@U)
         (t4 T@U)
         (heap@@16 T@U)
         (h@@39 T@U)
         (r@@18 T@U)
         (rd@@8 T@U)
         (bx0@@27 T@U)
         (bx1@@13 T@U)
         (bx2 T@U)
         (bx3 T@U))
  (! (let ((a!1 (and (= (type t0@@61) TyType)
                     (= (type t1@@37) TyType)
                     (= (type t2@@14) TyType)
                     (= (type t3) TyType)
                     (= (type t4) TyType)
                     (= (type heap@@16) (MapType0Type refType MapType1Type))
                     (= (type h@@39)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@18)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@8)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@27) BoxType)
                     (= (type bx1@@13) BoxType)
                     (= (type bx2) BoxType)
                     (= (type bx3) BoxType))))
       (=> a!1
           (= (Apply4 t0@@61
                      t1@@37
                      t2@@14
                      t3
                      t4
                      heap@@16
                      (Handle4 h@@39 r@@18 rd@@8)
                      bx0@@27
                      bx1@@13
                      bx2
                      bx3)
              (MapType4Select h@@39 heap@@16 bx0@@27 bx1@@13 bx2 bx3))))
     :pattern ((Apply4 t0@@61
                       t1@@37
                       t2@@14
                       t3
                       t4
                       heap@@16
                       (Handle4 h@@39 r@@18 rd@@8)
                       bx0@@27
                       bx1@@13
                       bx2
                       bx3))
     :skolemid |860|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@62 T@U)
         (t1@@38 T@U)
         (t2@@15 T@U)
         (t3@@0 T@U)
         (t4@@0 T@U)
         (heap@@17 T@U)
         (h@@40 T@U)
         (r@@19 T@U)
         (rd@@9 T@U)
         (bx0@@28 T@U)
         (bx1@@14 T@U)
         (bx2@@0 T@U)
         (bx3@@0 T@U))
  (! (let ((a!1 (and (= (type t0@@62) TyType)
                     (= (type t1@@38) TyType)
                     (= (type t2@@15) TyType)
                     (= (type t3@@0) TyType)
                     (= (type t4@@0) TyType)
                     (= (type heap@@17) (MapType0Type refType MapType1Type))
                     (= (type h@@40)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@19)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@9)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@28) BoxType)
                     (= (type bx1@@14) BoxType)
                     (= (type bx2@@0) BoxType)
                     (= (type bx3@@0) BoxType)
                     (U_2_bool (MapType4Select r@@19
                                               heap@@17
                                               bx0@@28
                                               bx1@@14
                                               bx2@@0
                                               bx3@@0)))))
       (=> a!1
           (Requires4 t0@@62
                      t1@@38
                      t2@@15
                      t3@@0
                      t4@@0
                      heap@@17
                      (Handle4 h@@40 r@@19 rd@@9)
                      bx0@@28
                      bx1@@14
                      bx2@@0
                      bx3@@0)))
     :pattern ((Requires4 t0@@62
                          t1@@38
                          t2@@15
                          t3@@0
                          t4@@0
                          heap@@17
                          (Handle4 h@@40 r@@19 rd@@9)
                          bx0@@28
                          bx1@@14
                          bx2@@0
                          bx3@@0))
     :skolemid |861|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@184 T@U)
         (arg1@@92 T@U)
         (arg2@@44 T@U)
         (arg3@@23 T@U)
         (arg4@@15 T@U)
         (arg5@@11 T@U)
         (arg6@@3 T@U)
         (arg7@@0 T@U)
         (arg8@@0 T@U)
         (arg9@@0 T@U)
         (arg10@@0 T@U))
  (! (= (type (Reads4 arg0@@184
                      arg1@@92
                      arg2@@44
                      arg3@@23
                      arg4@@15
                      arg5@@11
                      arg6@@3
                      arg7@@0
                      arg8@@0
                      arg9@@0
                      arg10@@0))
        (MapType0Type BoxType boolType))
     :pattern ((Reads4 arg0@@184
                       arg1@@92
                       arg2@@44
                       arg3@@23
                       arg4@@15
                       arg5@@11
                       arg6@@3
                       arg7@@0
                       arg8@@0
                       arg9@@0
                       arg10@@0))
     :qid |funType:Reads4|)))
(assert (forall ((t0@@63 T@U)
         (t1@@39 T@U)
         (t2@@16 T@U)
         (t3@@1 T@U)
         (t4@@1 T@U)
         (heap@@18 T@U)
         (h@@41 T@U)
         (r@@20 T@U)
         (rd@@10 T@U)
         (bx0@@29 T@U)
         (bx1@@15 T@U)
         (bx2@@1 T@U)
         (bx3@@1 T@U)
         (bx@@51 T@U))
  (! (let ((a!1 (and (= (type t0@@63) TyType)
                     (= (type t1@@39) TyType)
                     (= (type t2@@16) TyType)
                     (= (type t3@@1) TyType)
                     (= (type t4@@1) TyType)
                     (= (type heap@@18) (MapType0Type refType MapType1Type))
                     (= (type h@@41)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@20)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@10)
                        (MapType4Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@29) BoxType)
                     (= (type bx1@@15) BoxType)
                     (= (type bx2@@1) BoxType)
                     (= (type bx3@@1) BoxType)
                     (= (type bx@@51) BoxType)))
           (a!2 (U_2_bool (MapType0Select (Reads4 t0@@63
                                                  t1@@39
                                                  t2@@16
                                                  t3@@1
                                                  t4@@1
                                                  heap@@18
                                                  (Handle4 h@@41 r@@20 rd@@10)
                                                  bx0@@29
                                                  bx1@@15
                                                  bx2@@1
                                                  bx3@@1)
                                          bx@@51))))
     (let ((a!3 (= a!2
                   (U_2_bool (MapType0Select (MapType4Select rd@@10
                                                             heap@@18
                                                             bx0@@29
                                                             bx1@@15
                                                             bx2@@1
                                                             bx3@@1)
                                             bx@@51)))))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (Reads4 t0@@63
                                       t1@@39
                                       t2@@16
                                       t3@@1
                                       t4@@1
                                       heap@@18
                                       (Handle4 h@@41 r@@20 rd@@10)
                                       bx0@@29
                                       bx1@@15
                                       bx2@@1
                                       bx3@@1)
                               bx@@51))
     :skolemid |862|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@64 T@U)
         (t1@@40 T@U)
         (t2@@17 T@U)
         (t3@@2 T@U)
         (t4@@2 T@U)
         (h0@@18 T@U)
         (h1@@18 T@U)
         (f@@41 T@U)
         (bx0@@30 T@U)
         (bx1@@16 T@U)
         (bx2@@2 T@U)
         (bx3@@2 T@U))
  (! (let ((a!1 (forall ((o@@62 T@U) (fld@@17 T@U))
                  (! (let ((a!1 (= (type fld@@17)
                                   (FieldType (FieldTypeInv0 (type fld@@17))))))
                     (let ((a!2 (and (= (type o@@62) refType)
                                     a!1
                                     (not (= o@@62 null))
                                     (U_2_bool (MapType0Select (Reads4 t0@@64
                                                                       t1@@40
                                                                       t2@@17
                                                                       t3@@2
                                                                       t4@@2
                                                                       h0@@18
                                                                       f@@41
                                                                       bx0@@30
                                                                       bx1@@16
                                                                       bx2@@2
                                                                       bx3@@2)
                                                               ($Box o@@62))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@18 o@@62)
                                              fld@@17)
                              (MapType1Select (MapType0Select h1@@18 o@@62)
                                              fld@@17)))))
                     :no-pattern (type o@@62)
                     :no-pattern (type fld@@17)
                     :no-pattern (U_2_int o@@62)
                     :no-pattern (U_2_bool o@@62)
                     :no-pattern (U_2_int fld@@17)
                     :no-pattern (U_2_bool fld@@17)
                     :skolemid |863|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@64) TyType)
                (= (type t1@@40) TyType)
                (= (type t2@@17) TyType)
                (= (type t3@@2) TyType)
                (= (type t4@@2) TyType)
                (= (type h0@@18) (MapType0Type refType MapType1Type))
                (= (type h1@@18) (MapType0Type refType MapType1Type))
                (= (type f@@41) HandleTypeType)
                (= (type bx0@@30) BoxType)
                (= (type bx1@@16) BoxType)
                (= (type bx2@@2) BoxType)
                (= (type bx3@@2) BoxType)
                ($HeapSucc h0@@18 h1@@18)
                ($IsGoodHeap h0@@18)
                ($IsGoodHeap h1@@18)
                ($IsBox bx0@@30 t0@@64)
                ($IsBox bx1@@16 t1@@40)
                ($IsBox bx2@@2 t2@@17)
                ($IsBox bx3@@2 t3@@2)
                ($Is f@@41
                     (Tclass._System.___hFunc4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2))
                a!1)
           (= (Reads4 t0@@64
                      t1@@40
                      t2@@17
                      t3@@2
                      t4@@2
                      h0@@18
                      f@@41
                      bx0@@30
                      bx1@@16
                      bx2@@2
                      bx3@@2)
              (Reads4 t0@@64
                      t1@@40
                      t2@@17
                      t3@@2
                      t4@@2
                      h1@@18
                      f@@41
                      bx0@@30
                      bx1@@16
                      bx2@@2
                      bx3@@2))))
     :pattern (($HeapSucc h0@@18 h1@@18)
               (Reads4 t0@@64
                       t1@@40
                       t2@@17
                       t3@@2
                       t4@@2
                       h1@@18
                       f@@41
                       bx0@@30
                       bx1@@16
                       bx2@@2
                       bx3@@2))
     :skolemid |864|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@65 T@U)
         (t1@@41 T@U)
         (t2@@18 T@U)
         (t3@@3 T@U)
         (t4@@3 T@U)
         (h0@@19 T@U)
         (h1@@19 T@U)
         (f@@42 T@U)
         (bx0@@31 T@U)
         (bx1@@17 T@U)
         (bx2@@3 T@U)
         (bx3@@3 T@U))
  (! (let ((a!1 (forall ((o@@63 T@U) (fld@@18 T@U))
                  (! (let ((a!1 (= (type fld@@18)
                                   (FieldType (FieldTypeInv0 (type fld@@18))))))
                     (let ((a!2 (and (= (type o@@63) refType)
                                     a!1
                                     (not (= o@@63 null))
                                     (U_2_bool (MapType0Select (Reads4 t0@@65
                                                                       t1@@41
                                                                       t2@@18
                                                                       t3@@3
                                                                       t4@@3
                                                                       h1@@19
                                                                       f@@42
                                                                       bx0@@31
                                                                       bx1@@17
                                                                       bx2@@3
                                                                       bx3@@3)
                                                               ($Box o@@63))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@19 o@@63)
                                              fld@@18)
                              (MapType1Select (MapType0Select h1@@19 o@@63)
                                              fld@@18)))))
                     :no-pattern (type o@@63)
                     :no-pattern (type fld@@18)
                     :no-pattern (U_2_int o@@63)
                     :no-pattern (U_2_bool o@@63)
                     :no-pattern (U_2_int fld@@18)
                     :no-pattern (U_2_bool fld@@18)
                     :skolemid |865|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@65) TyType)
                (= (type t1@@41) TyType)
                (= (type t2@@18) TyType)
                (= (type t3@@3) TyType)
                (= (type t4@@3) TyType)
                (= (type h0@@19) (MapType0Type refType MapType1Type))
                (= (type h1@@19) (MapType0Type refType MapType1Type))
                (= (type f@@42) HandleTypeType)
                (= (type bx0@@31) BoxType)
                (= (type bx1@@17) BoxType)
                (= (type bx2@@3) BoxType)
                (= (type bx3@@3) BoxType)
                ($HeapSucc h0@@19 h1@@19)
                ($IsGoodHeap h0@@19)
                ($IsGoodHeap h1@@19)
                ($IsBox bx0@@31 t0@@65)
                ($IsBox bx1@@17 t1@@41)
                ($IsBox bx2@@3 t2@@18)
                ($IsBox bx3@@3 t3@@3)
                ($Is f@@42
                     (Tclass._System.___hFunc4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3))
                a!1)
           (= (Reads4 t0@@65
                      t1@@41
                      t2@@18
                      t3@@3
                      t4@@3
                      h0@@19
                      f@@42
                      bx0@@31
                      bx1@@17
                      bx2@@3
                      bx3@@3)
              (Reads4 t0@@65
                      t1@@41
                      t2@@18
                      t3@@3
                      t4@@3
                      h1@@19
                      f@@42
                      bx0@@31
                      bx1@@17
                      bx2@@3
                      bx3@@3))))
     :pattern (($HeapSucc h0@@19 h1@@19)
               (Reads4 t0@@65
                       t1@@41
                       t2@@18
                       t3@@3
                       t4@@3
                       h1@@19
                       f@@42
                       bx0@@31
                       bx1@@17
                       bx2@@3
                       bx3@@3))
     :skolemid |866|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@66 T@U)
         (t1@@42 T@U)
         (t2@@19 T@U)
         (t3@@4 T@U)
         (t4@@4 T@U)
         (h0@@20 T@U)
         (h1@@20 T@U)
         (f@@43 T@U)
         (bx0@@32 T@U)
         (bx1@@18 T@U)
         (bx2@@4 T@U)
         (bx3@@4 T@U))
  (! (let ((a!1 (forall ((o@@64 T@U) (fld@@19 T@U))
                  (! (let ((a!1 (= (type fld@@19)
                                   (FieldType (FieldTypeInv0 (type fld@@19))))))
                     (let ((a!2 (and (= (type o@@64) refType)
                                     a!1
                                     (not (= o@@64 null))
                                     (U_2_bool (MapType0Select (Reads4 t0@@66
                                                                       t1@@42
                                                                       t2@@19
                                                                       t3@@4
                                                                       t4@@4
                                                                       h0@@20
                                                                       f@@43
                                                                       bx0@@32
                                                                       bx1@@18
                                                                       bx2@@4
                                                                       bx3@@4)
                                                               ($Box o@@64))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@20 o@@64)
                                              fld@@19)
                              (MapType1Select (MapType0Select h1@@20 o@@64)
                                              fld@@19)))))
                     :no-pattern (type o@@64)
                     :no-pattern (type fld@@19)
                     :no-pattern (U_2_int o@@64)
                     :no-pattern (U_2_bool o@@64)
                     :no-pattern (U_2_int fld@@19)
                     :no-pattern (U_2_bool fld@@19)
                     :skolemid |867|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@66) TyType)
                (= (type t1@@42) TyType)
                (= (type t2@@19) TyType)
                (= (type t3@@4) TyType)
                (= (type t4@@4) TyType)
                (= (type h0@@20) (MapType0Type refType MapType1Type))
                (= (type h1@@20) (MapType0Type refType MapType1Type))
                (= (type f@@43) HandleTypeType)
                (= (type bx0@@32) BoxType)
                (= (type bx1@@18) BoxType)
                (= (type bx2@@4) BoxType)
                (= (type bx3@@4) BoxType)
                ($HeapSucc h0@@20 h1@@20)
                ($IsGoodHeap h0@@20)
                ($IsGoodHeap h1@@20)
                ($IsBox bx0@@32 t0@@66)
                ($IsBox bx1@@18 t1@@42)
                ($IsBox bx2@@4 t2@@19)
                ($IsBox bx3@@4 t3@@4)
                ($Is f@@43
                     (Tclass._System.___hFunc4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4))
                a!1)
           (= (Requires4 t0@@66
                         t1@@42
                         t2@@19
                         t3@@4
                         t4@@4
                         h0@@20
                         f@@43
                         bx0@@32
                         bx1@@18
                         bx2@@4
                         bx3@@4)
              (Requires4 t0@@66
                         t1@@42
                         t2@@19
                         t3@@4
                         t4@@4
                         h1@@20
                         f@@43
                         bx0@@32
                         bx1@@18
                         bx2@@4
                         bx3@@4))))
     :pattern (($HeapSucc h0@@20 h1@@20)
               (Requires4 t0@@66
                          t1@@42
                          t2@@19
                          t3@@4
                          t4@@4
                          h1@@20
                          f@@43
                          bx0@@32
                          bx1@@18
                          bx2@@4
                          bx3@@4))
     :skolemid |868|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@67 T@U)
         (t1@@43 T@U)
         (t2@@20 T@U)
         (t3@@5 T@U)
         (t4@@5 T@U)
         (h0@@21 T@U)
         (h1@@21 T@U)
         (f@@44 T@U)
         (bx0@@33 T@U)
         (bx1@@19 T@U)
         (bx2@@5 T@U)
         (bx3@@5 T@U))
  (! (let ((a!1 (forall ((o@@65 T@U) (fld@@20 T@U))
                  (! (let ((a!1 (= (type fld@@20)
                                   (FieldType (FieldTypeInv0 (type fld@@20))))))
                     (let ((a!2 (and (= (type o@@65) refType)
                                     a!1
                                     (not (= o@@65 null))
                                     (U_2_bool (MapType0Select (Reads4 t0@@67
                                                                       t1@@43
                                                                       t2@@20
                                                                       t3@@5
                                                                       t4@@5
                                                                       h1@@21
                                                                       f@@44
                                                                       bx0@@33
                                                                       bx1@@19
                                                                       bx2@@5
                                                                       bx3@@5)
                                                               ($Box o@@65))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@21 o@@65)
                                              fld@@20)
                              (MapType1Select (MapType0Select h1@@21 o@@65)
                                              fld@@20)))))
                     :no-pattern (type o@@65)
                     :no-pattern (type fld@@20)
                     :no-pattern (U_2_int o@@65)
                     :no-pattern (U_2_bool o@@65)
                     :no-pattern (U_2_int fld@@20)
                     :no-pattern (U_2_bool fld@@20)
                     :skolemid |869|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@67) TyType)
                (= (type t1@@43) TyType)
                (= (type t2@@20) TyType)
                (= (type t3@@5) TyType)
                (= (type t4@@5) TyType)
                (= (type h0@@21) (MapType0Type refType MapType1Type))
                (= (type h1@@21) (MapType0Type refType MapType1Type))
                (= (type f@@44) HandleTypeType)
                (= (type bx0@@33) BoxType)
                (= (type bx1@@19) BoxType)
                (= (type bx2@@5) BoxType)
                (= (type bx3@@5) BoxType)
                ($HeapSucc h0@@21 h1@@21)
                ($IsGoodHeap h0@@21)
                ($IsGoodHeap h1@@21)
                ($IsBox bx0@@33 t0@@67)
                ($IsBox bx1@@19 t1@@43)
                ($IsBox bx2@@5 t2@@20)
                ($IsBox bx3@@5 t3@@5)
                ($Is f@@44
                     (Tclass._System.___hFunc4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5))
                a!1)
           (= (Requires4 t0@@67
                         t1@@43
                         t2@@20
                         t3@@5
                         t4@@5
                         h0@@21
                         f@@44
                         bx0@@33
                         bx1@@19
                         bx2@@5
                         bx3@@5)
              (Requires4 t0@@67
                         t1@@43
                         t2@@20
                         t3@@5
                         t4@@5
                         h1@@21
                         f@@44
                         bx0@@33
                         bx1@@19
                         bx2@@5
                         bx3@@5))))
     :pattern (($HeapSucc h0@@21 h1@@21)
               (Requires4 t0@@67
                          t1@@43
                          t2@@20
                          t3@@5
                          t4@@5
                          h1@@21
                          f@@44
                          bx0@@33
                          bx1@@19
                          bx2@@5
                          bx3@@5))
     :skolemid |870|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@68 T@U)
         (t1@@44 T@U)
         (t2@@21 T@U)
         (t3@@6 T@U)
         (t4@@6 T@U)
         (h0@@22 T@U)
         (h1@@22 T@U)
         (f@@45 T@U)
         (bx0@@34 T@U)
         (bx1@@20 T@U)
         (bx2@@6 T@U)
         (bx3@@6 T@U))
  (! (let ((a!1 (forall ((o@@66 T@U) (fld@@21 T@U))
                  (! (let ((a!1 (= (type fld@@21)
                                   (FieldType (FieldTypeInv0 (type fld@@21))))))
                     (let ((a!2 (and (= (type o@@66) refType)
                                     a!1
                                     (not (= o@@66 null))
                                     (U_2_bool (MapType0Select (Reads4 t0@@68
                                                                       t1@@44
                                                                       t2@@21
                                                                       t3@@6
                                                                       t4@@6
                                                                       h0@@22
                                                                       f@@45
                                                                       bx0@@34
                                                                       bx1@@20
                                                                       bx2@@6
                                                                       bx3@@6)
                                                               ($Box o@@66))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@22 o@@66)
                                              fld@@21)
                              (MapType1Select (MapType0Select h1@@22 o@@66)
                                              fld@@21)))))
                     :no-pattern (type o@@66)
                     :no-pattern (type fld@@21)
                     :no-pattern (U_2_int o@@66)
                     :no-pattern (U_2_bool o@@66)
                     :no-pattern (U_2_int fld@@21)
                     :no-pattern (U_2_bool fld@@21)
                     :skolemid |871|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@68) TyType)
                (= (type t1@@44) TyType)
                (= (type t2@@21) TyType)
                (= (type t3@@6) TyType)
                (= (type t4@@6) TyType)
                (= (type h0@@22) (MapType0Type refType MapType1Type))
                (= (type h1@@22) (MapType0Type refType MapType1Type))
                (= (type f@@45) HandleTypeType)
                (= (type bx0@@34) BoxType)
                (= (type bx1@@20) BoxType)
                (= (type bx2@@6) BoxType)
                (= (type bx3@@6) BoxType)
                ($HeapSucc h0@@22 h1@@22)
                ($IsGoodHeap h0@@22)
                ($IsGoodHeap h1@@22)
                ($IsBox bx0@@34 t0@@68)
                ($IsBox bx1@@20 t1@@44)
                ($IsBox bx2@@6 t2@@21)
                ($IsBox bx3@@6 t3@@6)
                ($Is f@@45
                     (Tclass._System.___hFunc4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6))
                a!1)
           (= (Apply4 t0@@68
                      t1@@44
                      t2@@21
                      t3@@6
                      t4@@6
                      h0@@22
                      f@@45
                      bx0@@34
                      bx1@@20
                      bx2@@6
                      bx3@@6)
              (Apply4 t0@@68
                      t1@@44
                      t2@@21
                      t3@@6
                      t4@@6
                      h1@@22
                      f@@45
                      bx0@@34
                      bx1@@20
                      bx2@@6
                      bx3@@6))))
     :pattern (($HeapSucc h0@@22 h1@@22)
               (Apply4 t0@@68
                       t1@@44
                       t2@@21
                       t3@@6
                       t4@@6
                       h1@@22
                       f@@45
                       bx0@@34
                       bx1@@20
                       bx2@@6
                       bx3@@6))
     :skolemid |872|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@69 T@U)
         (t1@@45 T@U)
         (t2@@22 T@U)
         (t3@@7 T@U)
         (t4@@7 T@U)
         (h0@@23 T@U)
         (h1@@23 T@U)
         (f@@46 T@U)
         (bx0@@35 T@U)
         (bx1@@21 T@U)
         (bx2@@7 T@U)
         (bx3@@7 T@U))
  (! (let ((a!1 (forall ((o@@67 T@U) (fld@@22 T@U))
                  (! (let ((a!1 (= (type fld@@22)
                                   (FieldType (FieldTypeInv0 (type fld@@22))))))
                     (let ((a!2 (and (= (type o@@67) refType)
                                     a!1
                                     (not (= o@@67 null))
                                     (U_2_bool (MapType0Select (Reads4 t0@@69
                                                                       t1@@45
                                                                       t2@@22
                                                                       t3@@7
                                                                       t4@@7
                                                                       h1@@23
                                                                       f@@46
                                                                       bx0@@35
                                                                       bx1@@21
                                                                       bx2@@7
                                                                       bx3@@7)
                                                               ($Box o@@67))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@23 o@@67)
                                              fld@@22)
                              (MapType1Select (MapType0Select h1@@23 o@@67)
                                              fld@@22)))))
                     :no-pattern (type o@@67)
                     :no-pattern (type fld@@22)
                     :no-pattern (U_2_int o@@67)
                     :no-pattern (U_2_bool o@@67)
                     :no-pattern (U_2_int fld@@22)
                     :no-pattern (U_2_bool fld@@22)
                     :skolemid |873|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@69) TyType)
                (= (type t1@@45) TyType)
                (= (type t2@@22) TyType)
                (= (type t3@@7) TyType)
                (= (type t4@@7) TyType)
                (= (type h0@@23) (MapType0Type refType MapType1Type))
                (= (type h1@@23) (MapType0Type refType MapType1Type))
                (= (type f@@46) HandleTypeType)
                (= (type bx0@@35) BoxType)
                (= (type bx1@@21) BoxType)
                (= (type bx2@@7) BoxType)
                (= (type bx3@@7) BoxType)
                ($HeapSucc h0@@23 h1@@23)
                ($IsGoodHeap h0@@23)
                ($IsGoodHeap h1@@23)
                ($IsBox bx0@@35 t0@@69)
                ($IsBox bx1@@21 t1@@45)
                ($IsBox bx2@@7 t2@@22)
                ($IsBox bx3@@7 t3@@7)
                ($Is f@@46
                     (Tclass._System.___hFunc4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7))
                a!1)
           (= (Apply4 t0@@69
                      t1@@45
                      t2@@22
                      t3@@7
                      t4@@7
                      h0@@23
                      f@@46
                      bx0@@35
                      bx1@@21
                      bx2@@7
                      bx3@@7)
              (Apply4 t0@@69
                      t1@@45
                      t2@@22
                      t3@@7
                      t4@@7
                      h1@@23
                      f@@46
                      bx0@@35
                      bx1@@21
                      bx2@@7
                      bx3@@7))))
     :pattern (($HeapSucc h0@@23 h1@@23)
               (Apply4 t0@@69
                       t1@@45
                       t2@@22
                       t3@@7
                       t4@@7
                       h1@@23
                       f@@46
                       bx0@@35
                       bx1@@21
                       bx2@@7
                       bx3@@7))
     :skolemid |874|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@70 T@U)
         (t1@@46 T@U)
         (t2@@23 T@U)
         (t3@@8 T@U)
         (t4@@8 T@U)
         (heap@@19 T@U)
         (f@@47 T@U)
         (bx0@@36 T@U)
         (bx1@@22 T@U)
         (bx2@@8 T@U)
         (bx3@@8 T@U))
  (! (=> (and (= (type t0@@70) TyType)
              (= (type t1@@46) TyType)
              (= (type t2@@23) TyType)
              (= (type t3@@8) TyType)
              (= (type t4@@8) TyType)
              (= (type heap@@19) (MapType0Type refType MapType1Type))
              (= (type f@@47) HandleTypeType)
              (= (type bx0@@36) BoxType)
              (= (type bx1@@22) BoxType)
              (= (type bx2@@8) BoxType)
              (= (type bx3@@8) BoxType)
              ($IsGoodHeap heap@@19)
              ($IsBox bx0@@36 t0@@70)
              ($IsBox bx1@@22 t1@@46)
              ($IsBox bx2@@8 t2@@23)
              ($IsBox bx3@@8 t3@@8)
              ($Is f@@47
                   (Tclass._System.___hFunc4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8)))
         (= (|Set#Equal| (Reads4 t0@@70
                                 t1@@46
                                 t2@@23
                                 t3@@8
                                 t4@@8
                                 $OneHeap
                                 f@@47
                                 bx0@@36
                                 bx1@@22
                                 bx2@@8
                                 bx3@@8)
                         (|Set#Empty| BoxType))
            (|Set#Equal| (Reads4 t0@@70
                                 t1@@46
                                 t2@@23
                                 t3@@8
                                 t4@@8
                                 heap@@19
                                 f@@47
                                 bx0@@36
                                 bx1@@22
                                 bx2@@8
                                 bx3@@8)
                         (|Set#Empty| BoxType))))
     :pattern ((Reads4 t0@@70
                       t1@@46
                       t2@@23
                       t3@@8
                       t4@@8
                       $OneHeap
                       f@@47
                       bx0@@36
                       bx1@@22
                       bx2@@8
                       bx3@@8)
               ($IsGoodHeap heap@@19))
     :pattern ((Reads4 t0@@70
                       t1@@46
                       t2@@23
                       t3@@8
                       t4@@8
                       heap@@19
                       f@@47
                       bx0@@36
                       bx1@@22
                       bx2@@8
                       bx3@@8))
     :skolemid |875|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@71 T@U)
         (t1@@47 T@U)
         (t2@@24 T@U)
         (t3@@9 T@U)
         (t4@@9 T@U)
         (heap@@20 T@U)
         (f@@48 T@U)
         (bx0@@37 T@U)
         (bx1@@23 T@U)
         (bx2@@9 T@U)
         (bx3@@9 T@U))
  (! (=> (and (= (type t0@@71) TyType)
              (= (type t1@@47) TyType)
              (= (type t2@@24) TyType)
              (= (type t3@@9) TyType)
              (= (type t4@@9) TyType)
              (= (type heap@@20) (MapType0Type refType MapType1Type))
              (= (type f@@48) HandleTypeType)
              (= (type bx0@@37) BoxType)
              (= (type bx1@@23) BoxType)
              (= (type bx2@@9) BoxType)
              (= (type bx3@@9) BoxType)
              ($IsGoodHeap heap@@20)
              ($IsBox bx0@@37 t0@@71)
              ($IsBox bx1@@23 t1@@47)
              ($IsBox bx2@@9 t2@@24)
              ($IsBox bx3@@9 t3@@9)
              ($Is f@@48
                   (Tclass._System.___hFunc4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9))
              (|Set#Equal| (Reads4 t0@@71
                                   t1@@47
                                   t2@@24
                                   t3@@9
                                   t4@@9
                                   $OneHeap
                                   f@@48
                                   bx0@@37
                                   bx1@@23
                                   bx2@@9
                                   bx3@@9)
                           (|Set#Empty| BoxType)))
         (= (Requires4 t0@@71
                       t1@@47
                       t2@@24
                       t3@@9
                       t4@@9
                       $OneHeap
                       f@@48
                       bx0@@37
                       bx1@@23
                       bx2@@9
                       bx3@@9)
            (Requires4 t0@@71
                       t1@@47
                       t2@@24
                       t3@@9
                       t4@@9
                       heap@@20
                       f@@48
                       bx0@@37
                       bx1@@23
                       bx2@@9
                       bx3@@9)))
     :pattern ((Requires4 t0@@71
                          t1@@47
                          t2@@24
                          t3@@9
                          t4@@9
                          $OneHeap
                          f@@48
                          bx0@@37
                          bx1@@23
                          bx2@@9
                          bx3@@9)
               ($IsGoodHeap heap@@20))
     :pattern ((Requires4 t0@@71
                          t1@@47
                          t2@@24
                          t3@@9
                          t4@@9
                          heap@@20
                          f@@48
                          bx0@@37
                          bx1@@23
                          bx2@@9
                          bx3@@9))
     :skolemid |876|
     :qid |unknown.0:0|)))
(assert (forall ((f@@49 T@U)
         (t0@@72 T@U)
         (t1@@48 T@U)
         (t2@@25 T@U)
         (t3@@10 T@U)
         (t4@@10 T@U))
  (! (let ((a!1 (forall ((h@@42 T@U)
                         (bx0@@38 T@U)
                         (bx1@@24 T@U)
                         (bx2@@10 T@U)
                         (bx3@@10 T@U))
                  (! (=> (and (= (type h@@42)
                                 (MapType0Type refType MapType1Type))
                              (= (type bx0@@38) BoxType)
                              (= (type bx1@@24) BoxType)
                              (= (type bx2@@10) BoxType)
                              (= (type bx3@@10) BoxType)
                              ($IsGoodHeap h@@42)
                              ($IsBox bx0@@38 t0@@72)
                              ($IsBox bx1@@24 t1@@48)
                              ($IsBox bx2@@10 t2@@25)
                              ($IsBox bx3@@10 t3@@10)
                              (Requires4 t0@@72
                                         t1@@48
                                         t2@@25
                                         t3@@10
                                         t4@@10
                                         h@@42
                                         f@@49
                                         bx0@@38
                                         bx1@@24
                                         bx2@@10
                                         bx3@@10))
                         ($IsBox (Apply4 t0@@72
                                         t1@@48
                                         t2@@25
                                         t3@@10
                                         t4@@10
                                         h@@42
                                         f@@49
                                         bx0@@38
                                         bx1@@24
                                         bx2@@10
                                         bx3@@10)
                                 t4@@10))
                     :pattern ((Apply4 t0@@72
                                       t1@@48
                                       t2@@25
                                       t3@@10
                                       t4@@10
                                       h@@42
                                       f@@49
                                       bx0@@38
                                       bx1@@24
                                       bx2@@10
                                       bx3@@10))
                     :skolemid |877|
                     :qid |DafnyPreludebpl.545:12|))))
       (=> (and (= (type f@@49) HandleTypeType)
                (= (type t0@@72) TyType)
                (= (type t1@@48) TyType)
                (= (type t2@@25) TyType)
                (= (type t3@@10) TyType)
                (= (type t4@@10) TyType))
           (= ($Is f@@49
                   (Tclass._System.___hFunc4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10))
              a!1)))
     :pattern (($Is f@@49
                    (Tclass._System.___hFunc4
                      t0@@72
                      t1@@48
                      t2@@25
                      t3@@10
                      t4@@10)))
     :skolemid |878|
     :qid |unknown.0:0|)))
(assert (forall ((f@@50 T@U)
         (t0@@73 T@U)
         (t1@@49 T@U)
         (t2@@26 T@U)
         (t3@@11 T@U)
         (t4@@11 T@U)
         (u0@@2 T@U)
         (u1@@1 T@U)
         (u2@@0 T@U)
         (u3 T@U)
         (u4 T@U))
  (! (let ((a!1 (forall ((bx@@52 T@U))
                  (! (=> (and (= (type bx@@52) BoxType) ($IsBox bx@@52 u0@@2))
                         ($IsBox bx@@52 t0@@73))
                     :pattern (($IsBox bx@@52 u0@@2))
                     :pattern (($IsBox bx@@52 t0@@73))
                     :skolemid |879|
                     :qid |unknown.0:0|)))
           (a!2 (forall ((bx@@53 T@U))
                  (! (=> (and (= (type bx@@53) BoxType) ($IsBox bx@@53 u1@@1))
                         ($IsBox bx@@53 t1@@49))
                     :pattern (($IsBox bx@@53 u1@@1))
                     :pattern (($IsBox bx@@53 t1@@49))
                     :skolemid |880|
                     :qid |unknown.0:0|)))
           (a!3 (forall ((bx@@54 T@U))
                  (! (=> (and (= (type bx@@54) BoxType) ($IsBox bx@@54 u2@@0))
                         ($IsBox bx@@54 t2@@26))
                     :pattern (($IsBox bx@@54 u2@@0))
                     :pattern (($IsBox bx@@54 t2@@26))
                     :skolemid |881|
                     :qid |unknown.0:0|)))
           (a!4 (forall ((bx@@55 T@U))
                  (! (=> (and (= (type bx@@55) BoxType) ($IsBox bx@@55 u3))
                         ($IsBox bx@@55 t3@@11))
                     :pattern (($IsBox bx@@55 u3))
                     :pattern (($IsBox bx@@55 t3@@11))
                     :skolemid |882|
                     :qid |unknown.0:0|)))
           (a!5 (forall ((bx@@56 T@U))
                  (! (=> (and (= (type bx@@56) BoxType) ($IsBox bx@@56 t4@@11))
                         ($IsBox bx@@56 u4))
                     :pattern (($IsBox bx@@56 t4@@11))
                     :pattern (($IsBox bx@@56 u4))
                     :skolemid |883|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@50) HandleTypeType)
                (= (type t0@@73) TyType)
                (= (type t1@@49) TyType)
                (= (type t2@@26) TyType)
                (= (type t3@@11) TyType)
                (= (type t4@@11) TyType)
                (= (type u0@@2) TyType)
                (= (type u1@@1) TyType)
                (= (type u2@@0) TyType)
                (= (type u3) TyType)
                (= (type u4) TyType)
                ($Is f@@50
                     (Tclass._System.___hFunc4
                       t0@@73
                       t1@@49
                       t2@@26
                       t3@@11
                       t4@@11))
                a!1
                a!2
                a!3
                a!4
                a!5)
           ($Is f@@50 (Tclass._System.___hFunc4 u0@@2 u1@@1 u2@@0 u3 u4))))
     :pattern (($Is f@@50
                    (Tclass._System.___hFunc4
                      t0@@73
                      t1@@49
                      t2@@26
                      t3@@11
                      t4@@11))
               ($Is f@@50 (Tclass._System.___hFunc4 u0@@2 u1@@1 u2@@0 u3 u4)))
     :skolemid |884|
     :qid |unknown.0:0|)))
(assert (forall ((f@@51 T@U)
         (t0@@74 T@U)
         (t1@@50 T@U)
         (t2@@27 T@U)
         (t3@@12 T@U)
         (t4@@12 T@U)
         (h@@43 T@U))
  (! (let ((a!1 (forall ((bx0@@39 T@U)
                         (bx1@@25 T@U)
                         (bx2@@11 T@U)
                         (bx3@@11 T@U))
                  (! (let ((a!1 (forall ((r@@21 T@U))
                                  (! (let ((a!1 (and (not (= r@@21 null))
                                                     (U_2_bool (MapType0Select (Reads4 t0@@74
                                                                                       t1@@50
                                                                                       t2@@27
                                                                                       t3@@12
                                                                                       t4@@12
                                                                                       h@@43
                                                                                       f@@51
                                                                                       bx0@@39
                                                                                       bx1@@25
                                                                                       bx2@@11
                                                                                       bx3@@11)
                                                                               ($Box r@@21))))))
                                     (let ((a!2 (=> a!1
                                                    (U_2_bool (MapType1Select (MapType0Select h@@43
                                                                                              r@@21)
                                                                              alloc)))))
                                       (=> (= (type r@@21) refType) a!2)))
                                     :pattern ((MapType0Select (Reads4 t0@@74
                                                                       t1@@50
                                                                       t2@@27
                                                                       t3@@12
                                                                       t4@@12
                                                                       h@@43
                                                                       f@@51
                                                                       bx0@@39
                                                                       bx1@@25
                                                                       bx2@@11
                                                                       bx3@@11)
                                                               ($Box r@@21)))
                                     :skolemid |885|
                                     :qid |unknown.0:0|))))
                       (=> (and (= (type bx0@@39) BoxType)
                                (= (type bx1@@25) BoxType)
                                (= (type bx2@@11) BoxType)
                                (= (type bx3@@11) BoxType))
                           (=> (and ($IsBox bx0@@39 t0@@74)
                                    ($IsAllocBox bx0@@39 t0@@74 h@@43)
                                    ($IsBox bx1@@25 t1@@50)
                                    ($IsAllocBox bx1@@25 t1@@50 h@@43)
                                    ($IsBox bx2@@11 t2@@27)
                                    ($IsAllocBox bx2@@11 t2@@27 h@@43)
                                    ($IsBox bx3@@11 t3@@12)
                                    ($IsAllocBox bx3@@11 t3@@12 h@@43)
                                    (Requires4 t0@@74
                                               t1@@50
                                               t2@@27
                                               t3@@12
                                               t4@@12
                                               h@@43
                                               f@@51
                                               bx0@@39
                                               bx1@@25
                                               bx2@@11
                                               bx3@@11))
                               a!1)))
                     :pattern ((Apply4 t0@@74
                                       t1@@50
                                       t2@@27
                                       t3@@12
                                       t4@@12
                                       h@@43
                                       f@@51
                                       bx0@@39
                                       bx1@@25
                                       bx2@@11
                                       bx3@@11))
                     :pattern ((Reads4 t0@@74
                                       t1@@50
                                       t2@@27
                                       t3@@12
                                       t4@@12
                                       h@@43
                                       f@@51
                                       bx0@@39
                                       bx1@@25
                                       bx2@@11
                                       bx3@@11))
                     :skolemid |886|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@51) HandleTypeType)
                (= (type t0@@74) TyType)
                (= (type t1@@50) TyType)
                (= (type t2@@27) TyType)
                (= (type t3@@12) TyType)
                (= (type t4@@12) TyType)
                (= (type h@@43) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@43))
           (= ($IsAlloc f@@51
                        (Tclass._System.___hFunc4
                          t0@@74
                          t1@@50
                          t2@@27
                          t3@@12
                          t4@@12)
                        h@@43)
              a!1)))
     :pattern (($IsAlloc f@@51
                         (Tclass._System.___hFunc4
                           t0@@74
                           t1@@50
                           t2@@27
                           t3@@12
                           t4@@12)
                         h@@43))
     :skolemid |887|
     :qid |unknown.0:0|)))
(assert (forall ((f@@52 T@U)
         (t0@@75 T@U)
         (t1@@51 T@U)
         (t2@@28 T@U)
         (t3@@13 T@U)
         (t4@@13 T@U)
         (h@@44 T@U))
  (! (let ((a!1 (forall ((bx0@@40 T@U)
                         (bx1@@26 T@U)
                         (bx2@@12 T@U)
                         (bx3@@12 T@U))
                  (! (=> (and (= (type bx0@@40) BoxType)
                              (= (type bx1@@26) BoxType)
                              (= (type bx2@@12) BoxType)
                              (= (type bx3@@12) BoxType))
                         (=> (and ($IsAllocBox bx0@@40 t0@@75 h@@44)
                                  ($IsAllocBox bx1@@26 t1@@51 h@@44)
                                  ($IsAllocBox bx2@@12 t2@@28 h@@44)
                                  ($IsAllocBox bx3@@12 t3@@13 h@@44)
                                  (Requires4 t0@@75
                                             t1@@51
                                             t2@@28
                                             t3@@13
                                             t4@@13
                                             h@@44
                                             f@@52
                                             bx0@@40
                                             bx1@@26
                                             bx2@@12
                                             bx3@@12))
                             ($IsAllocBox (Apply4 t0@@75
                                                  t1@@51
                                                  t2@@28
                                                  t3@@13
                                                  t4@@13
                                                  h@@44
                                                  f@@52
                                                  bx0@@40
                                                  bx1@@26
                                                  bx2@@12
                                                  bx3@@12)
                                          t4@@13
                                          h@@44)))
                     :pattern ((Apply4 t0@@75
                                       t1@@51
                                       t2@@28
                                       t3@@13
                                       t4@@13
                                       h@@44
                                       f@@52
                                       bx0@@40
                                       bx1@@26
                                       bx2@@12
                                       bx3@@12))
                     :skolemid |888|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@52) HandleTypeType)
                (= (type t0@@75) TyType)
                (= (type t1@@51) TyType)
                (= (type t2@@28) TyType)
                (= (type t3@@13) TyType)
                (= (type t4@@13) TyType)
                (= (type h@@44) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@44)
                ($IsAlloc f@@52
                          (Tclass._System.___hFunc4
                            t0@@75
                            t1@@51
                            t2@@28
                            t3@@13
                            t4@@13)
                          h@@44))
           a!1))
     :pattern (($IsAlloc f@@52
                         (Tclass._System.___hFunc4
                           t0@@75
                           t1@@51
                           t2@@28
                           t3@@13
                           t4@@13)
                         h@@44))
     :skolemid |889|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@185 T@U)
         (arg1@@93 T@U)
         (arg2@@45 T@U)
         (arg3@@24 T@U)
         (arg4@@16 T@U))
  (! (= (type (Tclass._System.___hPartialFunc4
                arg0@@185
                arg1@@93
                arg2@@45
                arg3@@24
                arg4@@16))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc4
                 arg0@@185
                 arg1@@93
                 arg2@@45
                 arg3@@24
                 arg4@@16))
     :qid |funType:Tclass._System.___hPartialFunc4|)))
(assert (forall ((|#$T0@@41| T@U)
         (|#$T1@@25| T@U)
         (|#$T2@@6| T@U)
         (|#$T3@@6| T@U)
         (|#$R@@54| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc4
                               |#$T0@@41|
                               |#$T1@@25|
                               |#$T2@@6|
                               |#$T3@@6|
                               |#$R@@54|))
                        Tagclass._System.___hPartialFunc4)
                     (= (TagFamily (Tclass._System.___hPartialFunc4
                                     |#$T0@@41|
                                     |#$T1@@25|
                                     |#$T2@@6|
                                     |#$T3@@6|
                                     |#$R@@54|))
                        |tytagFamily$_#PartialFunc4|))))
       (=> (and (= (type |#$T0@@41|) TyType)
                (= (type |#$T1@@25|) TyType)
                (= (type |#$T2@@6|) TyType)
                (= (type |#$T3@@6|) TyType)
                (= (type |#$R@@54|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc4
                 |#$T0@@41|
                 |#$T1@@25|
                 |#$T2@@6|
                 |#$T3@@6|
                 |#$R@@54|))
     :skolemid |890|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@186 T@U))
  (! (= (type (Tclass._System.___hPartialFunc4_0 arg0@@186)) TyType)
     :pattern ((Tclass._System.___hPartialFunc4_0 arg0@@186))
     :qid |funType:Tclass._System.___hPartialFunc4_0|)))
(assert (forall ((|#$T0@@42| T@U)
         (|#$T1@@26| T@U)
         (|#$T2@@7| T@U)
         (|#$T3@@7| T@U)
         (|#$R@@55| T@U))
  (! (=> (and (= (type |#$T0@@42|) TyType)
              (= (type |#$T1@@26|) TyType)
              (= (type |#$T2@@7|) TyType)
              (= (type |#$T3@@7|) TyType)
              (= (type |#$R@@55|) TyType))
         (= (Tclass._System.___hPartialFunc4_0
              (Tclass._System.___hPartialFunc4
                |#$T0@@42|
                |#$T1@@26|
                |#$T2@@7|
                |#$T3@@7|
                |#$R@@55|))
            |#$T0@@42|))
     :pattern ((Tclass._System.___hPartialFunc4
                 |#$T0@@42|
                 |#$T1@@26|
                 |#$T2@@7|
                 |#$T3@@7|
                 |#$R@@55|))
     :skolemid |891|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@187 T@U))
  (! (= (type (Tclass._System.___hPartialFunc4_1 arg0@@187)) TyType)
     :pattern ((Tclass._System.___hPartialFunc4_1 arg0@@187))
     :qid |funType:Tclass._System.___hPartialFunc4_1|)))
(assert (forall ((|#$T0@@43| T@U)
         (|#$T1@@27| T@U)
         (|#$T2@@8| T@U)
         (|#$T3@@8| T@U)
         (|#$R@@56| T@U))
  (! (=> (and (= (type |#$T0@@43|) TyType)
              (= (type |#$T1@@27|) TyType)
              (= (type |#$T2@@8|) TyType)
              (= (type |#$T3@@8|) TyType)
              (= (type |#$R@@56|) TyType))
         (= (Tclass._System.___hPartialFunc4_1
              (Tclass._System.___hPartialFunc4
                |#$T0@@43|
                |#$T1@@27|
                |#$T2@@8|
                |#$T3@@8|
                |#$R@@56|))
            |#$T1@@27|))
     :pattern ((Tclass._System.___hPartialFunc4
                 |#$T0@@43|
                 |#$T1@@27|
                 |#$T2@@8|
                 |#$T3@@8|
                 |#$R@@56|))
     :skolemid |892|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@188 T@U))
  (! (= (type (Tclass._System.___hPartialFunc4_2 arg0@@188)) TyType)
     :pattern ((Tclass._System.___hPartialFunc4_2 arg0@@188))
     :qid |funType:Tclass._System.___hPartialFunc4_2|)))
(assert (forall ((|#$T0@@44| T@U)
         (|#$T1@@28| T@U)
         (|#$T2@@9| T@U)
         (|#$T3@@9| T@U)
         (|#$R@@57| T@U))
  (! (=> (and (= (type |#$T0@@44|) TyType)
              (= (type |#$T1@@28|) TyType)
              (= (type |#$T2@@9|) TyType)
              (= (type |#$T3@@9|) TyType)
              (= (type |#$R@@57|) TyType))
         (= (Tclass._System.___hPartialFunc4_2
              (Tclass._System.___hPartialFunc4
                |#$T0@@44|
                |#$T1@@28|
                |#$T2@@9|
                |#$T3@@9|
                |#$R@@57|))
            |#$T2@@9|))
     :pattern ((Tclass._System.___hPartialFunc4
                 |#$T0@@44|
                 |#$T1@@28|
                 |#$T2@@9|
                 |#$T3@@9|
                 |#$R@@57|))
     :skolemid |893|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@189 T@U))
  (! (= (type (Tclass._System.___hPartialFunc4_3 arg0@@189)) TyType)
     :pattern ((Tclass._System.___hPartialFunc4_3 arg0@@189))
     :qid |funType:Tclass._System.___hPartialFunc4_3|)))
(assert (forall ((|#$T0@@45| T@U)
         (|#$T1@@29| T@U)
         (|#$T2@@10| T@U)
         (|#$T3@@10| T@U)
         (|#$R@@58| T@U))
  (! (=> (and (= (type |#$T0@@45|) TyType)
              (= (type |#$T1@@29|) TyType)
              (= (type |#$T2@@10|) TyType)
              (= (type |#$T3@@10|) TyType)
              (= (type |#$R@@58|) TyType))
         (= (Tclass._System.___hPartialFunc4_3
              (Tclass._System.___hPartialFunc4
                |#$T0@@45|
                |#$T1@@29|
                |#$T2@@10|
                |#$T3@@10|
                |#$R@@58|))
            |#$T3@@10|))
     :pattern ((Tclass._System.___hPartialFunc4
                 |#$T0@@45|
                 |#$T1@@29|
                 |#$T2@@10|
                 |#$T3@@10|
                 |#$R@@58|))
     :skolemid |894|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@190 T@U))
  (! (= (type (Tclass._System.___hPartialFunc4_4 arg0@@190)) TyType)
     :pattern ((Tclass._System.___hPartialFunc4_4 arg0@@190))
     :qid |funType:Tclass._System.___hPartialFunc4_4|)))
(assert (forall ((|#$T0@@46| T@U)
         (|#$T1@@30| T@U)
         (|#$T2@@11| T@U)
         (|#$T3@@11| T@U)
         (|#$R@@59| T@U))
  (! (=> (and (= (type |#$T0@@46|) TyType)
              (= (type |#$T1@@30|) TyType)
              (= (type |#$T2@@11|) TyType)
              (= (type |#$T3@@11|) TyType)
              (= (type |#$R@@59|) TyType))
         (= (Tclass._System.___hPartialFunc4_4
              (Tclass._System.___hPartialFunc4
                |#$T0@@46|
                |#$T1@@30|
                |#$T2@@11|
                |#$T3@@11|
                |#$R@@59|))
            |#$R@@59|))
     :pattern ((Tclass._System.___hPartialFunc4
                 |#$T0@@46|
                 |#$T1@@30|
                 |#$T2@@11|
                 |#$T3@@11|
                 |#$R@@59|))
     :skolemid |895|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@47| T@U)
         (|#$T1@@31| T@U)
         (|#$T2@@12| T@U)
         (|#$T3@@12| T@U)
         (|#$R@@60| T@U)
         (bx@@57 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@57)) bx@@57)
                     ($Is ($Unbox HandleTypeType bx@@57)
                          (Tclass._System.___hPartialFunc4
                            |#$T0@@47|
                            |#$T1@@31|
                            |#$T2@@12|
                            |#$T3@@12|
                            |#$R@@60|)))))
       (=> (and (= (type |#$T0@@47|) TyType)
                (= (type |#$T1@@31|) TyType)
                (= (type |#$T2@@12|) TyType)
                (= (type |#$T3@@12|) TyType)
                (= (type |#$R@@60|) TyType)
                (= (type bx@@57) BoxType)
                ($IsBox bx@@57
                        (Tclass._System.___hPartialFunc4
                          |#$T0@@47|
                          |#$T1@@31|
                          |#$T2@@12|
                          |#$T3@@12|
                          |#$R@@60|)))
           a!1))
     :pattern (($IsBox bx@@57
                       (Tclass._System.___hPartialFunc4
                         |#$T0@@47|
                         |#$T1@@31|
                         |#$T2@@12|
                         |#$T3@@12|
                         |#$R@@60|)))
     :skolemid |896|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@48| T@U)
         (|#$T1@@32| T@U)
         (|#$T2@@13| T@U)
         (|#$T3@@13| T@U)
         (|#$R@@61| T@U)
         (|f#0@@11| T@U))
  (! (let ((a!1 (forall ((|x0#0@@3| T@U)
                         (|x1#0@@1| T@U)
                         (|x2#0| T@U)
                         (|x3#0| T@U))
                  (! (=> (and (= (type |x0#0@@3|) BoxType)
                              (= (type |x1#0@@1|) BoxType)
                              (= (type |x2#0|) BoxType)
                              (= (type |x3#0|) BoxType)
                              ($IsBox |x0#0@@3| |#$T0@@48|)
                              ($IsBox |x1#0@@1| |#$T1@@32|)
                              ($IsBox |x2#0| |#$T2@@13|)
                              ($IsBox |x3#0| |#$T3@@13|))
                         (|Set#Equal| (Reads4 |#$T0@@48|
                                              |#$T1@@32|
                                              |#$T2@@13|
                                              |#$T3@@13|
                                              |#$R@@61|
                                              $OneHeap
                                              |f#0@@11|
                                              |x0#0@@3|
                                              |x1#0@@1|
                                              |x2#0|
                                              |x3#0|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@3|)
                     :no-pattern (type |x1#0@@1|)
                     :no-pattern (type |x2#0|)
                     :no-pattern (type |x3#0|)
                     :no-pattern (U_2_int |x0#0@@3|)
                     :no-pattern (U_2_bool |x0#0@@3|)
                     :no-pattern (U_2_int |x1#0@@1|)
                     :no-pattern (U_2_bool |x1#0@@1|)
                     :no-pattern (U_2_int |x2#0|)
                     :no-pattern (U_2_bool |x2#0|)
                     :no-pattern (U_2_int |x3#0|)
                     :no-pattern (U_2_bool |x3#0|)
                     :skolemid |897|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@11|
                        (Tclass._System.___hPartialFunc4
                          |#$T0@@48|
                          |#$T1@@32|
                          |#$T2@@13|
                          |#$T3@@13|
                          |#$R@@61|))
                   (and ($Is |f#0@@11|
                             (Tclass._System.___hFunc4
                               |#$T0@@48|
                               |#$T1@@32|
                               |#$T2@@13|
                               |#$T3@@13|
                               |#$R@@61|))
                        a!1))))
       (=> (and (= (type |#$T0@@48|) TyType)
                (= (type |#$T1@@32|) TyType)
                (= (type |#$T2@@13|) TyType)
                (= (type |#$T3@@13|) TyType)
                (= (type |#$R@@61|) TyType)
                (= (type |f#0@@11|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@11|
                    (Tclass._System.___hPartialFunc4
                      |#$T0@@48|
                      |#$T1@@32|
                      |#$T2@@13|
                      |#$T3@@13|
                      |#$R@@61|)))
     :skolemid |898|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@49| T@U)
         (|#$T1@@33| T@U)
         (|#$T2@@14| T@U)
         (|#$T3@@14| T@U)
         (|#$R@@62| T@U)
         (|f#0@@12| T@U)
         ($h@@14 T@U))
  (! (=> (and (= (type |#$T0@@49|) TyType)
              (= (type |#$T1@@33|) TyType)
              (= (type |#$T2@@14|) TyType)
              (= (type |#$T3@@14|) TyType)
              (= (type |#$R@@62|) TyType)
              (= (type |f#0@@12|) HandleTypeType)
              (= (type $h@@14) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@12|
                      (Tclass._System.___hPartialFunc4
                        |#$T0@@49|
                        |#$T1@@33|
                        |#$T2@@14|
                        |#$T3@@14|
                        |#$R@@62|)
                      $h@@14)
            ($IsAlloc |f#0@@12|
                      (Tclass._System.___hFunc4
                        |#$T0@@49|
                        |#$T1@@33|
                        |#$T2@@14|
                        |#$T3@@14|
                        |#$R@@62|)
                      $h@@14)))
     :pattern (($IsAlloc |f#0@@12|
                         (Tclass._System.___hPartialFunc4
                           |#$T0@@49|
                           |#$T1@@33|
                           |#$T2@@14|
                           |#$T3@@14|
                           |#$R@@62|)
                         $h@@14))
     :skolemid |899|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@191 T@U)
         (arg1@@94 T@U)
         (arg2@@46 T@U)
         (arg3@@25 T@U)
         (arg4@@17 T@U))
  (! (= (type (Tclass._System.___hTotalFunc4
                arg0@@191
                arg1@@94
                arg2@@46
                arg3@@25
                arg4@@17))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc4
                 arg0@@191
                 arg1@@94
                 arg2@@46
                 arg3@@25
                 arg4@@17))
     :qid |funType:Tclass._System.___hTotalFunc4|)))
(assert (forall ((|#$T0@@50| T@U)
         (|#$T1@@34| T@U)
         (|#$T2@@15| T@U)
         (|#$T3@@15| T@U)
         (|#$R@@63| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc4
                               |#$T0@@50|
                               |#$T1@@34|
                               |#$T2@@15|
                               |#$T3@@15|
                               |#$R@@63|))
                        Tagclass._System.___hTotalFunc4)
                     (= (TagFamily (Tclass._System.___hTotalFunc4
                                     |#$T0@@50|
                                     |#$T1@@34|
                                     |#$T2@@15|
                                     |#$T3@@15|
                                     |#$R@@63|))
                        |tytagFamily$_#TotalFunc4|))))
       (=> (and (= (type |#$T0@@50|) TyType)
                (= (type |#$T1@@34|) TyType)
                (= (type |#$T2@@15|) TyType)
                (= (type |#$T3@@15|) TyType)
                (= (type |#$R@@63|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc4
                 |#$T0@@50|
                 |#$T1@@34|
                 |#$T2@@15|
                 |#$T3@@15|
                 |#$R@@63|))
     :skolemid |900|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@192 T@U))
  (! (= (type (Tclass._System.___hTotalFunc4_0 arg0@@192)) TyType)
     :pattern ((Tclass._System.___hTotalFunc4_0 arg0@@192))
     :qid |funType:Tclass._System.___hTotalFunc4_0|)))
(assert (forall ((|#$T0@@51| T@U)
         (|#$T1@@35| T@U)
         (|#$T2@@16| T@U)
         (|#$T3@@16| T@U)
         (|#$R@@64| T@U))
  (! (=> (and (= (type |#$T0@@51|) TyType)
              (= (type |#$T1@@35|) TyType)
              (= (type |#$T2@@16|) TyType)
              (= (type |#$T3@@16|) TyType)
              (= (type |#$R@@64|) TyType))
         (= (Tclass._System.___hTotalFunc4_0
              (Tclass._System.___hTotalFunc4
                |#$T0@@51|
                |#$T1@@35|
                |#$T2@@16|
                |#$T3@@16|
                |#$R@@64|))
            |#$T0@@51|))
     :pattern ((Tclass._System.___hTotalFunc4
                 |#$T0@@51|
                 |#$T1@@35|
                 |#$T2@@16|
                 |#$T3@@16|
                 |#$R@@64|))
     :skolemid |901|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@193 T@U))
  (! (= (type (Tclass._System.___hTotalFunc4_1 arg0@@193)) TyType)
     :pattern ((Tclass._System.___hTotalFunc4_1 arg0@@193))
     :qid |funType:Tclass._System.___hTotalFunc4_1|)))
(assert (forall ((|#$T0@@52| T@U)
         (|#$T1@@36| T@U)
         (|#$T2@@17| T@U)
         (|#$T3@@17| T@U)
         (|#$R@@65| T@U))
  (! (=> (and (= (type |#$T0@@52|) TyType)
              (= (type |#$T1@@36|) TyType)
              (= (type |#$T2@@17|) TyType)
              (= (type |#$T3@@17|) TyType)
              (= (type |#$R@@65|) TyType))
         (= (Tclass._System.___hTotalFunc4_1
              (Tclass._System.___hTotalFunc4
                |#$T0@@52|
                |#$T1@@36|
                |#$T2@@17|
                |#$T3@@17|
                |#$R@@65|))
            |#$T1@@36|))
     :pattern ((Tclass._System.___hTotalFunc4
                 |#$T0@@52|
                 |#$T1@@36|
                 |#$T2@@17|
                 |#$T3@@17|
                 |#$R@@65|))
     :skolemid |902|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@194 T@U))
  (! (= (type (Tclass._System.___hTotalFunc4_2 arg0@@194)) TyType)
     :pattern ((Tclass._System.___hTotalFunc4_2 arg0@@194))
     :qid |funType:Tclass._System.___hTotalFunc4_2|)))
(assert (forall ((|#$T0@@53| T@U)
         (|#$T1@@37| T@U)
         (|#$T2@@18| T@U)
         (|#$T3@@18| T@U)
         (|#$R@@66| T@U))
  (! (=> (and (= (type |#$T0@@53|) TyType)
              (= (type |#$T1@@37|) TyType)
              (= (type |#$T2@@18|) TyType)
              (= (type |#$T3@@18|) TyType)
              (= (type |#$R@@66|) TyType))
         (= (Tclass._System.___hTotalFunc4_2
              (Tclass._System.___hTotalFunc4
                |#$T0@@53|
                |#$T1@@37|
                |#$T2@@18|
                |#$T3@@18|
                |#$R@@66|))
            |#$T2@@18|))
     :pattern ((Tclass._System.___hTotalFunc4
                 |#$T0@@53|
                 |#$T1@@37|
                 |#$T2@@18|
                 |#$T3@@18|
                 |#$R@@66|))
     :skolemid |903|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@195 T@U))
  (! (= (type (Tclass._System.___hTotalFunc4_3 arg0@@195)) TyType)
     :pattern ((Tclass._System.___hTotalFunc4_3 arg0@@195))
     :qid |funType:Tclass._System.___hTotalFunc4_3|)))
(assert (forall ((|#$T0@@54| T@U)
         (|#$T1@@38| T@U)
         (|#$T2@@19| T@U)
         (|#$T3@@19| T@U)
         (|#$R@@67| T@U))
  (! (=> (and (= (type |#$T0@@54|) TyType)
              (= (type |#$T1@@38|) TyType)
              (= (type |#$T2@@19|) TyType)
              (= (type |#$T3@@19|) TyType)
              (= (type |#$R@@67|) TyType))
         (= (Tclass._System.___hTotalFunc4_3
              (Tclass._System.___hTotalFunc4
                |#$T0@@54|
                |#$T1@@38|
                |#$T2@@19|
                |#$T3@@19|
                |#$R@@67|))
            |#$T3@@19|))
     :pattern ((Tclass._System.___hTotalFunc4
                 |#$T0@@54|
                 |#$T1@@38|
                 |#$T2@@19|
                 |#$T3@@19|
                 |#$R@@67|))
     :skolemid |904|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@196 T@U))
  (! (= (type (Tclass._System.___hTotalFunc4_4 arg0@@196)) TyType)
     :pattern ((Tclass._System.___hTotalFunc4_4 arg0@@196))
     :qid |funType:Tclass._System.___hTotalFunc4_4|)))
(assert (forall ((|#$T0@@55| T@U)
         (|#$T1@@39| T@U)
         (|#$T2@@20| T@U)
         (|#$T3@@20| T@U)
         (|#$R@@68| T@U))
  (! (=> (and (= (type |#$T0@@55|) TyType)
              (= (type |#$T1@@39|) TyType)
              (= (type |#$T2@@20|) TyType)
              (= (type |#$T3@@20|) TyType)
              (= (type |#$R@@68|) TyType))
         (= (Tclass._System.___hTotalFunc4_4
              (Tclass._System.___hTotalFunc4
                |#$T0@@55|
                |#$T1@@39|
                |#$T2@@20|
                |#$T3@@20|
                |#$R@@68|))
            |#$R@@68|))
     :pattern ((Tclass._System.___hTotalFunc4
                 |#$T0@@55|
                 |#$T1@@39|
                 |#$T2@@20|
                 |#$T3@@20|
                 |#$R@@68|))
     :skolemid |905|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@56| T@U)
         (|#$T1@@40| T@U)
         (|#$T2@@21| T@U)
         (|#$T3@@21| T@U)
         (|#$R@@69| T@U)
         (bx@@58 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@58)) bx@@58)
                     ($Is ($Unbox HandleTypeType bx@@58)
                          (Tclass._System.___hTotalFunc4
                            |#$T0@@56|
                            |#$T1@@40|
                            |#$T2@@21|
                            |#$T3@@21|
                            |#$R@@69|)))))
       (=> (and (= (type |#$T0@@56|) TyType)
                (= (type |#$T1@@40|) TyType)
                (= (type |#$T2@@21|) TyType)
                (= (type |#$T3@@21|) TyType)
                (= (type |#$R@@69|) TyType)
                (= (type bx@@58) BoxType)
                ($IsBox bx@@58
                        (Tclass._System.___hTotalFunc4
                          |#$T0@@56|
                          |#$T1@@40|
                          |#$T2@@21|
                          |#$T3@@21|
                          |#$R@@69|)))
           a!1))
     :pattern (($IsBox bx@@58
                       (Tclass._System.___hTotalFunc4
                         |#$T0@@56|
                         |#$T1@@40|
                         |#$T2@@21|
                         |#$T3@@21|
                         |#$R@@69|)))
     :skolemid |906|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@57| T@U)
         (|#$T1@@41| T@U)
         (|#$T2@@22| T@U)
         (|#$T3@@22| T@U)
         (|#$R@@70| T@U)
         (|f#0@@13| T@U))
  (! (let ((a!1 (forall ((|x0#0@@4| T@U)
                         (|x1#0@@2| T@U)
                         (|x2#0@@0| T@U)
                         (|x3#0@@0| T@U))
                  (! (=> (and (= (type |x0#0@@4|) BoxType)
                              (= (type |x1#0@@2|) BoxType)
                              (= (type |x2#0@@0|) BoxType)
                              (= (type |x3#0@@0|) BoxType)
                              ($IsBox |x0#0@@4| |#$T0@@57|)
                              ($IsBox |x1#0@@2| |#$T1@@41|)
                              ($IsBox |x2#0@@0| |#$T2@@22|)
                              ($IsBox |x3#0@@0| |#$T3@@22|))
                         (Requires4 |#$T0@@57|
                                    |#$T1@@41|
                                    |#$T2@@22|
                                    |#$T3@@22|
                                    |#$R@@70|
                                    $OneHeap
                                    |f#0@@13|
                                    |x0#0@@4|
                                    |x1#0@@2|
                                    |x2#0@@0|
                                    |x3#0@@0|))
                     :no-pattern (type |x0#0@@4|)
                     :no-pattern (type |x1#0@@2|)
                     :no-pattern (type |x2#0@@0|)
                     :no-pattern (type |x3#0@@0|)
                     :no-pattern (U_2_int |x0#0@@4|)
                     :no-pattern (U_2_bool |x0#0@@4|)
                     :no-pattern (U_2_int |x1#0@@2|)
                     :no-pattern (U_2_bool |x1#0@@2|)
                     :no-pattern (U_2_int |x2#0@@0|)
                     :no-pattern (U_2_bool |x2#0@@0|)
                     :no-pattern (U_2_int |x3#0@@0|)
                     :no-pattern (U_2_bool |x3#0@@0|)
                     :skolemid |907|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@13|
                        (Tclass._System.___hTotalFunc4
                          |#$T0@@57|
                          |#$T1@@41|
                          |#$T2@@22|
                          |#$T3@@22|
                          |#$R@@70|))
                   (and ($Is |f#0@@13|
                             (Tclass._System.___hPartialFunc4
                               |#$T0@@57|
                               |#$T1@@41|
                               |#$T2@@22|
                               |#$T3@@22|
                               |#$R@@70|))
                        a!1))))
       (=> (and (= (type |#$T0@@57|) TyType)
                (= (type |#$T1@@41|) TyType)
                (= (type |#$T2@@22|) TyType)
                (= (type |#$T3@@22|) TyType)
                (= (type |#$R@@70|) TyType)
                (= (type |f#0@@13|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@13|
                    (Tclass._System.___hTotalFunc4
                      |#$T0@@57|
                      |#$T1@@41|
                      |#$T2@@22|
                      |#$T3@@22|
                      |#$R@@70|)))
     :skolemid |908|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@58| T@U)
         (|#$T1@@42| T@U)
         (|#$T2@@23| T@U)
         (|#$T3@@23| T@U)
         (|#$R@@71| T@U)
         (|f#0@@14| T@U)
         ($h@@15 T@U))
  (! (=> (and (= (type |#$T0@@58|) TyType)
              (= (type |#$T1@@42|) TyType)
              (= (type |#$T2@@23|) TyType)
              (= (type |#$T3@@23|) TyType)
              (= (type |#$R@@71|) TyType)
              (= (type |f#0@@14|) HandleTypeType)
              (= (type $h@@15) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@14|
                      (Tclass._System.___hTotalFunc4
                        |#$T0@@58|
                        |#$T1@@42|
                        |#$T2@@23|
                        |#$T3@@23|
                        |#$R@@71|)
                      $h@@15)
            ($IsAlloc |f#0@@14|
                      (Tclass._System.___hPartialFunc4
                        |#$T0@@58|
                        |#$T1@@42|
                        |#$T2@@23|
                        |#$T3@@23|
                        |#$R@@71|)
                      $h@@15)))
     :pattern (($IsAlloc |f#0@@14|
                         (Tclass._System.___hTotalFunc4
                           |#$T0@@58|
                           |#$T1@@42|
                           |#$T2@@23|
                           |#$T3@@23|
                           |#$R@@71|)
                         $h@@15))
     :skolemid |909|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@197 T@U) (arg1@@95 T@U) (arg2@@47 T@U) (arg3@@26 T@U))
  (! (= (type (Tclass._System.___hFunc3 arg0@@197 arg1@@95 arg2@@47 arg3@@26))
        TyType)
     :pattern ((Tclass._System.___hFunc3 arg0@@197 arg1@@95 arg2@@47 arg3@@26))
     :qid |funType:Tclass._System.___hFunc3|)))
(assert (forall ((|#$T0@@59| T@U) (|#$T1@@43| T@U) (|#$T2@@24| T@U) (|#$R@@72| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc3
                               |#$T0@@59|
                               |#$T1@@43|
                               |#$T2@@24|
                               |#$R@@72|))
                        Tagclass._System.___hFunc3)
                     (= (TagFamily (Tclass._System.___hFunc3
                                     |#$T0@@59|
                                     |#$T1@@43|
                                     |#$T2@@24|
                                     |#$R@@72|))
                        |tytagFamily$_#Func3|))))
       (=> (and (= (type |#$T0@@59|) TyType)
                (= (type |#$T1@@43|) TyType)
                (= (type |#$T2@@24|) TyType)
                (= (type |#$R@@72|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc3
                 |#$T0@@59|
                 |#$T1@@43|
                 |#$T2@@24|
                 |#$R@@72|))
     :skolemid |910|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@198 T@U))
  (! (= (type (Tclass._System.___hFunc3_0 arg0@@198)) TyType)
     :pattern ((Tclass._System.___hFunc3_0 arg0@@198))
     :qid |funType:Tclass._System.___hFunc3_0|)))
(assert (forall ((|#$T0@@60| T@U) (|#$T1@@44| T@U) (|#$T2@@25| T@U) (|#$R@@73| T@U))
  (! (=> (and (= (type |#$T0@@60|) TyType)
              (= (type |#$T1@@44|) TyType)
              (= (type |#$T2@@25|) TyType)
              (= (type |#$R@@73|) TyType))
         (= (Tclass._System.___hFunc3_0
              (Tclass._System.___hFunc3
                |#$T0@@60|
                |#$T1@@44|
                |#$T2@@25|
                |#$R@@73|))
            |#$T0@@60|))
     :pattern ((Tclass._System.___hFunc3
                 |#$T0@@60|
                 |#$T1@@44|
                 |#$T2@@25|
                 |#$R@@73|))
     :skolemid |911|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@199 T@U))
  (! (= (type (Tclass._System.___hFunc3_1 arg0@@199)) TyType)
     :pattern ((Tclass._System.___hFunc3_1 arg0@@199))
     :qid |funType:Tclass._System.___hFunc3_1|)))
(assert (forall ((|#$T0@@61| T@U) (|#$T1@@45| T@U) (|#$T2@@26| T@U) (|#$R@@74| T@U))
  (! (=> (and (= (type |#$T0@@61|) TyType)
              (= (type |#$T1@@45|) TyType)
              (= (type |#$T2@@26|) TyType)
              (= (type |#$R@@74|) TyType))
         (= (Tclass._System.___hFunc3_1
              (Tclass._System.___hFunc3
                |#$T0@@61|
                |#$T1@@45|
                |#$T2@@26|
                |#$R@@74|))
            |#$T1@@45|))
     :pattern ((Tclass._System.___hFunc3
                 |#$T0@@61|
                 |#$T1@@45|
                 |#$T2@@26|
                 |#$R@@74|))
     :skolemid |912|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@200 T@U))
  (! (= (type (Tclass._System.___hFunc3_2 arg0@@200)) TyType)
     :pattern ((Tclass._System.___hFunc3_2 arg0@@200))
     :qid |funType:Tclass._System.___hFunc3_2|)))
(assert (forall ((|#$T0@@62| T@U) (|#$T1@@46| T@U) (|#$T2@@27| T@U) (|#$R@@75| T@U))
  (! (=> (and (= (type |#$T0@@62|) TyType)
              (= (type |#$T1@@46|) TyType)
              (= (type |#$T2@@27|) TyType)
              (= (type |#$R@@75|) TyType))
         (= (Tclass._System.___hFunc3_2
              (Tclass._System.___hFunc3
                |#$T0@@62|
                |#$T1@@46|
                |#$T2@@27|
                |#$R@@75|))
            |#$T2@@27|))
     :pattern ((Tclass._System.___hFunc3
                 |#$T0@@62|
                 |#$T1@@46|
                 |#$T2@@27|
                 |#$R@@75|))
     :skolemid |913|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@201 T@U))
  (! (= (type (Tclass._System.___hFunc3_3 arg0@@201)) TyType)
     :pattern ((Tclass._System.___hFunc3_3 arg0@@201))
     :qid |funType:Tclass._System.___hFunc3_3|)))
(assert (forall ((|#$T0@@63| T@U) (|#$T1@@47| T@U) (|#$T2@@28| T@U) (|#$R@@76| T@U))
  (! (=> (and (= (type |#$T0@@63|) TyType)
              (= (type |#$T1@@47|) TyType)
              (= (type |#$T2@@28|) TyType)
              (= (type |#$R@@76|) TyType))
         (= (Tclass._System.___hFunc3_3
              (Tclass._System.___hFunc3
                |#$T0@@63|
                |#$T1@@47|
                |#$T2@@28|
                |#$R@@76|))
            |#$R@@76|))
     :pattern ((Tclass._System.___hFunc3
                 |#$T0@@63|
                 |#$T1@@47|
                 |#$T2@@28|
                 |#$R@@76|))
     :skolemid |914|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@64| T@U)
         (|#$T1@@48| T@U)
         (|#$T2@@29| T@U)
         (|#$R@@77| T@U)
         (bx@@59 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@59)) bx@@59)
                     ($Is ($Unbox HandleTypeType bx@@59)
                          (Tclass._System.___hFunc3
                            |#$T0@@64|
                            |#$T1@@48|
                            |#$T2@@29|
                            |#$R@@77|)))))
       (=> (and (= (type |#$T0@@64|) TyType)
                (= (type |#$T1@@48|) TyType)
                (= (type |#$T2@@29|) TyType)
                (= (type |#$R@@77|) TyType)
                (= (type bx@@59) BoxType)
                ($IsBox bx@@59
                        (Tclass._System.___hFunc3
                          |#$T0@@64|
                          |#$T1@@48|
                          |#$T2@@29|
                          |#$R@@77|)))
           a!1))
     :pattern (($IsBox bx@@59
                       (Tclass._System.___hFunc3
                         |#$T0@@64|
                         |#$T1@@48|
                         |#$T2@@29|
                         |#$R@@77|)))
     :skolemid |915|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@202 T@T)
                    (arg1@@96 T@T)
                    (arg2@@48 T@T)
                    (arg3@@27 T@T)
                    (arg4@@18 T@T))
             (! (= (Ctor (MapType5Type arg0@@202
                                       arg1@@96
                                       arg2@@48
                                       arg3@@27
                                       arg4@@18))
                   27)
                :qid |ctor:MapType5Type|)))
      (a!2 (forall ((arg0@@203 T@T)
                    (arg1@@97 T@T)
                    (arg2@@49 T@T)
                    (arg3@@28 T@T)
                    (arg4@@19 T@T))
             (! (= (MapType5TypeInv0 (MapType5Type arg0@@203
                                                   arg1@@97
                                                   arg2@@49
                                                   arg3@@28
                                                   arg4@@19))
                   arg0@@203)
                :pattern ((MapType5Type arg0@@203
                                        arg1@@97
                                        arg2@@49
                                        arg3@@28
                                        arg4@@19))
                :qid |typeInv:MapType5TypeInv0|)))
      (a!3 (forall ((arg0@@204 T@T)
                    (arg1@@98 T@T)
                    (arg2@@50 T@T)
                    (arg3@@29 T@T)
                    (arg4@@20 T@T))
             (! (= (MapType5TypeInv1 (MapType5Type arg0@@204
                                                   arg1@@98
                                                   arg2@@50
                                                   arg3@@29
                                                   arg4@@20))
                   arg1@@98)
                :pattern ((MapType5Type arg0@@204
                                        arg1@@98
                                        arg2@@50
                                        arg3@@29
                                        arg4@@20))
                :qid |typeInv:MapType5TypeInv1|)))
      (a!4 (forall ((arg0@@205 T@T)
                    (arg1@@99 T@T)
                    (arg2@@51 T@T)
                    (arg3@@30 T@T)
                    (arg4@@21 T@T))
             (! (= (MapType5TypeInv2 (MapType5Type arg0@@205
                                                   arg1@@99
                                                   arg2@@51
                                                   arg3@@30
                                                   arg4@@21))
                   arg2@@51)
                :pattern ((MapType5Type arg0@@205
                                        arg1@@99
                                        arg2@@51
                                        arg3@@30
                                        arg4@@21))
                :qid |typeInv:MapType5TypeInv2|)))
      (a!5 (forall ((arg0@@206 T@T)
                    (arg1@@100 T@T)
                    (arg2@@52 T@T)
                    (arg3@@31 T@T)
                    (arg4@@22 T@T))
             (! (= (MapType5TypeInv3 (MapType5Type arg0@@206
                                                   arg1@@100
                                                   arg2@@52
                                                   arg3@@31
                                                   arg4@@22))
                   arg3@@31)
                :pattern ((MapType5Type arg0@@206
                                        arg1@@100
                                        arg2@@52
                                        arg3@@31
                                        arg4@@22))
                :qid |typeInv:MapType5TypeInv3|)))
      (a!6 (forall ((arg0@@207 T@T)
                    (arg1@@101 T@T)
                    (arg2@@53 T@T)
                    (arg3@@32 T@T)
                    (arg4@@23 T@T))
             (! (= (MapType5TypeInv4 (MapType5Type arg0@@207
                                                   arg1@@101
                                                   arg2@@53
                                                   arg3@@32
                                                   arg4@@23))
                   arg4@@23)
                :pattern ((MapType5Type arg0@@207
                                        arg1@@101
                                        arg2@@53
                                        arg3@@32
                                        arg4@@23))
                :qid |typeInv:MapType5TypeInv4|)))
      (a!7 (forall ((arg0@@208 T@U)
                    (arg1@@102 T@U)
                    (arg2@@54 T@U)
                    (arg3@@33 T@U)
                    (arg4@@24 T@U))
             (! (= (type (MapType5Select arg0@@208
                                         arg1@@102
                                         arg2@@54
                                         arg3@@33
                                         arg4@@24))
                   (MapType5TypeInv4 (type arg0@@208)))
                :pattern ((MapType5Select arg0@@208
                                          arg1@@102
                                          arg2@@54
                                          arg3@@33
                                          arg4@@24))
                :qid |funType:MapType5Select|)))
      (a!8 (forall ((arg0@@209 T@U)
                    (arg1@@103 T@U)
                    (arg2@@55 T@U)
                    (arg3@@34 T@U)
                    (arg4@@25 T@U)
                    (arg5@@12 T@U))
             (! (= (type (MapType5Store arg0@@209
                                        arg1@@103
                                        arg2@@55
                                        arg3@@34
                                        arg4@@25
                                        arg5@@12))
                   (MapType5Type (type arg1@@103)
                                 (type arg2@@55)
                                 (type arg3@@34)
                                 (type arg4@@25)
                                 (type arg5@@12)))
                :pattern ((MapType5Store arg0@@209
                                         arg1@@103
                                         arg2@@55
                                         arg3@@34
                                         arg4@@25
                                         arg5@@12))
                :qid |funType:MapType5Store|)))
      (a!9 (forall ((m@@61 T@U)
                    (x0@@21 T@U)
                    (x1@@15 T@U)
                    (x2@@11 T@U)
                    (x3@@6 T@U)
                    (val@@22 T@U))
             (! (=> (= (type val@@22) (MapType5TypeInv4 (type m@@61)))
                    (= (MapType5Select (MapType5Store m@@61
                                                      x0@@21
                                                      x1@@15
                                                      x2@@11
                                                      x3@@6
                                                      val@@22)
                                       x0@@21
                                       x1@@15
                                       x2@@11
                                       x3@@6)
                       val@@22))
                :weight 0
                :qid |mapAx0:MapType5Select|)))
      (a!10 (forall ((arg0@@210 T@U)
                     (arg1@@104 T@U)
                     (arg2@@56 T@U)
                     (arg3@@35 T@U)
                     (arg4@@26 T@U)
                     (arg5@@13 T@U)
                     (arg6@@4 T@U)
                     (arg7@@1 T@U)
                     (arg8@@1 T@U))
              (! (= (type (Apply3 arg0@@210
                                  arg1@@104
                                  arg2@@56
                                  arg3@@35
                                  arg4@@26
                                  arg5@@13
                                  arg6@@4
                                  arg7@@1
                                  arg8@@1))
                    BoxType)
                 :pattern ((Apply3 arg0@@210
                                   arg1@@104
                                   arg2@@56
                                   arg3@@35
                                   arg4@@26
                                   arg5@@13
                                   arg6@@4
                                   arg7@@1
                                   arg8@@1))
                 :qid |funType:Apply3|)))
      (a!11 (forall ((arg0@@211 T@U) (arg1@@105 T@U) (arg2@@57 T@U))
              (! (= (type (Handle3 arg0@@211 arg1@@105 arg2@@57))
                    HandleTypeType)
                 :pattern ((Handle3 arg0@@211 arg1@@105 arg2@@57))
                 :qid |funType:Handle3|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       a!9
       (forall ((val@@23 T@U)
                (m@@62 T@U)
                (x0@@22 T@U)
                (x1@@16 T@U)
                (x2@@12 T@U)
                (x3@@7 T@U)
                (y0@@16 T@U)
                (y1@@12 T@U)
                (y2@@9 T@U)
                (y3@@5 T@U))
         (! (let ((a!1 (= (MapType5Select (MapType5Store m@@62
                                                         x0@@22
                                                         x1@@16
                                                         x2@@12
                                                         x3@@7
                                                         val@@23)
                                          y0@@16
                                          y1@@12
                                          y2@@9
                                          y3@@5)
                          (MapType5Select m@@62 y0@@16 y1@@12 y2@@9 y3@@5))))
              (or (= x0@@22 y0@@16) a!1))
            :weight 0
            :qid |mapAx1:MapType5Select:0|))
       (forall ((val@@24 T@U)
                (m@@63 T@U)
                (x0@@23 T@U)
                (x1@@17 T@U)
                (x2@@13 T@U)
                (x3@@8 T@U)
                (y0@@17 T@U)
                (y1@@13 T@U)
                (y2@@10 T@U)
                (y3@@6 T@U))
         (! (let ((a!1 (= (MapType5Select (MapType5Store m@@63
                                                         x0@@23
                                                         x1@@17
                                                         x2@@13
                                                         x3@@8
                                                         val@@24)
                                          y0@@17
                                          y1@@13
                                          y2@@10
                                          y3@@6)
                          (MapType5Select m@@63 y0@@17 y1@@13 y2@@10 y3@@6))))
              (or (= x1@@17 y1@@13) a!1))
            :weight 0
            :qid |mapAx1:MapType5Select:1|))
       (forall ((val@@25 T@U)
                (m@@64 T@U)
                (x0@@24 T@U)
                (x1@@18 T@U)
                (x2@@14 T@U)
                (x3@@9 T@U)
                (y0@@18 T@U)
                (y1@@14 T@U)
                (y2@@11 T@U)
                (y3@@7 T@U))
         (! (let ((a!1 (= (MapType5Select (MapType5Store m@@64
                                                         x0@@24
                                                         x1@@18
                                                         x2@@14
                                                         x3@@9
                                                         val@@25)
                                          y0@@18
                                          y1@@14
                                          y2@@11
                                          y3@@7)
                          (MapType5Select m@@64 y0@@18 y1@@14 y2@@11 y3@@7))))
              (or (= x2@@14 y2@@11) a!1))
            :weight 0
            :qid |mapAx1:MapType5Select:2|))
       (forall ((val@@26 T@U)
                (m@@65 T@U)
                (x0@@25 T@U)
                (x1@@19 T@U)
                (x2@@15 T@U)
                (x3@@10 T@U)
                (y0@@19 T@U)
                (y1@@15 T@U)
                (y2@@12 T@U)
                (y3@@8 T@U))
         (! (let ((a!1 (= (MapType5Select (MapType5Store m@@65
                                                         x0@@25
                                                         x1@@19
                                                         x2@@15
                                                         x3@@10
                                                         val@@26)
                                          y0@@19
                                          y1@@15
                                          y2@@12
                                          y3@@8)
                          (MapType5Select m@@65 y0@@19 y1@@15 y2@@12 y3@@8))))
              (or (= x3@@10 y3@@8) a!1))
            :weight 0
            :qid |mapAx1:MapType5Select:3|))
       (forall ((val@@27 T@U)
                (m@@66 T@U)
                (x0@@26 T@U)
                (x1@@20 T@U)
                (x2@@16 T@U)
                (x3@@11 T@U)
                (y0@@20 T@U)
                (y1@@16 T@U)
                (y2@@13 T@U)
                (y3@@9 T@U))
         (! (let ((a!1 (= (MapType5Select (MapType5Store m@@66
                                                         x0@@26
                                                         x1@@20
                                                         x2@@16
                                                         x3@@11
                                                         val@@27)
                                          y0@@20
                                          y1@@16
                                          y2@@13
                                          y3@@9)
                          (MapType5Select m@@66 y0@@20 y1@@16 y2@@13 y3@@9))))
              (or true a!1))
            :weight 0
            :qid |mapAx2:MapType5Select|))
       a!10
       a!11)))
(assert (forall ((t0@@76 T@U)
         (t1@@52 T@U)
         (t2@@29 T@U)
         (t3@@14 T@U)
         (heap@@21 T@U)
         (h@@45 T@U)
         (r@@22 T@U)
         (rd@@11 T@U)
         (bx0@@41 T@U)
         (bx1@@27 T@U)
         (bx2@@13 T@U))
  (! (let ((a!1 (and (= (type t0@@76) TyType)
                     (= (type t1@@52) TyType)
                     (= (type t2@@29) TyType)
                     (= (type t3@@14) TyType)
                     (= (type heap@@21) (MapType0Type refType MapType1Type))
                     (= (type h@@45)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@22)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@11)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@41) BoxType)
                     (= (type bx1@@27) BoxType)
                     (= (type bx2@@13) BoxType))))
       (=> a!1
           (= (Apply3 t0@@76
                      t1@@52
                      t2@@29
                      t3@@14
                      heap@@21
                      (Handle3 h@@45 r@@22 rd@@11)
                      bx0@@41
                      bx1@@27
                      bx2@@13)
              (MapType5Select h@@45 heap@@21 bx0@@41 bx1@@27 bx2@@13))))
     :pattern ((Apply3 t0@@76
                       t1@@52
                       t2@@29
                       t3@@14
                       heap@@21
                       (Handle3 h@@45 r@@22 rd@@11)
                       bx0@@41
                       bx1@@27
                       bx2@@13))
     :skolemid |916|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@77 T@U)
         (t1@@53 T@U)
         (t2@@30 T@U)
         (t3@@15 T@U)
         (heap@@22 T@U)
         (h@@46 T@U)
         (r@@23 T@U)
         (rd@@12 T@U)
         (bx0@@42 T@U)
         (bx1@@28 T@U)
         (bx2@@14 T@U))
  (! (let ((a!1 (and (= (type t0@@77) TyType)
                     (= (type t1@@53) TyType)
                     (= (type t2@@30) TyType)
                     (= (type t3@@15) TyType)
                     (= (type heap@@22) (MapType0Type refType MapType1Type))
                     (= (type h@@46)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@23)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@12)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@42) BoxType)
                     (= (type bx1@@28) BoxType)
                     (= (type bx2@@14) BoxType)
                     (U_2_bool (MapType5Select r@@23
                                               heap@@22
                                               bx0@@42
                                               bx1@@28
                                               bx2@@14)))))
       (=> a!1
           (Requires3 t0@@77
                      t1@@53
                      t2@@30
                      t3@@15
                      heap@@22
                      (Handle3 h@@46 r@@23 rd@@12)
                      bx0@@42
                      bx1@@28
                      bx2@@14)))
     :pattern ((Requires3 t0@@77
                          t1@@53
                          t2@@30
                          t3@@15
                          heap@@22
                          (Handle3 h@@46 r@@23 rd@@12)
                          bx0@@42
                          bx1@@28
                          bx2@@14))
     :skolemid |917|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@212 T@U)
         (arg1@@106 T@U)
         (arg2@@58 T@U)
         (arg3@@36 T@U)
         (arg4@@27 T@U)
         (arg5@@14 T@U)
         (arg6@@5 T@U)
         (arg7@@2 T@U)
         (arg8@@2 T@U))
  (! (= (type (Reads3 arg0@@212
                      arg1@@106
                      arg2@@58
                      arg3@@36
                      arg4@@27
                      arg5@@14
                      arg6@@5
                      arg7@@2
                      arg8@@2))
        (MapType0Type BoxType boolType))
     :pattern ((Reads3 arg0@@212
                       arg1@@106
                       arg2@@58
                       arg3@@36
                       arg4@@27
                       arg5@@14
                       arg6@@5
                       arg7@@2
                       arg8@@2))
     :qid |funType:Reads3|)))
(assert (forall ((t0@@78 T@U)
         (t1@@54 T@U)
         (t2@@31 T@U)
         (t3@@16 T@U)
         (heap@@23 T@U)
         (h@@47 T@U)
         (r@@24 T@U)
         (rd@@13 T@U)
         (bx0@@43 T@U)
         (bx1@@29 T@U)
         (bx2@@15 T@U)
         (bx@@60 T@U))
  (! (let ((a!1 (and (= (type t0@@78) TyType)
                     (= (type t1@@54) TyType)
                     (= (type t2@@31) TyType)
                     (= (type t3@@16) TyType)
                     (= (type heap@@23) (MapType0Type refType MapType1Type))
                     (= (type h@@47)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      BoxType))
                     (= (type r@@24)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      boolType))
                     (= (type rd@@13)
                        (MapType5Type (MapType0Type refType MapType1Type)
                                      BoxType
                                      BoxType
                                      BoxType
                                      (MapType0Type BoxType boolType)))
                     (= (type bx0@@43) BoxType)
                     (= (type bx1@@29) BoxType)
                     (= (type bx2@@15) BoxType)
                     (= (type bx@@60) BoxType)))
           (a!2 (U_2_bool (MapType0Select (Reads3 t0@@78
                                                  t1@@54
                                                  t2@@31
                                                  t3@@16
                                                  heap@@23
                                                  (Handle3 h@@47 r@@24 rd@@13)
                                                  bx0@@43
                                                  bx1@@29
                                                  bx2@@15)
                                          bx@@60))))
     (let ((a!3 (= a!2
                   (U_2_bool (MapType0Select (MapType5Select rd@@13
                                                             heap@@23
                                                             bx0@@43
                                                             bx1@@29
                                                             bx2@@15)
                                             bx@@60)))))
       (=> a!1 a!3)))
     :pattern ((MapType0Select (Reads3 t0@@78
                                       t1@@54
                                       t2@@31
                                       t3@@16
                                       heap@@23
                                       (Handle3 h@@47 r@@24 rd@@13)
                                       bx0@@43
                                       bx1@@29
                                       bx2@@15)
                               bx@@60))
     :skolemid |918|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@79 T@U)
         (t1@@55 T@U)
         (t2@@32 T@U)
         (t3@@17 T@U)
         (h0@@24 T@U)
         (h1@@24 T@U)
         (f@@53 T@U)
         (bx0@@44 T@U)
         (bx1@@30 T@U)
         (bx2@@16 T@U))
  (! (let ((a!1 (forall ((o@@68 T@U) (fld@@23 T@U))
                  (! (let ((a!1 (= (type fld@@23)
                                   (FieldType (FieldTypeInv0 (type fld@@23))))))
                     (let ((a!2 (and (= (type o@@68) refType)
                                     a!1
                                     (not (= o@@68 null))
                                     (U_2_bool (MapType0Select (Reads3 t0@@79
                                                                       t1@@55
                                                                       t2@@32
                                                                       t3@@17
                                                                       h0@@24
                                                                       f@@53
                                                                       bx0@@44
                                                                       bx1@@30
                                                                       bx2@@16)
                                                               ($Box o@@68))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@24 o@@68)
                                              fld@@23)
                              (MapType1Select (MapType0Select h1@@24 o@@68)
                                              fld@@23)))))
                     :no-pattern (type o@@68)
                     :no-pattern (type fld@@23)
                     :no-pattern (U_2_int o@@68)
                     :no-pattern (U_2_bool o@@68)
                     :no-pattern (U_2_int fld@@23)
                     :no-pattern (U_2_bool fld@@23)
                     :skolemid |919|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@79) TyType)
                (= (type t1@@55) TyType)
                (= (type t2@@32) TyType)
                (= (type t3@@17) TyType)
                (= (type h0@@24) (MapType0Type refType MapType1Type))
                (= (type h1@@24) (MapType0Type refType MapType1Type))
                (= (type f@@53) HandleTypeType)
                (= (type bx0@@44) BoxType)
                (= (type bx1@@30) BoxType)
                (= (type bx2@@16) BoxType)
                ($HeapSucc h0@@24 h1@@24)
                ($IsGoodHeap h0@@24)
                ($IsGoodHeap h1@@24)
                ($IsBox bx0@@44 t0@@79)
                ($IsBox bx1@@30 t1@@55)
                ($IsBox bx2@@16 t2@@32)
                ($Is f@@53
                     (Tclass._System.___hFunc3 t0@@79 t1@@55 t2@@32 t3@@17))
                a!1)
           (= (Reads3 t0@@79
                      t1@@55
                      t2@@32
                      t3@@17
                      h0@@24
                      f@@53
                      bx0@@44
                      bx1@@30
                      bx2@@16)
              (Reads3 t0@@79
                      t1@@55
                      t2@@32
                      t3@@17
                      h1@@24
                      f@@53
                      bx0@@44
                      bx1@@30
                      bx2@@16))))
     :pattern (($HeapSucc h0@@24 h1@@24)
               (Reads3 t0@@79
                       t1@@55
                       t2@@32
                       t3@@17
                       h1@@24
                       f@@53
                       bx0@@44
                       bx1@@30
                       bx2@@16))
     :skolemid |920|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@80 T@U)
         (t1@@56 T@U)
         (t2@@33 T@U)
         (t3@@18 T@U)
         (h0@@25 T@U)
         (h1@@25 T@U)
         (f@@54 T@U)
         (bx0@@45 T@U)
         (bx1@@31 T@U)
         (bx2@@17 T@U))
  (! (let ((a!1 (forall ((o@@69 T@U) (fld@@24 T@U))
                  (! (let ((a!1 (= (type fld@@24)
                                   (FieldType (FieldTypeInv0 (type fld@@24))))))
                     (let ((a!2 (and (= (type o@@69) refType)
                                     a!1
                                     (not (= o@@69 null))
                                     (U_2_bool (MapType0Select (Reads3 t0@@80
                                                                       t1@@56
                                                                       t2@@33
                                                                       t3@@18
                                                                       h1@@25
                                                                       f@@54
                                                                       bx0@@45
                                                                       bx1@@31
                                                                       bx2@@17)
                                                               ($Box o@@69))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@25 o@@69)
                                              fld@@24)
                              (MapType1Select (MapType0Select h1@@25 o@@69)
                                              fld@@24)))))
                     :no-pattern (type o@@69)
                     :no-pattern (type fld@@24)
                     :no-pattern (U_2_int o@@69)
                     :no-pattern (U_2_bool o@@69)
                     :no-pattern (U_2_int fld@@24)
                     :no-pattern (U_2_bool fld@@24)
                     :skolemid |921|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@80) TyType)
                (= (type t1@@56) TyType)
                (= (type t2@@33) TyType)
                (= (type t3@@18) TyType)
                (= (type h0@@25) (MapType0Type refType MapType1Type))
                (= (type h1@@25) (MapType0Type refType MapType1Type))
                (= (type f@@54) HandleTypeType)
                (= (type bx0@@45) BoxType)
                (= (type bx1@@31) BoxType)
                (= (type bx2@@17) BoxType)
                ($HeapSucc h0@@25 h1@@25)
                ($IsGoodHeap h0@@25)
                ($IsGoodHeap h1@@25)
                ($IsBox bx0@@45 t0@@80)
                ($IsBox bx1@@31 t1@@56)
                ($IsBox bx2@@17 t2@@33)
                ($Is f@@54
                     (Tclass._System.___hFunc3 t0@@80 t1@@56 t2@@33 t3@@18))
                a!1)
           (= (Reads3 t0@@80
                      t1@@56
                      t2@@33
                      t3@@18
                      h0@@25
                      f@@54
                      bx0@@45
                      bx1@@31
                      bx2@@17)
              (Reads3 t0@@80
                      t1@@56
                      t2@@33
                      t3@@18
                      h1@@25
                      f@@54
                      bx0@@45
                      bx1@@31
                      bx2@@17))))
     :pattern (($HeapSucc h0@@25 h1@@25)
               (Reads3 t0@@80
                       t1@@56
                       t2@@33
                       t3@@18
                       h1@@25
                       f@@54
                       bx0@@45
                       bx1@@31
                       bx2@@17))
     :skolemid |922|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@81 T@U)
         (t1@@57 T@U)
         (t2@@34 T@U)
         (t3@@19 T@U)
         (h0@@26 T@U)
         (h1@@26 T@U)
         (f@@55 T@U)
         (bx0@@46 T@U)
         (bx1@@32 T@U)
         (bx2@@18 T@U))
  (! (let ((a!1 (forall ((o@@70 T@U) (fld@@25 T@U))
                  (! (let ((a!1 (= (type fld@@25)
                                   (FieldType (FieldTypeInv0 (type fld@@25))))))
                     (let ((a!2 (and (= (type o@@70) refType)
                                     a!1
                                     (not (= o@@70 null))
                                     (U_2_bool (MapType0Select (Reads3 t0@@81
                                                                       t1@@57
                                                                       t2@@34
                                                                       t3@@19
                                                                       h0@@26
                                                                       f@@55
                                                                       bx0@@46
                                                                       bx1@@32
                                                                       bx2@@18)
                                                               ($Box o@@70))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@26 o@@70)
                                              fld@@25)
                              (MapType1Select (MapType0Select h1@@26 o@@70)
                                              fld@@25)))))
                     :no-pattern (type o@@70)
                     :no-pattern (type fld@@25)
                     :no-pattern (U_2_int o@@70)
                     :no-pattern (U_2_bool o@@70)
                     :no-pattern (U_2_int fld@@25)
                     :no-pattern (U_2_bool fld@@25)
                     :skolemid |923|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@81) TyType)
                (= (type t1@@57) TyType)
                (= (type t2@@34) TyType)
                (= (type t3@@19) TyType)
                (= (type h0@@26) (MapType0Type refType MapType1Type))
                (= (type h1@@26) (MapType0Type refType MapType1Type))
                (= (type f@@55) HandleTypeType)
                (= (type bx0@@46) BoxType)
                (= (type bx1@@32) BoxType)
                (= (type bx2@@18) BoxType)
                ($HeapSucc h0@@26 h1@@26)
                ($IsGoodHeap h0@@26)
                ($IsGoodHeap h1@@26)
                ($IsBox bx0@@46 t0@@81)
                ($IsBox bx1@@32 t1@@57)
                ($IsBox bx2@@18 t2@@34)
                ($Is f@@55
                     (Tclass._System.___hFunc3 t0@@81 t1@@57 t2@@34 t3@@19))
                a!1)
           (= (Requires3 t0@@81
                         t1@@57
                         t2@@34
                         t3@@19
                         h0@@26
                         f@@55
                         bx0@@46
                         bx1@@32
                         bx2@@18)
              (Requires3 t0@@81
                         t1@@57
                         t2@@34
                         t3@@19
                         h1@@26
                         f@@55
                         bx0@@46
                         bx1@@32
                         bx2@@18))))
     :pattern (($HeapSucc h0@@26 h1@@26)
               (Requires3 t0@@81
                          t1@@57
                          t2@@34
                          t3@@19
                          h1@@26
                          f@@55
                          bx0@@46
                          bx1@@32
                          bx2@@18))
     :skolemid |924|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@82 T@U)
         (t1@@58 T@U)
         (t2@@35 T@U)
         (t3@@20 T@U)
         (h0@@27 T@U)
         (h1@@27 T@U)
         (f@@56 T@U)
         (bx0@@47 T@U)
         (bx1@@33 T@U)
         (bx2@@19 T@U))
  (! (let ((a!1 (forall ((o@@71 T@U) (fld@@26 T@U))
                  (! (let ((a!1 (= (type fld@@26)
                                   (FieldType (FieldTypeInv0 (type fld@@26))))))
                     (let ((a!2 (and (= (type o@@71) refType)
                                     a!1
                                     (not (= o@@71 null))
                                     (U_2_bool (MapType0Select (Reads3 t0@@82
                                                                       t1@@58
                                                                       t2@@35
                                                                       t3@@20
                                                                       h1@@27
                                                                       f@@56
                                                                       bx0@@47
                                                                       bx1@@33
                                                                       bx2@@19)
                                                               ($Box o@@71))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@27 o@@71)
                                              fld@@26)
                              (MapType1Select (MapType0Select h1@@27 o@@71)
                                              fld@@26)))))
                     :no-pattern (type o@@71)
                     :no-pattern (type fld@@26)
                     :no-pattern (U_2_int o@@71)
                     :no-pattern (U_2_bool o@@71)
                     :no-pattern (U_2_int fld@@26)
                     :no-pattern (U_2_bool fld@@26)
                     :skolemid |925|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@82) TyType)
                (= (type t1@@58) TyType)
                (= (type t2@@35) TyType)
                (= (type t3@@20) TyType)
                (= (type h0@@27) (MapType0Type refType MapType1Type))
                (= (type h1@@27) (MapType0Type refType MapType1Type))
                (= (type f@@56) HandleTypeType)
                (= (type bx0@@47) BoxType)
                (= (type bx1@@33) BoxType)
                (= (type bx2@@19) BoxType)
                ($HeapSucc h0@@27 h1@@27)
                ($IsGoodHeap h0@@27)
                ($IsGoodHeap h1@@27)
                ($IsBox bx0@@47 t0@@82)
                ($IsBox bx1@@33 t1@@58)
                ($IsBox bx2@@19 t2@@35)
                ($Is f@@56
                     (Tclass._System.___hFunc3 t0@@82 t1@@58 t2@@35 t3@@20))
                a!1)
           (= (Requires3 t0@@82
                         t1@@58
                         t2@@35
                         t3@@20
                         h0@@27
                         f@@56
                         bx0@@47
                         bx1@@33
                         bx2@@19)
              (Requires3 t0@@82
                         t1@@58
                         t2@@35
                         t3@@20
                         h1@@27
                         f@@56
                         bx0@@47
                         bx1@@33
                         bx2@@19))))
     :pattern (($HeapSucc h0@@27 h1@@27)
               (Requires3 t0@@82
                          t1@@58
                          t2@@35
                          t3@@20
                          h1@@27
                          f@@56
                          bx0@@47
                          bx1@@33
                          bx2@@19))
     :skolemid |926|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@83 T@U)
         (t1@@59 T@U)
         (t2@@36 T@U)
         (t3@@21 T@U)
         (h0@@28 T@U)
         (h1@@28 T@U)
         (f@@57 T@U)
         (bx0@@48 T@U)
         (bx1@@34 T@U)
         (bx2@@20 T@U))
  (! (let ((a!1 (forall ((o@@72 T@U) (fld@@27 T@U))
                  (! (let ((a!1 (= (type fld@@27)
                                   (FieldType (FieldTypeInv0 (type fld@@27))))))
                     (let ((a!2 (and (= (type o@@72) refType)
                                     a!1
                                     (not (= o@@72 null))
                                     (U_2_bool (MapType0Select (Reads3 t0@@83
                                                                       t1@@59
                                                                       t2@@36
                                                                       t3@@21
                                                                       h0@@28
                                                                       f@@57
                                                                       bx0@@48
                                                                       bx1@@34
                                                                       bx2@@20)
                                                               ($Box o@@72))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@28 o@@72)
                                              fld@@27)
                              (MapType1Select (MapType0Select h1@@28 o@@72)
                                              fld@@27)))))
                     :no-pattern (type o@@72)
                     :no-pattern (type fld@@27)
                     :no-pattern (U_2_int o@@72)
                     :no-pattern (U_2_bool o@@72)
                     :no-pattern (U_2_int fld@@27)
                     :no-pattern (U_2_bool fld@@27)
                     :skolemid |927|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@83) TyType)
                (= (type t1@@59) TyType)
                (= (type t2@@36) TyType)
                (= (type t3@@21) TyType)
                (= (type h0@@28) (MapType0Type refType MapType1Type))
                (= (type h1@@28) (MapType0Type refType MapType1Type))
                (= (type f@@57) HandleTypeType)
                (= (type bx0@@48) BoxType)
                (= (type bx1@@34) BoxType)
                (= (type bx2@@20) BoxType)
                ($HeapSucc h0@@28 h1@@28)
                ($IsGoodHeap h0@@28)
                ($IsGoodHeap h1@@28)
                ($IsBox bx0@@48 t0@@83)
                ($IsBox bx1@@34 t1@@59)
                ($IsBox bx2@@20 t2@@36)
                ($Is f@@57
                     (Tclass._System.___hFunc3 t0@@83 t1@@59 t2@@36 t3@@21))
                a!1)
           (= (Apply3 t0@@83
                      t1@@59
                      t2@@36
                      t3@@21
                      h0@@28
                      f@@57
                      bx0@@48
                      bx1@@34
                      bx2@@20)
              (Apply3 t0@@83
                      t1@@59
                      t2@@36
                      t3@@21
                      h1@@28
                      f@@57
                      bx0@@48
                      bx1@@34
                      bx2@@20))))
     :pattern (($HeapSucc h0@@28 h1@@28)
               (Apply3 t0@@83
                       t1@@59
                       t2@@36
                       t3@@21
                       h1@@28
                       f@@57
                       bx0@@48
                       bx1@@34
                       bx2@@20))
     :skolemid |928|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@84 T@U)
         (t1@@60 T@U)
         (t2@@37 T@U)
         (t3@@22 T@U)
         (h0@@29 T@U)
         (h1@@29 T@U)
         (f@@58 T@U)
         (bx0@@49 T@U)
         (bx1@@35 T@U)
         (bx2@@21 T@U))
  (! (let ((a!1 (forall ((o@@73 T@U) (fld@@28 T@U))
                  (! (let ((a!1 (= (type fld@@28)
                                   (FieldType (FieldTypeInv0 (type fld@@28))))))
                     (let ((a!2 (and (= (type o@@73) refType)
                                     a!1
                                     (not (= o@@73 null))
                                     (U_2_bool (MapType0Select (Reads3 t0@@84
                                                                       t1@@60
                                                                       t2@@37
                                                                       t3@@22
                                                                       h1@@29
                                                                       f@@58
                                                                       bx0@@49
                                                                       bx1@@35
                                                                       bx2@@21)
                                                               ($Box o@@73))))))
                       (=> a!2
                           (= (MapType1Select (MapType0Select h0@@29 o@@73)
                                              fld@@28)
                              (MapType1Select (MapType0Select h1@@29 o@@73)
                                              fld@@28)))))
                     :no-pattern (type o@@73)
                     :no-pattern (type fld@@28)
                     :no-pattern (U_2_int o@@73)
                     :no-pattern (U_2_bool o@@73)
                     :no-pattern (U_2_int fld@@28)
                     :no-pattern (U_2_bool fld@@28)
                     :skolemid |929|
                     :qid |unknown.0:0|))))
       (=> (and (= (type t0@@84) TyType)
                (= (type t1@@60) TyType)
                (= (type t2@@37) TyType)
                (= (type t3@@22) TyType)
                (= (type h0@@29) (MapType0Type refType MapType1Type))
                (= (type h1@@29) (MapType0Type refType MapType1Type))
                (= (type f@@58) HandleTypeType)
                (= (type bx0@@49) BoxType)
                (= (type bx1@@35) BoxType)
                (= (type bx2@@21) BoxType)
                ($HeapSucc h0@@29 h1@@29)
                ($IsGoodHeap h0@@29)
                ($IsGoodHeap h1@@29)
                ($IsBox bx0@@49 t0@@84)
                ($IsBox bx1@@35 t1@@60)
                ($IsBox bx2@@21 t2@@37)
                ($Is f@@58
                     (Tclass._System.___hFunc3 t0@@84 t1@@60 t2@@37 t3@@22))
                a!1)
           (= (Apply3 t0@@84
                      t1@@60
                      t2@@37
                      t3@@22
                      h0@@29
                      f@@58
                      bx0@@49
                      bx1@@35
                      bx2@@21)
              (Apply3 t0@@84
                      t1@@60
                      t2@@37
                      t3@@22
                      h1@@29
                      f@@58
                      bx0@@49
                      bx1@@35
                      bx2@@21))))
     :pattern (($HeapSucc h0@@29 h1@@29)
               (Apply3 t0@@84
                       t1@@60
                       t2@@37
                       t3@@22
                       h1@@29
                       f@@58
                       bx0@@49
                       bx1@@35
                       bx2@@21))
     :skolemid |930|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@85 T@U)
         (t1@@61 T@U)
         (t2@@38 T@U)
         (t3@@23 T@U)
         (heap@@24 T@U)
         (f@@59 T@U)
         (bx0@@50 T@U)
         (bx1@@36 T@U)
         (bx2@@22 T@U))
  (! (=> (and (= (type t0@@85) TyType)
              (= (type t1@@61) TyType)
              (= (type t2@@38) TyType)
              (= (type t3@@23) TyType)
              (= (type heap@@24) (MapType0Type refType MapType1Type))
              (= (type f@@59) HandleTypeType)
              (= (type bx0@@50) BoxType)
              (= (type bx1@@36) BoxType)
              (= (type bx2@@22) BoxType)
              ($IsGoodHeap heap@@24)
              ($IsBox bx0@@50 t0@@85)
              ($IsBox bx1@@36 t1@@61)
              ($IsBox bx2@@22 t2@@38)
              ($Is f@@59 (Tclass._System.___hFunc3 t0@@85 t1@@61 t2@@38 t3@@23)))
         (= (|Set#Equal| (Reads3 t0@@85
                                 t1@@61
                                 t2@@38
                                 t3@@23
                                 $OneHeap
                                 f@@59
                                 bx0@@50
                                 bx1@@36
                                 bx2@@22)
                         (|Set#Empty| BoxType))
            (|Set#Equal| (Reads3 t0@@85
                                 t1@@61
                                 t2@@38
                                 t3@@23
                                 heap@@24
                                 f@@59
                                 bx0@@50
                                 bx1@@36
                                 bx2@@22)
                         (|Set#Empty| BoxType))))
     :pattern ((Reads3 t0@@85
                       t1@@61
                       t2@@38
                       t3@@23
                       $OneHeap
                       f@@59
                       bx0@@50
                       bx1@@36
                       bx2@@22)
               ($IsGoodHeap heap@@24))
     :pattern ((Reads3 t0@@85
                       t1@@61
                       t2@@38
                       t3@@23
                       heap@@24
                       f@@59
                       bx0@@50
                       bx1@@36
                       bx2@@22))
     :skolemid |931|
     :qid |unknown.0:0|)))
(assert (forall ((t0@@86 T@U)
         (t1@@62 T@U)
         (t2@@39 T@U)
         (t3@@24 T@U)
         (heap@@25 T@U)
         (f@@60 T@U)
         (bx0@@51 T@U)
         (bx1@@37 T@U)
         (bx2@@23 T@U))
  (! (=> (and (= (type t0@@86) TyType)
              (= (type t1@@62) TyType)
              (= (type t2@@39) TyType)
              (= (type t3@@24) TyType)
              (= (type heap@@25) (MapType0Type refType MapType1Type))
              (= (type f@@60) HandleTypeType)
              (= (type bx0@@51) BoxType)
              (= (type bx1@@37) BoxType)
              (= (type bx2@@23) BoxType)
              ($IsGoodHeap heap@@25)
              ($IsBox bx0@@51 t0@@86)
              ($IsBox bx1@@37 t1@@62)
              ($IsBox bx2@@23 t2@@39)
              ($Is f@@60 (Tclass._System.___hFunc3 t0@@86 t1@@62 t2@@39 t3@@24))
              (|Set#Equal| (Reads3 t0@@86
                                   t1@@62
                                   t2@@39
                                   t3@@24
                                   $OneHeap
                                   f@@60
                                   bx0@@51
                                   bx1@@37
                                   bx2@@23)
                           (|Set#Empty| BoxType)))
         (= (Requires3 t0@@86
                       t1@@62
                       t2@@39
                       t3@@24
                       $OneHeap
                       f@@60
                       bx0@@51
                       bx1@@37
                       bx2@@23)
            (Requires3 t0@@86
                       t1@@62
                       t2@@39
                       t3@@24
                       heap@@25
                       f@@60
                       bx0@@51
                       bx1@@37
                       bx2@@23)))
     :pattern ((Requires3 t0@@86
                          t1@@62
                          t2@@39
                          t3@@24
                          $OneHeap
                          f@@60
                          bx0@@51
                          bx1@@37
                          bx2@@23)
               ($IsGoodHeap heap@@25))
     :pattern ((Requires3 t0@@86
                          t1@@62
                          t2@@39
                          t3@@24
                          heap@@25
                          f@@60
                          bx0@@51
                          bx1@@37
                          bx2@@23))
     :skolemid |932|
     :qid |unknown.0:0|)))
(assert (forall ((f@@61 T@U) (t0@@87 T@U) (t1@@63 T@U) (t2@@40 T@U) (t3@@25 T@U))
  (! (let ((a!1 (forall ((h@@48 T@U) (bx0@@52 T@U) (bx1@@38 T@U) (bx2@@24 T@U))
                  (! (=> (and (= (type h@@48)
                                 (MapType0Type refType MapType1Type))
                              (= (type bx0@@52) BoxType)
                              (= (type bx1@@38) BoxType)
                              (= (type bx2@@24) BoxType)
                              ($IsGoodHeap h@@48)
                              ($IsBox bx0@@52 t0@@87)
                              ($IsBox bx1@@38 t1@@63)
                              ($IsBox bx2@@24 t2@@40)
                              (Requires3 t0@@87
                                         t1@@63
                                         t2@@40
                                         t3@@25
                                         h@@48
                                         f@@61
                                         bx0@@52
                                         bx1@@38
                                         bx2@@24))
                         ($IsBox (Apply3 t0@@87
                                         t1@@63
                                         t2@@40
                                         t3@@25
                                         h@@48
                                         f@@61
                                         bx0@@52
                                         bx1@@38
                                         bx2@@24)
                                 t3@@25))
                     :pattern ((Apply3 t0@@87
                                       t1@@63
                                       t2@@40
                                       t3@@25
                                       h@@48
                                       f@@61
                                       bx0@@52
                                       bx1@@38
                                       bx2@@24))
                     :skolemid |933|
                     :qid |DafnyPreludebpl.545:12|))))
       (=> (and (= (type f@@61) HandleTypeType)
                (= (type t0@@87) TyType)
                (= (type t1@@63) TyType)
                (= (type t2@@40) TyType)
                (= (type t3@@25) TyType))
           (= ($Is f@@61 (Tclass._System.___hFunc3 t0@@87 t1@@63 t2@@40 t3@@25))
              a!1)))
     :pattern (($Is f@@61
                    (Tclass._System.___hFunc3 t0@@87 t1@@63 t2@@40 t3@@25)))
     :skolemid |934|
     :qid |unknown.0:0|)))
(assert (forall ((f@@62 T@U)
         (t0@@88 T@U)
         (t1@@64 T@U)
         (t2@@41 T@U)
         (t3@@26 T@U)
         (u0@@3 T@U)
         (u1@@2 T@U)
         (u2@@1 T@U)
         (u3@@0 T@U))
  (! (let ((a!1 (forall ((bx@@61 T@U))
                  (! (=> (and (= (type bx@@61) BoxType) ($IsBox bx@@61 u0@@3))
                         ($IsBox bx@@61 t0@@88))
                     :pattern (($IsBox bx@@61 u0@@3))
                     :pattern (($IsBox bx@@61 t0@@88))
                     :skolemid |935|
                     :qid |unknown.0:0|)))
           (a!2 (forall ((bx@@62 T@U))
                  (! (=> (and (= (type bx@@62) BoxType) ($IsBox bx@@62 u1@@2))
                         ($IsBox bx@@62 t1@@64))
                     :pattern (($IsBox bx@@62 u1@@2))
                     :pattern (($IsBox bx@@62 t1@@64))
                     :skolemid |936|
                     :qid |unknown.0:0|)))
           (a!3 (forall ((bx@@63 T@U))
                  (! (=> (and (= (type bx@@63) BoxType) ($IsBox bx@@63 u2@@1))
                         ($IsBox bx@@63 t2@@41))
                     :pattern (($IsBox bx@@63 u2@@1))
                     :pattern (($IsBox bx@@63 t2@@41))
                     :skolemid |937|
                     :qid |unknown.0:0|)))
           (a!4 (forall ((bx@@64 T@U))
                  (! (=> (and (= (type bx@@64) BoxType) ($IsBox bx@@64 t3@@26))
                         ($IsBox bx@@64 u3@@0))
                     :pattern (($IsBox bx@@64 t3@@26))
                     :pattern (($IsBox bx@@64 u3@@0))
                     :skolemid |938|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@62) HandleTypeType)
                (= (type t0@@88) TyType)
                (= (type t1@@64) TyType)
                (= (type t2@@41) TyType)
                (= (type t3@@26) TyType)
                (= (type u0@@3) TyType)
                (= (type u1@@2) TyType)
                (= (type u2@@1) TyType)
                (= (type u3@@0) TyType)
                ($Is f@@62
                     (Tclass._System.___hFunc3 t0@@88 t1@@64 t2@@41 t3@@26))
                a!1
                a!2
                a!3
                a!4)
           ($Is f@@62 (Tclass._System.___hFunc3 u0@@3 u1@@2 u2@@1 u3@@0))))
     :pattern (($Is f@@62
                    (Tclass._System.___hFunc3 t0@@88 t1@@64 t2@@41 t3@@26))
               ($Is f@@62 (Tclass._System.___hFunc3 u0@@3 u1@@2 u2@@1 u3@@0)))
     :skolemid |939|
     :qid |unknown.0:0|)))
(assert (forall ((f@@63 T@U)
         (t0@@89 T@U)
         (t1@@65 T@U)
         (t2@@42 T@U)
         (t3@@27 T@U)
         (h@@49 T@U))
  (! (let ((a!1 (forall ((bx0@@53 T@U) (bx1@@39 T@U) (bx2@@25 T@U))
                  (! (let ((a!1 (forall ((r@@25 T@U))
                                  (! (let ((a!1 (and (not (= r@@25 null))
                                                     (U_2_bool (MapType0Select (Reads3 t0@@89
                                                                                       t1@@65
                                                                                       t2@@42
                                                                                       t3@@27
                                                                                       h@@49
                                                                                       f@@63
                                                                                       bx0@@53
                                                                                       bx1@@39
                                                                                       bx2@@25)
                                                                               ($Box r@@25))))))
                                     (let ((a!2 (=> a!1
                                                    (U_2_bool (MapType1Select (MapType0Select h@@49
                                                                                              r@@25)
                                                                              alloc)))))
                                       (=> (= (type r@@25) refType) a!2)))
                                     :pattern ((MapType0Select (Reads3 t0@@89
                                                                       t1@@65
                                                                       t2@@42
                                                                       t3@@27
                                                                       h@@49
                                                                       f@@63
                                                                       bx0@@53
                                                                       bx1@@39
                                                                       bx2@@25)
                                                               ($Box r@@25)))
                                     :skolemid |940|
                                     :qid |unknown.0:0|))))
                       (=> (and (= (type bx0@@53) BoxType)
                                (= (type bx1@@39) BoxType)
                                (= (type bx2@@25) BoxType))
                           (=> (and ($IsBox bx0@@53 t0@@89)
                                    ($IsAllocBox bx0@@53 t0@@89 h@@49)
                                    ($IsBox bx1@@39 t1@@65)
                                    ($IsAllocBox bx1@@39 t1@@65 h@@49)
                                    ($IsBox bx2@@25 t2@@42)
                                    ($IsAllocBox bx2@@25 t2@@42 h@@49)
                                    (Requires3 t0@@89
                                               t1@@65
                                               t2@@42
                                               t3@@27
                                               h@@49
                                               f@@63
                                               bx0@@53
                                               bx1@@39
                                               bx2@@25))
                               a!1)))
                     :pattern ((Apply3 t0@@89
                                       t1@@65
                                       t2@@42
                                       t3@@27
                                       h@@49
                                       f@@63
                                       bx0@@53
                                       bx1@@39
                                       bx2@@25))
                     :pattern ((Reads3 t0@@89
                                       t1@@65
                                       t2@@42
                                       t3@@27
                                       h@@49
                                       f@@63
                                       bx0@@53
                                       bx1@@39
                                       bx2@@25))
                     :skolemid |941|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@63) HandleTypeType)
                (= (type t0@@89) TyType)
                (= (type t1@@65) TyType)
                (= (type t2@@42) TyType)
                (= (type t3@@27) TyType)
                (= (type h@@49) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@49))
           (= ($IsAlloc f@@63
                        (Tclass._System.___hFunc3 t0@@89 t1@@65 t2@@42 t3@@27)
                        h@@49)
              a!1)))
     :pattern (($IsAlloc f@@63
                         (Tclass._System.___hFunc3 t0@@89 t1@@65 t2@@42 t3@@27)
                         h@@49))
     :skolemid |942|
     :qid |unknown.0:0|)))
(assert (forall ((f@@64 T@U)
         (t0@@90 T@U)
         (t1@@66 T@U)
         (t2@@43 T@U)
         (t3@@28 T@U)
         (h@@50 T@U))
  (! (let ((a!1 (forall ((bx0@@54 T@U) (bx1@@40 T@U) (bx2@@26 T@U))
                  (! (=> (and (= (type bx0@@54) BoxType)
                              (= (type bx1@@40) BoxType)
                              (= (type bx2@@26) BoxType))
                         (=> (and ($IsAllocBox bx0@@54 t0@@90 h@@50)
                                  ($IsAllocBox bx1@@40 t1@@66 h@@50)
                                  ($IsAllocBox bx2@@26 t2@@43 h@@50)
                                  (Requires3 t0@@90
                                             t1@@66
                                             t2@@43
                                             t3@@28
                                             h@@50
                                             f@@64
                                             bx0@@54
                                             bx1@@40
                                             bx2@@26))
                             ($IsAllocBox (Apply3 t0@@90
                                                  t1@@66
                                                  t2@@43
                                                  t3@@28
                                                  h@@50
                                                  f@@64
                                                  bx0@@54
                                                  bx1@@40
                                                  bx2@@26)
                                          t3@@28
                                          h@@50)))
                     :pattern ((Apply3 t0@@90
                                       t1@@66
                                       t2@@43
                                       t3@@28
                                       h@@50
                                       f@@64
                                       bx0@@54
                                       bx1@@40
                                       bx2@@26))
                     :skolemid |943|
                     :qid |unknown.0:0|))))
       (=> (and (= (type f@@64) HandleTypeType)
                (= (type t0@@90) TyType)
                (= (type t1@@66) TyType)
                (= (type t2@@43) TyType)
                (= (type t3@@28) TyType)
                (= (type h@@50) (MapType0Type refType MapType1Type))
                ($IsGoodHeap h@@50)
                ($IsAlloc f@@64
                          (Tclass._System.___hFunc3 t0@@90 t1@@66 t2@@43 t3@@28)
                          h@@50))
           a!1))
     :pattern (($IsAlloc f@@64
                         (Tclass._System.___hFunc3 t0@@90 t1@@66 t2@@43 t3@@28)
                         h@@50))
     :skolemid |944|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@213 T@U) (arg1@@107 T@U) (arg2@@59 T@U) (arg3@@37 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3
                arg0@@213
                arg1@@107
                arg2@@59
                arg3@@37))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc3
                 arg0@@213
                 arg1@@107
                 arg2@@59
                 arg3@@37))
     :qid |funType:Tclass._System.___hPartialFunc3|)))
(assert (forall ((|#$T0@@65| T@U) (|#$T1@@49| T@U) (|#$T2@@30| T@U) (|#$R@@78| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc3
                               |#$T0@@65|
                               |#$T1@@49|
                               |#$T2@@30|
                               |#$R@@78|))
                        Tagclass._System.___hPartialFunc3)
                     (= (TagFamily (Tclass._System.___hPartialFunc3
                                     |#$T0@@65|
                                     |#$T1@@49|
                                     |#$T2@@30|
                                     |#$R@@78|))
                        |tytagFamily$_#PartialFunc3|))))
       (=> (and (= (type |#$T0@@65|) TyType)
                (= (type |#$T1@@49|) TyType)
                (= (type |#$T2@@30|) TyType)
                (= (type |#$R@@78|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc3
                 |#$T0@@65|
                 |#$T1@@49|
                 |#$T2@@30|
                 |#$R@@78|))
     :skolemid |945|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@214 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3_0 arg0@@214)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3_0 arg0@@214))
     :qid |funType:Tclass._System.___hPartialFunc3_0|)))
(assert (forall ((|#$T0@@66| T@U) (|#$T1@@50| T@U) (|#$T2@@31| T@U) (|#$R@@79| T@U))
  (! (=> (and (= (type |#$T0@@66|) TyType)
              (= (type |#$T1@@50|) TyType)
              (= (type |#$T2@@31|) TyType)
              (= (type |#$R@@79|) TyType))
         (= (Tclass._System.___hPartialFunc3_0
              (Tclass._System.___hPartialFunc3
                |#$T0@@66|
                |#$T1@@50|
                |#$T2@@31|
                |#$R@@79|))
            |#$T0@@66|))
     :pattern ((Tclass._System.___hPartialFunc3
                 |#$T0@@66|
                 |#$T1@@50|
                 |#$T2@@31|
                 |#$R@@79|))
     :skolemid |946|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@215 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3_1 arg0@@215)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3_1 arg0@@215))
     :qid |funType:Tclass._System.___hPartialFunc3_1|)))
(assert (forall ((|#$T0@@67| T@U) (|#$T1@@51| T@U) (|#$T2@@32| T@U) (|#$R@@80| T@U))
  (! (=> (and (= (type |#$T0@@67|) TyType)
              (= (type |#$T1@@51|) TyType)
              (= (type |#$T2@@32|) TyType)
              (= (type |#$R@@80|) TyType))
         (= (Tclass._System.___hPartialFunc3_1
              (Tclass._System.___hPartialFunc3
                |#$T0@@67|
                |#$T1@@51|
                |#$T2@@32|
                |#$R@@80|))
            |#$T1@@51|))
     :pattern ((Tclass._System.___hPartialFunc3
                 |#$T0@@67|
                 |#$T1@@51|
                 |#$T2@@32|
                 |#$R@@80|))
     :skolemid |947|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@216 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3_2 arg0@@216)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3_2 arg0@@216))
     :qid |funType:Tclass._System.___hPartialFunc3_2|)))
(assert (forall ((|#$T0@@68| T@U) (|#$T1@@52| T@U) (|#$T2@@33| T@U) (|#$R@@81| T@U))
  (! (=> (and (= (type |#$T0@@68|) TyType)
              (= (type |#$T1@@52|) TyType)
              (= (type |#$T2@@33|) TyType)
              (= (type |#$R@@81|) TyType))
         (= (Tclass._System.___hPartialFunc3_2
              (Tclass._System.___hPartialFunc3
                |#$T0@@68|
                |#$T1@@52|
                |#$T2@@33|
                |#$R@@81|))
            |#$T2@@33|))
     :pattern ((Tclass._System.___hPartialFunc3
                 |#$T0@@68|
                 |#$T1@@52|
                 |#$T2@@33|
                 |#$R@@81|))
     :skolemid |948|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@217 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3_3 arg0@@217)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3_3 arg0@@217))
     :qid |funType:Tclass._System.___hPartialFunc3_3|)))
(assert (forall ((|#$T0@@69| T@U) (|#$T1@@53| T@U) (|#$T2@@34| T@U) (|#$R@@82| T@U))
  (! (=> (and (= (type |#$T0@@69|) TyType)
              (= (type |#$T1@@53|) TyType)
              (= (type |#$T2@@34|) TyType)
              (= (type |#$R@@82|) TyType))
         (= (Tclass._System.___hPartialFunc3_3
              (Tclass._System.___hPartialFunc3
                |#$T0@@69|
                |#$T1@@53|
                |#$T2@@34|
                |#$R@@82|))
            |#$R@@82|))
     :pattern ((Tclass._System.___hPartialFunc3
                 |#$T0@@69|
                 |#$T1@@53|
                 |#$T2@@34|
                 |#$R@@82|))
     :skolemid |949|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@70| T@U)
         (|#$T1@@54| T@U)
         (|#$T2@@35| T@U)
         (|#$R@@83| T@U)
         (bx@@65 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@65)) bx@@65)
                     ($Is ($Unbox HandleTypeType bx@@65)
                          (Tclass._System.___hPartialFunc3
                            |#$T0@@70|
                            |#$T1@@54|
                            |#$T2@@35|
                            |#$R@@83|)))))
       (=> (and (= (type |#$T0@@70|) TyType)
                (= (type |#$T1@@54|) TyType)
                (= (type |#$T2@@35|) TyType)
                (= (type |#$R@@83|) TyType)
                (= (type bx@@65) BoxType)
                ($IsBox bx@@65
                        (Tclass._System.___hPartialFunc3
                          |#$T0@@70|
                          |#$T1@@54|
                          |#$T2@@35|
                          |#$R@@83|)))
           a!1))
     :pattern (($IsBox bx@@65
                       (Tclass._System.___hPartialFunc3
                         |#$T0@@70|
                         |#$T1@@54|
                         |#$T2@@35|
                         |#$R@@83|)))
     :skolemid |950|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@71| T@U)
         (|#$T1@@55| T@U)
         (|#$T2@@36| T@U)
         (|#$R@@84| T@U)
         (|f#0@@15| T@U))
  (! (let ((a!1 (forall ((|x0#0@@5| T@U) (|x1#0@@3| T@U) (|x2#0@@1| T@U))
                  (! (=> (and (= (type |x0#0@@5|) BoxType)
                              (= (type |x1#0@@3|) BoxType)
                              (= (type |x2#0@@1|) BoxType)
                              ($IsBox |x0#0@@5| |#$T0@@71|)
                              ($IsBox |x1#0@@3| |#$T1@@55|)
                              ($IsBox |x2#0@@1| |#$T2@@36|))
                         (|Set#Equal| (Reads3 |#$T0@@71|
                                              |#$T1@@55|
                                              |#$T2@@36|
                                              |#$R@@84|
                                              $OneHeap
                                              |f#0@@15|
                                              |x0#0@@5|
                                              |x1#0@@3|
                                              |x2#0@@1|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@5|)
                     :no-pattern (type |x1#0@@3|)
                     :no-pattern (type |x2#0@@1|)
                     :no-pattern (U_2_int |x0#0@@5|)
                     :no-pattern (U_2_bool |x0#0@@5|)
                     :no-pattern (U_2_int |x1#0@@3|)
                     :no-pattern (U_2_bool |x1#0@@3|)
                     :no-pattern (U_2_int |x2#0@@1|)
                     :no-pattern (U_2_bool |x2#0@@1|)
                     :skolemid |951|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@15|
                        (Tclass._System.___hPartialFunc3
                          |#$T0@@71|
                          |#$T1@@55|
                          |#$T2@@36|
                          |#$R@@84|))
                   (and ($Is |f#0@@15|
                             (Tclass._System.___hFunc3
                               |#$T0@@71|
                               |#$T1@@55|
                               |#$T2@@36|
                               |#$R@@84|))
                        a!1))))
       (=> (and (= (type |#$T0@@71|) TyType)
                (= (type |#$T1@@55|) TyType)
                (= (type |#$T2@@36|) TyType)
                (= (type |#$R@@84|) TyType)
                (= (type |f#0@@15|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@15|
                    (Tclass._System.___hPartialFunc3
                      |#$T0@@71|
                      |#$T1@@55|
                      |#$T2@@36|
                      |#$R@@84|)))
     :skolemid |952|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@72| T@U)
         (|#$T1@@56| T@U)
         (|#$T2@@37| T@U)
         (|#$R@@85| T@U)
         (|f#0@@16| T@U)
         ($h@@16 T@U))
  (! (=> (and (= (type |#$T0@@72|) TyType)
              (= (type |#$T1@@56|) TyType)
              (= (type |#$T2@@37|) TyType)
              (= (type |#$R@@85|) TyType)
              (= (type |f#0@@16|) HandleTypeType)
              (= (type $h@@16) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@16|
                      (Tclass._System.___hPartialFunc3
                        |#$T0@@72|
                        |#$T1@@56|
                        |#$T2@@37|
                        |#$R@@85|)
                      $h@@16)
            ($IsAlloc |f#0@@16|
                      (Tclass._System.___hFunc3
                        |#$T0@@72|
                        |#$T1@@56|
                        |#$T2@@37|
                        |#$R@@85|)
                      $h@@16)))
     :pattern (($IsAlloc |f#0@@16|
                         (Tclass._System.___hPartialFunc3
                           |#$T0@@72|
                           |#$T1@@56|
                           |#$T2@@37|
                           |#$R@@85|)
                         $h@@16))
     :skolemid |953|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@218 T@U) (arg1@@108 T@U) (arg2@@60 T@U) (arg3@@38 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3
                arg0@@218
                arg1@@108
                arg2@@60
                arg3@@38))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc3
                 arg0@@218
                 arg1@@108
                 arg2@@60
                 arg3@@38))
     :qid |funType:Tclass._System.___hTotalFunc3|)))
(assert (forall ((|#$T0@@73| T@U) (|#$T1@@57| T@U) (|#$T2@@38| T@U) (|#$R@@86| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc3
                               |#$T0@@73|
                               |#$T1@@57|
                               |#$T2@@38|
                               |#$R@@86|))
                        Tagclass._System.___hTotalFunc3)
                     (= (TagFamily (Tclass._System.___hTotalFunc3
                                     |#$T0@@73|
                                     |#$T1@@57|
                                     |#$T2@@38|
                                     |#$R@@86|))
                        |tytagFamily$_#TotalFunc3|))))
       (=> (and (= (type |#$T0@@73|) TyType)
                (= (type |#$T1@@57|) TyType)
                (= (type |#$T2@@38|) TyType)
                (= (type |#$R@@86|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc3
                 |#$T0@@73|
                 |#$T1@@57|
                 |#$T2@@38|
                 |#$R@@86|))
     :skolemid |954|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@219 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3_0 arg0@@219)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3_0 arg0@@219))
     :qid |funType:Tclass._System.___hTotalFunc3_0|)))
(assert (forall ((|#$T0@@74| T@U) (|#$T1@@58| T@U) (|#$T2@@39| T@U) (|#$R@@87| T@U))
  (! (=> (and (= (type |#$T0@@74|) TyType)
              (= (type |#$T1@@58|) TyType)
              (= (type |#$T2@@39|) TyType)
              (= (type |#$R@@87|) TyType))
         (= (Tclass._System.___hTotalFunc3_0
              (Tclass._System.___hTotalFunc3
                |#$T0@@74|
                |#$T1@@58|
                |#$T2@@39|
                |#$R@@87|))
            |#$T0@@74|))
     :pattern ((Tclass._System.___hTotalFunc3
                 |#$T0@@74|
                 |#$T1@@58|
                 |#$T2@@39|
                 |#$R@@87|))
     :skolemid |955|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@220 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3_1 arg0@@220)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3_1 arg0@@220))
     :qid |funType:Tclass._System.___hTotalFunc3_1|)))
(assert (forall ((|#$T0@@75| T@U) (|#$T1@@59| T@U) (|#$T2@@40| T@U) (|#$R@@88| T@U))
  (! (=> (and (= (type |#$T0@@75|) TyType)
              (= (type |#$T1@@59|) TyType)
              (= (type |#$T2@@40|) TyType)
              (= (type |#$R@@88|) TyType))
         (= (Tclass._System.___hTotalFunc3_1
              (Tclass._System.___hTotalFunc3
                |#$T0@@75|
                |#$T1@@59|
                |#$T2@@40|
                |#$R@@88|))
            |#$T1@@59|))
     :pattern ((Tclass._System.___hTotalFunc3
                 |#$T0@@75|
                 |#$T1@@59|
                 |#$T2@@40|
                 |#$R@@88|))
     :skolemid |956|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@221 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3_2 arg0@@221)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3_2 arg0@@221))
     :qid |funType:Tclass._System.___hTotalFunc3_2|)))
(assert (forall ((|#$T0@@76| T@U) (|#$T1@@60| T@U) (|#$T2@@41| T@U) (|#$R@@89| T@U))
  (! (=> (and (= (type |#$T0@@76|) TyType)
              (= (type |#$T1@@60|) TyType)
              (= (type |#$T2@@41|) TyType)
              (= (type |#$R@@89|) TyType))
         (= (Tclass._System.___hTotalFunc3_2
              (Tclass._System.___hTotalFunc3
                |#$T0@@76|
                |#$T1@@60|
                |#$T2@@41|
                |#$R@@89|))
            |#$T2@@41|))
     :pattern ((Tclass._System.___hTotalFunc3
                 |#$T0@@76|
                 |#$T1@@60|
                 |#$T2@@41|
                 |#$R@@89|))
     :skolemid |957|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@222 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3_3 arg0@@222)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3_3 arg0@@222))
     :qid |funType:Tclass._System.___hTotalFunc3_3|)))
(assert (forall ((|#$T0@@77| T@U) (|#$T1@@61| T@U) (|#$T2@@42| T@U) (|#$R@@90| T@U))
  (! (=> (and (= (type |#$T0@@77|) TyType)
              (= (type |#$T1@@61|) TyType)
              (= (type |#$T2@@42|) TyType)
              (= (type |#$R@@90|) TyType))
         (= (Tclass._System.___hTotalFunc3_3
              (Tclass._System.___hTotalFunc3
                |#$T0@@77|
                |#$T1@@61|
                |#$T2@@42|
                |#$R@@90|))
            |#$R@@90|))
     :pattern ((Tclass._System.___hTotalFunc3
                 |#$T0@@77|
                 |#$T1@@61|
                 |#$T2@@42|
                 |#$R@@90|))
     :skolemid |958|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@78| T@U)
         (|#$T1@@62| T@U)
         (|#$T2@@43| T@U)
         (|#$R@@91| T@U)
         (bx@@66 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@66)) bx@@66)
                     ($Is ($Unbox HandleTypeType bx@@66)
                          (Tclass._System.___hTotalFunc3
                            |#$T0@@78|
                            |#$T1@@62|
                            |#$T2@@43|
                            |#$R@@91|)))))
       (=> (and (= (type |#$T0@@78|) TyType)
                (= (type |#$T1@@62|) TyType)
                (= (type |#$T2@@43|) TyType)
                (= (type |#$R@@91|) TyType)
                (= (type bx@@66) BoxType)
                ($IsBox bx@@66
                        (Tclass._System.___hTotalFunc3
                          |#$T0@@78|
                          |#$T1@@62|
                          |#$T2@@43|
                          |#$R@@91|)))
           a!1))
     :pattern (($IsBox bx@@66
                       (Tclass._System.___hTotalFunc3
                         |#$T0@@78|
                         |#$T1@@62|
                         |#$T2@@43|
                         |#$R@@91|)))
     :skolemid |959|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@79| T@U)
         (|#$T1@@63| T@U)
         (|#$T2@@44| T@U)
         (|#$R@@92| T@U)
         (|f#0@@17| T@U))
  (! (let ((a!1 (forall ((|x0#0@@6| T@U) (|x1#0@@4| T@U) (|x2#0@@2| T@U))
                  (! (=> (and (= (type |x0#0@@6|) BoxType)
                              (= (type |x1#0@@4|) BoxType)
                              (= (type |x2#0@@2|) BoxType)
                              ($IsBox |x0#0@@6| |#$T0@@79|)
                              ($IsBox |x1#0@@4| |#$T1@@63|)
                              ($IsBox |x2#0@@2| |#$T2@@44|))
                         (Requires3 |#$T0@@79|
                                    |#$T1@@63|
                                    |#$T2@@44|
                                    |#$R@@92|
                                    $OneHeap
                                    |f#0@@17|
                                    |x0#0@@6|
                                    |x1#0@@4|
                                    |x2#0@@2|))
                     :no-pattern (type |x0#0@@6|)
                     :no-pattern (type |x1#0@@4|)
                     :no-pattern (type |x2#0@@2|)
                     :no-pattern (U_2_int |x0#0@@6|)
                     :no-pattern (U_2_bool |x0#0@@6|)
                     :no-pattern (U_2_int |x1#0@@4|)
                     :no-pattern (U_2_bool |x1#0@@4|)
                     :no-pattern (U_2_int |x2#0@@2|)
                     :no-pattern (U_2_bool |x2#0@@2|)
                     :skolemid |960|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@17|
                        (Tclass._System.___hTotalFunc3
                          |#$T0@@79|
                          |#$T1@@63|
                          |#$T2@@44|
                          |#$R@@92|))
                   (and ($Is |f#0@@17|
                             (Tclass._System.___hPartialFunc3
                               |#$T0@@79|
                               |#$T1@@63|
                               |#$T2@@44|
                               |#$R@@92|))
                        a!1))))
       (=> (and (= (type |#$T0@@79|) TyType)
                (= (type |#$T1@@63|) TyType)
                (= (type |#$T2@@44|) TyType)
                (= (type |#$R@@92|) TyType)
                (= (type |f#0@@17|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@17|
                    (Tclass._System.___hTotalFunc3
                      |#$T0@@79|
                      |#$T1@@63|
                      |#$T2@@44|
                      |#$R@@92|)))
     :skolemid |961|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@80| T@U)
         (|#$T1@@64| T@U)
         (|#$T2@@45| T@U)
         (|#$R@@93| T@U)
         (|f#0@@18| T@U)
         ($h@@17 T@U))
  (! (=> (and (= (type |#$T0@@80|) TyType)
              (= (type |#$T1@@64|) TyType)
              (= (type |#$T2@@45|) TyType)
              (= (type |#$R@@93|) TyType)
              (= (type |f#0@@18|) HandleTypeType)
              (= (type $h@@17) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@18|
                      (Tclass._System.___hTotalFunc3
                        |#$T0@@80|
                        |#$T1@@64|
                        |#$T2@@45|
                        |#$R@@93|)
                      $h@@17)
            ($IsAlloc |f#0@@18|
                      (Tclass._System.___hPartialFunc3
                        |#$T0@@80|
                        |#$T1@@64|
                        |#$T2@@45|
                        |#$R@@93|)
                      $h@@17)))
     :pattern (($IsAlloc |f#0@@18|
                         (Tclass._System.___hTotalFunc3
                           |#$T0@@80|
                           |#$T1@@64|
                           |#$T2@@45|
                           |#$R@@93|)
                         $h@@17))
     :skolemid |962|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@223 T@U))
  (! (= (type (DatatypeCtorId arg0@@223)) DtCtorIdType)
     :pattern ((DatatypeCtorId arg0@@223))
     :qid |funType:DatatypeCtorId|)))
(assert (forall ((|a#0#0#0| T@U) (|a#0#1#0| T@U))
  (! (=> (and (= (type |a#0#0#0|) BoxType) (= (type |a#0#1#0|) BoxType))
         (= (DatatypeCtorId (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|))
            |##_System._tuple#2._#Make2|))
     :pattern ((|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|))
     :skolemid |963|
     :qid |unknown.0:0|)))
(assert (forall ((d@@0 T@U))
  (! (=> (= (type d@@0) DatatypeTypeType)
         (= (_System.Tuple2.___hMake2_q d@@0)
            (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|)))
     :pattern ((_System.Tuple2.___hMake2_q d@@0))
     :skolemid |964|
     :qid |unknown.0:0|)))
(assert (forall ((d@@1 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0| T@U) (|a#1#1#0| T@U))
                  (! (and (= (type |a#1#0#0|) BoxType)
                          (= (type |a#1#1#0|) BoxType)
                          (= d@@1
                             (|#_System._tuple#2._#Make2| |a#1#0#0| |a#1#1#0|)))
                     :no-pattern (type |a#1#0#0|)
                     :no-pattern (type |a#1#1#0|)
                     :no-pattern (U_2_int |a#1#0#0|)
                     :no-pattern (U_2_bool |a#1#0#0|)
                     :no-pattern (U_2_int |a#1#1#0|)
                     :no-pattern (U_2_bool |a#1#1#0|)
                     :skolemid |965|
                     :qid |unknown.0:0|))))
       (=> (and (= (type d@@1) DatatypeTypeType)
                (_System.Tuple2.___hMake2_q d@@1))
           a!1))
     :pattern ((_System.Tuple2.___hMake2_q d@@1))
     :skolemid |966|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2$T0| T@U) (|_System._tuple#2$T1| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.Tuple2
                               |_System._tuple#2$T0|
                               |_System._tuple#2$T1|))
                        Tagclass._System.Tuple2)
                     (= (TagFamily (Tclass._System.Tuple2
                                     |_System._tuple#2$T0|
                                     |_System._tuple#2$T1|))
                        |tytagFamily$_tuple#2|))))
       (=> (and (= (type |_System._tuple#2$T0|) TyType)
                (= (type |_System._tuple#2$T1|) TyType))
           a!1))
     :pattern ((Tclass._System.Tuple2
                 |_System._tuple#2$T0|
                 |_System._tuple#2$T1|))
     :skolemid |967|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@224 T@U))
  (! (= (type (Tclass._System.Tuple2_0 arg0@@224)) TyType)
     :pattern ((Tclass._System.Tuple2_0 arg0@@224))
     :qid |funType:Tclass._System.Tuple2_0|)))
(assert (forall ((|_System._tuple#2$T0@@0| T@U) (|_System._tuple#2$T1@@0| T@U))
  (! (=> (and (= (type |_System._tuple#2$T0@@0|) TyType)
              (= (type |_System._tuple#2$T1@@0|) TyType))
         (= (Tclass._System.Tuple2_0
              (Tclass._System.Tuple2
                |_System._tuple#2$T0@@0|
                |_System._tuple#2$T1@@0|))
            |_System._tuple#2$T0@@0|))
     :pattern ((Tclass._System.Tuple2
                 |_System._tuple#2$T0@@0|
                 |_System._tuple#2$T1@@0|))
     :skolemid |968|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@225 T@U))
  (! (= (type (Tclass._System.Tuple2_1 arg0@@225)) TyType)
     :pattern ((Tclass._System.Tuple2_1 arg0@@225))
     :qid |funType:Tclass._System.Tuple2_1|)))
(assert (forall ((|_System._tuple#2$T0@@1| T@U) (|_System._tuple#2$T1@@1| T@U))
  (! (=> (and (= (type |_System._tuple#2$T0@@1|) TyType)
              (= (type |_System._tuple#2$T1@@1|) TyType))
         (= (Tclass._System.Tuple2_1
              (Tclass._System.Tuple2
                |_System._tuple#2$T0@@1|
                |_System._tuple#2$T1@@1|))
            |_System._tuple#2$T1@@1|))
     :pattern ((Tclass._System.Tuple2
                 |_System._tuple#2$T0@@1|
                 |_System._tuple#2$T1@@1|))
     :skolemid |969|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2$T0@@2| T@U)
         (|_System._tuple#2$T1@@2| T@U)
         (bx@@67 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@67)) bx@@67)
                     ($Is ($Unbox DatatypeTypeType bx@@67)
                          (Tclass._System.Tuple2
                            |_System._tuple#2$T0@@2|
                            |_System._tuple#2$T1@@2|)))))
       (=> (and (= (type |_System._tuple#2$T0@@2|) TyType)
                (= (type |_System._tuple#2$T1@@2|) TyType)
                (= (type bx@@67) BoxType)
                ($IsBox bx@@67
                        (Tclass._System.Tuple2
                          |_System._tuple#2$T0@@2|
                          |_System._tuple#2$T1@@2|)))
           a!1))
     :pattern (($IsBox bx@@67
                       (Tclass._System.Tuple2
                         |_System._tuple#2$T0@@2|
                         |_System._tuple#2$T1@@2|)))
     :skolemid |970|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2$T0@@3| T@U)
         (|_System._tuple#2$T1@@3| T@U)
         (|a#2#0#0| T@U)
         (|a#2#1#0| T@U))
  (! (=> (and (= (type |_System._tuple#2$T0@@3|) TyType)
              (= (type |_System._tuple#2$T1@@3|) TyType)
              (= (type |a#2#0#0|) BoxType)
              (= (type |a#2#1#0|) BoxType))
         (= ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|)
                 (Tclass._System.Tuple2
                   |_System._tuple#2$T0@@3|
                   |_System._tuple#2$T1@@3|))
            (and ($IsBox |a#2#0#0| |_System._tuple#2$T0@@3|)
                 ($IsBox |a#2#1#0| |_System._tuple#2$T1@@3|))))
     :pattern (($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|)
                    (Tclass._System.Tuple2
                      |_System._tuple#2$T0@@3|
                      |_System._tuple#2$T1@@3|)))
     :skolemid |971|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2$T0@@4| T@U)
         (|_System._tuple#2$T1@@4| T@U)
         (|a#3#0#0| T@U)
         (|a#3#1#0| T@U)
         ($h@@18 T@U))
  (! (=> (and (= (type |_System._tuple#2$T0@@4|) TyType)
              (= (type |_System._tuple#2$T1@@4|) TyType)
              (= (type |a#3#0#0|) BoxType)
              (= (type |a#3#1#0|) BoxType)
              (= (type $h@@18) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@18))
         (= ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|)
                      (Tclass._System.Tuple2
                        |_System._tuple#2$T0@@4|
                        |_System._tuple#2$T1@@4|)
                      $h@@18)
            (and ($IsAllocBox |a#3#0#0| |_System._tuple#2$T0@@4| $h@@18)
                 ($IsAllocBox |a#3#1#0| |_System._tuple#2$T1@@4| $h@@18))))
     :pattern (($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|)
                         (Tclass._System.Tuple2
                           |_System._tuple#2$T0@@4|
                           |_System._tuple#2$T1@@4|)
                         $h@@18))
     :skolemid |972|
     :qid |unknown.0:0|)))
(assert (forall ((d@@2 T@U) (|_System._tuple#2$T0@@5| T@U) ($h@@19 T@U))
  (! (let ((a!1 (exists ((|_System._tuple#2$T1@@5| T@U))
                  (! (and (= (type |_System._tuple#2$T1@@5|) TyType)
                          ($IsAlloc d@@2
                                    (Tclass._System.Tuple2
                                      |_System._tuple#2$T0@@5|
                                      |_System._tuple#2$T1@@5|)
                                    $h@@19))
                     :pattern (($IsAlloc d@@2
                                         (Tclass._System.Tuple2
                                           |_System._tuple#2$T0@@5|
                                           |_System._tuple#2$T1@@5|)
                                         $h@@19))
                     :skolemid |973|
                     :qid |unknown.0:0|))))
       (=> (and (= (type d@@2) DatatypeTypeType)
                (= (type |_System._tuple#2$T0@@5|) TyType)
                (= (type $h@@19) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@19)
                (_System.Tuple2.___hMake2_q d@@2)
                a!1)
           ($IsAllocBox (_System.Tuple2._0 d@@2)
                        |_System._tuple#2$T0@@5|
                        $h@@19)))
     :pattern (($IsAllocBox (_System.Tuple2._0 d@@2)
                            |_System._tuple#2$T0@@5|
                            $h@@19))
     :skolemid |974|
     :qid |unknown.0:0|)))
(assert (forall ((d@@3 T@U) (|_System._tuple#2$T1@@6| T@U) ($h@@20 T@U))
  (! (let ((a!1 (exists ((|_System._tuple#2$T0@@6| T@U))
                  (! (and (= (type |_System._tuple#2$T0@@6|) TyType)
                          ($IsAlloc d@@3
                                    (Tclass._System.Tuple2
                                      |_System._tuple#2$T0@@6|
                                      |_System._tuple#2$T1@@6|)
                                    $h@@20))
                     :pattern (($IsAlloc d@@3
                                         (Tclass._System.Tuple2
                                           |_System._tuple#2$T0@@6|
                                           |_System._tuple#2$T1@@6|)
                                         $h@@20))
                     :skolemid |975|
                     :qid |unknown.0:0|))))
       (=> (and (= (type d@@3) DatatypeTypeType)
                (= (type |_System._tuple#2$T1@@6|) TyType)
                (= (type $h@@20) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@20)
                (_System.Tuple2.___hMake2_q d@@3)
                a!1)
           ($IsAllocBox (_System.Tuple2._1 d@@3)
                        |_System._tuple#2$T1@@6|
                        $h@@20)))
     :pattern (($IsAllocBox (_System.Tuple2._1 d@@3)
                            |_System._tuple#2$T1@@6|
                            $h@@20))
     :skolemid |976|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0| T@U) (|a#4#1#0| T@U))
  (! (=> (and (= (type |a#4#0#0|) BoxType) (= (type |a#4#1#0|) BoxType))
         (= (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|))
            (Lit (|#_System._tuple#2._#Make2| |a#4#0#0| |a#4#1#0|))))
     :pattern ((|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|)))
     :skolemid |977|
     :qid |unknown.0:0|)))
(assert (forall ((|a#5#0#0| T@U) (|a#5#1#0| T@U))
  (! (=> (and (= (type |a#5#0#0|) BoxType) (= (type |a#5#1#0|) BoxType))
         (= (_System.Tuple2._0
              (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|))
            |a#5#0#0|))
     :pattern ((|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|))
     :skolemid |978|
     :qid |unknown.0:0|)))
(assert (forall ((|a#6#0#0| T@U) (|a#6#1#0| T@U))
  (! (=> (and (= (type |a#6#0#0|) BoxType) (= (type |a#6#1#0|) BoxType))
         (< (BoxRank |a#6#0#0|)
            (DtRank (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|))))
     :pattern ((|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|))
     :skolemid |979|
     :qid |unknown.0:0|)))
(assert (forall ((|a#7#0#0| T@U) (|a#7#1#0| T@U))
  (! (=> (and (= (type |a#7#0#0|) BoxType) (= (type |a#7#1#0|) BoxType))
         (= (_System.Tuple2._1
              (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|))
            |a#7#1#0|))
     :pattern ((|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|))
     :skolemid |980|
     :qid |unknown.0:0|)))
(assert (forall ((|a#8#0#0| T@U) (|a#8#1#0| T@U))
  (! (=> (and (= (type |a#8#0#0|) BoxType) (= (type |a#8#1#0|) BoxType))
         (< (BoxRank |a#8#1#0|)
            (DtRank (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|))))
     :pattern ((|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|))
     :skolemid |981|
     :qid |unknown.0:0|)))
(assert (forall ((d@@4 T@U))
  (! (=> (and (= (type d@@4) DatatypeTypeType) (|$IsA#_System.Tuple2| d@@4))
         (_System.Tuple2.___hMake2_q d@@4))
     :pattern ((|$IsA#_System.Tuple2| d@@4))
     :skolemid |982|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2$T0@@7| T@U)
         (|_System._tuple#2$T1@@7| T@U)
         (d@@5 T@U))
  (! (=> (and (= (type |_System._tuple#2$T0@@7|) TyType)
              (= (type |_System._tuple#2$T1@@7|) TyType)
              (= (type d@@5) DatatypeTypeType)
              ($Is d@@5
                   (Tclass._System.Tuple2
                     |_System._tuple#2$T0@@7|
                     |_System._tuple#2$T1@@7|)))
         (_System.Tuple2.___hMake2_q d@@5))
     :pattern ((_System.Tuple2.___hMake2_q d@@5)
               ($Is d@@5
                    (Tclass._System.Tuple2
                      |_System._tuple#2$T0@@7|
                      |_System._tuple#2$T1@@7|)))
     :skolemid |983|
     :qid |unknown.0:0|)))
(assert (forall ((a@@112 T@U) (b@@61 T@U))
  (! (let ((a!1 (= (|_System.Tuple2#Equal| a@@112 b@@61)
                   (and (= (_System.Tuple2._0 a@@112) (_System.Tuple2._0 b@@61))
                        (= (_System.Tuple2._1 a@@112) (_System.Tuple2._1 b@@61))))))
       (=> (and (= (type a@@112) DatatypeTypeType)
                (= (type b@@61) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|_System.Tuple2#Equal| a@@112 b@@61))
     :skolemid |984|
     :qid |unknown.0:0|)))
(assert (forall ((a@@113 T@U) (b@@62 T@U))
  (! (=> (and (= (type a@@113) DatatypeTypeType)
              (= (type b@@62) DatatypeTypeType))
         (= (|_System.Tuple2#Equal| a@@113 b@@62) (= a@@113 b@@62)))
     :pattern ((|_System.Tuple2#Equal| a@@113 b@@62))
     :skolemid |985|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@226 T@U) (arg1@@109 T@U) (arg2@@61 T@U))
  (! (= (type (Tclass._System.___hFunc2OSO arg0@@226 arg1@@109 arg2@@61))
        TyType)
     :pattern ((Tclass._System.___hFunc2OSO arg0@@226 arg1@@109 arg2@@61))
     :qid |funType:Tclass._System.___hFunc2OSO|)))
(assert (forall ((|#$T0@@81| T@U) (|#$T1@@65| T@U) (|#$R@@94| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc2OSO
                               |#$T0@@81|
                               |#$T1@@65|
                               |#$R@@94|))
                        Tagclass._System.___hFunc2OSO)
                     (= (TagFamily (Tclass._System.___hFunc2OSO
                                     |#$T0@@81|
                                     |#$T1@@65|
                                     |#$R@@94|))
                        |tytagFamily$_#Func2OSO|))))
       (=> (and (= (type |#$T0@@81|) TyType)
                (= (type |#$T1@@65|) TyType)
                (= (type |#$R@@94|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc2OSO |#$T0@@81| |#$T1@@65| |#$R@@94|))
     :skolemid |986|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@227 T@U))
  (! (= (type (Tclass._System.___hFunc2OSO_0 arg0@@227)) TyType)
     :pattern ((Tclass._System.___hFunc2OSO_0 arg0@@227))
     :qid |funType:Tclass._System.___hFunc2OSO_0|)))
(assert (forall ((|#$T0@@82| T@U) (|#$T1@@66| T@U) (|#$R@@95| T@U))
  (! (=> (and (= (type |#$T0@@82|) TyType)
              (= (type |#$T1@@66|) TyType)
              (= (type |#$R@@95|) TyType))
         (= (Tclass._System.___hFunc2OSO_0
              (Tclass._System.___hFunc2OSO |#$T0@@82| |#$T1@@66| |#$R@@95|))
            |#$T0@@82|))
     :pattern ((Tclass._System.___hFunc2OSO |#$T0@@82| |#$T1@@66| |#$R@@95|))
     :skolemid |987|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@228 T@U))
  (! (= (type (Tclass._System.___hFunc2OSO_1 arg0@@228)) TyType)
     :pattern ((Tclass._System.___hFunc2OSO_1 arg0@@228))
     :qid |funType:Tclass._System.___hFunc2OSO_1|)))
(assert (forall ((|#$T0@@83| T@U) (|#$T1@@67| T@U) (|#$R@@96| T@U))
  (! (=> (and (= (type |#$T0@@83|) TyType)
              (= (type |#$T1@@67|) TyType)
              (= (type |#$R@@96|) TyType))
         (= (Tclass._System.___hFunc2OSO_1
              (Tclass._System.___hFunc2OSO |#$T0@@83| |#$T1@@67| |#$R@@96|))
            |#$T1@@67|))
     :pattern ((Tclass._System.___hFunc2OSO |#$T0@@83| |#$T1@@67| |#$R@@96|))
     :skolemid |988|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@229 T@U))
  (! (= (type (Tclass._System.___hFunc2OSO_2 arg0@@229)) TyType)
     :pattern ((Tclass._System.___hFunc2OSO_2 arg0@@229))
     :qid |funType:Tclass._System.___hFunc2OSO_2|)))
(assert (forall ((|#$T0@@84| T@U) (|#$T1@@68| T@U) (|#$R@@97| T@U))
  (! (=> (and (= (type |#$T0@@84|) TyType)
              (= (type |#$T1@@68|) TyType)
              (= (type |#$R@@97|) TyType))
         (= (Tclass._System.___hFunc2OSO_2
              (Tclass._System.___hFunc2OSO |#$T0@@84| |#$T1@@68| |#$R@@97|))
            |#$R@@97|))
     :pattern ((Tclass._System.___hFunc2OSO |#$T0@@84| |#$T1@@68| |#$R@@97|))
     :skolemid |989|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@85| T@U) (|#$T1@@69| T@U) (|#$R@@98| T@U) (bx@@68 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@68)) bx@@68)
                     ($Is ($Unbox HandleTypeType bx@@68)
                          (Tclass._System.___hFunc2OSO
                            |#$T0@@85|
                            |#$T1@@69|
                            |#$R@@98|)))))
       (=> (and (= (type |#$T0@@85|) TyType)
                (= (type |#$T1@@69|) TyType)
                (= (type |#$R@@98|) TyType)
                (= (type bx@@68) BoxType)
                ($IsBox bx@@68
                        (Tclass._System.___hFunc2OSO
                          |#$T0@@85|
                          |#$T1@@69|
                          |#$R@@98|)))
           a!1))
     :pattern (($IsBox bx@@68
                       (Tclass._System.___hFunc2OSO
                         |#$T0@@85|
                         |#$T1@@69|
                         |#$R@@98|)))
     :skolemid |990|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@230 T@U) (arg1@@110 T@U) (arg2@@62 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2OSO arg0@@230 arg1@@110 arg2@@62))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc2OSO arg0@@230 arg1@@110 arg2@@62))
     :qid |funType:Tclass._System.___hPartialFunc2OSO|)))
(assert (forall ((|#$T0@@86| T@U) (|#$T1@@70| T@U) (|#$R@@99| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc2OSO
                               |#$T0@@86|
                               |#$T1@@70|
                               |#$R@@99|))
                        Tagclass._System.___hPartialFunc2OSO)
                     (= (TagFamily (Tclass._System.___hPartialFunc2OSO
                                     |#$T0@@86|
                                     |#$T1@@70|
                                     |#$R@@99|))
                        |tytagFamily$_#PartialFunc2OSO|))))
       (=> (and (= (type |#$T0@@86|) TyType)
                (= (type |#$T1@@70|) TyType)
                (= (type |#$R@@99|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc2OSO
                 |#$T0@@86|
                 |#$T1@@70|
                 |#$R@@99|))
     :skolemid |991|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@231 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2OSO_0 arg0@@231)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2OSO_0 arg0@@231))
     :qid |funType:Tclass._System.___hPartialFunc2OSO_0|)))
(assert (forall ((|#$T0@@87| T@U) (|#$T1@@71| T@U) (|#$R@@100| T@U))
  (! (=> (and (= (type |#$T0@@87|) TyType)
              (= (type |#$T1@@71|) TyType)
              (= (type |#$R@@100|) TyType))
         (= (Tclass._System.___hPartialFunc2OSO_0
              (Tclass._System.___hPartialFunc2OSO
                |#$T0@@87|
                |#$T1@@71|
                |#$R@@100|))
            |#$T0@@87|))
     :pattern ((Tclass._System.___hPartialFunc2OSO
                 |#$T0@@87|
                 |#$T1@@71|
                 |#$R@@100|))
     :skolemid |992|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@232 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2OSO_1 arg0@@232)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2OSO_1 arg0@@232))
     :qid |funType:Tclass._System.___hPartialFunc2OSO_1|)))
(assert (forall ((|#$T0@@88| T@U) (|#$T1@@72| T@U) (|#$R@@101| T@U))
  (! (=> (and (= (type |#$T0@@88|) TyType)
              (= (type |#$T1@@72|) TyType)
              (= (type |#$R@@101|) TyType))
         (= (Tclass._System.___hPartialFunc2OSO_1
              (Tclass._System.___hPartialFunc2OSO
                |#$T0@@88|
                |#$T1@@72|
                |#$R@@101|))
            |#$T1@@72|))
     :pattern ((Tclass._System.___hPartialFunc2OSO
                 |#$T0@@88|
                 |#$T1@@72|
                 |#$R@@101|))
     :skolemid |993|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@233 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2OSO_2 arg0@@233)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2OSO_2 arg0@@233))
     :qid |funType:Tclass._System.___hPartialFunc2OSO_2|)))
(assert (forall ((|#$T0@@89| T@U) (|#$T1@@73| T@U) (|#$R@@102| T@U))
  (! (=> (and (= (type |#$T0@@89|) TyType)
              (= (type |#$T1@@73|) TyType)
              (= (type |#$R@@102|) TyType))
         (= (Tclass._System.___hPartialFunc2OSO_2
              (Tclass._System.___hPartialFunc2OSO
                |#$T0@@89|
                |#$T1@@73|
                |#$R@@102|))
            |#$R@@102|))
     :pattern ((Tclass._System.___hPartialFunc2OSO
                 |#$T0@@89|
                 |#$T1@@73|
                 |#$R@@102|))
     :skolemid |994|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@90| T@U) (|#$T1@@74| T@U) (|#$R@@103| T@U) (bx@@69 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@69)) bx@@69)
                     ($Is ($Unbox HandleTypeType bx@@69)
                          (Tclass._System.___hPartialFunc2OSO
                            |#$T0@@90|
                            |#$T1@@74|
                            |#$R@@103|)))))
       (=> (and (= (type |#$T0@@90|) TyType)
                (= (type |#$T1@@74|) TyType)
                (= (type |#$R@@103|) TyType)
                (= (type bx@@69) BoxType)
                ($IsBox bx@@69
                        (Tclass._System.___hPartialFunc2OSO
                          |#$T0@@90|
                          |#$T1@@74|
                          |#$R@@103|)))
           a!1))
     :pattern (($IsBox bx@@69
                       (Tclass._System.___hPartialFunc2OSO
                         |#$T0@@90|
                         |#$T1@@74|
                         |#$R@@103|)))
     :skolemid |995|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@91| T@U) (|#$T1@@75| T@U) (|#$R@@104| T@U) (|f#0@@19| T@U))
  (! (let ((a!1 (forall ((|x0#0@@7| T@U) (|x1#0@@5| T@U))
                  (! (=> (and (= (type |x0#0@@7|) BoxType)
                              (= (type |x1#0@@5|) BoxType)
                              ($IsBox |x0#0@@7| |#$T0@@91|)
                              ($IsBox |x1#0@@5| |#$T1@@75|))
                         (|Set#Equal| (Reads2 |#$T0@@91|
                                              |#$T1@@75|
                                              |#$R@@104|
                                              $OneHeap
                                              |f#0@@19|
                                              |x0#0@@7|
                                              |x1#0@@5|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@7|)
                     :no-pattern (type |x1#0@@5|)
                     :no-pattern (U_2_int |x0#0@@7|)
                     :no-pattern (U_2_bool |x0#0@@7|)
                     :no-pattern (U_2_int |x1#0@@5|)
                     :no-pattern (U_2_bool |x1#0@@5|)
                     :skolemid |996|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@19|
                        (Tclass._System.___hPartialFunc2OSO
                          |#$T0@@91|
                          |#$T1@@75|
                          |#$R@@104|))
                   (and ($Is |f#0@@19|
                             (Tclass._System.___hFunc2OSO
                               |#$T0@@91|
                               |#$T1@@75|
                               |#$R@@104|))
                        a!1))))
       (=> (and (= (type |#$T0@@91|) TyType)
                (= (type |#$T1@@75|) TyType)
                (= (type |#$R@@104|) TyType)
                (= (type |f#0@@19|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@19|
                    (Tclass._System.___hPartialFunc2OSO
                      |#$T0@@91|
                      |#$T1@@75|
                      |#$R@@104|)))
     :skolemid |997|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@92| T@U)
         (|#$T1@@76| T@U)
         (|#$R@@105| T@U)
         (|f#0@@20| T@U)
         ($h@@21 T@U))
  (! (=> (and (= (type |#$T0@@92|) TyType)
              (= (type |#$T1@@76|) TyType)
              (= (type |#$R@@105|) TyType)
              (= (type |f#0@@20|) HandleTypeType)
              (= (type $h@@21) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@20|
                      (Tclass._System.___hPartialFunc2OSO
                        |#$T0@@92|
                        |#$T1@@76|
                        |#$R@@105|)
                      $h@@21)
            ($IsAlloc |f#0@@20|
                      (Tclass._System.___hFunc2OSO
                        |#$T0@@92|
                        |#$T1@@76|
                        |#$R@@105|)
                      $h@@21)))
     :pattern (($IsAlloc |f#0@@20|
                         (Tclass._System.___hPartialFunc2OSO
                           |#$T0@@92|
                           |#$T1@@76|
                           |#$R@@105|)
                         $h@@21))
     :skolemid |998|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@234 T@U) (arg1@@111 T@U) (arg2@@63 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2OSO arg0@@234 arg1@@111 arg2@@63))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc2OSO arg0@@234 arg1@@111 arg2@@63))
     :qid |funType:Tclass._System.___hTotalFunc2OSO|)))
(assert (forall ((|#$T0@@93| T@U) (|#$T1@@77| T@U) (|#$R@@106| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc2OSO
                               |#$T0@@93|
                               |#$T1@@77|
                               |#$R@@106|))
                        Tagclass._System.___hTotalFunc2OSO)
                     (= (TagFamily (Tclass._System.___hTotalFunc2OSO
                                     |#$T0@@93|
                                     |#$T1@@77|
                                     |#$R@@106|))
                        |tytagFamily$_#TotalFunc2OSO|))))
       (=> (and (= (type |#$T0@@93|) TyType)
                (= (type |#$T1@@77|) TyType)
                (= (type |#$R@@106|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc2OSO
                 |#$T0@@93|
                 |#$T1@@77|
                 |#$R@@106|))
     :skolemid |999|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@235 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2OSO_0 arg0@@235)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2OSO_0 arg0@@235))
     :qid |funType:Tclass._System.___hTotalFunc2OSO_0|)))
(assert (forall ((|#$T0@@94| T@U) (|#$T1@@78| T@U) (|#$R@@107| T@U))
  (! (=> (and (= (type |#$T0@@94|) TyType)
              (= (type |#$T1@@78|) TyType)
              (= (type |#$R@@107|) TyType))
         (= (Tclass._System.___hTotalFunc2OSO_0
              (Tclass._System.___hTotalFunc2OSO
                |#$T0@@94|
                |#$T1@@78|
                |#$R@@107|))
            |#$T0@@94|))
     :pattern ((Tclass._System.___hTotalFunc2OSO
                 |#$T0@@94|
                 |#$T1@@78|
                 |#$R@@107|))
     :skolemid |1000|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@236 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2OSO_1 arg0@@236)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2OSO_1 arg0@@236))
     :qid |funType:Tclass._System.___hTotalFunc2OSO_1|)))
(assert (forall ((|#$T0@@95| T@U) (|#$T1@@79| T@U) (|#$R@@108| T@U))
  (! (=> (and (= (type |#$T0@@95|) TyType)
              (= (type |#$T1@@79|) TyType)
              (= (type |#$R@@108|) TyType))
         (= (Tclass._System.___hTotalFunc2OSO_1
              (Tclass._System.___hTotalFunc2OSO
                |#$T0@@95|
                |#$T1@@79|
                |#$R@@108|))
            |#$T1@@79|))
     :pattern ((Tclass._System.___hTotalFunc2OSO
                 |#$T0@@95|
                 |#$T1@@79|
                 |#$R@@108|))
     :skolemid |1001|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@237 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2OSO_2 arg0@@237)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2OSO_2 arg0@@237))
     :qid |funType:Tclass._System.___hTotalFunc2OSO_2|)))
(assert (forall ((|#$T0@@96| T@U) (|#$T1@@80| T@U) (|#$R@@109| T@U))
  (! (=> (and (= (type |#$T0@@96|) TyType)
              (= (type |#$T1@@80|) TyType)
              (= (type |#$R@@109|) TyType))
         (= (Tclass._System.___hTotalFunc2OSO_2
              (Tclass._System.___hTotalFunc2OSO
                |#$T0@@96|
                |#$T1@@80|
                |#$R@@109|))
            |#$R@@109|))
     :pattern ((Tclass._System.___hTotalFunc2OSO
                 |#$T0@@96|
                 |#$T1@@80|
                 |#$R@@109|))
     :skolemid |1002|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@97| T@U) (|#$T1@@81| T@U) (|#$R@@110| T@U) (bx@@70 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@70)) bx@@70)
                     ($Is ($Unbox HandleTypeType bx@@70)
                          (Tclass._System.___hTotalFunc2OSO
                            |#$T0@@97|
                            |#$T1@@81|
                            |#$R@@110|)))))
       (=> (and (= (type |#$T0@@97|) TyType)
                (= (type |#$T1@@81|) TyType)
                (= (type |#$R@@110|) TyType)
                (= (type bx@@70) BoxType)
                ($IsBox bx@@70
                        (Tclass._System.___hTotalFunc2OSO
                          |#$T0@@97|
                          |#$T1@@81|
                          |#$R@@110|)))
           a!1))
     :pattern (($IsBox bx@@70
                       (Tclass._System.___hTotalFunc2OSO
                         |#$T0@@97|
                         |#$T1@@81|
                         |#$R@@110|)))
     :skolemid |1003|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@98| T@U) (|#$T1@@82| T@U) (|#$R@@111| T@U) (|f#0@@21| T@U))
  (! (let ((a!1 (forall ((|x0#0@@8| T@U) (|x1#0@@6| T@U))
                  (! (=> (and (= (type |x0#0@@8|) BoxType)
                              (= (type |x1#0@@6|) BoxType)
                              ($IsBox |x0#0@@8| |#$T0@@98|)
                              ($IsBox |x1#0@@6| |#$T1@@82|))
                         (Requires2 |#$T0@@98|
                                    |#$T1@@82|
                                    |#$R@@111|
                                    $OneHeap
                                    |f#0@@21|
                                    |x0#0@@8|
                                    |x1#0@@6|))
                     :no-pattern (type |x0#0@@8|)
                     :no-pattern (type |x1#0@@6|)
                     :no-pattern (U_2_int |x0#0@@8|)
                     :no-pattern (U_2_bool |x0#0@@8|)
                     :no-pattern (U_2_int |x1#0@@6|)
                     :no-pattern (U_2_bool |x1#0@@6|)
                     :skolemid |1004|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@21|
                        (Tclass._System.___hTotalFunc2OSO
                          |#$T0@@98|
                          |#$T1@@82|
                          |#$R@@111|))
                   (and ($Is |f#0@@21|
                             (Tclass._System.___hPartialFunc2OSO
                               |#$T0@@98|
                               |#$T1@@82|
                               |#$R@@111|))
                        a!1))))
       (=> (and (= (type |#$T0@@98|) TyType)
                (= (type |#$T1@@82|) TyType)
                (= (type |#$R@@111|) TyType)
                (= (type |f#0@@21|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@21|
                    (Tclass._System.___hTotalFunc2OSO
                      |#$T0@@98|
                      |#$T1@@82|
                      |#$R@@111|)))
     :skolemid |1005|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@99| T@U)
         (|#$T1@@83| T@U)
         (|#$R@@112| T@U)
         (|f#0@@22| T@U)
         ($h@@22 T@U))
  (! (=> (and (= (type |#$T0@@99|) TyType)
              (= (type |#$T1@@83|) TyType)
              (= (type |#$R@@112|) TyType)
              (= (type |f#0@@22|) HandleTypeType)
              (= (type $h@@22) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@22|
                      (Tclass._System.___hTotalFunc2OSO
                        |#$T0@@99|
                        |#$T1@@83|
                        |#$R@@112|)
                      $h@@22)
            ($IsAlloc |f#0@@22|
                      (Tclass._System.___hPartialFunc2OSO
                        |#$T0@@99|
                        |#$T1@@83|
                        |#$R@@112|)
                      $h@@22)))
     :pattern (($IsAlloc |f#0@@22|
                         (Tclass._System.___hTotalFunc2OSO
                           |#$T0@@99|
                           |#$T1@@83|
                           |#$R@@112|)
                         $h@@22))
     :skolemid |1006|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@238 T@U) (arg1@@112 T@U) (arg2@@64 T@U) (arg3@@39 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOO
                arg0@@238
                arg1@@112
                arg2@@64
                arg3@@39))
        TyType)
     :pattern ((Tclass._System.___hFunc3LLOO
                 arg0@@238
                 arg1@@112
                 arg2@@64
                 arg3@@39))
     :qid |funType:Tclass._System.___hFunc3LLOO|)))
(assert (forall ((|#$T0@@100| T@U) (|#$T1@@84| T@U) (|#$T2@@46| T@U) (|#$R@@113| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc3LLOO
                               |#$T0@@100|
                               |#$T1@@84|
                               |#$T2@@46|
                               |#$R@@113|))
                        Tagclass._System.___hFunc3LLOO)
                     (= (TagFamily (Tclass._System.___hFunc3LLOO
                                     |#$T0@@100|
                                     |#$T1@@84|
                                     |#$T2@@46|
                                     |#$R@@113|))
                        |tytagFamily$_#Func3LLOO|))))
       (=> (and (= (type |#$T0@@100|) TyType)
                (= (type |#$T1@@84|) TyType)
                (= (type |#$T2@@46|) TyType)
                (= (type |#$R@@113|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc3LLOO
                 |#$T0@@100|
                 |#$T1@@84|
                 |#$T2@@46|
                 |#$R@@113|))
     :skolemid |1007|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@239 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOO_0 arg0@@239)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOO_0 arg0@@239))
     :qid |funType:Tclass._System.___hFunc3LLOO_0|)))
(assert (forall ((|#$T0@@101| T@U) (|#$T1@@85| T@U) (|#$T2@@47| T@U) (|#$R@@114| T@U))
  (! (=> (and (= (type |#$T0@@101|) TyType)
              (= (type |#$T1@@85|) TyType)
              (= (type |#$T2@@47|) TyType)
              (= (type |#$R@@114|) TyType))
         (= (Tclass._System.___hFunc3LLOO_0
              (Tclass._System.___hFunc3LLOO
                |#$T0@@101|
                |#$T1@@85|
                |#$T2@@47|
                |#$R@@114|))
            |#$T0@@101|))
     :pattern ((Tclass._System.___hFunc3LLOO
                 |#$T0@@101|
                 |#$T1@@85|
                 |#$T2@@47|
                 |#$R@@114|))
     :skolemid |1008|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@240 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOO_1 arg0@@240)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOO_1 arg0@@240))
     :qid |funType:Tclass._System.___hFunc3LLOO_1|)))
(assert (forall ((|#$T0@@102| T@U) (|#$T1@@86| T@U) (|#$T2@@48| T@U) (|#$R@@115| T@U))
  (! (=> (and (= (type |#$T0@@102|) TyType)
              (= (type |#$T1@@86|) TyType)
              (= (type |#$T2@@48|) TyType)
              (= (type |#$R@@115|) TyType))
         (= (Tclass._System.___hFunc3LLOO_1
              (Tclass._System.___hFunc3LLOO
                |#$T0@@102|
                |#$T1@@86|
                |#$T2@@48|
                |#$R@@115|))
            |#$T1@@86|))
     :pattern ((Tclass._System.___hFunc3LLOO
                 |#$T0@@102|
                 |#$T1@@86|
                 |#$T2@@48|
                 |#$R@@115|))
     :skolemid |1009|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@241 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOO_2 arg0@@241)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOO_2 arg0@@241))
     :qid |funType:Tclass._System.___hFunc3LLOO_2|)))
(assert (forall ((|#$T0@@103| T@U) (|#$T1@@87| T@U) (|#$T2@@49| T@U) (|#$R@@116| T@U))
  (! (=> (and (= (type |#$T0@@103|) TyType)
              (= (type |#$T1@@87|) TyType)
              (= (type |#$T2@@49|) TyType)
              (= (type |#$R@@116|) TyType))
         (= (Tclass._System.___hFunc3LLOO_2
              (Tclass._System.___hFunc3LLOO
                |#$T0@@103|
                |#$T1@@87|
                |#$T2@@49|
                |#$R@@116|))
            |#$T2@@49|))
     :pattern ((Tclass._System.___hFunc3LLOO
                 |#$T0@@103|
                 |#$T1@@87|
                 |#$T2@@49|
                 |#$R@@116|))
     :skolemid |1010|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@242 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOO_3 arg0@@242)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOO_3 arg0@@242))
     :qid |funType:Tclass._System.___hFunc3LLOO_3|)))
(assert (forall ((|#$T0@@104| T@U) (|#$T1@@88| T@U) (|#$T2@@50| T@U) (|#$R@@117| T@U))
  (! (=> (and (= (type |#$T0@@104|) TyType)
              (= (type |#$T1@@88|) TyType)
              (= (type |#$T2@@50|) TyType)
              (= (type |#$R@@117|) TyType))
         (= (Tclass._System.___hFunc3LLOO_3
              (Tclass._System.___hFunc3LLOO
                |#$T0@@104|
                |#$T1@@88|
                |#$T2@@50|
                |#$R@@117|))
            |#$R@@117|))
     :pattern ((Tclass._System.___hFunc3LLOO
                 |#$T0@@104|
                 |#$T1@@88|
                 |#$T2@@50|
                 |#$R@@117|))
     :skolemid |1011|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@105| T@U)
         (|#$T1@@89| T@U)
         (|#$T2@@51| T@U)
         (|#$R@@118| T@U)
         (bx@@71 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@71)) bx@@71)
                     ($Is ($Unbox HandleTypeType bx@@71)
                          (Tclass._System.___hFunc3LLOO
                            |#$T0@@105|
                            |#$T1@@89|
                            |#$T2@@51|
                            |#$R@@118|)))))
       (=> (and (= (type |#$T0@@105|) TyType)
                (= (type |#$T1@@89|) TyType)
                (= (type |#$T2@@51|) TyType)
                (= (type |#$R@@118|) TyType)
                (= (type bx@@71) BoxType)
                ($IsBox bx@@71
                        (Tclass._System.___hFunc3LLOO
                          |#$T0@@105|
                          |#$T1@@89|
                          |#$T2@@51|
                          |#$R@@118|)))
           a!1))
     :pattern (($IsBox bx@@71
                       (Tclass._System.___hFunc3LLOO
                         |#$T0@@105|
                         |#$T1@@89|
                         |#$T2@@51|
                         |#$R@@118|)))
     :skolemid |1012|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@243 T@U) (arg1@@113 T@U) (arg2@@65 T@U) (arg3@@40 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOO
                arg0@@243
                arg1@@113
                arg2@@65
                arg3@@40))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOO
                 arg0@@243
                 arg1@@113
                 arg2@@65
                 arg3@@40))
     :qid |funType:Tclass._System.___hPartialFunc3LLOO|)))
(assert (forall ((|#$T0@@106| T@U) (|#$T1@@90| T@U) (|#$T2@@52| T@U) (|#$R@@119| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc3LLOO
                               |#$T0@@106|
                               |#$T1@@90|
                               |#$T2@@52|
                               |#$R@@119|))
                        Tagclass._System.___hPartialFunc3LLOO)
                     (= (TagFamily (Tclass._System.___hPartialFunc3LLOO
                                     |#$T0@@106|
                                     |#$T1@@90|
                                     |#$T2@@52|
                                     |#$R@@119|))
                        |tytagFamily$_#PartialFunc3LLOO|))))
       (=> (and (= (type |#$T0@@106|) TyType)
                (= (type |#$T1@@90|) TyType)
                (= (type |#$T2@@52|) TyType)
                (= (type |#$R@@119|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc3LLOO
                 |#$T0@@106|
                 |#$T1@@90|
                 |#$T2@@52|
                 |#$R@@119|))
     :skolemid |1013|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@244 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOO_0 arg0@@244)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOO_0 arg0@@244))
     :qid |funType:Tclass._System.___hPartialFunc3LLOO_0|)))
(assert (forall ((|#$T0@@107| T@U) (|#$T1@@91| T@U) (|#$T2@@53| T@U) (|#$R@@120| T@U))
  (! (=> (and (= (type |#$T0@@107|) TyType)
              (= (type |#$T1@@91|) TyType)
              (= (type |#$T2@@53|) TyType)
              (= (type |#$R@@120|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOO_0
              (Tclass._System.___hPartialFunc3LLOO
                |#$T0@@107|
                |#$T1@@91|
                |#$T2@@53|
                |#$R@@120|))
            |#$T0@@107|))
     :pattern ((Tclass._System.___hPartialFunc3LLOO
                 |#$T0@@107|
                 |#$T1@@91|
                 |#$T2@@53|
                 |#$R@@120|))
     :skolemid |1014|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@245 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOO_1 arg0@@245)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOO_1 arg0@@245))
     :qid |funType:Tclass._System.___hPartialFunc3LLOO_1|)))
(assert (forall ((|#$T0@@108| T@U) (|#$T1@@92| T@U) (|#$T2@@54| T@U) (|#$R@@121| T@U))
  (! (=> (and (= (type |#$T0@@108|) TyType)
              (= (type |#$T1@@92|) TyType)
              (= (type |#$T2@@54|) TyType)
              (= (type |#$R@@121|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOO_1
              (Tclass._System.___hPartialFunc3LLOO
                |#$T0@@108|
                |#$T1@@92|
                |#$T2@@54|
                |#$R@@121|))
            |#$T1@@92|))
     :pattern ((Tclass._System.___hPartialFunc3LLOO
                 |#$T0@@108|
                 |#$T1@@92|
                 |#$T2@@54|
                 |#$R@@121|))
     :skolemid |1015|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@246 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOO_2 arg0@@246)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOO_2 arg0@@246))
     :qid |funType:Tclass._System.___hPartialFunc3LLOO_2|)))
(assert (forall ((|#$T0@@109| T@U) (|#$T1@@93| T@U) (|#$T2@@55| T@U) (|#$R@@122| T@U))
  (! (=> (and (= (type |#$T0@@109|) TyType)
              (= (type |#$T1@@93|) TyType)
              (= (type |#$T2@@55|) TyType)
              (= (type |#$R@@122|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOO_2
              (Tclass._System.___hPartialFunc3LLOO
                |#$T0@@109|
                |#$T1@@93|
                |#$T2@@55|
                |#$R@@122|))
            |#$T2@@55|))
     :pattern ((Tclass._System.___hPartialFunc3LLOO
                 |#$T0@@109|
                 |#$T1@@93|
                 |#$T2@@55|
                 |#$R@@122|))
     :skolemid |1016|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@247 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOO_3 arg0@@247)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOO_3 arg0@@247))
     :qid |funType:Tclass._System.___hPartialFunc3LLOO_3|)))
(assert (forall ((|#$T0@@110| T@U) (|#$T1@@94| T@U) (|#$T2@@56| T@U) (|#$R@@123| T@U))
  (! (=> (and (= (type |#$T0@@110|) TyType)
              (= (type |#$T1@@94|) TyType)
              (= (type |#$T2@@56|) TyType)
              (= (type |#$R@@123|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOO_3
              (Tclass._System.___hPartialFunc3LLOO
                |#$T0@@110|
                |#$T1@@94|
                |#$T2@@56|
                |#$R@@123|))
            |#$R@@123|))
     :pattern ((Tclass._System.___hPartialFunc3LLOO
                 |#$T0@@110|
                 |#$T1@@94|
                 |#$T2@@56|
                 |#$R@@123|))
     :skolemid |1017|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@111| T@U)
         (|#$T1@@95| T@U)
         (|#$T2@@57| T@U)
         (|#$R@@124| T@U)
         (bx@@72 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@72)) bx@@72)
                     ($Is ($Unbox HandleTypeType bx@@72)
                          (Tclass._System.___hPartialFunc3LLOO
                            |#$T0@@111|
                            |#$T1@@95|
                            |#$T2@@57|
                            |#$R@@124|)))))
       (=> (and (= (type |#$T0@@111|) TyType)
                (= (type |#$T1@@95|) TyType)
                (= (type |#$T2@@57|) TyType)
                (= (type |#$R@@124|) TyType)
                (= (type bx@@72) BoxType)
                ($IsBox bx@@72
                        (Tclass._System.___hPartialFunc3LLOO
                          |#$T0@@111|
                          |#$T1@@95|
                          |#$T2@@57|
                          |#$R@@124|)))
           a!1))
     :pattern (($IsBox bx@@72
                       (Tclass._System.___hPartialFunc3LLOO
                         |#$T0@@111|
                         |#$T1@@95|
                         |#$T2@@57|
                         |#$R@@124|)))
     :skolemid |1018|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@112| T@U)
         (|#$T1@@96| T@U)
         (|#$T2@@58| T@U)
         (|#$R@@125| T@U)
         (|f#0@@23| T@U))
  (! (let ((a!1 (forall ((|x0#0@@9| T@U) (|x1#0@@7| T@U) (|x2#0@@3| T@U))
                  (! (=> (and (= (type |x0#0@@9|) BoxType)
                              (= (type |x1#0@@7|) BoxType)
                              (= (type |x2#0@@3|) BoxType)
                              ($IsBox |x0#0@@9| |#$T0@@112|)
                              ($IsBox |x1#0@@7| |#$T1@@96|)
                              ($IsBox |x2#0@@3| |#$T2@@58|))
                         (|Set#Equal| (Reads3 |#$T0@@112|
                                              |#$T1@@96|
                                              |#$T2@@58|
                                              |#$R@@125|
                                              $OneHeap
                                              |f#0@@23|
                                              |x0#0@@9|
                                              |x1#0@@7|
                                              |x2#0@@3|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@9|)
                     :no-pattern (type |x1#0@@7|)
                     :no-pattern (type |x2#0@@3|)
                     :no-pattern (U_2_int |x0#0@@9|)
                     :no-pattern (U_2_bool |x0#0@@9|)
                     :no-pattern (U_2_int |x1#0@@7|)
                     :no-pattern (U_2_bool |x1#0@@7|)
                     :no-pattern (U_2_int |x2#0@@3|)
                     :no-pattern (U_2_bool |x2#0@@3|)
                     :skolemid |1019|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@23|
                        (Tclass._System.___hPartialFunc3LLOO
                          |#$T0@@112|
                          |#$T1@@96|
                          |#$T2@@58|
                          |#$R@@125|))
                   (and ($Is |f#0@@23|
                             (Tclass._System.___hFunc3LLOO
                               |#$T0@@112|
                               |#$T1@@96|
                               |#$T2@@58|
                               |#$R@@125|))
                        a!1))))
       (=> (and (= (type |#$T0@@112|) TyType)
                (= (type |#$T1@@96|) TyType)
                (= (type |#$T2@@58|) TyType)
                (= (type |#$R@@125|) TyType)
                (= (type |f#0@@23|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@23|
                    (Tclass._System.___hPartialFunc3LLOO
                      |#$T0@@112|
                      |#$T1@@96|
                      |#$T2@@58|
                      |#$R@@125|)))
     :skolemid |1020|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@113| T@U)
         (|#$T1@@97| T@U)
         (|#$T2@@59| T@U)
         (|#$R@@126| T@U)
         (|f#0@@24| T@U)
         ($h@@23 T@U))
  (! (=> (and (= (type |#$T0@@113|) TyType)
              (= (type |#$T1@@97|) TyType)
              (= (type |#$T2@@59|) TyType)
              (= (type |#$R@@126|) TyType)
              (= (type |f#0@@24|) HandleTypeType)
              (= (type $h@@23) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@24|
                      (Tclass._System.___hPartialFunc3LLOO
                        |#$T0@@113|
                        |#$T1@@97|
                        |#$T2@@59|
                        |#$R@@126|)
                      $h@@23)
            ($IsAlloc |f#0@@24|
                      (Tclass._System.___hFunc3LLOO
                        |#$T0@@113|
                        |#$T1@@97|
                        |#$T2@@59|
                        |#$R@@126|)
                      $h@@23)))
     :pattern (($IsAlloc |f#0@@24|
                         (Tclass._System.___hPartialFunc3LLOO
                           |#$T0@@113|
                           |#$T1@@97|
                           |#$T2@@59|
                           |#$R@@126|)
                         $h@@23))
     :skolemid |1021|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@248 T@U) (arg1@@114 T@U) (arg2@@66 T@U) (arg3@@41 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOO
                arg0@@248
                arg1@@114
                arg2@@66
                arg3@@41))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOO
                 arg0@@248
                 arg1@@114
                 arg2@@66
                 arg3@@41))
     :qid |funType:Tclass._System.___hTotalFunc3LLOO|)))
(assert (forall ((|#$T0@@114| T@U) (|#$T1@@98| T@U) (|#$T2@@60| T@U) (|#$R@@127| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc3LLOO
                               |#$T0@@114|
                               |#$T1@@98|
                               |#$T2@@60|
                               |#$R@@127|))
                        Tagclass._System.___hTotalFunc3LLOO)
                     (= (TagFamily (Tclass._System.___hTotalFunc3LLOO
                                     |#$T0@@114|
                                     |#$T1@@98|
                                     |#$T2@@60|
                                     |#$R@@127|))
                        |tytagFamily$_#TotalFunc3LLOO|))))
       (=> (and (= (type |#$T0@@114|) TyType)
                (= (type |#$T1@@98|) TyType)
                (= (type |#$T2@@60|) TyType)
                (= (type |#$R@@127|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc3LLOO
                 |#$T0@@114|
                 |#$T1@@98|
                 |#$T2@@60|
                 |#$R@@127|))
     :skolemid |1022|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@249 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOO_0 arg0@@249)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOO_0 arg0@@249))
     :qid |funType:Tclass._System.___hTotalFunc3LLOO_0|)))
(assert (forall ((|#$T0@@115| T@U) (|#$T1@@99| T@U) (|#$T2@@61| T@U) (|#$R@@128| T@U))
  (! (=> (and (= (type |#$T0@@115|) TyType)
              (= (type |#$T1@@99|) TyType)
              (= (type |#$T2@@61|) TyType)
              (= (type |#$R@@128|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOO_0
              (Tclass._System.___hTotalFunc3LLOO
                |#$T0@@115|
                |#$T1@@99|
                |#$T2@@61|
                |#$R@@128|))
            |#$T0@@115|))
     :pattern ((Tclass._System.___hTotalFunc3LLOO
                 |#$T0@@115|
                 |#$T1@@99|
                 |#$T2@@61|
                 |#$R@@128|))
     :skolemid |1023|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@250 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOO_1 arg0@@250)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOO_1 arg0@@250))
     :qid |funType:Tclass._System.___hTotalFunc3LLOO_1|)))
(assert (forall ((|#$T0@@116| T@U) (|#$T1@@100| T@U) (|#$T2@@62| T@U) (|#$R@@129| T@U))
  (! (=> (and (= (type |#$T0@@116|) TyType)
              (= (type |#$T1@@100|) TyType)
              (= (type |#$T2@@62|) TyType)
              (= (type |#$R@@129|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOO_1
              (Tclass._System.___hTotalFunc3LLOO
                |#$T0@@116|
                |#$T1@@100|
                |#$T2@@62|
                |#$R@@129|))
            |#$T1@@100|))
     :pattern ((Tclass._System.___hTotalFunc3LLOO
                 |#$T0@@116|
                 |#$T1@@100|
                 |#$T2@@62|
                 |#$R@@129|))
     :skolemid |1024|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@251 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOO_2 arg0@@251)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOO_2 arg0@@251))
     :qid |funType:Tclass._System.___hTotalFunc3LLOO_2|)))
(assert (forall ((|#$T0@@117| T@U) (|#$T1@@101| T@U) (|#$T2@@63| T@U) (|#$R@@130| T@U))
  (! (=> (and (= (type |#$T0@@117|) TyType)
              (= (type |#$T1@@101|) TyType)
              (= (type |#$T2@@63|) TyType)
              (= (type |#$R@@130|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOO_2
              (Tclass._System.___hTotalFunc3LLOO
                |#$T0@@117|
                |#$T1@@101|
                |#$T2@@63|
                |#$R@@130|))
            |#$T2@@63|))
     :pattern ((Tclass._System.___hTotalFunc3LLOO
                 |#$T0@@117|
                 |#$T1@@101|
                 |#$T2@@63|
                 |#$R@@130|))
     :skolemid |1025|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@252 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOO_3 arg0@@252)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOO_3 arg0@@252))
     :qid |funType:Tclass._System.___hTotalFunc3LLOO_3|)))
(assert (forall ((|#$T0@@118| T@U) (|#$T1@@102| T@U) (|#$T2@@64| T@U) (|#$R@@131| T@U))
  (! (=> (and (= (type |#$T0@@118|) TyType)
              (= (type |#$T1@@102|) TyType)
              (= (type |#$T2@@64|) TyType)
              (= (type |#$R@@131|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOO_3
              (Tclass._System.___hTotalFunc3LLOO
                |#$T0@@118|
                |#$T1@@102|
                |#$T2@@64|
                |#$R@@131|))
            |#$R@@131|))
     :pattern ((Tclass._System.___hTotalFunc3LLOO
                 |#$T0@@118|
                 |#$T1@@102|
                 |#$T2@@64|
                 |#$R@@131|))
     :skolemid |1026|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@119| T@U)
         (|#$T1@@103| T@U)
         (|#$T2@@65| T@U)
         (|#$R@@132| T@U)
         (bx@@73 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@73)) bx@@73)
                     ($Is ($Unbox HandleTypeType bx@@73)
                          (Tclass._System.___hTotalFunc3LLOO
                            |#$T0@@119|
                            |#$T1@@103|
                            |#$T2@@65|
                            |#$R@@132|)))))
       (=> (and (= (type |#$T0@@119|) TyType)
                (= (type |#$T1@@103|) TyType)
                (= (type |#$T2@@65|) TyType)
                (= (type |#$R@@132|) TyType)
                (= (type bx@@73) BoxType)
                ($IsBox bx@@73
                        (Tclass._System.___hTotalFunc3LLOO
                          |#$T0@@119|
                          |#$T1@@103|
                          |#$T2@@65|
                          |#$R@@132|)))
           a!1))
     :pattern (($IsBox bx@@73
                       (Tclass._System.___hTotalFunc3LLOO
                         |#$T0@@119|
                         |#$T1@@103|
                         |#$T2@@65|
                         |#$R@@132|)))
     :skolemid |1027|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@120| T@U)
         (|#$T1@@104| T@U)
         (|#$T2@@66| T@U)
         (|#$R@@133| T@U)
         (|f#0@@25| T@U))
  (! (let ((a!1 (forall ((|x0#0@@10| T@U) (|x1#0@@8| T@U) (|x2#0@@4| T@U))
                  (! (=> (and (= (type |x0#0@@10|) BoxType)
                              (= (type |x1#0@@8|) BoxType)
                              (= (type |x2#0@@4|) BoxType)
                              ($IsBox |x0#0@@10| |#$T0@@120|)
                              ($IsBox |x1#0@@8| |#$T1@@104|)
                              ($IsBox |x2#0@@4| |#$T2@@66|))
                         (Requires3 |#$T0@@120|
                                    |#$T1@@104|
                                    |#$T2@@66|
                                    |#$R@@133|
                                    $OneHeap
                                    |f#0@@25|
                                    |x0#0@@10|
                                    |x1#0@@8|
                                    |x2#0@@4|))
                     :no-pattern (type |x0#0@@10|)
                     :no-pattern (type |x1#0@@8|)
                     :no-pattern (type |x2#0@@4|)
                     :no-pattern (U_2_int |x0#0@@10|)
                     :no-pattern (U_2_bool |x0#0@@10|)
                     :no-pattern (U_2_int |x1#0@@8|)
                     :no-pattern (U_2_bool |x1#0@@8|)
                     :no-pattern (U_2_int |x2#0@@4|)
                     :no-pattern (U_2_bool |x2#0@@4|)
                     :skolemid |1028|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@25|
                        (Tclass._System.___hTotalFunc3LLOO
                          |#$T0@@120|
                          |#$T1@@104|
                          |#$T2@@66|
                          |#$R@@133|))
                   (and ($Is |f#0@@25|
                             (Tclass._System.___hPartialFunc3LLOO
                               |#$T0@@120|
                               |#$T1@@104|
                               |#$T2@@66|
                               |#$R@@133|))
                        a!1))))
       (=> (and (= (type |#$T0@@120|) TyType)
                (= (type |#$T1@@104|) TyType)
                (= (type |#$T2@@66|) TyType)
                (= (type |#$R@@133|) TyType)
                (= (type |f#0@@25|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@25|
                    (Tclass._System.___hTotalFunc3LLOO
                      |#$T0@@120|
                      |#$T1@@104|
                      |#$T2@@66|
                      |#$R@@133|)))
     :skolemid |1029|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@121| T@U)
         (|#$T1@@105| T@U)
         (|#$T2@@67| T@U)
         (|#$R@@134| T@U)
         (|f#0@@26| T@U)
         ($h@@24 T@U))
  (! (=> (and (= (type |#$T0@@121|) TyType)
              (= (type |#$T1@@105|) TyType)
              (= (type |#$T2@@67|) TyType)
              (= (type |#$R@@134|) TyType)
              (= (type |f#0@@26|) HandleTypeType)
              (= (type $h@@24) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@26|
                      (Tclass._System.___hTotalFunc3LLOO
                        |#$T0@@121|
                        |#$T1@@105|
                        |#$T2@@67|
                        |#$R@@134|)
                      $h@@24)
            ($IsAlloc |f#0@@26|
                      (Tclass._System.___hPartialFunc3LLOO
                        |#$T0@@121|
                        |#$T1@@105|
                        |#$T2@@67|
                        |#$R@@134|)
                      $h@@24)))
     :pattern (($IsAlloc |f#0@@26|
                         (Tclass._System.___hTotalFunc3LLOO
                           |#$T0@@121|
                           |#$T1@@105|
                           |#$T2@@67|
                           |#$R@@134|)
                         $h@@24))
     :skolemid |1030|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@253 T@U) (arg1@@115 T@U))
  (! (= (type (Tclass._System.___hFunc1OS arg0@@253 arg1@@115)) TyType)
     :pattern ((Tclass._System.___hFunc1OS arg0@@253 arg1@@115))
     :qid |funType:Tclass._System.___hFunc1OS|)))
(assert (forall ((|#$T0@@122| T@U) (|#$R@@135| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|))
                        Tagclass._System.___hFunc1OS)
                     (= (TagFamily (Tclass._System.___hFunc1OS
                                     |#$T0@@122|
                                     |#$R@@135|))
                        |tytagFamily$_#Func1OS|))))
       (=> (and (= (type |#$T0@@122|) TyType) (= (type |#$R@@135|) TyType)) a!1))
     :pattern ((Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|))
     :skolemid |1031|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@254 T@U))
  (! (= (type (Tclass._System.___hFunc1OS_0 arg0@@254)) TyType)
     :pattern ((Tclass._System.___hFunc1OS_0 arg0@@254))
     :qid |funType:Tclass._System.___hFunc1OS_0|)))
(assert (forall ((|#$T0@@123| T@U) (|#$R@@136| T@U))
  (! (=> (and (= (type |#$T0@@123|) TyType) (= (type |#$R@@136|) TyType))
         (= (Tclass._System.___hFunc1OS_0
              (Tclass._System.___hFunc1OS |#$T0@@123| |#$R@@136|))
            |#$T0@@123|))
     :pattern ((Tclass._System.___hFunc1OS |#$T0@@123| |#$R@@136|))
     :skolemid |1032|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@255 T@U))
  (! (= (type (Tclass._System.___hFunc1OS_1 arg0@@255)) TyType)
     :pattern ((Tclass._System.___hFunc1OS_1 arg0@@255))
     :qid |funType:Tclass._System.___hFunc1OS_1|)))
(assert (forall ((|#$T0@@124| T@U) (|#$R@@137| T@U))
  (! (=> (and (= (type |#$T0@@124|) TyType) (= (type |#$R@@137|) TyType))
         (= (Tclass._System.___hFunc1OS_1
              (Tclass._System.___hFunc1OS |#$T0@@124| |#$R@@137|))
            |#$R@@137|))
     :pattern ((Tclass._System.___hFunc1OS |#$T0@@124| |#$R@@137|))
     :skolemid |1033|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@125| T@U) (|#$R@@138| T@U) (bx@@74 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@74)) bx@@74)
                     ($Is ($Unbox HandleTypeType bx@@74)
                          (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|)))))
       (=> (and (= (type |#$T0@@125|) TyType)
                (= (type |#$R@@138|) TyType)
                (= (type bx@@74) BoxType)
                ($IsBox bx@@74
                        (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|)))
           a!1))
     :pattern (($IsBox bx@@74
                       (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|)))
     :skolemid |1034|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@256 T@U) (arg1@@116 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1OS arg0@@256 arg1@@116)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1OS arg0@@256 arg1@@116))
     :qid |funType:Tclass._System.___hPartialFunc1OS|)))
(assert (forall ((|#$T0@@126| T@U) (|#$R@@139| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc1OS
                               |#$T0@@126|
                               |#$R@@139|))
                        Tagclass._System.___hPartialFunc1OS)
                     (= (TagFamily (Tclass._System.___hPartialFunc1OS
                                     |#$T0@@126|
                                     |#$R@@139|))
                        |tytagFamily$_#PartialFunc1OS|))))
       (=> (and (= (type |#$T0@@126|) TyType) (= (type |#$R@@139|) TyType)) a!1))
     :pattern ((Tclass._System.___hPartialFunc1OS |#$T0@@126| |#$R@@139|))
     :skolemid |1035|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@257 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1OS_0 arg0@@257)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1OS_0 arg0@@257))
     :qid |funType:Tclass._System.___hPartialFunc1OS_0|)))
(assert (forall ((|#$T0@@127| T@U) (|#$R@@140| T@U))
  (! (=> (and (= (type |#$T0@@127|) TyType) (= (type |#$R@@140|) TyType))
         (= (Tclass._System.___hPartialFunc1OS_0
              (Tclass._System.___hPartialFunc1OS |#$T0@@127| |#$R@@140|))
            |#$T0@@127|))
     :pattern ((Tclass._System.___hPartialFunc1OS |#$T0@@127| |#$R@@140|))
     :skolemid |1036|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@258 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1OS_1 arg0@@258)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1OS_1 arg0@@258))
     :qid |funType:Tclass._System.___hPartialFunc1OS_1|)))
(assert (forall ((|#$T0@@128| T@U) (|#$R@@141| T@U))
  (! (=> (and (= (type |#$T0@@128|) TyType) (= (type |#$R@@141|) TyType))
         (= (Tclass._System.___hPartialFunc1OS_1
              (Tclass._System.___hPartialFunc1OS |#$T0@@128| |#$R@@141|))
            |#$R@@141|))
     :pattern ((Tclass._System.___hPartialFunc1OS |#$T0@@128| |#$R@@141|))
     :skolemid |1037|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@129| T@U) (|#$R@@142| T@U) (bx@@75 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@75)) bx@@75)
                     ($Is ($Unbox HandleTypeType bx@@75)
                          (Tclass._System.___hPartialFunc1OS
                            |#$T0@@129|
                            |#$R@@142|)))))
       (=> (and (= (type |#$T0@@129|) TyType)
                (= (type |#$R@@142|) TyType)
                (= (type bx@@75) BoxType)
                ($IsBox bx@@75
                        (Tclass._System.___hPartialFunc1OS
                          |#$T0@@129|
                          |#$R@@142|)))
           a!1))
     :pattern (($IsBox bx@@75
                       (Tclass._System.___hPartialFunc1OS
                         |#$T0@@129|
                         |#$R@@142|)))
     :skolemid |1038|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@130| T@U) (|#$R@@143| T@U) (|f#0@@27| T@U))
  (! (let ((a!1 (forall ((|x0#0@@11| T@U))
                  (! (=> (and (= (type |x0#0@@11|) BoxType)
                              ($IsBox |x0#0@@11| |#$T0@@130|))
                         (|Set#Equal| (Reads1 |#$T0@@130|
                                              |#$R@@143|
                                              $OneHeap
                                              |f#0@@27|
                                              |x0#0@@11|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@11|)
                     :no-pattern (U_2_int |x0#0@@11|)
                     :no-pattern (U_2_bool |x0#0@@11|)
                     :skolemid |1039|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@27|
                        (Tclass._System.___hPartialFunc1OS
                          |#$T0@@130|
                          |#$R@@143|))
                   (and ($Is |f#0@@27|
                             (Tclass._System.___hFunc1OS |#$T0@@130| |#$R@@143|))
                        a!1))))
       (=> (and (= (type |#$T0@@130|) TyType)
                (= (type |#$R@@143|) TyType)
                (= (type |f#0@@27|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@27|
                    (Tclass._System.___hPartialFunc1OS |#$T0@@130| |#$R@@143|)))
     :skolemid |1040|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@131| T@U) (|#$R@@144| T@U) (|f#0@@28| T@U) ($h@@25 T@U))
  (! (=> (and (= (type |#$T0@@131|) TyType)
              (= (type |#$R@@144|) TyType)
              (= (type |f#0@@28|) HandleTypeType)
              (= (type $h@@25) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@28|
                      (Tclass._System.___hPartialFunc1OS |#$T0@@131| |#$R@@144|)
                      $h@@25)
            ($IsAlloc |f#0@@28|
                      (Tclass._System.___hFunc1OS |#$T0@@131| |#$R@@144|)
                      $h@@25)))
     :pattern (($IsAlloc |f#0@@28|
                         (Tclass._System.___hPartialFunc1OS
                           |#$T0@@131|
                           |#$R@@144|)
                         $h@@25))
     :skolemid |1041|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@259 T@U) (arg1@@117 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1OS arg0@@259 arg1@@117)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1OS arg0@@259 arg1@@117))
     :qid |funType:Tclass._System.___hTotalFunc1OS|)))
(assert (forall ((|#$T0@@132| T@U) (|#$R@@145| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc1OS
                               |#$T0@@132|
                               |#$R@@145|))
                        Tagclass._System.___hTotalFunc1OS)
                     (= (TagFamily (Tclass._System.___hTotalFunc1OS
                                     |#$T0@@132|
                                     |#$R@@145|))
                        |tytagFamily$_#TotalFunc1OS|))))
       (=> (and (= (type |#$T0@@132|) TyType) (= (type |#$R@@145|) TyType)) a!1))
     :pattern ((Tclass._System.___hTotalFunc1OS |#$T0@@132| |#$R@@145|))
     :skolemid |1042|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@260 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1OS_0 arg0@@260)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1OS_0 arg0@@260))
     :qid |funType:Tclass._System.___hTotalFunc1OS_0|)))
(assert (forall ((|#$T0@@133| T@U) (|#$R@@146| T@U))
  (! (=> (and (= (type |#$T0@@133|) TyType) (= (type |#$R@@146|) TyType))
         (= (Tclass._System.___hTotalFunc1OS_0
              (Tclass._System.___hTotalFunc1OS |#$T0@@133| |#$R@@146|))
            |#$T0@@133|))
     :pattern ((Tclass._System.___hTotalFunc1OS |#$T0@@133| |#$R@@146|))
     :skolemid |1043|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@261 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1OS_1 arg0@@261)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1OS_1 arg0@@261))
     :qid |funType:Tclass._System.___hTotalFunc1OS_1|)))
(assert (forall ((|#$T0@@134| T@U) (|#$R@@147| T@U))
  (! (=> (and (= (type |#$T0@@134|) TyType) (= (type |#$R@@147|) TyType))
         (= (Tclass._System.___hTotalFunc1OS_1
              (Tclass._System.___hTotalFunc1OS |#$T0@@134| |#$R@@147|))
            |#$R@@147|))
     :pattern ((Tclass._System.___hTotalFunc1OS |#$T0@@134| |#$R@@147|))
     :skolemid |1044|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@135| T@U) (|#$R@@148| T@U) (bx@@76 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@76)) bx@@76)
                     ($Is ($Unbox HandleTypeType bx@@76)
                          (Tclass._System.___hTotalFunc1OS
                            |#$T0@@135|
                            |#$R@@148|)))))
       (=> (and (= (type |#$T0@@135|) TyType)
                (= (type |#$R@@148|) TyType)
                (= (type bx@@76) BoxType)
                ($IsBox bx@@76
                        (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|)))
           a!1))
     :pattern (($IsBox bx@@76
                       (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|)))
     :skolemid |1045|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@136| T@U) (|#$R@@149| T@U) (|f#0@@29| T@U))
  (! (let ((a!1 (forall ((|x0#0@@12| T@U))
                  (! (=> (and (= (type |x0#0@@12|) BoxType)
                              ($IsBox |x0#0@@12| |#$T0@@136|))
                         (Requires1 |#$T0@@136|
                                    |#$R@@149|
                                    $OneHeap
                                    |f#0@@29|
                                    |x0#0@@12|))
                     :no-pattern (type |x0#0@@12|)
                     :no-pattern (U_2_int |x0#0@@12|)
                     :no-pattern (U_2_bool |x0#0@@12|)
                     :skolemid |1046|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@29|
                        (Tclass._System.___hTotalFunc1OS |#$T0@@136| |#$R@@149|))
                   (and ($Is |f#0@@29|
                             (Tclass._System.___hPartialFunc1OS
                               |#$T0@@136|
                               |#$R@@149|))
                        a!1))))
       (=> (and (= (type |#$T0@@136|) TyType)
                (= (type |#$R@@149|) TyType)
                (= (type |f#0@@29|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@29|
                    (Tclass._System.___hTotalFunc1OS |#$T0@@136| |#$R@@149|)))
     :skolemid |1047|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@137| T@U) (|#$R@@150| T@U) (|f#0@@30| T@U) ($h@@26 T@U))
  (! (=> (and (= (type |#$T0@@137|) TyType)
              (= (type |#$R@@150|) TyType)
              (= (type |f#0@@30|) HandleTypeType)
              (= (type $h@@26) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@30|
                      (Tclass._System.___hTotalFunc1OS |#$T0@@137| |#$R@@150|)
                      $h@@26)
            ($IsAlloc |f#0@@30|
                      (Tclass._System.___hPartialFunc1OS |#$T0@@137| |#$R@@150|)
                      $h@@26)))
     :pattern (($IsAlloc |f#0@@30|
                         (Tclass._System.___hTotalFunc1OS
                           |#$T0@@137|
                           |#$R@@150|)
                         $h@@26))
     :skolemid |1048|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@262 T@U))
  (! (= (type (Tclass._System.___hFunc0L arg0@@262)) TyType)
     :pattern ((Tclass._System.___hFunc0L arg0@@262))
     :qid |funType:Tclass._System.___hFunc0L|)))
(assert (forall ((|#$R@@151| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc0L |#$R@@151|))
                        Tagclass._System.___hFunc0L)
                     (= (TagFamily (Tclass._System.___hFunc0L |#$R@@151|))
                        |tytagFamily$_#Func0L|))))
       (=> (= (type |#$R@@151|) TyType) a!1))
     :pattern ((Tclass._System.___hFunc0L |#$R@@151|))
     :skolemid |1049|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@263 T@U))
  (! (= (type (Tclass._System.___hFunc0L_0 arg0@@263)) TyType)
     :pattern ((Tclass._System.___hFunc0L_0 arg0@@263))
     :qid |funType:Tclass._System.___hFunc0L_0|)))
(assert (forall ((|#$R@@152| T@U))
  (! (=> (= (type |#$R@@152|) TyType)
         (= (Tclass._System.___hFunc0L_0 (Tclass._System.___hFunc0L |#$R@@152|))
            |#$R@@152|))
     :pattern ((Tclass._System.___hFunc0L |#$R@@152|))
     :skolemid |1050|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@153| T@U) (bx@@77 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@77)) bx@@77)
                     ($Is ($Unbox HandleTypeType bx@@77)
                          (Tclass._System.___hFunc0L |#$R@@153|)))))
       (=> (and (= (type |#$R@@153|) TyType)
                (= (type bx@@77) BoxType)
                ($IsBox bx@@77 (Tclass._System.___hFunc0L |#$R@@153|)))
           a!1))
     :pattern (($IsBox bx@@77 (Tclass._System.___hFunc0L |#$R@@153|)))
     :skolemid |1051|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@264 T@U))
  (! (= (type (Tclass._System.___hPartialFunc0L arg0@@264)) TyType)
     :pattern ((Tclass._System.___hPartialFunc0L arg0@@264))
     :qid |funType:Tclass._System.___hPartialFunc0L|)))
(assert (forall ((|#$R@@154| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc0L |#$R@@154|))
                        Tagclass._System.___hPartialFunc0L)
                     (= (TagFamily (Tclass._System.___hPartialFunc0L |#$R@@154|))
                        |tytagFamily$_#PartialFunc0L|))))
       (=> (= (type |#$R@@154|) TyType) a!1))
     :pattern ((Tclass._System.___hPartialFunc0L |#$R@@154|))
     :skolemid |1052|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@265 T@U))
  (! (= (type (Tclass._System.___hPartialFunc0L_0 arg0@@265)) TyType)
     :pattern ((Tclass._System.___hPartialFunc0L_0 arg0@@265))
     :qid |funType:Tclass._System.___hPartialFunc0L_0|)))
(assert (forall ((|#$R@@155| T@U))
  (! (=> (= (type |#$R@@155|) TyType)
         (= (Tclass._System.___hPartialFunc0L_0
              (Tclass._System.___hPartialFunc0L |#$R@@155|))
            |#$R@@155|))
     :pattern ((Tclass._System.___hPartialFunc0L |#$R@@155|))
     :skolemid |1053|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@156| T@U) (bx@@78 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@78)) bx@@78)
                     ($Is ($Unbox HandleTypeType bx@@78)
                          (Tclass._System.___hPartialFunc0L |#$R@@156|)))))
       (=> (and (= (type |#$R@@156|) TyType)
                (= (type bx@@78) BoxType)
                ($IsBox bx@@78 (Tclass._System.___hPartialFunc0L |#$R@@156|)))
           a!1))
     :pattern (($IsBox bx@@78 (Tclass._System.___hPartialFunc0L |#$R@@156|)))
     :skolemid |1054|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@157| T@U) (|f#0@@31| T@U))
  (! (let ((a!1 (= ($Is |f#0@@31| (Tclass._System.___hPartialFunc0L |#$R@@157|))
                   (and ($Is |f#0@@31| (Tclass._System.___hFunc0L |#$R@@157|))
                        (|Set#Equal| (Reads0 |#$R@@157| $OneHeap |f#0@@31|)
                                     (|Set#Empty| BoxType))))))
       (=> (and (= (type |#$R@@157|) TyType)
                (= (type |f#0@@31|) HandleTypeType))
           a!1))
     :pattern (($Is |f#0@@31| (Tclass._System.___hPartialFunc0L |#$R@@157|)))
     :skolemid |1055|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@158| T@U) (|f#0@@32| T@U) ($h@@27 T@U))
  (! (=> (and (= (type |#$R@@158|) TyType)
              (= (type |f#0@@32|) HandleTypeType)
              (= (type $h@@27) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@32|
                      (Tclass._System.___hPartialFunc0L |#$R@@158|)
                      $h@@27)
            ($IsAlloc |f#0@@32| (Tclass._System.___hFunc0L |#$R@@158|) $h@@27)))
     :pattern (($IsAlloc |f#0@@32|
                         (Tclass._System.___hPartialFunc0L |#$R@@158|)
                         $h@@27))
     :skolemid |1056|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@266 T@U))
  (! (= (type (Tclass._System.___hTotalFunc0L arg0@@266)) TyType)
     :pattern ((Tclass._System.___hTotalFunc0L arg0@@266))
     :qid |funType:Tclass._System.___hTotalFunc0L|)))
(assert (forall ((|#$R@@159| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc0L |#$R@@159|))
                        Tagclass._System.___hTotalFunc0L)
                     (= (TagFamily (Tclass._System.___hTotalFunc0L |#$R@@159|))
                        |tytagFamily$_#TotalFunc0L|))))
       (=> (= (type |#$R@@159|) TyType) a!1))
     :pattern ((Tclass._System.___hTotalFunc0L |#$R@@159|))
     :skolemid |1057|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@267 T@U))
  (! (= (type (Tclass._System.___hTotalFunc0L_0 arg0@@267)) TyType)
     :pattern ((Tclass._System.___hTotalFunc0L_0 arg0@@267))
     :qid |funType:Tclass._System.___hTotalFunc0L_0|)))
(assert (forall ((|#$R@@160| T@U))
  (! (=> (= (type |#$R@@160|) TyType)
         (= (Tclass._System.___hTotalFunc0L_0
              (Tclass._System.___hTotalFunc0L |#$R@@160|))
            |#$R@@160|))
     :pattern ((Tclass._System.___hTotalFunc0L |#$R@@160|))
     :skolemid |1058|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@161| T@U) (bx@@79 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@79)) bx@@79)
                     ($Is ($Unbox HandleTypeType bx@@79)
                          (Tclass._System.___hTotalFunc0L |#$R@@161|)))))
       (=> (and (= (type |#$R@@161|) TyType)
                (= (type bx@@79) BoxType)
                ($IsBox bx@@79 (Tclass._System.___hTotalFunc0L |#$R@@161|)))
           a!1))
     :pattern (($IsBox bx@@79 (Tclass._System.___hTotalFunc0L |#$R@@161|)))
     :skolemid |1059|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@162| T@U) (|f#0@@33| T@U))
  (! (let ((a!1 (= ($Is |f#0@@33| (Tclass._System.___hTotalFunc0L |#$R@@162|))
                   (and ($Is |f#0@@33|
                             (Tclass._System.___hPartialFunc0L |#$R@@162|))
                        (Requires0 |#$R@@162| $OneHeap |f#0@@33|)))))
       (=> (and (= (type |#$R@@162|) TyType)
                (= (type |f#0@@33|) HandleTypeType))
           a!1))
     :pattern (($Is |f#0@@33| (Tclass._System.___hTotalFunc0L |#$R@@162|)))
     :skolemid |1060|
     :qid |unknown.0:0|)))
(assert (forall ((|#$R@@163| T@U) (|f#0@@34| T@U) ($h@@28 T@U))
  (! (=> (and (= (type |#$R@@163|) TyType)
              (= (type |f#0@@34|) HandleTypeType)
              (= (type $h@@28) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@34|
                      (Tclass._System.___hTotalFunc0L |#$R@@163|)
                      $h@@28)
            ($IsAlloc |f#0@@34|
                      (Tclass._System.___hPartialFunc0L |#$R@@163|)
                      $h@@28)))
     :pattern (($IsAlloc |f#0@@34|
                         (Tclass._System.___hTotalFunc0L |#$R@@163|)
                         $h@@28))
     :skolemid |1061|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@268 T@U) (arg1@@118 T@U) (arg2@@67 T@U))
  (! (= (type (Tclass._System.___hFunc2LOO arg0@@268 arg1@@118 arg2@@67))
        TyType)
     :pattern ((Tclass._System.___hFunc2LOO arg0@@268 arg1@@118 arg2@@67))
     :qid |funType:Tclass._System.___hFunc2LOO|)))
(assert (forall ((|#$T0@@138| T@U) (|#$T1@@106| T@U) (|#$R@@164| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc2LOO
                               |#$T0@@138|
                               |#$T1@@106|
                               |#$R@@164|))
                        Tagclass._System.___hFunc2LOO)
                     (= (TagFamily (Tclass._System.___hFunc2LOO
                                     |#$T0@@138|
                                     |#$T1@@106|
                                     |#$R@@164|))
                        |tytagFamily$_#Func2LOO|))))
       (=> (and (= (type |#$T0@@138|) TyType)
                (= (type |#$T1@@106|) TyType)
                (= (type |#$R@@164|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc2LOO |#$T0@@138| |#$T1@@106| |#$R@@164|))
     :skolemid |1062|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@269 T@U))
  (! (= (type (Tclass._System.___hFunc2LOO_0 arg0@@269)) TyType)
     :pattern ((Tclass._System.___hFunc2LOO_0 arg0@@269))
     :qid |funType:Tclass._System.___hFunc2LOO_0|)))
(assert (forall ((|#$T0@@139| T@U) (|#$T1@@107| T@U) (|#$R@@165| T@U))
  (! (=> (and (= (type |#$T0@@139|) TyType)
              (= (type |#$T1@@107|) TyType)
              (= (type |#$R@@165|) TyType))
         (= (Tclass._System.___hFunc2LOO_0
              (Tclass._System.___hFunc2LOO |#$T0@@139| |#$T1@@107| |#$R@@165|))
            |#$T0@@139|))
     :pattern ((Tclass._System.___hFunc2LOO |#$T0@@139| |#$T1@@107| |#$R@@165|))
     :skolemid |1063|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@270 T@U))
  (! (= (type (Tclass._System.___hFunc2LOO_1 arg0@@270)) TyType)
     :pattern ((Tclass._System.___hFunc2LOO_1 arg0@@270))
     :qid |funType:Tclass._System.___hFunc2LOO_1|)))
(assert (forall ((|#$T0@@140| T@U) (|#$T1@@108| T@U) (|#$R@@166| T@U))
  (! (=> (and (= (type |#$T0@@140|) TyType)
              (= (type |#$T1@@108|) TyType)
              (= (type |#$R@@166|) TyType))
         (= (Tclass._System.___hFunc2LOO_1
              (Tclass._System.___hFunc2LOO |#$T0@@140| |#$T1@@108| |#$R@@166|))
            |#$T1@@108|))
     :pattern ((Tclass._System.___hFunc2LOO |#$T0@@140| |#$T1@@108| |#$R@@166|))
     :skolemid |1064|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@271 T@U))
  (! (= (type (Tclass._System.___hFunc2LOO_2 arg0@@271)) TyType)
     :pattern ((Tclass._System.___hFunc2LOO_2 arg0@@271))
     :qid |funType:Tclass._System.___hFunc2LOO_2|)))
(assert (forall ((|#$T0@@141| T@U) (|#$T1@@109| T@U) (|#$R@@167| T@U))
  (! (=> (and (= (type |#$T0@@141|) TyType)
              (= (type |#$T1@@109|) TyType)
              (= (type |#$R@@167|) TyType))
         (= (Tclass._System.___hFunc2LOO_2
              (Tclass._System.___hFunc2LOO |#$T0@@141| |#$T1@@109| |#$R@@167|))
            |#$R@@167|))
     :pattern ((Tclass._System.___hFunc2LOO |#$T0@@141| |#$T1@@109| |#$R@@167|))
     :skolemid |1065|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@142| T@U) (|#$T1@@110| T@U) (|#$R@@168| T@U) (bx@@80 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@80)) bx@@80)
                     ($Is ($Unbox HandleTypeType bx@@80)
                          (Tclass._System.___hFunc2LOO
                            |#$T0@@142|
                            |#$T1@@110|
                            |#$R@@168|)))))
       (=> (and (= (type |#$T0@@142|) TyType)
                (= (type |#$T1@@110|) TyType)
                (= (type |#$R@@168|) TyType)
                (= (type bx@@80) BoxType)
                ($IsBox bx@@80
                        (Tclass._System.___hFunc2LOO
                          |#$T0@@142|
                          |#$T1@@110|
                          |#$R@@168|)))
           a!1))
     :pattern (($IsBox bx@@80
                       (Tclass._System.___hFunc2LOO
                         |#$T0@@142|
                         |#$T1@@110|
                         |#$R@@168|)))
     :skolemid |1066|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@272 T@U) (arg1@@119 T@U) (arg2@@68 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LOO arg0@@272 arg1@@119 arg2@@68))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc2LOO arg0@@272 arg1@@119 arg2@@68))
     :qid |funType:Tclass._System.___hPartialFunc2LOO|)))
(assert (forall ((|#$T0@@143| T@U) (|#$T1@@111| T@U) (|#$R@@169| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc2LOO
                               |#$T0@@143|
                               |#$T1@@111|
                               |#$R@@169|))
                        Tagclass._System.___hPartialFunc2LOO)
                     (= (TagFamily (Tclass._System.___hPartialFunc2LOO
                                     |#$T0@@143|
                                     |#$T1@@111|
                                     |#$R@@169|))
                        |tytagFamily$_#PartialFunc2LOO|))))
       (=> (and (= (type |#$T0@@143|) TyType)
                (= (type |#$T1@@111|) TyType)
                (= (type |#$R@@169|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc2LOO
                 |#$T0@@143|
                 |#$T1@@111|
                 |#$R@@169|))
     :skolemid |1067|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@273 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LOO_0 arg0@@273)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2LOO_0 arg0@@273))
     :qid |funType:Tclass._System.___hPartialFunc2LOO_0|)))
(assert (forall ((|#$T0@@144| T@U) (|#$T1@@112| T@U) (|#$R@@170| T@U))
  (! (=> (and (= (type |#$T0@@144|) TyType)
              (= (type |#$T1@@112|) TyType)
              (= (type |#$R@@170|) TyType))
         (= (Tclass._System.___hPartialFunc2LOO_0
              (Tclass._System.___hPartialFunc2LOO
                |#$T0@@144|
                |#$T1@@112|
                |#$R@@170|))
            |#$T0@@144|))
     :pattern ((Tclass._System.___hPartialFunc2LOO
                 |#$T0@@144|
                 |#$T1@@112|
                 |#$R@@170|))
     :skolemid |1068|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@274 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LOO_1 arg0@@274)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2LOO_1 arg0@@274))
     :qid |funType:Tclass._System.___hPartialFunc2LOO_1|)))
(assert (forall ((|#$T0@@145| T@U) (|#$T1@@113| T@U) (|#$R@@171| T@U))
  (! (=> (and (= (type |#$T0@@145|) TyType)
              (= (type |#$T1@@113|) TyType)
              (= (type |#$R@@171|) TyType))
         (= (Tclass._System.___hPartialFunc2LOO_1
              (Tclass._System.___hPartialFunc2LOO
                |#$T0@@145|
                |#$T1@@113|
                |#$R@@171|))
            |#$T1@@113|))
     :pattern ((Tclass._System.___hPartialFunc2LOO
                 |#$T0@@145|
                 |#$T1@@113|
                 |#$R@@171|))
     :skolemid |1069|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@275 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LOO_2 arg0@@275)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2LOO_2 arg0@@275))
     :qid |funType:Tclass._System.___hPartialFunc2LOO_2|)))
(assert (forall ((|#$T0@@146| T@U) (|#$T1@@114| T@U) (|#$R@@172| T@U))
  (! (=> (and (= (type |#$T0@@146|) TyType)
              (= (type |#$T1@@114|) TyType)
              (= (type |#$R@@172|) TyType))
         (= (Tclass._System.___hPartialFunc2LOO_2
              (Tclass._System.___hPartialFunc2LOO
                |#$T0@@146|
                |#$T1@@114|
                |#$R@@172|))
            |#$R@@172|))
     :pattern ((Tclass._System.___hPartialFunc2LOO
                 |#$T0@@146|
                 |#$T1@@114|
                 |#$R@@172|))
     :skolemid |1070|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@147| T@U) (|#$T1@@115| T@U) (|#$R@@173| T@U) (bx@@81 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@81)) bx@@81)
                     ($Is ($Unbox HandleTypeType bx@@81)
                          (Tclass._System.___hPartialFunc2LOO
                            |#$T0@@147|
                            |#$T1@@115|
                            |#$R@@173|)))))
       (=> (and (= (type |#$T0@@147|) TyType)
                (= (type |#$T1@@115|) TyType)
                (= (type |#$R@@173|) TyType)
                (= (type bx@@81) BoxType)
                ($IsBox bx@@81
                        (Tclass._System.___hPartialFunc2LOO
                          |#$T0@@147|
                          |#$T1@@115|
                          |#$R@@173|)))
           a!1))
     :pattern (($IsBox bx@@81
                       (Tclass._System.___hPartialFunc2LOO
                         |#$T0@@147|
                         |#$T1@@115|
                         |#$R@@173|)))
     :skolemid |1071|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@148| T@U) (|#$T1@@116| T@U) (|#$R@@174| T@U) (|f#0@@35| T@U))
  (! (let ((a!1 (forall ((|x0#0@@13| T@U) (|x1#0@@9| T@U))
                  (! (=> (and (= (type |x0#0@@13|) BoxType)
                              (= (type |x1#0@@9|) BoxType)
                              ($IsBox |x0#0@@13| |#$T0@@148|)
                              ($IsBox |x1#0@@9| |#$T1@@116|))
                         (|Set#Equal| (Reads2 |#$T0@@148|
                                              |#$T1@@116|
                                              |#$R@@174|
                                              $OneHeap
                                              |f#0@@35|
                                              |x0#0@@13|
                                              |x1#0@@9|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@13|)
                     :no-pattern (type |x1#0@@9|)
                     :no-pattern (U_2_int |x0#0@@13|)
                     :no-pattern (U_2_bool |x0#0@@13|)
                     :no-pattern (U_2_int |x1#0@@9|)
                     :no-pattern (U_2_bool |x1#0@@9|)
                     :skolemid |1072|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@35|
                        (Tclass._System.___hPartialFunc2LOO
                          |#$T0@@148|
                          |#$T1@@116|
                          |#$R@@174|))
                   (and ($Is |f#0@@35|
                             (Tclass._System.___hFunc2LOO
                               |#$T0@@148|
                               |#$T1@@116|
                               |#$R@@174|))
                        a!1))))
       (=> (and (= (type |#$T0@@148|) TyType)
                (= (type |#$T1@@116|) TyType)
                (= (type |#$R@@174|) TyType)
                (= (type |f#0@@35|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@35|
                    (Tclass._System.___hPartialFunc2LOO
                      |#$T0@@148|
                      |#$T1@@116|
                      |#$R@@174|)))
     :skolemid |1073|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@149| T@U)
         (|#$T1@@117| T@U)
         (|#$R@@175| T@U)
         (|f#0@@36| T@U)
         ($h@@29 T@U))
  (! (=> (and (= (type |#$T0@@149|) TyType)
              (= (type |#$T1@@117|) TyType)
              (= (type |#$R@@175|) TyType)
              (= (type |f#0@@36|) HandleTypeType)
              (= (type $h@@29) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@36|
                      (Tclass._System.___hPartialFunc2LOO
                        |#$T0@@149|
                        |#$T1@@117|
                        |#$R@@175|)
                      $h@@29)
            ($IsAlloc |f#0@@36|
                      (Tclass._System.___hFunc2LOO
                        |#$T0@@149|
                        |#$T1@@117|
                        |#$R@@175|)
                      $h@@29)))
     :pattern (($IsAlloc |f#0@@36|
                         (Tclass._System.___hPartialFunc2LOO
                           |#$T0@@149|
                           |#$T1@@117|
                           |#$R@@175|)
                         $h@@29))
     :skolemid |1074|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@276 T@U) (arg1@@120 T@U) (arg2@@69 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LOO arg0@@276 arg1@@120 arg2@@69))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc2LOO arg0@@276 arg1@@120 arg2@@69))
     :qid |funType:Tclass._System.___hTotalFunc2LOO|)))
(assert (forall ((|#$T0@@150| T@U) (|#$T1@@118| T@U) (|#$R@@176| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc2LOO
                               |#$T0@@150|
                               |#$T1@@118|
                               |#$R@@176|))
                        Tagclass._System.___hTotalFunc2LOO)
                     (= (TagFamily (Tclass._System.___hTotalFunc2LOO
                                     |#$T0@@150|
                                     |#$T1@@118|
                                     |#$R@@176|))
                        |tytagFamily$_#TotalFunc2LOO|))))
       (=> (and (= (type |#$T0@@150|) TyType)
                (= (type |#$T1@@118|) TyType)
                (= (type |#$R@@176|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc2LOO
                 |#$T0@@150|
                 |#$T1@@118|
                 |#$R@@176|))
     :skolemid |1075|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@277 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LOO_0 arg0@@277)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2LOO_0 arg0@@277))
     :qid |funType:Tclass._System.___hTotalFunc2LOO_0|)))
(assert (forall ((|#$T0@@151| T@U) (|#$T1@@119| T@U) (|#$R@@177| T@U))
  (! (=> (and (= (type |#$T0@@151|) TyType)
              (= (type |#$T1@@119|) TyType)
              (= (type |#$R@@177|) TyType))
         (= (Tclass._System.___hTotalFunc2LOO_0
              (Tclass._System.___hTotalFunc2LOO
                |#$T0@@151|
                |#$T1@@119|
                |#$R@@177|))
            |#$T0@@151|))
     :pattern ((Tclass._System.___hTotalFunc2LOO
                 |#$T0@@151|
                 |#$T1@@119|
                 |#$R@@177|))
     :skolemid |1076|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@278 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LOO_1 arg0@@278)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2LOO_1 arg0@@278))
     :qid |funType:Tclass._System.___hTotalFunc2LOO_1|)))
(assert (forall ((|#$T0@@152| T@U) (|#$T1@@120| T@U) (|#$R@@178| T@U))
  (! (=> (and (= (type |#$T0@@152|) TyType)
              (= (type |#$T1@@120|) TyType)
              (= (type |#$R@@178|) TyType))
         (= (Tclass._System.___hTotalFunc2LOO_1
              (Tclass._System.___hTotalFunc2LOO
                |#$T0@@152|
                |#$T1@@120|
                |#$R@@178|))
            |#$T1@@120|))
     :pattern ((Tclass._System.___hTotalFunc2LOO
                 |#$T0@@152|
                 |#$T1@@120|
                 |#$R@@178|))
     :skolemid |1077|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@279 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LOO_2 arg0@@279)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2LOO_2 arg0@@279))
     :qid |funType:Tclass._System.___hTotalFunc2LOO_2|)))
(assert (forall ((|#$T0@@153| T@U) (|#$T1@@121| T@U) (|#$R@@179| T@U))
  (! (=> (and (= (type |#$T0@@153|) TyType)
              (= (type |#$T1@@121|) TyType)
              (= (type |#$R@@179|) TyType))
         (= (Tclass._System.___hTotalFunc2LOO_2
              (Tclass._System.___hTotalFunc2LOO
                |#$T0@@153|
                |#$T1@@121|
                |#$R@@179|))
            |#$R@@179|))
     :pattern ((Tclass._System.___hTotalFunc2LOO
                 |#$T0@@153|
                 |#$T1@@121|
                 |#$R@@179|))
     :skolemid |1078|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@154| T@U) (|#$T1@@122| T@U) (|#$R@@180| T@U) (bx@@82 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@82)) bx@@82)
                     ($Is ($Unbox HandleTypeType bx@@82)
                          (Tclass._System.___hTotalFunc2LOO
                            |#$T0@@154|
                            |#$T1@@122|
                            |#$R@@180|)))))
       (=> (and (= (type |#$T0@@154|) TyType)
                (= (type |#$T1@@122|) TyType)
                (= (type |#$R@@180|) TyType)
                (= (type bx@@82) BoxType)
                ($IsBox bx@@82
                        (Tclass._System.___hTotalFunc2LOO
                          |#$T0@@154|
                          |#$T1@@122|
                          |#$R@@180|)))
           a!1))
     :pattern (($IsBox bx@@82
                       (Tclass._System.___hTotalFunc2LOO
                         |#$T0@@154|
                         |#$T1@@122|
                         |#$R@@180|)))
     :skolemid |1079|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@155| T@U) (|#$T1@@123| T@U) (|#$R@@181| T@U) (|f#0@@37| T@U))
  (! (let ((a!1 (forall ((|x0#0@@14| T@U) (|x1#0@@10| T@U))
                  (! (=> (and (= (type |x0#0@@14|) BoxType)
                              (= (type |x1#0@@10|) BoxType)
                              ($IsBox |x0#0@@14| |#$T0@@155|)
                              ($IsBox |x1#0@@10| |#$T1@@123|))
                         (Requires2 |#$T0@@155|
                                    |#$T1@@123|
                                    |#$R@@181|
                                    $OneHeap
                                    |f#0@@37|
                                    |x0#0@@14|
                                    |x1#0@@10|))
                     :no-pattern (type |x0#0@@14|)
                     :no-pattern (type |x1#0@@10|)
                     :no-pattern (U_2_int |x0#0@@14|)
                     :no-pattern (U_2_bool |x0#0@@14|)
                     :no-pattern (U_2_int |x1#0@@10|)
                     :no-pattern (U_2_bool |x1#0@@10|)
                     :skolemid |1080|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@37|
                        (Tclass._System.___hTotalFunc2LOO
                          |#$T0@@155|
                          |#$T1@@123|
                          |#$R@@181|))
                   (and ($Is |f#0@@37|
                             (Tclass._System.___hPartialFunc2LOO
                               |#$T0@@155|
                               |#$T1@@123|
                               |#$R@@181|))
                        a!1))))
       (=> (and (= (type |#$T0@@155|) TyType)
                (= (type |#$T1@@123|) TyType)
                (= (type |#$R@@181|) TyType)
                (= (type |f#0@@37|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@37|
                    (Tclass._System.___hTotalFunc2LOO
                      |#$T0@@155|
                      |#$T1@@123|
                      |#$R@@181|)))
     :skolemid |1081|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@156| T@U)
         (|#$T1@@124| T@U)
         (|#$R@@182| T@U)
         (|f#0@@38| T@U)
         ($h@@30 T@U))
  (! (=> (and (= (type |#$T0@@156|) TyType)
              (= (type |#$T1@@124|) TyType)
              (= (type |#$R@@182|) TyType)
              (= (type |f#0@@38|) HandleTypeType)
              (= (type $h@@30) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@38|
                      (Tclass._System.___hTotalFunc2LOO
                        |#$T0@@156|
                        |#$T1@@124|
                        |#$R@@182|)
                      $h@@30)
            ($IsAlloc |f#0@@38|
                      (Tclass._System.___hPartialFunc2LOO
                        |#$T0@@156|
                        |#$T1@@124|
                        |#$R@@182|)
                      $h@@30)))
     :pattern (($IsAlloc |f#0@@38|
                         (Tclass._System.___hTotalFunc2LOO
                           |#$T0@@156|
                           |#$T1@@124|
                           |#$R@@182|)
                         $h@@30))
     :skolemid |1082|
     :qid |unknown.0:0|)))
(assert (= (type |#_System._tuple#0._#Make0|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#_System._tuple#0._#Make0|) |##_System._tuple#0._#Make0|))
(assert (forall ((d@@6 T@U))
  (! (=> (= (type d@@6) DatatypeTypeType)
         (= (_System.Tuple0.___hMake0_q d@@6)
            (= (DatatypeCtorId d@@6) |##_System._tuple#0._#Make0|)))
     :pattern ((_System.Tuple0.___hMake0_q d@@6))
     :skolemid |1083|
     :qid |unknown.0:0|)))
(assert (forall ((d@@7 T@U))
  (! (=> (and (= (type d@@7) DatatypeTypeType)
              (_System.Tuple0.___hMake0_q d@@7))
         (= d@@7 |#_System._tuple#0._#Make0|))
     :pattern ((_System.Tuple0.___hMake0_q d@@7))
     :skolemid |1084|
     :qid |unknown.0:0|)))
(assert (= (type Tclass._System.Tuple0) TyType))
(assert (= (Tag Tclass._System.Tuple0) Tagclass._System.Tuple0))
(assert (= (TagFamily Tclass._System.Tuple0) |tytagFamily$_tuple#0|))
(assert (forall ((bx@@83 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@83)) bx@@83)
                     ($Is ($Unbox DatatypeTypeType bx@@83)
                          Tclass._System.Tuple0))))
       (=> (and (= (type bx@@83) BoxType) ($IsBox bx@@83 Tclass._System.Tuple0))
           a!1))
     :pattern (($IsBox bx@@83 Tclass._System.Tuple0))
     :skolemid |1085|
     :qid |unknown.0:0|)))
(assert ($Is |#_System._tuple#0._#Make0| Tclass._System.Tuple0))
(assert (forall (($h@@31 T@U))
  (! (=> (and (= (type $h@@31) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@31))
         ($IsAlloc |#_System._tuple#0._#Make0| Tclass._System.Tuple0 $h@@31))
     :pattern (($IsAlloc |#_System._tuple#0._#Make0|
                         Tclass._System.Tuple0
                         $h@@31))
     :skolemid |1086|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#_System._tuple#0._#Make0| (Lit |#_System._tuple#0._#Make0|)))
(assert (forall ((d@@8 T@U))
  (! (=> (and (= (type d@@8) DatatypeTypeType) (|$IsA#_System.Tuple0| d@@8))
         (_System.Tuple0.___hMake0_q d@@8))
     :pattern ((|$IsA#_System.Tuple0| d@@8))
     :skolemid |1087|
     :qid |unknown.0:0|)))
(assert (forall ((d@@9 T@U))
  (! (=> (and (= (type d@@9) DatatypeTypeType) ($Is d@@9 Tclass._System.Tuple0))
         (_System.Tuple0.___hMake0_q d@@9))
     :pattern ((_System.Tuple0.___hMake0_q d@@9)
               ($Is d@@9 Tclass._System.Tuple0))
     :skolemid |1088|
     :qid |unknown.0:0|)))
(assert (forall ((a@@114 T@U) (b@@63 T@U))
  (! (=> (and (= (type a@@114) DatatypeTypeType)
              (= (type b@@63) DatatypeTypeType)
              true)
         (= (|_System.Tuple0#Equal| a@@114 b@@63) true))
     :pattern ((|_System.Tuple0#Equal| a@@114 b@@63))
     :skolemid |1089|
     :qid |unknown.0:0|)))
(assert (forall ((a@@115 T@U) (b@@64 T@U))
  (! (=> (and (= (type a@@115) DatatypeTypeType)
              (= (type b@@64) DatatypeTypeType))
         (= (|_System.Tuple0#Equal| a@@115 b@@64) (= a@@115 b@@64)))
     :pattern ((|_System.Tuple0#Equal| a@@115 b@@64))
     :skolemid |1090|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@280 T@U) (arg1@@121 T@U))
  (! (= (type (Tclass._System.___hFunc1OL arg0@@280 arg1@@121)) TyType)
     :pattern ((Tclass._System.___hFunc1OL arg0@@280 arg1@@121))
     :qid |funType:Tclass._System.___hFunc1OL|)))
(assert (forall ((|#$T0@@157| T@U) (|#$R@@183| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|))
                        Tagclass._System.___hFunc1OL)
                     (= (TagFamily (Tclass._System.___hFunc1OL
                                     |#$T0@@157|
                                     |#$R@@183|))
                        |tytagFamily$_#Func1OL|))))
       (=> (and (= (type |#$T0@@157|) TyType) (= (type |#$R@@183|) TyType)) a!1))
     :pattern ((Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|))
     :skolemid |1091|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@281 T@U))
  (! (= (type (Tclass._System.___hFunc1OL_0 arg0@@281)) TyType)
     :pattern ((Tclass._System.___hFunc1OL_0 arg0@@281))
     :qid |funType:Tclass._System.___hFunc1OL_0|)))
(assert (forall ((|#$T0@@158| T@U) (|#$R@@184| T@U))
  (! (=> (and (= (type |#$T0@@158|) TyType) (= (type |#$R@@184|) TyType))
         (= (Tclass._System.___hFunc1OL_0
              (Tclass._System.___hFunc1OL |#$T0@@158| |#$R@@184|))
            |#$T0@@158|))
     :pattern ((Tclass._System.___hFunc1OL |#$T0@@158| |#$R@@184|))
     :skolemid |1092|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@282 T@U))
  (! (= (type (Tclass._System.___hFunc1OL_1 arg0@@282)) TyType)
     :pattern ((Tclass._System.___hFunc1OL_1 arg0@@282))
     :qid |funType:Tclass._System.___hFunc1OL_1|)))
(assert (forall ((|#$T0@@159| T@U) (|#$R@@185| T@U))
  (! (=> (and (= (type |#$T0@@159|) TyType) (= (type |#$R@@185|) TyType))
         (= (Tclass._System.___hFunc1OL_1
              (Tclass._System.___hFunc1OL |#$T0@@159| |#$R@@185|))
            |#$R@@185|))
     :pattern ((Tclass._System.___hFunc1OL |#$T0@@159| |#$R@@185|))
     :skolemid |1093|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@160| T@U) (|#$R@@186| T@U) (bx@@84 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@84)) bx@@84)
                     ($Is ($Unbox HandleTypeType bx@@84)
                          (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|)))))
       (=> (and (= (type |#$T0@@160|) TyType)
                (= (type |#$R@@186|) TyType)
                (= (type bx@@84) BoxType)
                ($IsBox bx@@84
                        (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|)))
           a!1))
     :pattern (($IsBox bx@@84
                       (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|)))
     :skolemid |1094|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@283 T@U) (arg1@@122 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1OL arg0@@283 arg1@@122)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1OL arg0@@283 arg1@@122))
     :qid |funType:Tclass._System.___hPartialFunc1OL|)))
(assert (forall ((|#$T0@@161| T@U) (|#$R@@187| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc1OL
                               |#$T0@@161|
                               |#$R@@187|))
                        Tagclass._System.___hPartialFunc1OL)
                     (= (TagFamily (Tclass._System.___hPartialFunc1OL
                                     |#$T0@@161|
                                     |#$R@@187|))
                        |tytagFamily$_#PartialFunc1OL|))))
       (=> (and (= (type |#$T0@@161|) TyType) (= (type |#$R@@187|) TyType)) a!1))
     :pattern ((Tclass._System.___hPartialFunc1OL |#$T0@@161| |#$R@@187|))
     :skolemid |1095|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@284 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1OL_0 arg0@@284)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1OL_0 arg0@@284))
     :qid |funType:Tclass._System.___hPartialFunc1OL_0|)))
(assert (forall ((|#$T0@@162| T@U) (|#$R@@188| T@U))
  (! (=> (and (= (type |#$T0@@162|) TyType) (= (type |#$R@@188|) TyType))
         (= (Tclass._System.___hPartialFunc1OL_0
              (Tclass._System.___hPartialFunc1OL |#$T0@@162| |#$R@@188|))
            |#$T0@@162|))
     :pattern ((Tclass._System.___hPartialFunc1OL |#$T0@@162| |#$R@@188|))
     :skolemid |1096|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@285 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1OL_1 arg0@@285)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1OL_1 arg0@@285))
     :qid |funType:Tclass._System.___hPartialFunc1OL_1|)))
(assert (forall ((|#$T0@@163| T@U) (|#$R@@189| T@U))
  (! (=> (and (= (type |#$T0@@163|) TyType) (= (type |#$R@@189|) TyType))
         (= (Tclass._System.___hPartialFunc1OL_1
              (Tclass._System.___hPartialFunc1OL |#$T0@@163| |#$R@@189|))
            |#$R@@189|))
     :pattern ((Tclass._System.___hPartialFunc1OL |#$T0@@163| |#$R@@189|))
     :skolemid |1097|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@164| T@U) (|#$R@@190| T@U) (bx@@85 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@85)) bx@@85)
                     ($Is ($Unbox HandleTypeType bx@@85)
                          (Tclass._System.___hPartialFunc1OL
                            |#$T0@@164|
                            |#$R@@190|)))))
       (=> (and (= (type |#$T0@@164|) TyType)
                (= (type |#$R@@190|) TyType)
                (= (type bx@@85) BoxType)
                ($IsBox bx@@85
                        (Tclass._System.___hPartialFunc1OL
                          |#$T0@@164|
                          |#$R@@190|)))
           a!1))
     :pattern (($IsBox bx@@85
                       (Tclass._System.___hPartialFunc1OL
                         |#$T0@@164|
                         |#$R@@190|)))
     :skolemid |1098|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@165| T@U) (|#$R@@191| T@U) (|f#0@@39| T@U))
  (! (let ((a!1 (forall ((|x0#0@@15| T@U))
                  (! (=> (and (= (type |x0#0@@15|) BoxType)
                              ($IsBox |x0#0@@15| |#$T0@@165|))
                         (|Set#Equal| (Reads1 |#$T0@@165|
                                              |#$R@@191|
                                              $OneHeap
                                              |f#0@@39|
                                              |x0#0@@15|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@15|)
                     :no-pattern (U_2_int |x0#0@@15|)
                     :no-pattern (U_2_bool |x0#0@@15|)
                     :skolemid |1099|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@39|
                        (Tclass._System.___hPartialFunc1OL
                          |#$T0@@165|
                          |#$R@@191|))
                   (and ($Is |f#0@@39|
                             (Tclass._System.___hFunc1OL |#$T0@@165| |#$R@@191|))
                        a!1))))
       (=> (and (= (type |#$T0@@165|) TyType)
                (= (type |#$R@@191|) TyType)
                (= (type |f#0@@39|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@39|
                    (Tclass._System.___hPartialFunc1OL |#$T0@@165| |#$R@@191|)))
     :skolemid |1100|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@166| T@U) (|#$R@@192| T@U) (|f#0@@40| T@U) ($h@@32 T@U))
  (! (=> (and (= (type |#$T0@@166|) TyType)
              (= (type |#$R@@192|) TyType)
              (= (type |f#0@@40|) HandleTypeType)
              (= (type $h@@32) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@40|
                      (Tclass._System.___hPartialFunc1OL |#$T0@@166| |#$R@@192|)
                      $h@@32)
            ($IsAlloc |f#0@@40|
                      (Tclass._System.___hFunc1OL |#$T0@@166| |#$R@@192|)
                      $h@@32)))
     :pattern (($IsAlloc |f#0@@40|
                         (Tclass._System.___hPartialFunc1OL
                           |#$T0@@166|
                           |#$R@@192|)
                         $h@@32))
     :skolemid |1101|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@286 T@U) (arg1@@123 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1OL arg0@@286 arg1@@123)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1OL arg0@@286 arg1@@123))
     :qid |funType:Tclass._System.___hTotalFunc1OL|)))
(assert (forall ((|#$T0@@167| T@U) (|#$R@@193| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc1OL
                               |#$T0@@167|
                               |#$R@@193|))
                        Tagclass._System.___hTotalFunc1OL)
                     (= (TagFamily (Tclass._System.___hTotalFunc1OL
                                     |#$T0@@167|
                                     |#$R@@193|))
                        |tytagFamily$_#TotalFunc1OL|))))
       (=> (and (= (type |#$T0@@167|) TyType) (= (type |#$R@@193|) TyType)) a!1))
     :pattern ((Tclass._System.___hTotalFunc1OL |#$T0@@167| |#$R@@193|))
     :skolemid |1102|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@287 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1OL_0 arg0@@287)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1OL_0 arg0@@287))
     :qid |funType:Tclass._System.___hTotalFunc1OL_0|)))
(assert (forall ((|#$T0@@168| T@U) (|#$R@@194| T@U))
  (! (=> (and (= (type |#$T0@@168|) TyType) (= (type |#$R@@194|) TyType))
         (= (Tclass._System.___hTotalFunc1OL_0
              (Tclass._System.___hTotalFunc1OL |#$T0@@168| |#$R@@194|))
            |#$T0@@168|))
     :pattern ((Tclass._System.___hTotalFunc1OL |#$T0@@168| |#$R@@194|))
     :skolemid |1103|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@288 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1OL_1 arg0@@288)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1OL_1 arg0@@288))
     :qid |funType:Tclass._System.___hTotalFunc1OL_1|)))
(assert (forall ((|#$T0@@169| T@U) (|#$R@@195| T@U))
  (! (=> (and (= (type |#$T0@@169|) TyType) (= (type |#$R@@195|) TyType))
         (= (Tclass._System.___hTotalFunc1OL_1
              (Tclass._System.___hTotalFunc1OL |#$T0@@169| |#$R@@195|))
            |#$R@@195|))
     :pattern ((Tclass._System.___hTotalFunc1OL |#$T0@@169| |#$R@@195|))
     :skolemid |1104|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@170| T@U) (|#$R@@196| T@U) (bx@@86 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@86)) bx@@86)
                     ($Is ($Unbox HandleTypeType bx@@86)
                          (Tclass._System.___hTotalFunc1OL
                            |#$T0@@170|
                            |#$R@@196|)))))
       (=> (and (= (type |#$T0@@170|) TyType)
                (= (type |#$R@@196|) TyType)
                (= (type bx@@86) BoxType)
                ($IsBox bx@@86
                        (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|)))
           a!1))
     :pattern (($IsBox bx@@86
                       (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|)))
     :skolemid |1105|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@171| T@U) (|#$R@@197| T@U) (|f#0@@41| T@U))
  (! (let ((a!1 (forall ((|x0#0@@16| T@U))
                  (! (=> (and (= (type |x0#0@@16|) BoxType)
                              ($IsBox |x0#0@@16| |#$T0@@171|))
                         (Requires1 |#$T0@@171|
                                    |#$R@@197|
                                    $OneHeap
                                    |f#0@@41|
                                    |x0#0@@16|))
                     :no-pattern (type |x0#0@@16|)
                     :no-pattern (U_2_int |x0#0@@16|)
                     :no-pattern (U_2_bool |x0#0@@16|)
                     :skolemid |1106|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@41|
                        (Tclass._System.___hTotalFunc1OL |#$T0@@171| |#$R@@197|))
                   (and ($Is |f#0@@41|
                             (Tclass._System.___hPartialFunc1OL
                               |#$T0@@171|
                               |#$R@@197|))
                        a!1))))
       (=> (and (= (type |#$T0@@171|) TyType)
                (= (type |#$R@@197|) TyType)
                (= (type |f#0@@41|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@41|
                    (Tclass._System.___hTotalFunc1OL |#$T0@@171| |#$R@@197|)))
     :skolemid |1107|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@172| T@U) (|#$R@@198| T@U) (|f#0@@42| T@U) ($h@@33 T@U))
  (! (=> (and (= (type |#$T0@@172|) TyType)
              (= (type |#$R@@198|) TyType)
              (= (type |f#0@@42|) HandleTypeType)
              (= (type $h@@33) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@42|
                      (Tclass._System.___hTotalFunc1OL |#$T0@@172| |#$R@@198|)
                      $h@@33)
            ($IsAlloc |f#0@@42|
                      (Tclass._System.___hPartialFunc1OL |#$T0@@172| |#$R@@198|)
                      $h@@33)))
     :pattern (($IsAlloc |f#0@@42|
                         (Tclass._System.___hTotalFunc1OL
                           |#$T0@@172|
                           |#$R@@198|)
                         $h@@33))
     :skolemid |1108|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@289 T@U) (arg1@@124 T@U))
  (! (= (type (Tclass._System.___hFunc1LO arg0@@289 arg1@@124)) TyType)
     :pattern ((Tclass._System.___hFunc1LO arg0@@289 arg1@@124))
     :qid |funType:Tclass._System.___hFunc1LO|)))
(assert (forall ((|#$T0@@173| T@U) (|#$R@@199| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|))
                        Tagclass._System.___hFunc1LO)
                     (= (TagFamily (Tclass._System.___hFunc1LO
                                     |#$T0@@173|
                                     |#$R@@199|))
                        |tytagFamily$_#Func1LO|))))
       (=> (and (= (type |#$T0@@173|) TyType) (= (type |#$R@@199|) TyType)) a!1))
     :pattern ((Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|))
     :skolemid |1109|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@290 T@U))
  (! (= (type (Tclass._System.___hFunc1LO_0 arg0@@290)) TyType)
     :pattern ((Tclass._System.___hFunc1LO_0 arg0@@290))
     :qid |funType:Tclass._System.___hFunc1LO_0|)))
(assert (forall ((|#$T0@@174| T@U) (|#$R@@200| T@U))
  (! (=> (and (= (type |#$T0@@174|) TyType) (= (type |#$R@@200|) TyType))
         (= (Tclass._System.___hFunc1LO_0
              (Tclass._System.___hFunc1LO |#$T0@@174| |#$R@@200|))
            |#$T0@@174|))
     :pattern ((Tclass._System.___hFunc1LO |#$T0@@174| |#$R@@200|))
     :skolemid |1110|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@291 T@U))
  (! (= (type (Tclass._System.___hFunc1LO_1 arg0@@291)) TyType)
     :pattern ((Tclass._System.___hFunc1LO_1 arg0@@291))
     :qid |funType:Tclass._System.___hFunc1LO_1|)))
(assert (forall ((|#$T0@@175| T@U) (|#$R@@201| T@U))
  (! (=> (and (= (type |#$T0@@175|) TyType) (= (type |#$R@@201|) TyType))
         (= (Tclass._System.___hFunc1LO_1
              (Tclass._System.___hFunc1LO |#$T0@@175| |#$R@@201|))
            |#$R@@201|))
     :pattern ((Tclass._System.___hFunc1LO |#$T0@@175| |#$R@@201|))
     :skolemid |1111|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@176| T@U) (|#$R@@202| T@U) (bx@@87 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@87)) bx@@87)
                     ($Is ($Unbox HandleTypeType bx@@87)
                          (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|)))))
       (=> (and (= (type |#$T0@@176|) TyType)
                (= (type |#$R@@202|) TyType)
                (= (type bx@@87) BoxType)
                ($IsBox bx@@87
                        (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|)))
           a!1))
     :pattern (($IsBox bx@@87
                       (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|)))
     :skolemid |1112|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@292 T@U) (arg1@@125 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1LO arg0@@292 arg1@@125)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1LO arg0@@292 arg1@@125))
     :qid |funType:Tclass._System.___hPartialFunc1LO|)))
(assert (forall ((|#$T0@@177| T@U) (|#$R@@203| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc1LO
                               |#$T0@@177|
                               |#$R@@203|))
                        Tagclass._System.___hPartialFunc1LO)
                     (= (TagFamily (Tclass._System.___hPartialFunc1LO
                                     |#$T0@@177|
                                     |#$R@@203|))
                        |tytagFamily$_#PartialFunc1LO|))))
       (=> (and (= (type |#$T0@@177|) TyType) (= (type |#$R@@203|) TyType)) a!1))
     :pattern ((Tclass._System.___hPartialFunc1LO |#$T0@@177| |#$R@@203|))
     :skolemid |1113|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@293 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1LO_0 arg0@@293)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1LO_0 arg0@@293))
     :qid |funType:Tclass._System.___hPartialFunc1LO_0|)))
(assert (forall ((|#$T0@@178| T@U) (|#$R@@204| T@U))
  (! (=> (and (= (type |#$T0@@178|) TyType) (= (type |#$R@@204|) TyType))
         (= (Tclass._System.___hPartialFunc1LO_0
              (Tclass._System.___hPartialFunc1LO |#$T0@@178| |#$R@@204|))
            |#$T0@@178|))
     :pattern ((Tclass._System.___hPartialFunc1LO |#$T0@@178| |#$R@@204|))
     :skolemid |1114|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@294 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1LO_1 arg0@@294)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1LO_1 arg0@@294))
     :qid |funType:Tclass._System.___hPartialFunc1LO_1|)))
(assert (forall ((|#$T0@@179| T@U) (|#$R@@205| T@U))
  (! (=> (and (= (type |#$T0@@179|) TyType) (= (type |#$R@@205|) TyType))
         (= (Tclass._System.___hPartialFunc1LO_1
              (Tclass._System.___hPartialFunc1LO |#$T0@@179| |#$R@@205|))
            |#$R@@205|))
     :pattern ((Tclass._System.___hPartialFunc1LO |#$T0@@179| |#$R@@205|))
     :skolemid |1115|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@180| T@U) (|#$R@@206| T@U) (bx@@88 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@88)) bx@@88)
                     ($Is ($Unbox HandleTypeType bx@@88)
                          (Tclass._System.___hPartialFunc1LO
                            |#$T0@@180|
                            |#$R@@206|)))))
       (=> (and (= (type |#$T0@@180|) TyType)
                (= (type |#$R@@206|) TyType)
                (= (type bx@@88) BoxType)
                ($IsBox bx@@88
                        (Tclass._System.___hPartialFunc1LO
                          |#$T0@@180|
                          |#$R@@206|)))
           a!1))
     :pattern (($IsBox bx@@88
                       (Tclass._System.___hPartialFunc1LO
                         |#$T0@@180|
                         |#$R@@206|)))
     :skolemid |1116|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@181| T@U) (|#$R@@207| T@U) (|f#0@@43| T@U))
  (! (let ((a!1 (forall ((|x0#0@@17| T@U))
                  (! (=> (and (= (type |x0#0@@17|) BoxType)
                              ($IsBox |x0#0@@17| |#$T0@@181|))
                         (|Set#Equal| (Reads1 |#$T0@@181|
                                              |#$R@@207|
                                              $OneHeap
                                              |f#0@@43|
                                              |x0#0@@17|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@17|)
                     :no-pattern (U_2_int |x0#0@@17|)
                     :no-pattern (U_2_bool |x0#0@@17|)
                     :skolemid |1117|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@43|
                        (Tclass._System.___hPartialFunc1LO
                          |#$T0@@181|
                          |#$R@@207|))
                   (and ($Is |f#0@@43|
                             (Tclass._System.___hFunc1LO |#$T0@@181| |#$R@@207|))
                        a!1))))
       (=> (and (= (type |#$T0@@181|) TyType)
                (= (type |#$R@@207|) TyType)
                (= (type |f#0@@43|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@43|
                    (Tclass._System.___hPartialFunc1LO |#$T0@@181| |#$R@@207|)))
     :skolemid |1118|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@182| T@U) (|#$R@@208| T@U) (|f#0@@44| T@U) ($h@@34 T@U))
  (! (=> (and (= (type |#$T0@@182|) TyType)
              (= (type |#$R@@208|) TyType)
              (= (type |f#0@@44|) HandleTypeType)
              (= (type $h@@34) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@44|
                      (Tclass._System.___hPartialFunc1LO |#$T0@@182| |#$R@@208|)
                      $h@@34)
            ($IsAlloc |f#0@@44|
                      (Tclass._System.___hFunc1LO |#$T0@@182| |#$R@@208|)
                      $h@@34)))
     :pattern (($IsAlloc |f#0@@44|
                         (Tclass._System.___hPartialFunc1LO
                           |#$T0@@182|
                           |#$R@@208|)
                         $h@@34))
     :skolemid |1119|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@295 T@U) (arg1@@126 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1LO arg0@@295 arg1@@126)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1LO arg0@@295 arg1@@126))
     :qid |funType:Tclass._System.___hTotalFunc1LO|)))
(assert (forall ((|#$T0@@183| T@U) (|#$R@@209| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc1LO
                               |#$T0@@183|
                               |#$R@@209|))
                        Tagclass._System.___hTotalFunc1LO)
                     (= (TagFamily (Tclass._System.___hTotalFunc1LO
                                     |#$T0@@183|
                                     |#$R@@209|))
                        |tytagFamily$_#TotalFunc1LO|))))
       (=> (and (= (type |#$T0@@183|) TyType) (= (type |#$R@@209|) TyType)) a!1))
     :pattern ((Tclass._System.___hTotalFunc1LO |#$T0@@183| |#$R@@209|))
     :skolemid |1120|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@296 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1LO_0 arg0@@296)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1LO_0 arg0@@296))
     :qid |funType:Tclass._System.___hTotalFunc1LO_0|)))
(assert (forall ((|#$T0@@184| T@U) (|#$R@@210| T@U))
  (! (=> (and (= (type |#$T0@@184|) TyType) (= (type |#$R@@210|) TyType))
         (= (Tclass._System.___hTotalFunc1LO_0
              (Tclass._System.___hTotalFunc1LO |#$T0@@184| |#$R@@210|))
            |#$T0@@184|))
     :pattern ((Tclass._System.___hTotalFunc1LO |#$T0@@184| |#$R@@210|))
     :skolemid |1121|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@297 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1LO_1 arg0@@297)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1LO_1 arg0@@297))
     :qid |funType:Tclass._System.___hTotalFunc1LO_1|)))
(assert (forall ((|#$T0@@185| T@U) (|#$R@@211| T@U))
  (! (=> (and (= (type |#$T0@@185|) TyType) (= (type |#$R@@211|) TyType))
         (= (Tclass._System.___hTotalFunc1LO_1
              (Tclass._System.___hTotalFunc1LO |#$T0@@185| |#$R@@211|))
            |#$R@@211|))
     :pattern ((Tclass._System.___hTotalFunc1LO |#$T0@@185| |#$R@@211|))
     :skolemid |1122|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@186| T@U) (|#$R@@212| T@U) (bx@@89 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@89)) bx@@89)
                     ($Is ($Unbox HandleTypeType bx@@89)
                          (Tclass._System.___hTotalFunc1LO
                            |#$T0@@186|
                            |#$R@@212|)))))
       (=> (and (= (type |#$T0@@186|) TyType)
                (= (type |#$R@@212|) TyType)
                (= (type bx@@89) BoxType)
                ($IsBox bx@@89
                        (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|)))
           a!1))
     :pattern (($IsBox bx@@89
                       (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|)))
     :skolemid |1123|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@187| T@U) (|#$R@@213| T@U) (|f#0@@45| T@U))
  (! (let ((a!1 (forall ((|x0#0@@18| T@U))
                  (! (=> (and (= (type |x0#0@@18|) BoxType)
                              ($IsBox |x0#0@@18| |#$T0@@187|))
                         (Requires1 |#$T0@@187|
                                    |#$R@@213|
                                    $OneHeap
                                    |f#0@@45|
                                    |x0#0@@18|))
                     :no-pattern (type |x0#0@@18|)
                     :no-pattern (U_2_int |x0#0@@18|)
                     :no-pattern (U_2_bool |x0#0@@18|)
                     :skolemid |1124|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@45|
                        (Tclass._System.___hTotalFunc1LO |#$T0@@187| |#$R@@213|))
                   (and ($Is |f#0@@45|
                             (Tclass._System.___hPartialFunc1LO
                               |#$T0@@187|
                               |#$R@@213|))
                        a!1))))
       (=> (and (= (type |#$T0@@187|) TyType)
                (= (type |#$R@@213|) TyType)
                (= (type |f#0@@45|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@45|
                    (Tclass._System.___hTotalFunc1LO |#$T0@@187| |#$R@@213|)))
     :skolemid |1125|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@188| T@U) (|#$R@@214| T@U) (|f#0@@46| T@U) ($h@@35 T@U))
  (! (=> (and (= (type |#$T0@@188|) TyType)
              (= (type |#$R@@214|) TyType)
              (= (type |f#0@@46|) HandleTypeType)
              (= (type $h@@35) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@46|
                      (Tclass._System.___hTotalFunc1LO |#$T0@@188| |#$R@@214|)
                      $h@@35)
            ($IsAlloc |f#0@@46|
                      (Tclass._System.___hPartialFunc1LO |#$T0@@188| |#$R@@214|)
                      $h@@35)))
     :pattern (($IsAlloc |f#0@@46|
                         (Tclass._System.___hTotalFunc1LO
                           |#$T0@@188|
                           |#$R@@214|)
                         $h@@35))
     :skolemid |1126|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@298 T@U) (arg1@@127 T@U))
  (! (= (type (|#_System._tuple#2OLL._#Make2| arg0@@298 arg1@@127))
        DatatypeTypeType)
     :pattern ((|#_System._tuple#2OLL._#Make2| arg0@@298 arg1@@127))
     :qid |funType:#_System._tuple#2OLL._#Make2|)))
(assert (forall ((|a#14#0#0| T@U) (|a#14#1#0| T@U))
  (! (=> (and (= (type |a#14#0#0|) BoxType) (= (type |a#14#1#0|) BoxType))
         (= (DatatypeCtorId (|#_System._tuple#2OLL._#Make2|
                              |a#14#0#0|
                              |a#14#1#0|))
            |##_System._tuple#2OLL._#Make2|))
     :pattern ((|#_System._tuple#2OLL._#Make2| |a#14#0#0| |a#14#1#0|))
     :skolemid |1127|
     :qid |unknown.0:0|)))
(assert (forall ((d@@10 T@U))
  (! (=> (= (type d@@10) DatatypeTypeType)
         (= (_System.Tuple2OLL.___hMake2_q d@@10)
            (= (DatatypeCtorId d@@10) |##_System._tuple#2OLL._#Make2|)))
     :pattern ((_System.Tuple2OLL.___hMake2_q d@@10))
     :skolemid |1128|
     :qid |unknown.0:0|)))
(assert (forall ((d@@11 T@U))
  (! (let ((a!1 (exists ((|a#15#0#0| T@U) (|a#15#1#0| T@U))
                  (! (and (= (type |a#15#0#0|) BoxType)
                          (= (type |a#15#1#0|) BoxType)
                          (= d@@11
                             (|#_System._tuple#2OLL._#Make2|
                               |a#15#0#0|
                               |a#15#1#0|)))
                     :no-pattern (type |a#15#0#0|)
                     :no-pattern (type |a#15#1#0|)
                     :no-pattern (U_2_int |a#15#0#0|)
                     :no-pattern (U_2_bool |a#15#0#0|)
                     :no-pattern (U_2_int |a#15#1#0|)
                     :no-pattern (U_2_bool |a#15#1#0|)
                     :skolemid |1129|
                     :qid |unknown.0:0|))))
       (=> (and (= (type d@@11) DatatypeTypeType)
                (_System.Tuple2OLL.___hMake2_q d@@11))
           a!1))
     :pattern ((_System.Tuple2OLL.___hMake2_q d@@11))
     :skolemid |1130|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@299 T@U) (arg1@@128 T@U))
  (! (= (type (Tclass._System.Tuple2OLL arg0@@299 arg1@@128)) TyType)
     :pattern ((Tclass._System.Tuple2OLL arg0@@299 arg1@@128))
     :qid |funType:Tclass._System.Tuple2OLL|)))
(assert (forall ((|_System._tuple#2OLL$T0| T@U) (|_System._tuple#2OLL$T1| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.Tuple2OLL
                               |_System._tuple#2OLL$T0|
                               |_System._tuple#2OLL$T1|))
                        Tagclass._System.Tuple2OLL)
                     (= (TagFamily (Tclass._System.Tuple2OLL
                                     |_System._tuple#2OLL$T0|
                                     |_System._tuple#2OLL$T1|))
                        |tytagFamily$_tuple#2OLL|))))
       (=> (and (= (type |_System._tuple#2OLL$T0|) TyType)
                (= (type |_System._tuple#2OLL$T1|) TyType))
           a!1))
     :pattern ((Tclass._System.Tuple2OLL
                 |_System._tuple#2OLL$T0|
                 |_System._tuple#2OLL$T1|))
     :skolemid |1131|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@300 T@U))
  (! (= (type (Tclass._System.Tuple2OLL_0 arg0@@300)) TyType)
     :pattern ((Tclass._System.Tuple2OLL_0 arg0@@300))
     :qid |funType:Tclass._System.Tuple2OLL_0|)))
(assert (forall ((|_System._tuple#2OLL$T0@@0| T@U) (|_System._tuple#2OLL$T1@@0| T@U))
  (! (=> (and (= (type |_System._tuple#2OLL$T0@@0|) TyType)
              (= (type |_System._tuple#2OLL$T1@@0|) TyType))
         (= (Tclass._System.Tuple2OLL_0
              (Tclass._System.Tuple2OLL
                |_System._tuple#2OLL$T0@@0|
                |_System._tuple#2OLL$T1@@0|))
            |_System._tuple#2OLL$T0@@0|))
     :pattern ((Tclass._System.Tuple2OLL
                 |_System._tuple#2OLL$T0@@0|
                 |_System._tuple#2OLL$T1@@0|))
     :skolemid |1132|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@301 T@U))
  (! (= (type (Tclass._System.Tuple2OLL_1 arg0@@301)) TyType)
     :pattern ((Tclass._System.Tuple2OLL_1 arg0@@301))
     :qid |funType:Tclass._System.Tuple2OLL_1|)))
(assert (forall ((|_System._tuple#2OLL$T0@@1| T@U) (|_System._tuple#2OLL$T1@@1| T@U))
  (! (=> (and (= (type |_System._tuple#2OLL$T0@@1|) TyType)
              (= (type |_System._tuple#2OLL$T1@@1|) TyType))
         (= (Tclass._System.Tuple2OLL_1
              (Tclass._System.Tuple2OLL
                |_System._tuple#2OLL$T0@@1|
                |_System._tuple#2OLL$T1@@1|))
            |_System._tuple#2OLL$T1@@1|))
     :pattern ((Tclass._System.Tuple2OLL
                 |_System._tuple#2OLL$T0@@1|
                 |_System._tuple#2OLL$T1@@1|))
     :skolemid |1133|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2OLL$T0@@2| T@U)
         (|_System._tuple#2OLL$T1@@2| T@U)
         (bx@@90 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@90)) bx@@90)
                     ($Is ($Unbox DatatypeTypeType bx@@90)
                          (Tclass._System.Tuple2OLL
                            |_System._tuple#2OLL$T0@@2|
                            |_System._tuple#2OLL$T1@@2|)))))
       (=> (and (= (type |_System._tuple#2OLL$T0@@2|) TyType)
                (= (type |_System._tuple#2OLL$T1@@2|) TyType)
                (= (type bx@@90) BoxType)
                ($IsBox bx@@90
                        (Tclass._System.Tuple2OLL
                          |_System._tuple#2OLL$T0@@2|
                          |_System._tuple#2OLL$T1@@2|)))
           a!1))
     :pattern (($IsBox bx@@90
                       (Tclass._System.Tuple2OLL
                         |_System._tuple#2OLL$T0@@2|
                         |_System._tuple#2OLL$T1@@2|)))
     :skolemid |1134|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2OLL$T0@@3| T@U)
         (|_System._tuple#2OLL$T1@@3| T@U)
         (|a#16#0#0| T@U)
         (|a#16#1#0| T@U))
  (! (=> (and (= (type |_System._tuple#2OLL$T0@@3|) TyType)
              (= (type |_System._tuple#2OLL$T1@@3|) TyType)
              (= (type |a#16#0#0|) BoxType)
              (= (type |a#16#1#0|) BoxType))
         (= ($Is (|#_System._tuple#2OLL._#Make2| |a#16#0#0| |a#16#1#0|)
                 (Tclass._System.Tuple2OLL
                   |_System._tuple#2OLL$T0@@3|
                   |_System._tuple#2OLL$T1@@3|))
            (and ($IsBox |a#16#0#0| |_System._tuple#2OLL$T0@@3|)
                 ($IsBox |a#16#1#0| |_System._tuple#2OLL$T1@@3|))))
     :pattern (($Is (|#_System._tuple#2OLL._#Make2| |a#16#0#0| |a#16#1#0|)
                    (Tclass._System.Tuple2OLL
                      |_System._tuple#2OLL$T0@@3|
                      |_System._tuple#2OLL$T1@@3|)))
     :skolemid |1135|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2OLL$T0@@4| T@U)
         (|_System._tuple#2OLL$T1@@4| T@U)
         (|a#17#0#0| T@U)
         (|a#17#1#0| T@U)
         ($h@@36 T@U))
  (! (=> (and (= (type |_System._tuple#2OLL$T0@@4|) TyType)
              (= (type |_System._tuple#2OLL$T1@@4|) TyType)
              (= (type |a#17#0#0|) BoxType)
              (= (type |a#17#1#0|) BoxType)
              (= (type $h@@36) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@36))
         (= ($IsAlloc (|#_System._tuple#2OLL._#Make2| |a#17#0#0| |a#17#1#0|)
                      (Tclass._System.Tuple2OLL
                        |_System._tuple#2OLL$T0@@4|
                        |_System._tuple#2OLL$T1@@4|)
                      $h@@36)
            (and ($IsAllocBox |a#17#0#0| |_System._tuple#2OLL$T0@@4| $h@@36)
                 ($IsAllocBox |a#17#1#0| |_System._tuple#2OLL$T1@@4| $h@@36))))
     :pattern (($IsAlloc (|#_System._tuple#2OLL._#Make2| |a#17#0#0| |a#17#1#0|)
                         (Tclass._System.Tuple2OLL
                           |_System._tuple#2OLL$T0@@4|
                           |_System._tuple#2OLL$T1@@4|)
                         $h@@36))
     :skolemid |1136|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@302 T@U))
  (! (= (type (_System.Tuple2OLL._0 arg0@@302)) BoxType)
     :pattern ((_System.Tuple2OLL._0 arg0@@302))
     :qid |funType:_System.Tuple2OLL._0|)))
(assert (forall ((d@@12 T@U) (|_System._tuple#2OLL$T0@@5| T@U) ($h@@37 T@U))
  (! (let ((a!1 (exists ((|_System._tuple#2OLL$T1@@5| T@U))
                  (! (and (= (type |_System._tuple#2OLL$T1@@5|) TyType)
                          ($IsAlloc d@@12
                                    (Tclass._System.Tuple2OLL
                                      |_System._tuple#2OLL$T0@@5|
                                      |_System._tuple#2OLL$T1@@5|)
                                    $h@@37))
                     :pattern (($IsAlloc d@@12
                                         (Tclass._System.Tuple2OLL
                                           |_System._tuple#2OLL$T0@@5|
                                           |_System._tuple#2OLL$T1@@5|)
                                         $h@@37))
                     :skolemid |1137|
                     :qid |unknown.0:0|))))
       (=> (and (= (type d@@12) DatatypeTypeType)
                (= (type |_System._tuple#2OLL$T0@@5|) TyType)
                (= (type $h@@37) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@37)
                (_System.Tuple2OLL.___hMake2_q d@@12)
                a!1)
           ($IsAllocBox (_System.Tuple2OLL._0 d@@12)
                        |_System._tuple#2OLL$T0@@5|
                        $h@@37)))
     :pattern (($IsAllocBox (_System.Tuple2OLL._0 d@@12)
                            |_System._tuple#2OLL$T0@@5|
                            $h@@37))
     :skolemid |1138|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@303 T@U))
  (! (= (type (_System.Tuple2OLL._1 arg0@@303)) BoxType)
     :pattern ((_System.Tuple2OLL._1 arg0@@303))
     :qid |funType:_System.Tuple2OLL._1|)))
(assert (forall ((d@@13 T@U) (|_System._tuple#2OLL$T1@@6| T@U) ($h@@38 T@U))
  (! (let ((a!1 (exists ((|_System._tuple#2OLL$T0@@6| T@U))
                  (! (and (= (type |_System._tuple#2OLL$T0@@6|) TyType)
                          ($IsAlloc d@@13
                                    (Tclass._System.Tuple2OLL
                                      |_System._tuple#2OLL$T0@@6|
                                      |_System._tuple#2OLL$T1@@6|)
                                    $h@@38))
                     :pattern (($IsAlloc d@@13
                                         (Tclass._System.Tuple2OLL
                                           |_System._tuple#2OLL$T0@@6|
                                           |_System._tuple#2OLL$T1@@6|)
                                         $h@@38))
                     :skolemid |1139|
                     :qid |unknown.0:0|))))
       (=> (and (= (type d@@13) DatatypeTypeType)
                (= (type |_System._tuple#2OLL$T1@@6|) TyType)
                (= (type $h@@38) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@38)
                (_System.Tuple2OLL.___hMake2_q d@@13)
                a!1)
           ($IsAllocBox (_System.Tuple2OLL._1 d@@13)
                        |_System._tuple#2OLL$T1@@6|
                        $h@@38)))
     :pattern (($IsAllocBox (_System.Tuple2OLL._1 d@@13)
                            |_System._tuple#2OLL$T1@@6|
                            $h@@38))
     :skolemid |1140|
     :qid |unknown.0:0|)))
(assert (forall ((|a#18#0#0| T@U) (|a#18#1#0| T@U))
  (! (=> (and (= (type |a#18#0#0|) BoxType) (= (type |a#18#1#0|) BoxType))
         (= (|#_System._tuple#2OLL._#Make2| (Lit |a#18#0#0|) (Lit |a#18#1#0|))
            (Lit (|#_System._tuple#2OLL._#Make2| |a#18#0#0| |a#18#1#0|))))
     :pattern ((|#_System._tuple#2OLL._#Make2|
                 (Lit |a#18#0#0|)
                 (Lit |a#18#1#0|)))
     :skolemid |1141|
     :qid |unknown.0:0|)))
(assert (forall ((|a#19#0#0| T@U) (|a#19#1#0| T@U))
  (! (=> (and (= (type |a#19#0#0|) BoxType) (= (type |a#19#1#0|) BoxType))
         (= (_System.Tuple2OLL._0
              (|#_System._tuple#2OLL._#Make2| |a#19#0#0| |a#19#1#0|))
            |a#19#0#0|))
     :pattern ((|#_System._tuple#2OLL._#Make2| |a#19#0#0| |a#19#1#0|))
     :skolemid |1142|
     :qid |unknown.0:0|)))
(assert (forall ((|a#20#0#0| T@U) (|a#20#1#0| T@U))
  (! (=> (and (= (type |a#20#0#0|) BoxType) (= (type |a#20#1#0|) BoxType))
         (< (BoxRank |a#20#0#0|)
            (DtRank (|#_System._tuple#2OLL._#Make2| |a#20#0#0| |a#20#1#0|))))
     :pattern ((|#_System._tuple#2OLL._#Make2| |a#20#0#0| |a#20#1#0|))
     :skolemid |1143|
     :qid |unknown.0:0|)))
(assert (forall ((|a#21#0#0| T@U) (|a#21#1#0| T@U))
  (! (=> (and (= (type |a#21#0#0|) BoxType) (= (type |a#21#1#0|) BoxType))
         (= (_System.Tuple2OLL._1
              (|#_System._tuple#2OLL._#Make2| |a#21#0#0| |a#21#1#0|))
            |a#21#1#0|))
     :pattern ((|#_System._tuple#2OLL._#Make2| |a#21#0#0| |a#21#1#0|))
     :skolemid |1144|
     :qid |unknown.0:0|)))
(assert (forall ((|a#22#0#0| T@U) (|a#22#1#0| T@U))
  (! (=> (and (= (type |a#22#0#0|) BoxType) (= (type |a#22#1#0|) BoxType))
         (< (BoxRank |a#22#1#0|)
            (DtRank (|#_System._tuple#2OLL._#Make2| |a#22#0#0| |a#22#1#0|))))
     :pattern ((|#_System._tuple#2OLL._#Make2| |a#22#0#0| |a#22#1#0|))
     :skolemid |1145|
     :qid |unknown.0:0|)))
(assert (forall ((d@@14 T@U))
  (! (=> (and (= (type d@@14) DatatypeTypeType)
              (|$IsA#_System.Tuple2OLL| d@@14))
         (_System.Tuple2OLL.___hMake2_q d@@14))
     :pattern ((|$IsA#_System.Tuple2OLL| d@@14))
     :skolemid |1146|
     :qid |unknown.0:0|)))
(assert (forall ((|_System._tuple#2OLL$T0@@7| T@U)
         (|_System._tuple#2OLL$T1@@7| T@U)
         (d@@15 T@U))
  (! (=> (and (= (type |_System._tuple#2OLL$T0@@7|) TyType)
              (= (type |_System._tuple#2OLL$T1@@7|) TyType)
              (= (type d@@15) DatatypeTypeType)
              ($Is d@@15
                   (Tclass._System.Tuple2OLL
                     |_System._tuple#2OLL$T0@@7|
                     |_System._tuple#2OLL$T1@@7|)))
         (_System.Tuple2OLL.___hMake2_q d@@15))
     :pattern ((_System.Tuple2OLL.___hMake2_q d@@15)
               ($Is d@@15
                    (Tclass._System.Tuple2OLL
                      |_System._tuple#2OLL$T0@@7|
                      |_System._tuple#2OLL$T1@@7|)))
     :skolemid |1147|
     :qid |unknown.0:0|)))
(assert (forall ((a@@116 T@U) (b@@65 T@U))
  (! (let ((a!1 (= (|_System.Tuple2OLL#Equal| a@@116 b@@65)
                   (and (= (_System.Tuple2OLL._0 a@@116)
                           (_System.Tuple2OLL._0 b@@65))
                        (= (_System.Tuple2OLL._1 a@@116)
                           (_System.Tuple2OLL._1 b@@65))))))
       (=> (and (= (type a@@116) DatatypeTypeType)
                (= (type b@@65) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|_System.Tuple2OLL#Equal| a@@116 b@@65))
     :skolemid |1148|
     :qid |unknown.0:0|)))
(assert (forall ((a@@117 T@U) (b@@66 T@U))
  (! (=> (and (= (type a@@117) DatatypeTypeType)
              (= (type b@@66) DatatypeTypeType))
         (= (|_System.Tuple2OLL#Equal| a@@117 b@@66) (= a@@117 b@@66)))
     :pattern ((|_System.Tuple2OLL#Equal| a@@117 b@@66))
     :skolemid |1149|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@304 T@U) (arg1@@129 T@U) (arg2@@70 T@U) (arg3@@42 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOL
                arg0@@304
                arg1@@129
                arg2@@70
                arg3@@42))
        TyType)
     :pattern ((Tclass._System.___hFunc3LLOL
                 arg0@@304
                 arg1@@129
                 arg2@@70
                 arg3@@42))
     :qid |funType:Tclass._System.___hFunc3LLOL|)))
(assert (forall ((|#$T0@@189| T@U) (|#$T1@@125| T@U) (|#$T2@@68| T@U) (|#$R@@215| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc3LLOL
                               |#$T0@@189|
                               |#$T1@@125|
                               |#$T2@@68|
                               |#$R@@215|))
                        Tagclass._System.___hFunc3LLOL)
                     (= (TagFamily (Tclass._System.___hFunc3LLOL
                                     |#$T0@@189|
                                     |#$T1@@125|
                                     |#$T2@@68|
                                     |#$R@@215|))
                        |tytagFamily$_#Func3LLOL|))))
       (=> (and (= (type |#$T0@@189|) TyType)
                (= (type |#$T1@@125|) TyType)
                (= (type |#$T2@@68|) TyType)
                (= (type |#$R@@215|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc3LLOL
                 |#$T0@@189|
                 |#$T1@@125|
                 |#$T2@@68|
                 |#$R@@215|))
     :skolemid |1150|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@305 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOL_0 arg0@@305)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOL_0 arg0@@305))
     :qid |funType:Tclass._System.___hFunc3LLOL_0|)))
(assert (forall ((|#$T0@@190| T@U) (|#$T1@@126| T@U) (|#$T2@@69| T@U) (|#$R@@216| T@U))
  (! (=> (and (= (type |#$T0@@190|) TyType)
              (= (type |#$T1@@126|) TyType)
              (= (type |#$T2@@69|) TyType)
              (= (type |#$R@@216|) TyType))
         (= (Tclass._System.___hFunc3LLOL_0
              (Tclass._System.___hFunc3LLOL
                |#$T0@@190|
                |#$T1@@126|
                |#$T2@@69|
                |#$R@@216|))
            |#$T0@@190|))
     :pattern ((Tclass._System.___hFunc3LLOL
                 |#$T0@@190|
                 |#$T1@@126|
                 |#$T2@@69|
                 |#$R@@216|))
     :skolemid |1151|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@306 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOL_1 arg0@@306)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOL_1 arg0@@306))
     :qid |funType:Tclass._System.___hFunc3LLOL_1|)))
(assert (forall ((|#$T0@@191| T@U) (|#$T1@@127| T@U) (|#$T2@@70| T@U) (|#$R@@217| T@U))
  (! (=> (and (= (type |#$T0@@191|) TyType)
              (= (type |#$T1@@127|) TyType)
              (= (type |#$T2@@70|) TyType)
              (= (type |#$R@@217|) TyType))
         (= (Tclass._System.___hFunc3LLOL_1
              (Tclass._System.___hFunc3LLOL
                |#$T0@@191|
                |#$T1@@127|
                |#$T2@@70|
                |#$R@@217|))
            |#$T1@@127|))
     :pattern ((Tclass._System.___hFunc3LLOL
                 |#$T0@@191|
                 |#$T1@@127|
                 |#$T2@@70|
                 |#$R@@217|))
     :skolemid |1152|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@307 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOL_2 arg0@@307)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOL_2 arg0@@307))
     :qid |funType:Tclass._System.___hFunc3LLOL_2|)))
(assert (forall ((|#$T0@@192| T@U) (|#$T1@@128| T@U) (|#$T2@@71| T@U) (|#$R@@218| T@U))
  (! (=> (and (= (type |#$T0@@192|) TyType)
              (= (type |#$T1@@128|) TyType)
              (= (type |#$T2@@71|) TyType)
              (= (type |#$R@@218|) TyType))
         (= (Tclass._System.___hFunc3LLOL_2
              (Tclass._System.___hFunc3LLOL
                |#$T0@@192|
                |#$T1@@128|
                |#$T2@@71|
                |#$R@@218|))
            |#$T2@@71|))
     :pattern ((Tclass._System.___hFunc3LLOL
                 |#$T0@@192|
                 |#$T1@@128|
                 |#$T2@@71|
                 |#$R@@218|))
     :skolemid |1153|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@308 T@U))
  (! (= (type (Tclass._System.___hFunc3LLOL_3 arg0@@308)) TyType)
     :pattern ((Tclass._System.___hFunc3LLOL_3 arg0@@308))
     :qid |funType:Tclass._System.___hFunc3LLOL_3|)))
(assert (forall ((|#$T0@@193| T@U) (|#$T1@@129| T@U) (|#$T2@@72| T@U) (|#$R@@219| T@U))
  (! (=> (and (= (type |#$T0@@193|) TyType)
              (= (type |#$T1@@129|) TyType)
              (= (type |#$T2@@72|) TyType)
              (= (type |#$R@@219|) TyType))
         (= (Tclass._System.___hFunc3LLOL_3
              (Tclass._System.___hFunc3LLOL
                |#$T0@@193|
                |#$T1@@129|
                |#$T2@@72|
                |#$R@@219|))
            |#$R@@219|))
     :pattern ((Tclass._System.___hFunc3LLOL
                 |#$T0@@193|
                 |#$T1@@129|
                 |#$T2@@72|
                 |#$R@@219|))
     :skolemid |1154|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@194| T@U)
         (|#$T1@@130| T@U)
         (|#$T2@@73| T@U)
         (|#$R@@220| T@U)
         (bx@@91 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@91)) bx@@91)
                     ($Is ($Unbox HandleTypeType bx@@91)
                          (Tclass._System.___hFunc3LLOL
                            |#$T0@@194|
                            |#$T1@@130|
                            |#$T2@@73|
                            |#$R@@220|)))))
       (=> (and (= (type |#$T0@@194|) TyType)
                (= (type |#$T1@@130|) TyType)
                (= (type |#$T2@@73|) TyType)
                (= (type |#$R@@220|) TyType)
                (= (type bx@@91) BoxType)
                ($IsBox bx@@91
                        (Tclass._System.___hFunc3LLOL
                          |#$T0@@194|
                          |#$T1@@130|
                          |#$T2@@73|
                          |#$R@@220|)))
           a!1))
     :pattern (($IsBox bx@@91
                       (Tclass._System.___hFunc3LLOL
                         |#$T0@@194|
                         |#$T1@@130|
                         |#$T2@@73|
                         |#$R@@220|)))
     :skolemid |1155|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@309 T@U) (arg1@@130 T@U) (arg2@@71 T@U) (arg3@@43 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOL
                arg0@@309
                arg1@@130
                arg2@@71
                arg3@@43))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOL
                 arg0@@309
                 arg1@@130
                 arg2@@71
                 arg3@@43))
     :qid |funType:Tclass._System.___hPartialFunc3LLOL|)))
(assert (forall ((|#$T0@@195| T@U) (|#$T1@@131| T@U) (|#$T2@@74| T@U) (|#$R@@221| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc3LLOL
                               |#$T0@@195|
                               |#$T1@@131|
                               |#$T2@@74|
                               |#$R@@221|))
                        Tagclass._System.___hPartialFunc3LLOL)
                     (= (TagFamily (Tclass._System.___hPartialFunc3LLOL
                                     |#$T0@@195|
                                     |#$T1@@131|
                                     |#$T2@@74|
                                     |#$R@@221|))
                        |tytagFamily$_#PartialFunc3LLOL|))))
       (=> (and (= (type |#$T0@@195|) TyType)
                (= (type |#$T1@@131|) TyType)
                (= (type |#$T2@@74|) TyType)
                (= (type |#$R@@221|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc3LLOL
                 |#$T0@@195|
                 |#$T1@@131|
                 |#$T2@@74|
                 |#$R@@221|))
     :skolemid |1156|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@310 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOL_0 arg0@@310)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOL_0 arg0@@310))
     :qid |funType:Tclass._System.___hPartialFunc3LLOL_0|)))
(assert (forall ((|#$T0@@196| T@U) (|#$T1@@132| T@U) (|#$T2@@75| T@U) (|#$R@@222| T@U))
  (! (=> (and (= (type |#$T0@@196|) TyType)
              (= (type |#$T1@@132|) TyType)
              (= (type |#$T2@@75|) TyType)
              (= (type |#$R@@222|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOL_0
              (Tclass._System.___hPartialFunc3LLOL
                |#$T0@@196|
                |#$T1@@132|
                |#$T2@@75|
                |#$R@@222|))
            |#$T0@@196|))
     :pattern ((Tclass._System.___hPartialFunc3LLOL
                 |#$T0@@196|
                 |#$T1@@132|
                 |#$T2@@75|
                 |#$R@@222|))
     :skolemid |1157|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@311 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOL_1 arg0@@311)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOL_1 arg0@@311))
     :qid |funType:Tclass._System.___hPartialFunc3LLOL_1|)))
(assert (forall ((|#$T0@@197| T@U) (|#$T1@@133| T@U) (|#$T2@@76| T@U) (|#$R@@223| T@U))
  (! (=> (and (= (type |#$T0@@197|) TyType)
              (= (type |#$T1@@133|) TyType)
              (= (type |#$T2@@76|) TyType)
              (= (type |#$R@@223|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOL_1
              (Tclass._System.___hPartialFunc3LLOL
                |#$T0@@197|
                |#$T1@@133|
                |#$T2@@76|
                |#$R@@223|))
            |#$T1@@133|))
     :pattern ((Tclass._System.___hPartialFunc3LLOL
                 |#$T0@@197|
                 |#$T1@@133|
                 |#$T2@@76|
                 |#$R@@223|))
     :skolemid |1158|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@312 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOL_2 arg0@@312)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOL_2 arg0@@312))
     :qid |funType:Tclass._System.___hPartialFunc3LLOL_2|)))
(assert (forall ((|#$T0@@198| T@U) (|#$T1@@134| T@U) (|#$T2@@77| T@U) (|#$R@@224| T@U))
  (! (=> (and (= (type |#$T0@@198|) TyType)
              (= (type |#$T1@@134|) TyType)
              (= (type |#$T2@@77|) TyType)
              (= (type |#$R@@224|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOL_2
              (Tclass._System.___hPartialFunc3LLOL
                |#$T0@@198|
                |#$T1@@134|
                |#$T2@@77|
                |#$R@@224|))
            |#$T2@@77|))
     :pattern ((Tclass._System.___hPartialFunc3LLOL
                 |#$T0@@198|
                 |#$T1@@134|
                 |#$T2@@77|
                 |#$R@@224|))
     :skolemid |1159|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@313 T@U))
  (! (= (type (Tclass._System.___hPartialFunc3LLOL_3 arg0@@313)) TyType)
     :pattern ((Tclass._System.___hPartialFunc3LLOL_3 arg0@@313))
     :qid |funType:Tclass._System.___hPartialFunc3LLOL_3|)))
(assert (forall ((|#$T0@@199| T@U) (|#$T1@@135| T@U) (|#$T2@@78| T@U) (|#$R@@225| T@U))
  (! (=> (and (= (type |#$T0@@199|) TyType)
              (= (type |#$T1@@135|) TyType)
              (= (type |#$T2@@78|) TyType)
              (= (type |#$R@@225|) TyType))
         (= (Tclass._System.___hPartialFunc3LLOL_3
              (Tclass._System.___hPartialFunc3LLOL
                |#$T0@@199|
                |#$T1@@135|
                |#$T2@@78|
                |#$R@@225|))
            |#$R@@225|))
     :pattern ((Tclass._System.___hPartialFunc3LLOL
                 |#$T0@@199|
                 |#$T1@@135|
                 |#$T2@@78|
                 |#$R@@225|))
     :skolemid |1160|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@200| T@U)
         (|#$T1@@136| T@U)
         (|#$T2@@79| T@U)
         (|#$R@@226| T@U)
         (bx@@92 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@92)) bx@@92)
                     ($Is ($Unbox HandleTypeType bx@@92)
                          (Tclass._System.___hPartialFunc3LLOL
                            |#$T0@@200|
                            |#$T1@@136|
                            |#$T2@@79|
                            |#$R@@226|)))))
       (=> (and (= (type |#$T0@@200|) TyType)
                (= (type |#$T1@@136|) TyType)
                (= (type |#$T2@@79|) TyType)
                (= (type |#$R@@226|) TyType)
                (= (type bx@@92) BoxType)
                ($IsBox bx@@92
                        (Tclass._System.___hPartialFunc3LLOL
                          |#$T0@@200|
                          |#$T1@@136|
                          |#$T2@@79|
                          |#$R@@226|)))
           a!1))
     :pattern (($IsBox bx@@92
                       (Tclass._System.___hPartialFunc3LLOL
                         |#$T0@@200|
                         |#$T1@@136|
                         |#$T2@@79|
                         |#$R@@226|)))
     :skolemid |1161|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@201| T@U)
         (|#$T1@@137| T@U)
         (|#$T2@@80| T@U)
         (|#$R@@227| T@U)
         (|f#0@@47| T@U))
  (! (let ((a!1 (forall ((|x0#0@@19| T@U) (|x1#0@@11| T@U) (|x2#0@@5| T@U))
                  (! (=> (and (= (type |x0#0@@19|) BoxType)
                              (= (type |x1#0@@11|) BoxType)
                              (= (type |x2#0@@5|) BoxType)
                              ($IsBox |x0#0@@19| |#$T0@@201|)
                              ($IsBox |x1#0@@11| |#$T1@@137|)
                              ($IsBox |x2#0@@5| |#$T2@@80|))
                         (|Set#Equal| (Reads3 |#$T0@@201|
                                              |#$T1@@137|
                                              |#$T2@@80|
                                              |#$R@@227|
                                              $OneHeap
                                              |f#0@@47|
                                              |x0#0@@19|
                                              |x1#0@@11|
                                              |x2#0@@5|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@19|)
                     :no-pattern (type |x1#0@@11|)
                     :no-pattern (type |x2#0@@5|)
                     :no-pattern (U_2_int |x0#0@@19|)
                     :no-pattern (U_2_bool |x0#0@@19|)
                     :no-pattern (U_2_int |x1#0@@11|)
                     :no-pattern (U_2_bool |x1#0@@11|)
                     :no-pattern (U_2_int |x2#0@@5|)
                     :no-pattern (U_2_bool |x2#0@@5|)
                     :skolemid |1162|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@47|
                        (Tclass._System.___hPartialFunc3LLOL
                          |#$T0@@201|
                          |#$T1@@137|
                          |#$T2@@80|
                          |#$R@@227|))
                   (and ($Is |f#0@@47|
                             (Tclass._System.___hFunc3LLOL
                               |#$T0@@201|
                               |#$T1@@137|
                               |#$T2@@80|
                               |#$R@@227|))
                        a!1))))
       (=> (and (= (type |#$T0@@201|) TyType)
                (= (type |#$T1@@137|) TyType)
                (= (type |#$T2@@80|) TyType)
                (= (type |#$R@@227|) TyType)
                (= (type |f#0@@47|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@47|
                    (Tclass._System.___hPartialFunc3LLOL
                      |#$T0@@201|
                      |#$T1@@137|
                      |#$T2@@80|
                      |#$R@@227|)))
     :skolemid |1163|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@202| T@U)
         (|#$T1@@138| T@U)
         (|#$T2@@81| T@U)
         (|#$R@@228| T@U)
         (|f#0@@48| T@U)
         ($h@@39 T@U))
  (! (=> (and (= (type |#$T0@@202|) TyType)
              (= (type |#$T1@@138|) TyType)
              (= (type |#$T2@@81|) TyType)
              (= (type |#$R@@228|) TyType)
              (= (type |f#0@@48|) HandleTypeType)
              (= (type $h@@39) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@48|
                      (Tclass._System.___hPartialFunc3LLOL
                        |#$T0@@202|
                        |#$T1@@138|
                        |#$T2@@81|
                        |#$R@@228|)
                      $h@@39)
            ($IsAlloc |f#0@@48|
                      (Tclass._System.___hFunc3LLOL
                        |#$T0@@202|
                        |#$T1@@138|
                        |#$T2@@81|
                        |#$R@@228|)
                      $h@@39)))
     :pattern (($IsAlloc |f#0@@48|
                         (Tclass._System.___hPartialFunc3LLOL
                           |#$T0@@202|
                           |#$T1@@138|
                           |#$T2@@81|
                           |#$R@@228|)
                         $h@@39))
     :skolemid |1164|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@314 T@U) (arg1@@131 T@U) (arg2@@72 T@U) (arg3@@44 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOL
                arg0@@314
                arg1@@131
                arg2@@72
                arg3@@44))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOL
                 arg0@@314
                 arg1@@131
                 arg2@@72
                 arg3@@44))
     :qid |funType:Tclass._System.___hTotalFunc3LLOL|)))
(assert (forall ((|#$T0@@203| T@U) (|#$T1@@139| T@U) (|#$T2@@82| T@U) (|#$R@@229| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc3LLOL
                               |#$T0@@203|
                               |#$T1@@139|
                               |#$T2@@82|
                               |#$R@@229|))
                        Tagclass._System.___hTotalFunc3LLOL)
                     (= (TagFamily (Tclass._System.___hTotalFunc3LLOL
                                     |#$T0@@203|
                                     |#$T1@@139|
                                     |#$T2@@82|
                                     |#$R@@229|))
                        |tytagFamily$_#TotalFunc3LLOL|))))
       (=> (and (= (type |#$T0@@203|) TyType)
                (= (type |#$T1@@139|) TyType)
                (= (type |#$T2@@82|) TyType)
                (= (type |#$R@@229|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc3LLOL
                 |#$T0@@203|
                 |#$T1@@139|
                 |#$T2@@82|
                 |#$R@@229|))
     :skolemid |1165|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@315 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOL_0 arg0@@315)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOL_0 arg0@@315))
     :qid |funType:Tclass._System.___hTotalFunc3LLOL_0|)))
(assert (forall ((|#$T0@@204| T@U) (|#$T1@@140| T@U) (|#$T2@@83| T@U) (|#$R@@230| T@U))
  (! (=> (and (= (type |#$T0@@204|) TyType)
              (= (type |#$T1@@140|) TyType)
              (= (type |#$T2@@83|) TyType)
              (= (type |#$R@@230|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOL_0
              (Tclass._System.___hTotalFunc3LLOL
                |#$T0@@204|
                |#$T1@@140|
                |#$T2@@83|
                |#$R@@230|))
            |#$T0@@204|))
     :pattern ((Tclass._System.___hTotalFunc3LLOL
                 |#$T0@@204|
                 |#$T1@@140|
                 |#$T2@@83|
                 |#$R@@230|))
     :skolemid |1166|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@316 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOL_1 arg0@@316)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOL_1 arg0@@316))
     :qid |funType:Tclass._System.___hTotalFunc3LLOL_1|)))
(assert (forall ((|#$T0@@205| T@U) (|#$T1@@141| T@U) (|#$T2@@84| T@U) (|#$R@@231| T@U))
  (! (=> (and (= (type |#$T0@@205|) TyType)
              (= (type |#$T1@@141|) TyType)
              (= (type |#$T2@@84|) TyType)
              (= (type |#$R@@231|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOL_1
              (Tclass._System.___hTotalFunc3LLOL
                |#$T0@@205|
                |#$T1@@141|
                |#$T2@@84|
                |#$R@@231|))
            |#$T1@@141|))
     :pattern ((Tclass._System.___hTotalFunc3LLOL
                 |#$T0@@205|
                 |#$T1@@141|
                 |#$T2@@84|
                 |#$R@@231|))
     :skolemid |1167|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@317 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOL_2 arg0@@317)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOL_2 arg0@@317))
     :qid |funType:Tclass._System.___hTotalFunc3LLOL_2|)))
(assert (forall ((|#$T0@@206| T@U) (|#$T1@@142| T@U) (|#$T2@@85| T@U) (|#$R@@232| T@U))
  (! (=> (and (= (type |#$T0@@206|) TyType)
              (= (type |#$T1@@142|) TyType)
              (= (type |#$T2@@85|) TyType)
              (= (type |#$R@@232|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOL_2
              (Tclass._System.___hTotalFunc3LLOL
                |#$T0@@206|
                |#$T1@@142|
                |#$T2@@85|
                |#$R@@232|))
            |#$T2@@85|))
     :pattern ((Tclass._System.___hTotalFunc3LLOL
                 |#$T0@@206|
                 |#$T1@@142|
                 |#$T2@@85|
                 |#$R@@232|))
     :skolemid |1168|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@318 T@U))
  (! (= (type (Tclass._System.___hTotalFunc3LLOL_3 arg0@@318)) TyType)
     :pattern ((Tclass._System.___hTotalFunc3LLOL_3 arg0@@318))
     :qid |funType:Tclass._System.___hTotalFunc3LLOL_3|)))
(assert (forall ((|#$T0@@207| T@U) (|#$T1@@143| T@U) (|#$T2@@86| T@U) (|#$R@@233| T@U))
  (! (=> (and (= (type |#$T0@@207|) TyType)
              (= (type |#$T1@@143|) TyType)
              (= (type |#$T2@@86|) TyType)
              (= (type |#$R@@233|) TyType))
         (= (Tclass._System.___hTotalFunc3LLOL_3
              (Tclass._System.___hTotalFunc3LLOL
                |#$T0@@207|
                |#$T1@@143|
                |#$T2@@86|
                |#$R@@233|))
            |#$R@@233|))
     :pattern ((Tclass._System.___hTotalFunc3LLOL
                 |#$T0@@207|
                 |#$T1@@143|
                 |#$T2@@86|
                 |#$R@@233|))
     :skolemid |1169|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@208| T@U)
         (|#$T1@@144| T@U)
         (|#$T2@@87| T@U)
         (|#$R@@234| T@U)
         (bx@@93 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@93)) bx@@93)
                     ($Is ($Unbox HandleTypeType bx@@93)
                          (Tclass._System.___hTotalFunc3LLOL
                            |#$T0@@208|
                            |#$T1@@144|
                            |#$T2@@87|
                            |#$R@@234|)))))
       (=> (and (= (type |#$T0@@208|) TyType)
                (= (type |#$T1@@144|) TyType)
                (= (type |#$T2@@87|) TyType)
                (= (type |#$R@@234|) TyType)
                (= (type bx@@93) BoxType)
                ($IsBox bx@@93
                        (Tclass._System.___hTotalFunc3LLOL
                          |#$T0@@208|
                          |#$T1@@144|
                          |#$T2@@87|
                          |#$R@@234|)))
           a!1))
     :pattern (($IsBox bx@@93
                       (Tclass._System.___hTotalFunc3LLOL
                         |#$T0@@208|
                         |#$T1@@144|
                         |#$T2@@87|
                         |#$R@@234|)))
     :skolemid |1170|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@209| T@U)
         (|#$T1@@145| T@U)
         (|#$T2@@88| T@U)
         (|#$R@@235| T@U)
         (|f#0@@49| T@U))
  (! (let ((a!1 (forall ((|x0#0@@20| T@U) (|x1#0@@12| T@U) (|x2#0@@6| T@U))
                  (! (=> (and (= (type |x0#0@@20|) BoxType)
                              (= (type |x1#0@@12|) BoxType)
                              (= (type |x2#0@@6|) BoxType)
                              ($IsBox |x0#0@@20| |#$T0@@209|)
                              ($IsBox |x1#0@@12| |#$T1@@145|)
                              ($IsBox |x2#0@@6| |#$T2@@88|))
                         (Requires3 |#$T0@@209|
                                    |#$T1@@145|
                                    |#$T2@@88|
                                    |#$R@@235|
                                    $OneHeap
                                    |f#0@@49|
                                    |x0#0@@20|
                                    |x1#0@@12|
                                    |x2#0@@6|))
                     :no-pattern (type |x0#0@@20|)
                     :no-pattern (type |x1#0@@12|)
                     :no-pattern (type |x2#0@@6|)
                     :no-pattern (U_2_int |x0#0@@20|)
                     :no-pattern (U_2_bool |x0#0@@20|)
                     :no-pattern (U_2_int |x1#0@@12|)
                     :no-pattern (U_2_bool |x1#0@@12|)
                     :no-pattern (U_2_int |x2#0@@6|)
                     :no-pattern (U_2_bool |x2#0@@6|)
                     :skolemid |1171|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@49|
                        (Tclass._System.___hTotalFunc3LLOL
                          |#$T0@@209|
                          |#$T1@@145|
                          |#$T2@@88|
                          |#$R@@235|))
                   (and ($Is |f#0@@49|
                             (Tclass._System.___hPartialFunc3LLOL
                               |#$T0@@209|
                               |#$T1@@145|
                               |#$T2@@88|
                               |#$R@@235|))
                        a!1))))
       (=> (and (= (type |#$T0@@209|) TyType)
                (= (type |#$T1@@145|) TyType)
                (= (type |#$T2@@88|) TyType)
                (= (type |#$R@@235|) TyType)
                (= (type |f#0@@49|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@49|
                    (Tclass._System.___hTotalFunc3LLOL
                      |#$T0@@209|
                      |#$T1@@145|
                      |#$T2@@88|
                      |#$R@@235|)))
     :skolemid |1172|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@210| T@U)
         (|#$T1@@146| T@U)
         (|#$T2@@89| T@U)
         (|#$R@@236| T@U)
         (|f#0@@50| T@U)
         ($h@@40 T@U))
  (! (=> (and (= (type |#$T0@@210|) TyType)
              (= (type |#$T1@@146|) TyType)
              (= (type |#$T2@@89|) TyType)
              (= (type |#$R@@236|) TyType)
              (= (type |f#0@@50|) HandleTypeType)
              (= (type $h@@40) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@50|
                      (Tclass._System.___hTotalFunc3LLOL
                        |#$T0@@210|
                        |#$T1@@146|
                        |#$T2@@89|
                        |#$R@@236|)
                      $h@@40)
            ($IsAlloc |f#0@@50|
                      (Tclass._System.___hPartialFunc3LLOL
                        |#$T0@@210|
                        |#$T1@@146|
                        |#$T2@@89|
                        |#$R@@236|)
                      $h@@40)))
     :pattern (($IsAlloc |f#0@@50|
                         (Tclass._System.___hTotalFunc3LLOL
                           |#$T0@@210|
                           |#$T1@@146|
                           |#$T2@@89|
                           |#$R@@236|)
                         $h@@40))
     :skolemid |1173|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@319 T@U) (arg1@@132 T@U) (arg2@@73 T@U))
  (! (= (type (Tclass._System.___hFunc2SSO arg0@@319 arg1@@132 arg2@@73))
        TyType)
     :pattern ((Tclass._System.___hFunc2SSO arg0@@319 arg1@@132 arg2@@73))
     :qid |funType:Tclass._System.___hFunc2SSO|)))
(assert (forall ((|#$T0@@211| T@U) (|#$T1@@147| T@U) (|#$R@@237| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc2SSO
                               |#$T0@@211|
                               |#$T1@@147|
                               |#$R@@237|))
                        Tagclass._System.___hFunc2SSO)
                     (= (TagFamily (Tclass._System.___hFunc2SSO
                                     |#$T0@@211|
                                     |#$T1@@147|
                                     |#$R@@237|))
                        |tytagFamily$_#Func2SSO|))))
       (=> (and (= (type |#$T0@@211|) TyType)
                (= (type |#$T1@@147|) TyType)
                (= (type |#$R@@237|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc2SSO |#$T0@@211| |#$T1@@147| |#$R@@237|))
     :skolemid |1174|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@320 T@U))
  (! (= (type (Tclass._System.___hFunc2SSO_0 arg0@@320)) TyType)
     :pattern ((Tclass._System.___hFunc2SSO_0 arg0@@320))
     :qid |funType:Tclass._System.___hFunc2SSO_0|)))
(assert (forall ((|#$T0@@212| T@U) (|#$T1@@148| T@U) (|#$R@@238| T@U))
  (! (=> (and (= (type |#$T0@@212|) TyType)
              (= (type |#$T1@@148|) TyType)
              (= (type |#$R@@238|) TyType))
         (= (Tclass._System.___hFunc2SSO_0
              (Tclass._System.___hFunc2SSO |#$T0@@212| |#$T1@@148| |#$R@@238|))
            |#$T0@@212|))
     :pattern ((Tclass._System.___hFunc2SSO |#$T0@@212| |#$T1@@148| |#$R@@238|))
     :skolemid |1175|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@321 T@U))
  (! (= (type (Tclass._System.___hFunc2SSO_1 arg0@@321)) TyType)
     :pattern ((Tclass._System.___hFunc2SSO_1 arg0@@321))
     :qid |funType:Tclass._System.___hFunc2SSO_1|)))
(assert (forall ((|#$T0@@213| T@U) (|#$T1@@149| T@U) (|#$R@@239| T@U))
  (! (=> (and (= (type |#$T0@@213|) TyType)
              (= (type |#$T1@@149|) TyType)
              (= (type |#$R@@239|) TyType))
         (= (Tclass._System.___hFunc2SSO_1
              (Tclass._System.___hFunc2SSO |#$T0@@213| |#$T1@@149| |#$R@@239|))
            |#$T1@@149|))
     :pattern ((Tclass._System.___hFunc2SSO |#$T0@@213| |#$T1@@149| |#$R@@239|))
     :skolemid |1176|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@322 T@U))
  (! (= (type (Tclass._System.___hFunc2SSO_2 arg0@@322)) TyType)
     :pattern ((Tclass._System.___hFunc2SSO_2 arg0@@322))
     :qid |funType:Tclass._System.___hFunc2SSO_2|)))
(assert (forall ((|#$T0@@214| T@U) (|#$T1@@150| T@U) (|#$R@@240| T@U))
  (! (=> (and (= (type |#$T0@@214|) TyType)
              (= (type |#$T1@@150|) TyType)
              (= (type |#$R@@240|) TyType))
         (= (Tclass._System.___hFunc2SSO_2
              (Tclass._System.___hFunc2SSO |#$T0@@214| |#$T1@@150| |#$R@@240|))
            |#$R@@240|))
     :pattern ((Tclass._System.___hFunc2SSO |#$T0@@214| |#$T1@@150| |#$R@@240|))
     :skolemid |1177|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@215| T@U) (|#$T1@@151| T@U) (|#$R@@241| T@U) (bx@@94 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@94)) bx@@94)
                     ($Is ($Unbox HandleTypeType bx@@94)
                          (Tclass._System.___hFunc2SSO
                            |#$T0@@215|
                            |#$T1@@151|
                            |#$R@@241|)))))
       (=> (and (= (type |#$T0@@215|) TyType)
                (= (type |#$T1@@151|) TyType)
                (= (type |#$R@@241|) TyType)
                (= (type bx@@94) BoxType)
                ($IsBox bx@@94
                        (Tclass._System.___hFunc2SSO
                          |#$T0@@215|
                          |#$T1@@151|
                          |#$R@@241|)))
           a!1))
     :pattern (($IsBox bx@@94
                       (Tclass._System.___hFunc2SSO
                         |#$T0@@215|
                         |#$T1@@151|
                         |#$R@@241|)))
     :skolemid |1178|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@323 T@U) (arg1@@133 T@U) (arg2@@74 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2SSO arg0@@323 arg1@@133 arg2@@74))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc2SSO arg0@@323 arg1@@133 arg2@@74))
     :qid |funType:Tclass._System.___hPartialFunc2SSO|)))
(assert (forall ((|#$T0@@216| T@U) (|#$T1@@152| T@U) (|#$R@@242| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc2SSO
                               |#$T0@@216|
                               |#$T1@@152|
                               |#$R@@242|))
                        Tagclass._System.___hPartialFunc2SSO)
                     (= (TagFamily (Tclass._System.___hPartialFunc2SSO
                                     |#$T0@@216|
                                     |#$T1@@152|
                                     |#$R@@242|))
                        |tytagFamily$_#PartialFunc2SSO|))))
       (=> (and (= (type |#$T0@@216|) TyType)
                (= (type |#$T1@@152|) TyType)
                (= (type |#$R@@242|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc2SSO
                 |#$T0@@216|
                 |#$T1@@152|
                 |#$R@@242|))
     :skolemid |1179|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@324 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2SSO_0 arg0@@324)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2SSO_0 arg0@@324))
     :qid |funType:Tclass._System.___hPartialFunc2SSO_0|)))
(assert (forall ((|#$T0@@217| T@U) (|#$T1@@153| T@U) (|#$R@@243| T@U))
  (! (=> (and (= (type |#$T0@@217|) TyType)
              (= (type |#$T1@@153|) TyType)
              (= (type |#$R@@243|) TyType))
         (= (Tclass._System.___hPartialFunc2SSO_0
              (Tclass._System.___hPartialFunc2SSO
                |#$T0@@217|
                |#$T1@@153|
                |#$R@@243|))
            |#$T0@@217|))
     :pattern ((Tclass._System.___hPartialFunc2SSO
                 |#$T0@@217|
                 |#$T1@@153|
                 |#$R@@243|))
     :skolemid |1180|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@325 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2SSO_1 arg0@@325)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2SSO_1 arg0@@325))
     :qid |funType:Tclass._System.___hPartialFunc2SSO_1|)))
(assert (forall ((|#$T0@@218| T@U) (|#$T1@@154| T@U) (|#$R@@244| T@U))
  (! (=> (and (= (type |#$T0@@218|) TyType)
              (= (type |#$T1@@154|) TyType)
              (= (type |#$R@@244|) TyType))
         (= (Tclass._System.___hPartialFunc2SSO_1
              (Tclass._System.___hPartialFunc2SSO
                |#$T0@@218|
                |#$T1@@154|
                |#$R@@244|))
            |#$T1@@154|))
     :pattern ((Tclass._System.___hPartialFunc2SSO
                 |#$T0@@218|
                 |#$T1@@154|
                 |#$R@@244|))
     :skolemid |1181|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@326 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2SSO_2 arg0@@326)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2SSO_2 arg0@@326))
     :qid |funType:Tclass._System.___hPartialFunc2SSO_2|)))
(assert (forall ((|#$T0@@219| T@U) (|#$T1@@155| T@U) (|#$R@@245| T@U))
  (! (=> (and (= (type |#$T0@@219|) TyType)
              (= (type |#$T1@@155|) TyType)
              (= (type |#$R@@245|) TyType))
         (= (Tclass._System.___hPartialFunc2SSO_2
              (Tclass._System.___hPartialFunc2SSO
                |#$T0@@219|
                |#$T1@@155|
                |#$R@@245|))
            |#$R@@245|))
     :pattern ((Tclass._System.___hPartialFunc2SSO
                 |#$T0@@219|
                 |#$T1@@155|
                 |#$R@@245|))
     :skolemid |1182|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@220| T@U) (|#$T1@@156| T@U) (|#$R@@246| T@U) (bx@@95 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@95)) bx@@95)
                     ($Is ($Unbox HandleTypeType bx@@95)
                          (Tclass._System.___hPartialFunc2SSO
                            |#$T0@@220|
                            |#$T1@@156|
                            |#$R@@246|)))))
       (=> (and (= (type |#$T0@@220|) TyType)
                (= (type |#$T1@@156|) TyType)
                (= (type |#$R@@246|) TyType)
                (= (type bx@@95) BoxType)
                ($IsBox bx@@95
                        (Tclass._System.___hPartialFunc2SSO
                          |#$T0@@220|
                          |#$T1@@156|
                          |#$R@@246|)))
           a!1))
     :pattern (($IsBox bx@@95
                       (Tclass._System.___hPartialFunc2SSO
                         |#$T0@@220|
                         |#$T1@@156|
                         |#$R@@246|)))
     :skolemid |1183|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@221| T@U) (|#$T1@@157| T@U) (|#$R@@247| T@U) (|f#0@@51| T@U))
  (! (let ((a!1 (forall ((|x0#0@@21| T@U) (|x1#0@@13| T@U))
                  (! (=> (and (= (type |x0#0@@21|) BoxType)
                              (= (type |x1#0@@13|) BoxType)
                              ($IsBox |x0#0@@21| |#$T0@@221|)
                              ($IsBox |x1#0@@13| |#$T1@@157|))
                         (|Set#Equal| (Reads2 |#$T0@@221|
                                              |#$T1@@157|
                                              |#$R@@247|
                                              $OneHeap
                                              |f#0@@51|
                                              |x0#0@@21|
                                              |x1#0@@13|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@21|)
                     :no-pattern (type |x1#0@@13|)
                     :no-pattern (U_2_int |x0#0@@21|)
                     :no-pattern (U_2_bool |x0#0@@21|)
                     :no-pattern (U_2_int |x1#0@@13|)
                     :no-pattern (U_2_bool |x1#0@@13|)
                     :skolemid |1184|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@51|
                        (Tclass._System.___hPartialFunc2SSO
                          |#$T0@@221|
                          |#$T1@@157|
                          |#$R@@247|))
                   (and ($Is |f#0@@51|
                             (Tclass._System.___hFunc2SSO
                               |#$T0@@221|
                               |#$T1@@157|
                               |#$R@@247|))
                        a!1))))
       (=> (and (= (type |#$T0@@221|) TyType)
                (= (type |#$T1@@157|) TyType)
                (= (type |#$R@@247|) TyType)
                (= (type |f#0@@51|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@51|
                    (Tclass._System.___hPartialFunc2SSO
                      |#$T0@@221|
                      |#$T1@@157|
                      |#$R@@247|)))
     :skolemid |1185|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@222| T@U)
         (|#$T1@@158| T@U)
         (|#$R@@248| T@U)
         (|f#0@@52| T@U)
         ($h@@41 T@U))
  (! (=> (and (= (type |#$T0@@222|) TyType)
              (= (type |#$T1@@158|) TyType)
              (= (type |#$R@@248|) TyType)
              (= (type |f#0@@52|) HandleTypeType)
              (= (type $h@@41) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@52|
                      (Tclass._System.___hPartialFunc2SSO
                        |#$T0@@222|
                        |#$T1@@158|
                        |#$R@@248|)
                      $h@@41)
            ($IsAlloc |f#0@@52|
                      (Tclass._System.___hFunc2SSO
                        |#$T0@@222|
                        |#$T1@@158|
                        |#$R@@248|)
                      $h@@41)))
     :pattern (($IsAlloc |f#0@@52|
                         (Tclass._System.___hPartialFunc2SSO
                           |#$T0@@222|
                           |#$T1@@158|
                           |#$R@@248|)
                         $h@@41))
     :skolemid |1186|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@327 T@U) (arg1@@134 T@U) (arg2@@75 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2SSO arg0@@327 arg1@@134 arg2@@75))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc2SSO arg0@@327 arg1@@134 arg2@@75))
     :qid |funType:Tclass._System.___hTotalFunc2SSO|)))
(assert (forall ((|#$T0@@223| T@U) (|#$T1@@159| T@U) (|#$R@@249| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc2SSO
                               |#$T0@@223|
                               |#$T1@@159|
                               |#$R@@249|))
                        Tagclass._System.___hTotalFunc2SSO)
                     (= (TagFamily (Tclass._System.___hTotalFunc2SSO
                                     |#$T0@@223|
                                     |#$T1@@159|
                                     |#$R@@249|))
                        |tytagFamily$_#TotalFunc2SSO|))))
       (=> (and (= (type |#$T0@@223|) TyType)
                (= (type |#$T1@@159|) TyType)
                (= (type |#$R@@249|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc2SSO
                 |#$T0@@223|
                 |#$T1@@159|
                 |#$R@@249|))
     :skolemid |1187|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@328 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2SSO_0 arg0@@328)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2SSO_0 arg0@@328))
     :qid |funType:Tclass._System.___hTotalFunc2SSO_0|)))
(assert (forall ((|#$T0@@224| T@U) (|#$T1@@160| T@U) (|#$R@@250| T@U))
  (! (=> (and (= (type |#$T0@@224|) TyType)
              (= (type |#$T1@@160|) TyType)
              (= (type |#$R@@250|) TyType))
         (= (Tclass._System.___hTotalFunc2SSO_0
              (Tclass._System.___hTotalFunc2SSO
                |#$T0@@224|
                |#$T1@@160|
                |#$R@@250|))
            |#$T0@@224|))
     :pattern ((Tclass._System.___hTotalFunc2SSO
                 |#$T0@@224|
                 |#$T1@@160|
                 |#$R@@250|))
     :skolemid |1188|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@329 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2SSO_1 arg0@@329)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2SSO_1 arg0@@329))
     :qid |funType:Tclass._System.___hTotalFunc2SSO_1|)))
(assert (forall ((|#$T0@@225| T@U) (|#$T1@@161| T@U) (|#$R@@251| T@U))
  (! (=> (and (= (type |#$T0@@225|) TyType)
              (= (type |#$T1@@161|) TyType)
              (= (type |#$R@@251|) TyType))
         (= (Tclass._System.___hTotalFunc2SSO_1
              (Tclass._System.___hTotalFunc2SSO
                |#$T0@@225|
                |#$T1@@161|
                |#$R@@251|))
            |#$T1@@161|))
     :pattern ((Tclass._System.___hTotalFunc2SSO
                 |#$T0@@225|
                 |#$T1@@161|
                 |#$R@@251|))
     :skolemid |1189|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@330 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2SSO_2 arg0@@330)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2SSO_2 arg0@@330))
     :qid |funType:Tclass._System.___hTotalFunc2SSO_2|)))
(assert (forall ((|#$T0@@226| T@U) (|#$T1@@162| T@U) (|#$R@@252| T@U))
  (! (=> (and (= (type |#$T0@@226|) TyType)
              (= (type |#$T1@@162|) TyType)
              (= (type |#$R@@252|) TyType))
         (= (Tclass._System.___hTotalFunc2SSO_2
              (Tclass._System.___hTotalFunc2SSO
                |#$T0@@226|
                |#$T1@@162|
                |#$R@@252|))
            |#$R@@252|))
     :pattern ((Tclass._System.___hTotalFunc2SSO
                 |#$T0@@226|
                 |#$T1@@162|
                 |#$R@@252|))
     :skolemid |1190|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@227| T@U) (|#$T1@@163| T@U) (|#$R@@253| T@U) (bx@@96 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@96)) bx@@96)
                     ($Is ($Unbox HandleTypeType bx@@96)
                          (Tclass._System.___hTotalFunc2SSO
                            |#$T0@@227|
                            |#$T1@@163|
                            |#$R@@253|)))))
       (=> (and (= (type |#$T0@@227|) TyType)
                (= (type |#$T1@@163|) TyType)
                (= (type |#$R@@253|) TyType)
                (= (type bx@@96) BoxType)
                ($IsBox bx@@96
                        (Tclass._System.___hTotalFunc2SSO
                          |#$T0@@227|
                          |#$T1@@163|
                          |#$R@@253|)))
           a!1))
     :pattern (($IsBox bx@@96
                       (Tclass._System.___hTotalFunc2SSO
                         |#$T0@@227|
                         |#$T1@@163|
                         |#$R@@253|)))
     :skolemid |1191|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@228| T@U) (|#$T1@@164| T@U) (|#$R@@254| T@U) (|f#0@@53| T@U))
  (! (let ((a!1 (forall ((|x0#0@@22| T@U) (|x1#0@@14| T@U))
                  (! (=> (and (= (type |x0#0@@22|) BoxType)
                              (= (type |x1#0@@14|) BoxType)
                              ($IsBox |x0#0@@22| |#$T0@@228|)
                              ($IsBox |x1#0@@14| |#$T1@@164|))
                         (Requires2 |#$T0@@228|
                                    |#$T1@@164|
                                    |#$R@@254|
                                    $OneHeap
                                    |f#0@@53|
                                    |x0#0@@22|
                                    |x1#0@@14|))
                     :no-pattern (type |x0#0@@22|)
                     :no-pattern (type |x1#0@@14|)
                     :no-pattern (U_2_int |x0#0@@22|)
                     :no-pattern (U_2_bool |x0#0@@22|)
                     :no-pattern (U_2_int |x1#0@@14|)
                     :no-pattern (U_2_bool |x1#0@@14|)
                     :skolemid |1192|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@53|
                        (Tclass._System.___hTotalFunc2SSO
                          |#$T0@@228|
                          |#$T1@@164|
                          |#$R@@254|))
                   (and ($Is |f#0@@53|
                             (Tclass._System.___hPartialFunc2SSO
                               |#$T0@@228|
                               |#$T1@@164|
                               |#$R@@254|))
                        a!1))))
       (=> (and (= (type |#$T0@@228|) TyType)
                (= (type |#$T1@@164|) TyType)
                (= (type |#$R@@254|) TyType)
                (= (type |f#0@@53|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@53|
                    (Tclass._System.___hTotalFunc2SSO
                      |#$T0@@228|
                      |#$T1@@164|
                      |#$R@@254|)))
     :skolemid |1193|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@229| T@U)
         (|#$T1@@165| T@U)
         (|#$R@@255| T@U)
         (|f#0@@54| T@U)
         ($h@@42 T@U))
  (! (=> (and (= (type |#$T0@@229|) TyType)
              (= (type |#$T1@@165|) TyType)
              (= (type |#$R@@255|) TyType)
              (= (type |f#0@@54|) HandleTypeType)
              (= (type $h@@42) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@54|
                      (Tclass._System.___hTotalFunc2SSO
                        |#$T0@@229|
                        |#$T1@@165|
                        |#$R@@255|)
                      $h@@42)
            ($IsAlloc |f#0@@54|
                      (Tclass._System.___hPartialFunc2SSO
                        |#$T0@@229|
                        |#$T1@@165|
                        |#$R@@255|)
                      $h@@42)))
     :pattern (($IsAlloc |f#0@@54|
                         (Tclass._System.___hTotalFunc2SSO
                           |#$T0@@229|
                           |#$T1@@165|
                           |#$R@@255|)
                         $h@@42))
     :skolemid |1194|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@331 T@U) (arg1@@135 T@U) (arg2@@76 T@U))
  (! (= (type (Tclass._System.___hFunc2LLO arg0@@331 arg1@@135 arg2@@76))
        TyType)
     :pattern ((Tclass._System.___hFunc2LLO arg0@@331 arg1@@135 arg2@@76))
     :qid |funType:Tclass._System.___hFunc2LLO|)))
(assert (forall ((|#$T0@@230| T@U) (|#$T1@@166| T@U) (|#$R@@256| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc2LLO
                               |#$T0@@230|
                               |#$T1@@166|
                               |#$R@@256|))
                        Tagclass._System.___hFunc2LLO)
                     (= (TagFamily (Tclass._System.___hFunc2LLO
                                     |#$T0@@230|
                                     |#$T1@@166|
                                     |#$R@@256|))
                        |tytagFamily$_#Func2LLO|))))
       (=> (and (= (type |#$T0@@230|) TyType)
                (= (type |#$T1@@166|) TyType)
                (= (type |#$R@@256|) TyType))
           a!1))
     :pattern ((Tclass._System.___hFunc2LLO |#$T0@@230| |#$T1@@166| |#$R@@256|))
     :skolemid |1195|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@332 T@U))
  (! (= (type (Tclass._System.___hFunc2LLO_0 arg0@@332)) TyType)
     :pattern ((Tclass._System.___hFunc2LLO_0 arg0@@332))
     :qid |funType:Tclass._System.___hFunc2LLO_0|)))
(assert (forall ((|#$T0@@231| T@U) (|#$T1@@167| T@U) (|#$R@@257| T@U))
  (! (=> (and (= (type |#$T0@@231|) TyType)
              (= (type |#$T1@@167|) TyType)
              (= (type |#$R@@257|) TyType))
         (= (Tclass._System.___hFunc2LLO_0
              (Tclass._System.___hFunc2LLO |#$T0@@231| |#$T1@@167| |#$R@@257|))
            |#$T0@@231|))
     :pattern ((Tclass._System.___hFunc2LLO |#$T0@@231| |#$T1@@167| |#$R@@257|))
     :skolemid |1196|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@333 T@U))
  (! (= (type (Tclass._System.___hFunc2LLO_1 arg0@@333)) TyType)
     :pattern ((Tclass._System.___hFunc2LLO_1 arg0@@333))
     :qid |funType:Tclass._System.___hFunc2LLO_1|)))
(assert (forall ((|#$T0@@232| T@U) (|#$T1@@168| T@U) (|#$R@@258| T@U))
  (! (=> (and (= (type |#$T0@@232|) TyType)
              (= (type |#$T1@@168|) TyType)
              (= (type |#$R@@258|) TyType))
         (= (Tclass._System.___hFunc2LLO_1
              (Tclass._System.___hFunc2LLO |#$T0@@232| |#$T1@@168| |#$R@@258|))
            |#$T1@@168|))
     :pattern ((Tclass._System.___hFunc2LLO |#$T0@@232| |#$T1@@168| |#$R@@258|))
     :skolemid |1197|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@334 T@U))
  (! (= (type (Tclass._System.___hFunc2LLO_2 arg0@@334)) TyType)
     :pattern ((Tclass._System.___hFunc2LLO_2 arg0@@334))
     :qid |funType:Tclass._System.___hFunc2LLO_2|)))
(assert (forall ((|#$T0@@233| T@U) (|#$T1@@169| T@U) (|#$R@@259| T@U))
  (! (=> (and (= (type |#$T0@@233|) TyType)
              (= (type |#$T1@@169|) TyType)
              (= (type |#$R@@259|) TyType))
         (= (Tclass._System.___hFunc2LLO_2
              (Tclass._System.___hFunc2LLO |#$T0@@233| |#$T1@@169| |#$R@@259|))
            |#$R@@259|))
     :pattern ((Tclass._System.___hFunc2LLO |#$T0@@233| |#$T1@@169| |#$R@@259|))
     :skolemid |1198|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@234| T@U) (|#$T1@@170| T@U) (|#$R@@260| T@U) (bx@@97 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@97)) bx@@97)
                     ($Is ($Unbox HandleTypeType bx@@97)
                          (Tclass._System.___hFunc2LLO
                            |#$T0@@234|
                            |#$T1@@170|
                            |#$R@@260|)))))
       (=> (and (= (type |#$T0@@234|) TyType)
                (= (type |#$T1@@170|) TyType)
                (= (type |#$R@@260|) TyType)
                (= (type bx@@97) BoxType)
                ($IsBox bx@@97
                        (Tclass._System.___hFunc2LLO
                          |#$T0@@234|
                          |#$T1@@170|
                          |#$R@@260|)))
           a!1))
     :pattern (($IsBox bx@@97
                       (Tclass._System.___hFunc2LLO
                         |#$T0@@234|
                         |#$T1@@170|
                         |#$R@@260|)))
     :skolemid |1199|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@335 T@U) (arg1@@136 T@U) (arg2@@77 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LLO arg0@@335 arg1@@136 arg2@@77))
        TyType)
     :pattern ((Tclass._System.___hPartialFunc2LLO arg0@@335 arg1@@136 arg2@@77))
     :qid |funType:Tclass._System.___hPartialFunc2LLO|)))
(assert (forall ((|#$T0@@235| T@U) (|#$T1@@171| T@U) (|#$R@@261| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc2LLO
                               |#$T0@@235|
                               |#$T1@@171|
                               |#$R@@261|))
                        Tagclass._System.___hPartialFunc2LLO)
                     (= (TagFamily (Tclass._System.___hPartialFunc2LLO
                                     |#$T0@@235|
                                     |#$T1@@171|
                                     |#$R@@261|))
                        |tytagFamily$_#PartialFunc2LLO|))))
       (=> (and (= (type |#$T0@@235|) TyType)
                (= (type |#$T1@@171|) TyType)
                (= (type |#$R@@261|) TyType))
           a!1))
     :pattern ((Tclass._System.___hPartialFunc2LLO
                 |#$T0@@235|
                 |#$T1@@171|
                 |#$R@@261|))
     :skolemid |1200|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@336 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LLO_0 arg0@@336)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2LLO_0 arg0@@336))
     :qid |funType:Tclass._System.___hPartialFunc2LLO_0|)))
(assert (forall ((|#$T0@@236| T@U) (|#$T1@@172| T@U) (|#$R@@262| T@U))
  (! (=> (and (= (type |#$T0@@236|) TyType)
              (= (type |#$T1@@172|) TyType)
              (= (type |#$R@@262|) TyType))
         (= (Tclass._System.___hPartialFunc2LLO_0
              (Tclass._System.___hPartialFunc2LLO
                |#$T0@@236|
                |#$T1@@172|
                |#$R@@262|))
            |#$T0@@236|))
     :pattern ((Tclass._System.___hPartialFunc2LLO
                 |#$T0@@236|
                 |#$T1@@172|
                 |#$R@@262|))
     :skolemid |1201|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@337 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LLO_1 arg0@@337)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2LLO_1 arg0@@337))
     :qid |funType:Tclass._System.___hPartialFunc2LLO_1|)))
(assert (forall ((|#$T0@@237| T@U) (|#$T1@@173| T@U) (|#$R@@263| T@U))
  (! (=> (and (= (type |#$T0@@237|) TyType)
              (= (type |#$T1@@173|) TyType)
              (= (type |#$R@@263|) TyType))
         (= (Tclass._System.___hPartialFunc2LLO_1
              (Tclass._System.___hPartialFunc2LLO
                |#$T0@@237|
                |#$T1@@173|
                |#$R@@263|))
            |#$T1@@173|))
     :pattern ((Tclass._System.___hPartialFunc2LLO
                 |#$T0@@237|
                 |#$T1@@173|
                 |#$R@@263|))
     :skolemid |1202|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@338 T@U))
  (! (= (type (Tclass._System.___hPartialFunc2LLO_2 arg0@@338)) TyType)
     :pattern ((Tclass._System.___hPartialFunc2LLO_2 arg0@@338))
     :qid |funType:Tclass._System.___hPartialFunc2LLO_2|)))
(assert (forall ((|#$T0@@238| T@U) (|#$T1@@174| T@U) (|#$R@@264| T@U))
  (! (=> (and (= (type |#$T0@@238|) TyType)
              (= (type |#$T1@@174|) TyType)
              (= (type |#$R@@264|) TyType))
         (= (Tclass._System.___hPartialFunc2LLO_2
              (Tclass._System.___hPartialFunc2LLO
                |#$T0@@238|
                |#$T1@@174|
                |#$R@@264|))
            |#$R@@264|))
     :pattern ((Tclass._System.___hPartialFunc2LLO
                 |#$T0@@238|
                 |#$T1@@174|
                 |#$R@@264|))
     :skolemid |1203|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@239| T@U) (|#$T1@@175| T@U) (|#$R@@265| T@U) (bx@@98 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@98)) bx@@98)
                     ($Is ($Unbox HandleTypeType bx@@98)
                          (Tclass._System.___hPartialFunc2LLO
                            |#$T0@@239|
                            |#$T1@@175|
                            |#$R@@265|)))))
       (=> (and (= (type |#$T0@@239|) TyType)
                (= (type |#$T1@@175|) TyType)
                (= (type |#$R@@265|) TyType)
                (= (type bx@@98) BoxType)
                ($IsBox bx@@98
                        (Tclass._System.___hPartialFunc2LLO
                          |#$T0@@239|
                          |#$T1@@175|
                          |#$R@@265|)))
           a!1))
     :pattern (($IsBox bx@@98
                       (Tclass._System.___hPartialFunc2LLO
                         |#$T0@@239|
                         |#$T1@@175|
                         |#$R@@265|)))
     :skolemid |1204|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@240| T@U) (|#$T1@@176| T@U) (|#$R@@266| T@U) (|f#0@@55| T@U))
  (! (let ((a!1 (forall ((|x0#0@@23| T@U) (|x1#0@@15| T@U))
                  (! (=> (and (= (type |x0#0@@23|) BoxType)
                              (= (type |x1#0@@15|) BoxType)
                              ($IsBox |x0#0@@23| |#$T0@@240|)
                              ($IsBox |x1#0@@15| |#$T1@@176|))
                         (|Set#Equal| (Reads2 |#$T0@@240|
                                              |#$T1@@176|
                                              |#$R@@266|
                                              $OneHeap
                                              |f#0@@55|
                                              |x0#0@@23|
                                              |x1#0@@15|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@23|)
                     :no-pattern (type |x1#0@@15|)
                     :no-pattern (U_2_int |x0#0@@23|)
                     :no-pattern (U_2_bool |x0#0@@23|)
                     :no-pattern (U_2_int |x1#0@@15|)
                     :no-pattern (U_2_bool |x1#0@@15|)
                     :skolemid |1205|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@55|
                        (Tclass._System.___hPartialFunc2LLO
                          |#$T0@@240|
                          |#$T1@@176|
                          |#$R@@266|))
                   (and ($Is |f#0@@55|
                             (Tclass._System.___hFunc2LLO
                               |#$T0@@240|
                               |#$T1@@176|
                               |#$R@@266|))
                        a!1))))
       (=> (and (= (type |#$T0@@240|) TyType)
                (= (type |#$T1@@176|) TyType)
                (= (type |#$R@@266|) TyType)
                (= (type |f#0@@55|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@55|
                    (Tclass._System.___hPartialFunc2LLO
                      |#$T0@@240|
                      |#$T1@@176|
                      |#$R@@266|)))
     :skolemid |1206|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@241| T@U)
         (|#$T1@@177| T@U)
         (|#$R@@267| T@U)
         (|f#0@@56| T@U)
         ($h@@43 T@U))
  (! (=> (and (= (type |#$T0@@241|) TyType)
              (= (type |#$T1@@177|) TyType)
              (= (type |#$R@@267|) TyType)
              (= (type |f#0@@56|) HandleTypeType)
              (= (type $h@@43) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@56|
                      (Tclass._System.___hPartialFunc2LLO
                        |#$T0@@241|
                        |#$T1@@177|
                        |#$R@@267|)
                      $h@@43)
            ($IsAlloc |f#0@@56|
                      (Tclass._System.___hFunc2LLO
                        |#$T0@@241|
                        |#$T1@@177|
                        |#$R@@267|)
                      $h@@43)))
     :pattern (($IsAlloc |f#0@@56|
                         (Tclass._System.___hPartialFunc2LLO
                           |#$T0@@241|
                           |#$T1@@177|
                           |#$R@@267|)
                         $h@@43))
     :skolemid |1207|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@339 T@U) (arg1@@137 T@U) (arg2@@78 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LLO arg0@@339 arg1@@137 arg2@@78))
        TyType)
     :pattern ((Tclass._System.___hTotalFunc2LLO arg0@@339 arg1@@137 arg2@@78))
     :qid |funType:Tclass._System.___hTotalFunc2LLO|)))
(assert (forall ((|#$T0@@242| T@U) (|#$T1@@178| T@U) (|#$R@@268| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc2LLO
                               |#$T0@@242|
                               |#$T1@@178|
                               |#$R@@268|))
                        Tagclass._System.___hTotalFunc2LLO)
                     (= (TagFamily (Tclass._System.___hTotalFunc2LLO
                                     |#$T0@@242|
                                     |#$T1@@178|
                                     |#$R@@268|))
                        |tytagFamily$_#TotalFunc2LLO|))))
       (=> (and (= (type |#$T0@@242|) TyType)
                (= (type |#$T1@@178|) TyType)
                (= (type |#$R@@268|) TyType))
           a!1))
     :pattern ((Tclass._System.___hTotalFunc2LLO
                 |#$T0@@242|
                 |#$T1@@178|
                 |#$R@@268|))
     :skolemid |1208|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@340 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LLO_0 arg0@@340)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2LLO_0 arg0@@340))
     :qid |funType:Tclass._System.___hTotalFunc2LLO_0|)))
(assert (forall ((|#$T0@@243| T@U) (|#$T1@@179| T@U) (|#$R@@269| T@U))
  (! (=> (and (= (type |#$T0@@243|) TyType)
              (= (type |#$T1@@179|) TyType)
              (= (type |#$R@@269|) TyType))
         (= (Tclass._System.___hTotalFunc2LLO_0
              (Tclass._System.___hTotalFunc2LLO
                |#$T0@@243|
                |#$T1@@179|
                |#$R@@269|))
            |#$T0@@243|))
     :pattern ((Tclass._System.___hTotalFunc2LLO
                 |#$T0@@243|
                 |#$T1@@179|
                 |#$R@@269|))
     :skolemid |1209|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@341 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LLO_1 arg0@@341)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2LLO_1 arg0@@341))
     :qid |funType:Tclass._System.___hTotalFunc2LLO_1|)))
(assert (forall ((|#$T0@@244| T@U) (|#$T1@@180| T@U) (|#$R@@270| T@U))
  (! (=> (and (= (type |#$T0@@244|) TyType)
              (= (type |#$T1@@180|) TyType)
              (= (type |#$R@@270|) TyType))
         (= (Tclass._System.___hTotalFunc2LLO_1
              (Tclass._System.___hTotalFunc2LLO
                |#$T0@@244|
                |#$T1@@180|
                |#$R@@270|))
            |#$T1@@180|))
     :pattern ((Tclass._System.___hTotalFunc2LLO
                 |#$T0@@244|
                 |#$T1@@180|
                 |#$R@@270|))
     :skolemid |1210|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@342 T@U))
  (! (= (type (Tclass._System.___hTotalFunc2LLO_2 arg0@@342)) TyType)
     :pattern ((Tclass._System.___hTotalFunc2LLO_2 arg0@@342))
     :qid |funType:Tclass._System.___hTotalFunc2LLO_2|)))
(assert (forall ((|#$T0@@245| T@U) (|#$T1@@181| T@U) (|#$R@@271| T@U))
  (! (=> (and (= (type |#$T0@@245|) TyType)
              (= (type |#$T1@@181|) TyType)
              (= (type |#$R@@271|) TyType))
         (= (Tclass._System.___hTotalFunc2LLO_2
              (Tclass._System.___hTotalFunc2LLO
                |#$T0@@245|
                |#$T1@@181|
                |#$R@@271|))
            |#$R@@271|))
     :pattern ((Tclass._System.___hTotalFunc2LLO
                 |#$T0@@245|
                 |#$T1@@181|
                 |#$R@@271|))
     :skolemid |1211|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@246| T@U) (|#$T1@@182| T@U) (|#$R@@272| T@U) (bx@@99 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@99)) bx@@99)
                     ($Is ($Unbox HandleTypeType bx@@99)
                          (Tclass._System.___hTotalFunc2LLO
                            |#$T0@@246|
                            |#$T1@@182|
                            |#$R@@272|)))))
       (=> (and (= (type |#$T0@@246|) TyType)
                (= (type |#$T1@@182|) TyType)
                (= (type |#$R@@272|) TyType)
                (= (type bx@@99) BoxType)
                ($IsBox bx@@99
                        (Tclass._System.___hTotalFunc2LLO
                          |#$T0@@246|
                          |#$T1@@182|
                          |#$R@@272|)))
           a!1))
     :pattern (($IsBox bx@@99
                       (Tclass._System.___hTotalFunc2LLO
                         |#$T0@@246|
                         |#$T1@@182|
                         |#$R@@272|)))
     :skolemid |1212|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@247| T@U) (|#$T1@@183| T@U) (|#$R@@273| T@U) (|f#0@@57| T@U))
  (! (let ((a!1 (forall ((|x0#0@@24| T@U) (|x1#0@@16| T@U))
                  (! (=> (and (= (type |x0#0@@24|) BoxType)
                              (= (type |x1#0@@16|) BoxType)
                              ($IsBox |x0#0@@24| |#$T0@@247|)
                              ($IsBox |x1#0@@16| |#$T1@@183|))
                         (Requires2 |#$T0@@247|
                                    |#$T1@@183|
                                    |#$R@@273|
                                    $OneHeap
                                    |f#0@@57|
                                    |x0#0@@24|
                                    |x1#0@@16|))
                     :no-pattern (type |x0#0@@24|)
                     :no-pattern (type |x1#0@@16|)
                     :no-pattern (U_2_int |x0#0@@24|)
                     :no-pattern (U_2_bool |x0#0@@24|)
                     :no-pattern (U_2_int |x1#0@@16|)
                     :no-pattern (U_2_bool |x1#0@@16|)
                     :skolemid |1213|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@57|
                        (Tclass._System.___hTotalFunc2LLO
                          |#$T0@@247|
                          |#$T1@@183|
                          |#$R@@273|))
                   (and ($Is |f#0@@57|
                             (Tclass._System.___hPartialFunc2LLO
                               |#$T0@@247|
                               |#$T1@@183|
                               |#$R@@273|))
                        a!1))))
       (=> (and (= (type |#$T0@@247|) TyType)
                (= (type |#$T1@@183|) TyType)
                (= (type |#$R@@273|) TyType)
                (= (type |f#0@@57|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@57|
                    (Tclass._System.___hTotalFunc2LLO
                      |#$T0@@247|
                      |#$T1@@183|
                      |#$R@@273|)))
     :skolemid |1214|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@248| T@U)
         (|#$T1@@184| T@U)
         (|#$R@@274| T@U)
         (|f#0@@58| T@U)
         ($h@@44 T@U))
  (! (=> (and (= (type |#$T0@@248|) TyType)
              (= (type |#$T1@@184|) TyType)
              (= (type |#$R@@274|) TyType)
              (= (type |f#0@@58|) HandleTypeType)
              (= (type $h@@44) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@58|
                      (Tclass._System.___hTotalFunc2LLO
                        |#$T0@@248|
                        |#$T1@@184|
                        |#$R@@274|)
                      $h@@44)
            ($IsAlloc |f#0@@58|
                      (Tclass._System.___hPartialFunc2LLO
                        |#$T0@@248|
                        |#$T1@@184|
                        |#$R@@274|)
                      $h@@44)))
     :pattern (($IsAlloc |f#0@@58|
                         (Tclass._System.___hTotalFunc2LLO
                           |#$T0@@248|
                           |#$T1@@184|
                           |#$R@@274|)
                         $h@@44))
     :skolemid |1215|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@343 T@U) (arg1@@138 T@U))
  (! (= (type (Tclass._System.___hFunc1SS arg0@@343 arg1@@138)) TyType)
     :pattern ((Tclass._System.___hFunc1SS arg0@@343 arg1@@138))
     :qid |funType:Tclass._System.___hFunc1SS|)))
(assert (forall ((|#$T0@@249| T@U) (|#$R@@275| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|))
                        Tagclass._System.___hFunc1SS)
                     (= (TagFamily (Tclass._System.___hFunc1SS
                                     |#$T0@@249|
                                     |#$R@@275|))
                        |tytagFamily$_#Func1SS|))))
       (=> (and (= (type |#$T0@@249|) TyType) (= (type |#$R@@275|) TyType)) a!1))
     :pattern ((Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|))
     :skolemid |1216|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@344 T@U))
  (! (= (type (Tclass._System.___hFunc1SS_0 arg0@@344)) TyType)
     :pattern ((Tclass._System.___hFunc1SS_0 arg0@@344))
     :qid |funType:Tclass._System.___hFunc1SS_0|)))
(assert (forall ((|#$T0@@250| T@U) (|#$R@@276| T@U))
  (! (=> (and (= (type |#$T0@@250|) TyType) (= (type |#$R@@276|) TyType))
         (= (Tclass._System.___hFunc1SS_0
              (Tclass._System.___hFunc1SS |#$T0@@250| |#$R@@276|))
            |#$T0@@250|))
     :pattern ((Tclass._System.___hFunc1SS |#$T0@@250| |#$R@@276|))
     :skolemid |1217|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@345 T@U))
  (! (= (type (Tclass._System.___hFunc1SS_1 arg0@@345)) TyType)
     :pattern ((Tclass._System.___hFunc1SS_1 arg0@@345))
     :qid |funType:Tclass._System.___hFunc1SS_1|)))
(assert (forall ((|#$T0@@251| T@U) (|#$R@@277| T@U))
  (! (=> (and (= (type |#$T0@@251|) TyType) (= (type |#$R@@277|) TyType))
         (= (Tclass._System.___hFunc1SS_1
              (Tclass._System.___hFunc1SS |#$T0@@251| |#$R@@277|))
            |#$R@@277|))
     :pattern ((Tclass._System.___hFunc1SS |#$T0@@251| |#$R@@277|))
     :skolemid |1218|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@252| T@U) (|#$R@@278| T@U) (bx@@100 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@100)) bx@@100)
                     ($Is ($Unbox HandleTypeType bx@@100)
                          (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|)))))
       (=> (and (= (type |#$T0@@252|) TyType)
                (= (type |#$R@@278|) TyType)
                (= (type bx@@100) BoxType)
                ($IsBox bx@@100
                        (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|)))
           a!1))
     :pattern (($IsBox bx@@100
                       (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|)))
     :skolemid |1219|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@346 T@U) (arg1@@139 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1SS arg0@@346 arg1@@139)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1SS arg0@@346 arg1@@139))
     :qid |funType:Tclass._System.___hPartialFunc1SS|)))
(assert (forall ((|#$T0@@253| T@U) (|#$R@@279| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc1SS
                               |#$T0@@253|
                               |#$R@@279|))
                        Tagclass._System.___hPartialFunc1SS)
                     (= (TagFamily (Tclass._System.___hPartialFunc1SS
                                     |#$T0@@253|
                                     |#$R@@279|))
                        |tytagFamily$_#PartialFunc1SS|))))
       (=> (and (= (type |#$T0@@253|) TyType) (= (type |#$R@@279|) TyType)) a!1))
     :pattern ((Tclass._System.___hPartialFunc1SS |#$T0@@253| |#$R@@279|))
     :skolemid |1220|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@347 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1SS_0 arg0@@347)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1SS_0 arg0@@347))
     :qid |funType:Tclass._System.___hPartialFunc1SS_0|)))
(assert (forall ((|#$T0@@254| T@U) (|#$R@@280| T@U))
  (! (=> (and (= (type |#$T0@@254|) TyType) (= (type |#$R@@280|) TyType))
         (= (Tclass._System.___hPartialFunc1SS_0
              (Tclass._System.___hPartialFunc1SS |#$T0@@254| |#$R@@280|))
            |#$T0@@254|))
     :pattern ((Tclass._System.___hPartialFunc1SS |#$T0@@254| |#$R@@280|))
     :skolemid |1221|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@348 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1SS_1 arg0@@348)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1SS_1 arg0@@348))
     :qid |funType:Tclass._System.___hPartialFunc1SS_1|)))
(assert (forall ((|#$T0@@255| T@U) (|#$R@@281| T@U))
  (! (=> (and (= (type |#$T0@@255|) TyType) (= (type |#$R@@281|) TyType))
         (= (Tclass._System.___hPartialFunc1SS_1
              (Tclass._System.___hPartialFunc1SS |#$T0@@255| |#$R@@281|))
            |#$R@@281|))
     :pattern ((Tclass._System.___hPartialFunc1SS |#$T0@@255| |#$R@@281|))
     :skolemid |1222|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@256| T@U) (|#$R@@282| T@U) (bx@@101 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@101)) bx@@101)
                     ($Is ($Unbox HandleTypeType bx@@101)
                          (Tclass._System.___hPartialFunc1SS
                            |#$T0@@256|
                            |#$R@@282|)))))
       (=> (and (= (type |#$T0@@256|) TyType)
                (= (type |#$R@@282|) TyType)
                (= (type bx@@101) BoxType)
                ($IsBox bx@@101
                        (Tclass._System.___hPartialFunc1SS
                          |#$T0@@256|
                          |#$R@@282|)))
           a!1))
     :pattern (($IsBox bx@@101
                       (Tclass._System.___hPartialFunc1SS
                         |#$T0@@256|
                         |#$R@@282|)))
     :skolemid |1223|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@257| T@U) (|#$R@@283| T@U) (|f#0@@59| T@U))
  (! (let ((a!1 (forall ((|x0#0@@25| T@U))
                  (! (=> (and (= (type |x0#0@@25|) BoxType)
                              ($IsBox |x0#0@@25| |#$T0@@257|))
                         (|Set#Equal| (Reads1 |#$T0@@257|
                                              |#$R@@283|
                                              $OneHeap
                                              |f#0@@59|
                                              |x0#0@@25|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@25|)
                     :no-pattern (U_2_int |x0#0@@25|)
                     :no-pattern (U_2_bool |x0#0@@25|)
                     :skolemid |1224|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@59|
                        (Tclass._System.___hPartialFunc1SS
                          |#$T0@@257|
                          |#$R@@283|))
                   (and ($Is |f#0@@59|
                             (Tclass._System.___hFunc1SS |#$T0@@257| |#$R@@283|))
                        a!1))))
       (=> (and (= (type |#$T0@@257|) TyType)
                (= (type |#$R@@283|) TyType)
                (= (type |f#0@@59|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@59|
                    (Tclass._System.___hPartialFunc1SS |#$T0@@257| |#$R@@283|)))
     :skolemid |1225|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@258| T@U) (|#$R@@284| T@U) (|f#0@@60| T@U) ($h@@45 T@U))
  (! (=> (and (= (type |#$T0@@258|) TyType)
              (= (type |#$R@@284|) TyType)
              (= (type |f#0@@60|) HandleTypeType)
              (= (type $h@@45) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@60|
                      (Tclass._System.___hPartialFunc1SS |#$T0@@258| |#$R@@284|)
                      $h@@45)
            ($IsAlloc |f#0@@60|
                      (Tclass._System.___hFunc1SS |#$T0@@258| |#$R@@284|)
                      $h@@45)))
     :pattern (($IsAlloc |f#0@@60|
                         (Tclass._System.___hPartialFunc1SS
                           |#$T0@@258|
                           |#$R@@284|)
                         $h@@45))
     :skolemid |1226|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@349 T@U) (arg1@@140 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1SS arg0@@349 arg1@@140)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1SS arg0@@349 arg1@@140))
     :qid |funType:Tclass._System.___hTotalFunc1SS|)))
(assert (forall ((|#$T0@@259| T@U) (|#$R@@285| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc1SS
                               |#$T0@@259|
                               |#$R@@285|))
                        Tagclass._System.___hTotalFunc1SS)
                     (= (TagFamily (Tclass._System.___hTotalFunc1SS
                                     |#$T0@@259|
                                     |#$R@@285|))
                        |tytagFamily$_#TotalFunc1SS|))))
       (=> (and (= (type |#$T0@@259|) TyType) (= (type |#$R@@285|) TyType)) a!1))
     :pattern ((Tclass._System.___hTotalFunc1SS |#$T0@@259| |#$R@@285|))
     :skolemid |1227|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@350 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1SS_0 arg0@@350)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1SS_0 arg0@@350))
     :qid |funType:Tclass._System.___hTotalFunc1SS_0|)))
(assert (forall ((|#$T0@@260| T@U) (|#$R@@286| T@U))
  (! (=> (and (= (type |#$T0@@260|) TyType) (= (type |#$R@@286|) TyType))
         (= (Tclass._System.___hTotalFunc1SS_0
              (Tclass._System.___hTotalFunc1SS |#$T0@@260| |#$R@@286|))
            |#$T0@@260|))
     :pattern ((Tclass._System.___hTotalFunc1SS |#$T0@@260| |#$R@@286|))
     :skolemid |1228|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@351 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1SS_1 arg0@@351)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1SS_1 arg0@@351))
     :qid |funType:Tclass._System.___hTotalFunc1SS_1|)))
(assert (forall ((|#$T0@@261| T@U) (|#$R@@287| T@U))
  (! (=> (and (= (type |#$T0@@261|) TyType) (= (type |#$R@@287|) TyType))
         (= (Tclass._System.___hTotalFunc1SS_1
              (Tclass._System.___hTotalFunc1SS |#$T0@@261| |#$R@@287|))
            |#$R@@287|))
     :pattern ((Tclass._System.___hTotalFunc1SS |#$T0@@261| |#$R@@287|))
     :skolemid |1229|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@262| T@U) (|#$R@@288| T@U) (bx@@102 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@102)) bx@@102)
                     ($Is ($Unbox HandleTypeType bx@@102)
                          (Tclass._System.___hTotalFunc1SS
                            |#$T0@@262|
                            |#$R@@288|)))))
       (=> (and (= (type |#$T0@@262|) TyType)
                (= (type |#$R@@288|) TyType)
                (= (type bx@@102) BoxType)
                ($IsBox bx@@102
                        (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|)))
           a!1))
     :pattern (($IsBox bx@@102
                       (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|)))
     :skolemid |1230|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@263| T@U) (|#$R@@289| T@U) (|f#0@@61| T@U))
  (! (let ((a!1 (forall ((|x0#0@@26| T@U))
                  (! (=> (and (= (type |x0#0@@26|) BoxType)
                              ($IsBox |x0#0@@26| |#$T0@@263|))
                         (Requires1 |#$T0@@263|
                                    |#$R@@289|
                                    $OneHeap
                                    |f#0@@61|
                                    |x0#0@@26|))
                     :no-pattern (type |x0#0@@26|)
                     :no-pattern (U_2_int |x0#0@@26|)
                     :no-pattern (U_2_bool |x0#0@@26|)
                     :skolemid |1231|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@61|
                        (Tclass._System.___hTotalFunc1SS |#$T0@@263| |#$R@@289|))
                   (and ($Is |f#0@@61|
                             (Tclass._System.___hPartialFunc1SS
                               |#$T0@@263|
                               |#$R@@289|))
                        a!1))))
       (=> (and (= (type |#$T0@@263|) TyType)
                (= (type |#$R@@289|) TyType)
                (= (type |f#0@@61|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@61|
                    (Tclass._System.___hTotalFunc1SS |#$T0@@263| |#$R@@289|)))
     :skolemid |1232|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@264| T@U) (|#$R@@290| T@U) (|f#0@@62| T@U) ($h@@46 T@U))
  (! (=> (and (= (type |#$T0@@264|) TyType)
              (= (type |#$R@@290|) TyType)
              (= (type |f#0@@62|) HandleTypeType)
              (= (type $h@@46) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@62|
                      (Tclass._System.___hTotalFunc1SS |#$T0@@264| |#$R@@290|)
                      $h@@46)
            ($IsAlloc |f#0@@62|
                      (Tclass._System.___hPartialFunc1SS |#$T0@@264| |#$R@@290|)
                      $h@@46)))
     :pattern (($IsAlloc |f#0@@62|
                         (Tclass._System.___hTotalFunc1SS
                           |#$T0@@264|
                           |#$R@@290|)
                         $h@@46))
     :skolemid |1233|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@352 T@U) (arg1@@141 T@U))
  (! (= (type (Tclass._System.___hFunc1LL arg0@@352 arg1@@141)) TyType)
     :pattern ((Tclass._System.___hFunc1LL arg0@@352 arg1@@141))
     :qid |funType:Tclass._System.___hFunc1LL|)))
(assert (forall ((|#$T0@@265| T@U) (|#$R@@291| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|))
                        Tagclass._System.___hFunc1LL)
                     (= (TagFamily (Tclass._System.___hFunc1LL
                                     |#$T0@@265|
                                     |#$R@@291|))
                        |tytagFamily$_#Func1LL|))))
       (=> (and (= (type |#$T0@@265|) TyType) (= (type |#$R@@291|) TyType)) a!1))
     :pattern ((Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|))
     :skolemid |1234|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@353 T@U))
  (! (= (type (Tclass._System.___hFunc1LL_0 arg0@@353)) TyType)
     :pattern ((Tclass._System.___hFunc1LL_0 arg0@@353))
     :qid |funType:Tclass._System.___hFunc1LL_0|)))
(assert (forall ((|#$T0@@266| T@U) (|#$R@@292| T@U))
  (! (=> (and (= (type |#$T0@@266|) TyType) (= (type |#$R@@292|) TyType))
         (= (Tclass._System.___hFunc1LL_0
              (Tclass._System.___hFunc1LL |#$T0@@266| |#$R@@292|))
            |#$T0@@266|))
     :pattern ((Tclass._System.___hFunc1LL |#$T0@@266| |#$R@@292|))
     :skolemid |1235|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@354 T@U))
  (! (= (type (Tclass._System.___hFunc1LL_1 arg0@@354)) TyType)
     :pattern ((Tclass._System.___hFunc1LL_1 arg0@@354))
     :qid |funType:Tclass._System.___hFunc1LL_1|)))
(assert (forall ((|#$T0@@267| T@U) (|#$R@@293| T@U))
  (! (=> (and (= (type |#$T0@@267|) TyType) (= (type |#$R@@293|) TyType))
         (= (Tclass._System.___hFunc1LL_1
              (Tclass._System.___hFunc1LL |#$T0@@267| |#$R@@293|))
            |#$R@@293|))
     :pattern ((Tclass._System.___hFunc1LL |#$T0@@267| |#$R@@293|))
     :skolemid |1236|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@268| T@U) (|#$R@@294| T@U) (bx@@103 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@103)) bx@@103)
                     ($Is ($Unbox HandleTypeType bx@@103)
                          (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|)))))
       (=> (and (= (type |#$T0@@268|) TyType)
                (= (type |#$R@@294|) TyType)
                (= (type bx@@103) BoxType)
                ($IsBox bx@@103
                        (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|)))
           a!1))
     :pattern (($IsBox bx@@103
                       (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|)))
     :skolemid |1237|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@355 T@U) (arg1@@142 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1LL arg0@@355 arg1@@142)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1LL arg0@@355 arg1@@142))
     :qid |funType:Tclass._System.___hPartialFunc1LL|)))
(assert (forall ((|#$T0@@269| T@U) (|#$R@@295| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hPartialFunc1LL
                               |#$T0@@269|
                               |#$R@@295|))
                        Tagclass._System.___hPartialFunc1LL)
                     (= (TagFamily (Tclass._System.___hPartialFunc1LL
                                     |#$T0@@269|
                                     |#$R@@295|))
                        |tytagFamily$_#PartialFunc1LL|))))
       (=> (and (= (type |#$T0@@269|) TyType) (= (type |#$R@@295|) TyType)) a!1))
     :pattern ((Tclass._System.___hPartialFunc1LL |#$T0@@269| |#$R@@295|))
     :skolemid |1238|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@356 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1LL_0 arg0@@356)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1LL_0 arg0@@356))
     :qid |funType:Tclass._System.___hPartialFunc1LL_0|)))
(assert (forall ((|#$T0@@270| T@U) (|#$R@@296| T@U))
  (! (=> (and (= (type |#$T0@@270|) TyType) (= (type |#$R@@296|) TyType))
         (= (Tclass._System.___hPartialFunc1LL_0
              (Tclass._System.___hPartialFunc1LL |#$T0@@270| |#$R@@296|))
            |#$T0@@270|))
     :pattern ((Tclass._System.___hPartialFunc1LL |#$T0@@270| |#$R@@296|))
     :skolemid |1239|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@357 T@U))
  (! (= (type (Tclass._System.___hPartialFunc1LL_1 arg0@@357)) TyType)
     :pattern ((Tclass._System.___hPartialFunc1LL_1 arg0@@357))
     :qid |funType:Tclass._System.___hPartialFunc1LL_1|)))
(assert (forall ((|#$T0@@271| T@U) (|#$R@@297| T@U))
  (! (=> (and (= (type |#$T0@@271|) TyType) (= (type |#$R@@297|) TyType))
         (= (Tclass._System.___hPartialFunc1LL_1
              (Tclass._System.___hPartialFunc1LL |#$T0@@271| |#$R@@297|))
            |#$R@@297|))
     :pattern ((Tclass._System.___hPartialFunc1LL |#$T0@@271| |#$R@@297|))
     :skolemid |1240|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@272| T@U) (|#$R@@298| T@U) (bx@@104 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@104)) bx@@104)
                     ($Is ($Unbox HandleTypeType bx@@104)
                          (Tclass._System.___hPartialFunc1LL
                            |#$T0@@272|
                            |#$R@@298|)))))
       (=> (and (= (type |#$T0@@272|) TyType)
                (= (type |#$R@@298|) TyType)
                (= (type bx@@104) BoxType)
                ($IsBox bx@@104
                        (Tclass._System.___hPartialFunc1LL
                          |#$T0@@272|
                          |#$R@@298|)))
           a!1))
     :pattern (($IsBox bx@@104
                       (Tclass._System.___hPartialFunc1LL
                         |#$T0@@272|
                         |#$R@@298|)))
     :skolemid |1241|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@273| T@U) (|#$R@@299| T@U) (|f#0@@63| T@U))
  (! (let ((a!1 (forall ((|x0#0@@27| T@U))
                  (! (=> (and (= (type |x0#0@@27|) BoxType)
                              ($IsBox |x0#0@@27| |#$T0@@273|))
                         (|Set#Equal| (Reads1 |#$T0@@273|
                                              |#$R@@299|
                                              $OneHeap
                                              |f#0@@63|
                                              |x0#0@@27|)
                                      (|Set#Empty| BoxType)))
                     :no-pattern (type |x0#0@@27|)
                     :no-pattern (U_2_int |x0#0@@27|)
                     :no-pattern (U_2_bool |x0#0@@27|)
                     :skolemid |1242|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@63|
                        (Tclass._System.___hPartialFunc1LL
                          |#$T0@@273|
                          |#$R@@299|))
                   (and ($Is |f#0@@63|
                             (Tclass._System.___hFunc1LL |#$T0@@273| |#$R@@299|))
                        a!1))))
       (=> (and (= (type |#$T0@@273|) TyType)
                (= (type |#$R@@299|) TyType)
                (= (type |f#0@@63|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@63|
                    (Tclass._System.___hPartialFunc1LL |#$T0@@273| |#$R@@299|)))
     :skolemid |1243|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@274| T@U) (|#$R@@300| T@U) (|f#0@@64| T@U) ($h@@47 T@U))
  (! (=> (and (= (type |#$T0@@274|) TyType)
              (= (type |#$R@@300|) TyType)
              (= (type |f#0@@64|) HandleTypeType)
              (= (type $h@@47) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@64|
                      (Tclass._System.___hPartialFunc1LL |#$T0@@274| |#$R@@300|)
                      $h@@47)
            ($IsAlloc |f#0@@64|
                      (Tclass._System.___hFunc1LL |#$T0@@274| |#$R@@300|)
                      $h@@47)))
     :pattern (($IsAlloc |f#0@@64|
                         (Tclass._System.___hPartialFunc1LL
                           |#$T0@@274|
                           |#$R@@300|)
                         $h@@47))
     :skolemid |1244|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@358 T@U) (arg1@@143 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1LL arg0@@358 arg1@@143)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1LL arg0@@358 arg1@@143))
     :qid |funType:Tclass._System.___hTotalFunc1LL|)))
(assert (forall ((|#$T0@@275| T@U) (|#$R@@301| T@U))
  (! (let ((a!1 (and (= (Tag (Tclass._System.___hTotalFunc1LL
                               |#$T0@@275|
                               |#$R@@301|))
                        Tagclass._System.___hTotalFunc1LL)
                     (= (TagFamily (Tclass._System.___hTotalFunc1LL
                                     |#$T0@@275|
                                     |#$R@@301|))
                        |tytagFamily$_#TotalFunc1LL|))))
       (=> (and (= (type |#$T0@@275|) TyType) (= (type |#$R@@301|) TyType)) a!1))
     :pattern ((Tclass._System.___hTotalFunc1LL |#$T0@@275| |#$R@@301|))
     :skolemid |1245|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@359 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1LL_0 arg0@@359)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1LL_0 arg0@@359))
     :qid |funType:Tclass._System.___hTotalFunc1LL_0|)))
(assert (forall ((|#$T0@@276| T@U) (|#$R@@302| T@U))
  (! (=> (and (= (type |#$T0@@276|) TyType) (= (type |#$R@@302|) TyType))
         (= (Tclass._System.___hTotalFunc1LL_0
              (Tclass._System.___hTotalFunc1LL |#$T0@@276| |#$R@@302|))
            |#$T0@@276|))
     :pattern ((Tclass._System.___hTotalFunc1LL |#$T0@@276| |#$R@@302|))
     :skolemid |1246|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@360 T@U))
  (! (= (type (Tclass._System.___hTotalFunc1LL_1 arg0@@360)) TyType)
     :pattern ((Tclass._System.___hTotalFunc1LL_1 arg0@@360))
     :qid |funType:Tclass._System.___hTotalFunc1LL_1|)))
(assert (forall ((|#$T0@@277| T@U) (|#$R@@303| T@U))
  (! (=> (and (= (type |#$T0@@277|) TyType) (= (type |#$R@@303|) TyType))
         (= (Tclass._System.___hTotalFunc1LL_1
              (Tclass._System.___hTotalFunc1LL |#$T0@@277| |#$R@@303|))
            |#$R@@303|))
     :pattern ((Tclass._System.___hTotalFunc1LL |#$T0@@277| |#$R@@303|))
     :skolemid |1247|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@278| T@U) (|#$R@@304| T@U) (bx@@105 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox HandleTypeType bx@@105)) bx@@105)
                     ($Is ($Unbox HandleTypeType bx@@105)
                          (Tclass._System.___hTotalFunc1LL
                            |#$T0@@278|
                            |#$R@@304|)))))
       (=> (and (= (type |#$T0@@278|) TyType)
                (= (type |#$R@@304|) TyType)
                (= (type bx@@105) BoxType)
                ($IsBox bx@@105
                        (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|)))
           a!1))
     :pattern (($IsBox bx@@105
                       (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|)))
     :skolemid |1248|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@279| T@U) (|#$R@@305| T@U) (|f#0@@65| T@U))
  (! (let ((a!1 (forall ((|x0#0@@28| T@U))
                  (! (=> (and (= (type |x0#0@@28|) BoxType)
                              ($IsBox |x0#0@@28| |#$T0@@279|))
                         (Requires1 |#$T0@@279|
                                    |#$R@@305|
                                    $OneHeap
                                    |f#0@@65|
                                    |x0#0@@28|))
                     :no-pattern (type |x0#0@@28|)
                     :no-pattern (U_2_int |x0#0@@28|)
                     :no-pattern (U_2_bool |x0#0@@28|)
                     :skolemid |1249|
                     :qid |unknown.0:0|))))
     (let ((a!2 (= ($Is |f#0@@65|
                        (Tclass._System.___hTotalFunc1LL |#$T0@@279| |#$R@@305|))
                   (and ($Is |f#0@@65|
                             (Tclass._System.___hPartialFunc1LL
                               |#$T0@@279|
                               |#$R@@305|))
                        a!1))))
       (=> (and (= (type |#$T0@@279|) TyType)
                (= (type |#$R@@305|) TyType)
                (= (type |f#0@@65|) HandleTypeType))
           a!2)))
     :pattern (($Is |f#0@@65|
                    (Tclass._System.___hTotalFunc1LL |#$T0@@279| |#$R@@305|)))
     :skolemid |1250|
     :qid |unknown.0:0|)))
(assert (forall ((|#$T0@@280| T@U) (|#$R@@306| T@U) (|f#0@@66| T@U) ($h@@48 T@U))
  (! (=> (and (= (type |#$T0@@280|) TyType)
              (= (type |#$R@@306|) TyType)
              (= (type |f#0@@66|) HandleTypeType)
              (= (type $h@@48) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |f#0@@66|
                      (Tclass._System.___hTotalFunc1LL |#$T0@@280| |#$R@@306|)
                      $h@@48)
            ($IsAlloc |f#0@@66|
                      (Tclass._System.___hPartialFunc1LL |#$T0@@280| |#$R@@306|)
                      $h@@48)))
     :pattern (($IsAlloc |f#0@@66|
                         (Tclass._System.___hTotalFunc1LL
                           |#$T0@@280|
                           |#$R@@306|)
                         $h@@48))
     :skolemid |1251|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.PagedBetreeRefinement.__default) TyType))
(assert (= (Tag Tclass.PagedBetreeRefinement.__default)
   Tagclass.PagedBetreeRefinement.__default))
(assert (= (TagFamily Tclass.PagedBetreeRefinement.__default) tytagFamily$_default))
(assert (forall ((bx@@106 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@106)) bx@@106)
                     ($Is ($Unbox refType bx@@106)
                          Tclass.PagedBetreeRefinement.__default))))
       (=> (and (= (type bx@@106) BoxType)
                ($IsBox bx@@106 Tclass.PagedBetreeRefinement.__default))
           a!1))
     :pattern (($IsBox bx@@106 Tclass.PagedBetreeRefinement.__default))
     :skolemid |1252|
     :qid |unknown.0:0|)))
(assert (forall (($o@@9 T@U))
  (! (let ((a!1 (= ($Is $o@@9 Tclass.PagedBetreeRefinement.__default)
                   (or (= $o@@9 null)
                       (= (dtype $o@@9) Tclass.PagedBetreeRefinement.__default)))))
       (=> (= (type $o@@9) refType) a!1))
     :pattern (($Is $o@@9 Tclass.PagedBetreeRefinement.__default))
     :skolemid |1253|
     :qid |unknown.0:0|)))
(assert (forall (($o@@10 T@U) ($h@@49 T@U))
  (! (let ((a!1 (or (= $o@@10 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@49 $o@@10)
                                              alloc)))))
       (=> (and (= (type $o@@10) refType)
                (= (type $h@@49) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@10 Tclass.PagedBetreeRefinement.__default $h@@49)
              a!1)))
     :pattern (($IsAlloc $o@@10 Tclass.PagedBetreeRefinement.__default $h@@49))
     :skolemid |1254|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@361 T@U) (arg1@@144 T@U) (arg2@@79 T@U))
  (! (= (type (PagedBetreeRefinement.__default.BuildQueryReceipt
                arg0@@361
                arg1@@144
                arg2@@79))
        DatatypeTypeType)
     :pattern ((PagedBetreeRefinement.__default.BuildQueryReceipt
                 arg0@@361
                 arg1@@144
                 arg2@@79))
     :qid |funType:PagedBetreeRefinement.__default.BuildQueryReceipt|)))
(assert (forall (($ly T@U) (|node#0| T@U) (|key#0| T@U))
  (! (=> (and (= (type $ly) LayerTypeType)
              (= (type |node#0|) DatatypeTypeType)
              (= (type |key#0|) (SeqType BoxType)))
         (= (PagedBetreeRefinement.__default.BuildQueryReceipt
              ($LS $ly)
              |node#0|
              |key#0|)
            (PagedBetreeRefinement.__default.BuildQueryReceipt
              $ly
              |node#0|
              |key#0|)))
     :pattern ((PagedBetreeRefinement.__default.BuildQueryReceipt
                 ($LS $ly)
                 |node#0|
                 |key#0|))
     :skolemid |1255|
     :qid |PagedBetreeRefinementidfy.23:12|)))
(assert (let ((a!1 (forall ((arg0@@362 T@U))
             (! (= (type (AsFuelBottom arg0@@362)) LayerTypeType)
                :pattern ((AsFuelBottom arg0@@362))
                :qid |funType:AsFuelBottom|))))
  (and a!1 (= (type $LZ) LayerTypeType))))
(assert (forall (($ly@@0 T@U) (|node#0@@0| T@U) (|key#0@@0| T@U))
  (! (=> (and (= (type $ly@@0) LayerTypeType)
              (= (type |node#0@@0|) DatatypeTypeType)
              (= (type |key#0@@0|) (SeqType BoxType)))
         (= (PagedBetreeRefinement.__default.BuildQueryReceipt
              $ly@@0
              |node#0@@0|
              |key#0@@0|)
            (PagedBetreeRefinement.__default.BuildQueryReceipt
              $LZ
              |node#0@@0|
              |key#0@@0|)))
     :pattern ((PagedBetreeRefinement.__default.BuildQueryReceipt
                 (AsFuelBottom $ly@@0)
                 |node#0@@0|
                 |key#0@@0|))
     :skolemid |1256|
     :qid |PagedBetreeRefinementidfy.23:12|)))
(assert (= (type Tclass.PagedBetree.BetreeNode) TyType))
(assert (= (Tag Tclass.PagedBetree.BetreeNode) Tagclass.PagedBetree.BetreeNode))
(assert (= (TagFamily Tclass.PagedBetree.BetreeNode) tytagFamily$BetreeNode))
(assert (forall ((bx@@107 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@107)) bx@@107)
                     ($Is ($Unbox DatatypeTypeType bx@@107)
                          Tclass.PagedBetree.BetreeNode))))
       (=> (and (= (type bx@@107) BoxType)
                ($IsBox bx@@107 Tclass.PagedBetree.BetreeNode))
           a!1))
     :pattern (($IsBox bx@@107 Tclass.PagedBetree.BetreeNode))
     :skolemid |1257|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.KeyType.Key) TyType))
(assert (= (Tag Tclass.KeyType.Key) Tagclass.KeyType.Key))
(assert (= (TagFamily Tclass.KeyType.Key) tytagFamily$Key))
(assert (forall ((bx@@108 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (SeqType BoxType) bx@@108)) bx@@108)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (SeqType BoxType) bx@@108) Tclass.KeyType.Key))))
       (=> (and (= (type bx@@108) BoxType) ($IsBox bx@@108 Tclass.KeyType.Key))
           a!2)))
     :pattern (($IsBox bx@@108 Tclass.KeyType.Key))
     :skolemid |1258|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.PagedBetree.QueryReceipt) TyType))
(assert (= (Tag Tclass.PagedBetree.QueryReceipt) Tagclass.PagedBetree.QueryReceipt))
(assert (= (TagFamily Tclass.PagedBetree.QueryReceipt) tytagFamily$QueryReceipt))
(assert (forall ((bx@@109 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@109)) bx@@109)
                     ($Is ($Unbox DatatypeTypeType bx@@109)
                          Tclass.PagedBetree.QueryReceipt))))
       (=> (and (= (type bx@@109) BoxType)
                ($IsBox bx@@109 Tclass.PagedBetree.QueryReceipt))
           a!1))
     :pattern (($IsBox bx@@109 Tclass.PagedBetree.QueryReceipt))
     :skolemid |1259|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@363 T@U))
  (! (= (type (PagedBetree.QueryReceipt.key arg0@@363)) (SeqType BoxType))
     :pattern ((PagedBetree.QueryReceipt.key arg0@@363))
     :qid |funType:PagedBetree.QueryReceipt.key|)))
(assert (let ((a!1 (forall (($ly@@1 T@U) (|node#0@@1| T@U) (|key#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                 |node#0@@1|
                                 |key#0@@1|)
                               (and (not (= 3 $FunctionContextHeight))
                                    ($Is |node#0@@1|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@1| Tclass.KeyType.Key)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |node#0@@1|))))
                      (a!2 (and (|Seq#Equal| (PagedBetree.QueryReceipt.key
                                               (PagedBetreeRefinement.__default.BuildQueryReceipt
                                                 $ly@@1
                                                 |node#0@@1|
                                                 |key#0@@1|))
                                             |key#0@@1|)
                                (PagedBetree.QueryReceipt.Valid
                                  (PagedBetreeRefinement.__default.BuildQueryReceipt
                                    $ly@@1
                                    |node#0@@1|
                                    |key#0@@1|))
                                ($Is (PagedBetreeRefinement.__default.BuildQueryReceipt
                                       $ly@@1
                                       |node#0@@1|
                                       |key#0@@1|)
                                     Tclass.PagedBetree.QueryReceipt))))
                  (=> (and (= (type $ly@@1) LayerTypeType)
                           (= (type |node#0@@1|) DatatypeTypeType)
                           (= (type |key#0@@1|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((PagedBetreeRefinement.__default.BuildQueryReceipt
                            $ly@@1
                            |node#0@@1|
                            |key#0@@1|))
                :skolemid |1260|
                :qid |PagedBetreeRefinementidfy.23:12|))))
  (=> (<= 3 $FunctionContextHeight) a!1)))
(assert (forall (($ly@@2 T@U) (|node#0@@2| T@U) (|key#0@@2| T@U))
  (! (=> (and (= (type $ly@@2) LayerTypeType)
              (= (type |node#0@@2|) DatatypeTypeType)
              (= (type |key#0@@2|) (SeqType BoxType))
              ($Is |node#0@@2| Tclass.PagedBetree.BetreeNode)
              ($Is |key#0@@2| Tclass.KeyType.Key))
         (= (|PagedBetreeRefinement.__default.BuildQueryReceipt#requires|
              $ly@@2
              |node#0@@2|
              |key#0@@2|)
            (PagedBetree.BetreeNode.WF ($LS $LZ) |node#0@@2|)))
     :pattern ((|PagedBetreeRefinement.__default.BuildQueryReceipt#requires|
                 $ly@@2
                 |node#0@@2|
                 |key#0@@2|))
     :skolemid |1261|
     :qid |PagedBetreeRefinementidfy.23:12|)))
(assert (let ((a!1 (forall ((arg0@@364 T@U))
             (! (= (type (PagedBetree.BetreeNode.children arg0@@364))
                   DatatypeTypeType)
                :pattern ((PagedBetree.BetreeNode.children arg0@@364))
                :qid |funType:PagedBetree.BetreeNode.children|)))
      (a!2 (forall ((arg0@@365 T@U))
             (! (= (type (PagedBetree.ChildMap.mapp arg0@@365))
                   (IMapType BoxType BoxType))
                :pattern ((PagedBetree.ChildMap.mapp arg0@@365))
                :qid |funType:PagedBetree.ChildMap.mapp|)))
      (a!3 (forall ((arg0@@366 T@U))
             (! (= (type (PagedBetree.BetreeNode.buffers arg0@@366))
                   DatatypeTypeType)
                :pattern ((PagedBetree.BetreeNode.buffers arg0@@366))
                :qid |funType:PagedBetree.BetreeNode.buffers|)))
      (a!4 (forall ((arg0@@367 T@U) (arg1@@145 T@U))
             (! (= (type (Buffers.BufferStack.Query arg0@@367 arg1@@145))
                   DatatypeTypeType)
                :pattern ((Buffers.BufferStack.Query arg0@@367 arg1@@145))
                :qid |funType:Buffers.BufferStack.Query|)))
      (a!5 (forall ((arg0@@368 T@U))
             (! (= (type (PagedBetree.QueryReceipt.Result arg0@@368))
                   DatatypeTypeType)
                :pattern ((PagedBetree.QueryReceipt.Result arg0@@368))
                :qid |funType:PagedBetree.QueryReceipt.Result|)))
      (a!6 (forall ((arg0@@369 T@U) (arg1@@146 T@U) (arg2@@80 T@U))
             (! (= (type (|#PagedBetree.QueryReceipt.QueryReceipt|
                           arg0@@369
                           arg1@@146
                           arg2@@80))
                   DatatypeTypeType)
                :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                            arg0@@369
                            arg1@@146
                            arg2@@80))
                :qid |funType:#PagedBetree.QueryReceipt.QueryReceipt|)))
      (a!7 (forall ((arg0@@370 T@U) (arg1@@147 T@U))
             (! (= (type (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                           arg0@@370
                           arg1@@147))
                   DatatypeTypeType)
                :pattern ((|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                            arg0@@370
                            arg1@@147))
                :qid |funType:#PagedBetree.QueryReceiptLine.QueryReceiptLine|)))
      (a!8 (forall ((arg0@@371 T@U))
             (! (= (type (|#ValueMessage.Message.Define| arg0@@371))
                   DatatypeTypeType)
                :pattern ((|#ValueMessage.Message.Define| arg0@@371))
                :qid |funType:#ValueMessage.Message.Define|)))
      (a!9 (forall ((arg0@@372 T@U) (arg1@@148 T@U))
             (! (= (type (ValueMessage.__default.Merge arg0@@372 arg1@@148))
                   DatatypeTypeType)
                :pattern ((ValueMessage.__default.Merge arg0@@372 arg1@@148))
                :qid |funType:ValueMessage.__default.Merge|)))
      (a!10 (forall ((arg0@@373 T@U))
              (! (= (type (PagedBetree.QueryReceipt.lines arg0@@373))
                    (SeqType BoxType))
                 :pattern ((PagedBetree.QueryReceipt.lines arg0@@373))
                 :qid |funType:PagedBetree.QueryReceipt.lines|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       (= (type |#PagedBetree.BetreeNode.Nil|) DatatypeTypeType)
       a!8
       (= (type ValueMessage.__default.DefaultValue) (SeqType BoxType))
       a!9
       a!10)))
(assert (let ((a!1 (forall (($ly@@3 T@U) (|node#0@@3| T@U) (|key#0@@3| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                 |node#0@@3|
                                 |key#0@@3|)
                               (and (not (= 3 $FunctionContextHeight))
                                    ($Is |node#0@@3|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@3| Tclass.KeyType.Key)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |node#0@@3|))))
                      (a!2 (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                              (PagedBetree.BetreeNode.children
                                                                |node#0@@3|)))
                                           ($Box |key#0@@3|)))
                      (a!5 (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                             (Lit |#PagedBetree.BetreeNode.Nil|)
                             (Lit (|#ValueMessage.Message.Define|
                                    (Lit ValueMessage.__default.DefaultValue))))))
                (let ((a!3 (|ValueMessage.__default.Merge#canCall|
                             (Buffers.BufferStack.Query
                               (PagedBetree.BetreeNode.buffers |node#0@@3|)
                               |key#0@@3|)
                             (PagedBetree.QueryReceipt.Result
                               (PagedBetreeRefinement.__default.BuildQueryReceipt
                                 $ly@@3
                                 ($Unbox DatatypeTypeType a!2)
                                 |key#0@@3|))))
                      (a!6 (Lit (|Seq#Build| (|Seq#Empty| BoxType)
                                             ($Box (Lit a!5)))))
                      (a!7 (ValueMessage.__default.Merge
                             (Buffers.BufferStack.Query
                               (PagedBetree.BetreeNode.buffers |node#0@@3|)
                               |key#0@@3|)
                             (PagedBetree.QueryReceipt.Result
                               (PagedBetreeRefinement.__default.BuildQueryReceipt
                                 $ly@@3
                                 ($Unbox DatatypeTypeType a!2)
                                 |key#0@@3|)))))
                (let ((a!4 (and (PagedBetree.ChildMap.ChildMap_q
                                  (PagedBetree.BetreeNode.children |node#0@@3|))
                                (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                  ($Unbox DatatypeTypeType a!2)
                                  |key#0@@3|)
                                (|Buffers.BufferStack.Query#canCall|
                                  (PagedBetree.BetreeNode.buffers |node#0@@3|)
                                  |key#0@@3|)
                                (|PagedBetree.QueryReceipt.Result#canCall|
                                  (PagedBetreeRefinement.__default.BuildQueryReceipt
                                    $ly@@3
                                    ($Unbox DatatypeTypeType a!2)
                                    |key#0@@3|))
                                a!3
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (PagedBetreeRefinement.__default.BuildQueryReceipt
                                    $ly@@3
                                    ($Unbox DatatypeTypeType a!2)
                                    |key#0@@3|))))
                      (a!8 (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType)
                                                      ($Box (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                                                              |node#0@@3|
                                                              a!7)))
                                         (PagedBetree.QueryReceipt.lines
                                           (PagedBetreeRefinement.__default.BuildQueryReceipt
                                             $ly@@3
                                             ($Unbox DatatypeTypeType a!2)
                                             |key#0@@3|)))))
                (let ((a!9 (and (=> (PagedBetree.BetreeNode.Nil_q |node#0@@3|)
                                    |ValueMessage.__default.DefaultValue#canCall|)
                                (=> (not (PagedBetree.BetreeNode.Nil_q
                                           |node#0@@3|))
                                    a!4)
                                (= (PagedBetreeRefinement.__default.BuildQueryReceipt
                                     ($LS $ly@@3)
                                     |node#0@@3|
                                     |key#0@@3|)
                                   (ite (PagedBetree.BetreeNode.Nil_q
                                          |node#0@@3|)
                                        (|#PagedBetree.QueryReceipt.QueryReceipt|
                                          |key#0@@3|
                                          |node#0@@3|
                                          a!6)
                                        (|#PagedBetree.QueryReceipt.QueryReceipt|
                                          |key#0@@3|
                                          |node#0@@3|
                                          a!8))))))
                  (=> (and (= (type $ly@@3) LayerTypeType)
                           (= (type |node#0@@3|) DatatypeTypeType)
                           (= (type |key#0@@3|) (SeqType BoxType))
                           a!1)
                      a!9)))))
                :pattern ((PagedBetreeRefinement.__default.BuildQueryReceipt
                            ($LS $ly@@3)
                            |node#0@@3|
                            |key#0@@3|))
                :skolemid |1262|
                :qid |PagedBetreeRefinementidfy.23:12|))))
  (=> (<= 3 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall (($ly@@4 T@U) (|node#0@@4| T@U) (|key#0@@4| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit |node#0@@4|)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q
                                            (Lit |node#0@@4|)))))
                      (a!4 (PagedBetree.ChildMap.ChildMap_q
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit |node#0@@4|)))))
                      (a!5 (PagedBetree.ChildMap.mapp
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit |node#0@@4|)))))
                      (a!7 (|Buffers.BufferStack.Query#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |node#0@@4|)))
                             |key#0@@4|))
                      (a!8 (Buffers.BufferStack.Query
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |node#0@@4|)))
                             |key#0@@4|))
                      (a!11 (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                              (Lit |#PagedBetree.BetreeNode.Nil|)
                              (Lit (|#ValueMessage.Message.Define|
                                     (Lit ValueMessage.__default.DefaultValue))))))
                (let ((a!2 (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                 (Lit |node#0@@4|)
                                 |key#0@@4|)
                               (and (not (= 3 $FunctionContextHeight))
                                    ($Is |node#0@@4|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@4| Tclass.KeyType.Key)
                                    (U_2_bool a!1))))
                      (a!6 ($Unbox DatatypeTypeType
                                   (MapType0Select (|IMap#Elements| (Lit a!5))
                                                   ($Box |key#0@@4|))))
                      (a!12 (Lit (|Seq#Build| (|Seq#Empty| BoxType)
                                              ($Box (Lit a!11))))))
                (let ((a!9 (|ValueMessage.__default.Merge#canCall|
                             a!8
                             (PagedBetree.QueryReceipt.Result
                               (PagedBetreeRefinement.__default.BuildQueryReceipt
                                 ($LS $ly@@4)
                                 a!6
                                 |key#0@@4|))))
                      (a!13 (ValueMessage.__default.Merge
                              a!8
                              (PagedBetree.QueryReceipt.Result
                                (PagedBetreeRefinement.__default.BuildQueryReceipt
                                  ($LS $ly@@4)
                                  a!6
                                  |key#0@@4|)))))
                (let ((a!10 (and a!4
                                 (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                   a!6
                                   |key#0@@4|)
                                 a!7
                                 (|PagedBetree.QueryReceipt.Result#canCall|
                                   (PagedBetreeRefinement.__default.BuildQueryReceipt
                                     ($LS $ly@@4)
                                     a!6
                                     |key#0@@4|))
                                 a!9
                                 (PagedBetree.QueryReceipt.QueryReceipt_q
                                   (PagedBetreeRefinement.__default.BuildQueryReceipt
                                     ($LS $ly@@4)
                                     a!6
                                     |key#0@@4|))))
                      (a!14 (|Seq#Build| (|Seq#Empty| BoxType)
                                         ($Box (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                                                 (Lit |node#0@@4|)
                                                 a!13)))))
                (let ((a!15 (|Seq#Append| a!14
                                          (PagedBetree.QueryReceipt.lines
                                            (PagedBetreeRefinement.__default.BuildQueryReceipt
                                              ($LS $ly@@4)
                                              a!6
                                              |key#0@@4|)))))
                (let ((a!16 (= (PagedBetreeRefinement.__default.BuildQueryReceipt
                                 ($LS $ly@@4)
                                 (Lit |node#0@@4|)
                                 |key#0@@4|)
                               (ite (PagedBetree.BetreeNode.Nil_q
                                      (Lit |node#0@@4|))
                                    (|#PagedBetree.QueryReceipt.QueryReceipt|
                                      |key#0@@4|
                                      (Lit |node#0@@4|)
                                      a!12)
                                    (|#PagedBetree.QueryReceipt.QueryReceipt|
                                      |key#0@@4|
                                      (Lit |node#0@@4|)
                                      a!15)))))
                (let ((a!17 (and (=> (U_2_bool a!3)
                                     |ValueMessage.__default.DefaultValue#canCall|)
                                 (=> (not (U_2_bool a!3)) a!10)
                                 a!16)))
                  (=> (and (= (type $ly@@4) LayerTypeType)
                           (= (type |node#0@@4|) DatatypeTypeType)
                           (= (type |key#0@@4|) (SeqType BoxType))
                           a!2)
                      a!17))))))))
                :pattern ((PagedBetreeRefinement.__default.BuildQueryReceipt
                            ($LS $ly@@4)
                            (Lit |node#0@@4|)
                            |key#0@@4|))
                :weight 3
                :skolemid |1263|
                :qid |PagedBetreeRefinementidfy.23:12|))))
  (=> (<= 3 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall (($ly@@5 T@U) (|node#0@@5| T@U) (|key#0@@5| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit |node#0@@5|)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q
                                            (Lit |node#0@@5|)))))
                      (a!4 (PagedBetree.ChildMap.ChildMap_q
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit |node#0@@5|)))))
                      (a!5 (PagedBetree.ChildMap.mapp
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit |node#0@@5|)))))
                      (a!7 (|Buffers.BufferStack.Query#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |node#0@@5|)))
                             (Lit |key#0@@5|)))
                      (a!8 (Buffers.BufferStack.Query
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |node#0@@5|)))
                             (Lit |key#0@@5|)))
                      (a!11 (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                              (Lit |#PagedBetree.BetreeNode.Nil|)
                              (Lit (|#ValueMessage.Message.Define|
                                     (Lit ValueMessage.__default.DefaultValue))))))
                (let ((a!2 (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                 (Lit |node#0@@5|)
                                 (Lit |key#0@@5|))
                               (and (not (= 3 $FunctionContextHeight))
                                    ($Is |node#0@@5|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@5| Tclass.KeyType.Key)
                                    (U_2_bool a!1))))
                      (a!6 ($Unbox DatatypeTypeType
                                   (MapType0Select (|IMap#Elements| (Lit a!5))
                                                   ($Box (Lit |key#0@@5|)))))
                      (a!12 (Lit (|Seq#Build| (|Seq#Empty| BoxType)
                                              ($Box (Lit a!11))))))
                (let ((a!9 (|ValueMessage.__default.Merge#canCall|
                             (Lit a!8)
                             (PagedBetree.QueryReceipt.Result
                               (PagedBetreeRefinement.__default.BuildQueryReceipt
                                 ($LS $ly@@5)
                                 a!6
                                 (Lit |key#0@@5|)))))
                      (a!13 (ValueMessage.__default.Merge
                              (Lit a!8)
                              (PagedBetree.QueryReceipt.Result
                                (PagedBetreeRefinement.__default.BuildQueryReceipt
                                  ($LS $ly@@5)
                                  a!6
                                  (Lit |key#0@@5|))))))
                (let ((a!10 (and a!4
                                 (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                   a!6
                                   (Lit |key#0@@5|))
                                 a!7
                                 (|PagedBetree.QueryReceipt.Result#canCall|
                                   (PagedBetreeRefinement.__default.BuildQueryReceipt
                                     ($LS $ly@@5)
                                     a!6
                                     (Lit |key#0@@5|)))
                                 a!9
                                 (PagedBetree.QueryReceipt.QueryReceipt_q
                                   (PagedBetreeRefinement.__default.BuildQueryReceipt
                                     ($LS $ly@@5)
                                     a!6
                                     (Lit |key#0@@5|)))))
                      (a!14 (|Seq#Build| (|Seq#Empty| BoxType)
                                         ($Box (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                                                 (Lit |node#0@@5|)
                                                 a!13)))))
                (let ((a!15 (|Seq#Append| a!14
                                          (PagedBetree.QueryReceipt.lines
                                            (PagedBetreeRefinement.__default.BuildQueryReceipt
                                              ($LS $ly@@5)
                                              a!6
                                              (Lit |key#0@@5|))))))
                (let ((a!16 (= (PagedBetreeRefinement.__default.BuildQueryReceipt
                                 ($LS $ly@@5)
                                 (Lit |node#0@@5|)
                                 (Lit |key#0@@5|))
                               (ite (PagedBetree.BetreeNode.Nil_q
                                      (Lit |node#0@@5|))
                                    (|#PagedBetree.QueryReceipt.QueryReceipt|
                                      (Lit |key#0@@5|)
                                      (Lit |node#0@@5|)
                                      a!12)
                                    (|#PagedBetree.QueryReceipt.QueryReceipt|
                                      (Lit |key#0@@5|)
                                      (Lit |node#0@@5|)
                                      a!15)))))
                (let ((a!17 (and (=> (U_2_bool a!3)
                                     |ValueMessage.__default.DefaultValue#canCall|)
                                 (=> (not (U_2_bool a!3)) a!10)
                                 a!16)))
                  (=> (and (= (type $ly@@5) LayerTypeType)
                           (= (type |node#0@@5|) DatatypeTypeType)
                           (= (type |key#0@@5|) (SeqType BoxType))
                           a!2)
                      a!17))))))))
                :pattern ((PagedBetreeRefinement.__default.BuildQueryReceipt
                            ($LS $ly@@5)
                            (Lit |node#0@@5|)
                            (Lit |key#0@@5|)))
                :weight 3
                :skolemid |1264|
                :qid |PagedBetreeRefinementidfy.23:12|))))
  (=> (<= 3 $FunctionContextHeight) a!1)))
(assert (= (type Tclass.PagedBetree.ChildMap) TyType))
(assert (= (Tag Tclass.PagedBetree.ChildMap) Tagclass.PagedBetree.ChildMap))
(assert (= (TagFamily Tclass.PagedBetree.ChildMap) tytagFamily$ChildMap))
(assert (forall ((bx@@110 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@110)) bx@@110)
                     ($Is ($Unbox DatatypeTypeType bx@@110)
                          Tclass.PagedBetree.ChildMap))))
       (=> (and (= (type bx@@110) BoxType)
                ($IsBox bx@@110 Tclass.PagedBetree.ChildMap))
           a!1))
     :pattern (($IsBox bx@@110 Tclass.PagedBetree.ChildMap))
     :skolemid |1267|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.ValueMessage.Message) TyType))
(assert (= (Tag Tclass.ValueMessage.Message) Tagclass.ValueMessage.Message))
(assert (= (TagFamily Tclass.ValueMessage.Message) tytagFamily$Message))
(assert (forall ((bx@@111 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@111)) bx@@111)
                     ($Is ($Unbox DatatypeTypeType bx@@111)
                          Tclass.ValueMessage.Message))))
       (=> (and (= (type bx@@111) BoxType)
                ($IsBox bx@@111 Tclass.ValueMessage.Message))
           a!1))
     :pattern (($IsBox bx@@111 Tclass.ValueMessage.Message))
     :skolemid |1272|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.Buffers.BufferStack) TyType))
(assert (= (Tag Tclass.Buffers.BufferStack) Tagclass.Buffers.BufferStack))
(assert (= (TagFamily Tclass.Buffers.BufferStack) tytagFamily$BufferStack))
(assert (forall ((bx@@112 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@112)) bx@@112)
                     ($Is ($Unbox DatatypeTypeType bx@@112)
                          Tclass.Buffers.BufferStack))))
       (=> (and (= (type bx@@112) BoxType)
                ($IsBox bx@@112 Tclass.Buffers.BufferStack))
           a!1))
     :pattern (($IsBox bx@@112 Tclass.Buffers.BufferStack))
     :skolemid |1273|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.PagedBetree.QueryReceiptLine) TyType))
(assert (= (Tag Tclass.PagedBetree.QueryReceiptLine)
   Tagclass.PagedBetree.QueryReceiptLine))
(assert (= (TagFamily Tclass.PagedBetree.QueryReceiptLine) tytagFamily$QueryReceiptLine))
(assert (forall ((bx@@113 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@113)) bx@@113)
                     ($Is ($Unbox DatatypeTypeType bx@@113)
                          Tclass.PagedBetree.QueryReceiptLine))))
       (=> (and (= (type bx@@113) BoxType)
                ($IsBox bx@@113 Tclass.PagedBetree.QueryReceiptLine))
           a!1))
     :pattern (($IsBox bx@@113 Tclass.PagedBetree.QueryReceiptLine))
     :skolemid |1275|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@374 T@U) (arg1@@149 T@U))
  (! (= (type (PagedBetreeRefinement.__default.INodeAt arg0@@374 arg1@@149))
        DatatypeTypeType)
     :pattern ((PagedBetreeRefinement.__default.INodeAt arg0@@374 arg1@@149))
     :qid |funType:PagedBetreeRefinement.__default.INodeAt|)))
(assert (let ((a!1 (forall ((|betreeNode#0| T@U) (|key#0@@6| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.INodeAt#canCall|
                                 |betreeNode#0|
                                 |key#0@@6|)
                               (and (not (= 5 $FunctionContextHeight))
                                    ($Is |betreeNode#0|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@6| Tclass.KeyType.Key)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |betreeNode#0|)))))
                  (=> (and (= (type |betreeNode#0|) DatatypeTypeType)
                           (= (type |key#0@@6|) (SeqType BoxType))
                           a!1)
                      ($Is (PagedBetreeRefinement.__default.INodeAt
                             |betreeNode#0|
                             |key#0@@6|)
                           Tclass.ValueMessage.Message)))
                :pattern ((PagedBetreeRefinement.__default.INodeAt
                            |betreeNode#0|
                            |key#0@@6|))
                :skolemid |1308|
                :qid |PagedBetreeRefinementidfy.45:20|))))
  (=> (<= 5 $FunctionContextHeight) a!1)))
(assert (forall ((|betreeNode#0@@0| T@U) (|key#0@@7| T@U))
  (! (=> (and (= (type |betreeNode#0@@0|) DatatypeTypeType)
              (= (type |key#0@@7|) (SeqType BoxType))
              ($Is |betreeNode#0@@0| Tclass.PagedBetree.BetreeNode)
              ($Is |key#0@@7| Tclass.KeyType.Key))
         (= (|PagedBetreeRefinement.__default.INodeAt#requires|
              |betreeNode#0@@0|
              |key#0@@7|)
            (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0@@0|)))
     :pattern ((|PagedBetreeRefinement.__default.INodeAt#requires|
                 |betreeNode#0@@0|
                 |key#0@@7|))
     :skolemid |1309|
     :qid |PagedBetreeRefinementidfy.45:20|)))
(assert (let ((a!1 (forall ((|betreeNode#0@@1| T@U) (|key#0@@8| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.INodeAt#canCall|
                                 |betreeNode#0@@1|
                                 |key#0@@8|)
                               (and (not (= 5 $FunctionContextHeight))
                                    ($Is |betreeNode#0@@1|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@8| Tclass.KeyType.Key)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |betreeNode#0@@1|))))
                      (a!2 (= (PagedBetreeRefinement.__default.INodeAt
                                |betreeNode#0@@1|
                                |key#0@@8|)
                              (PagedBetree.QueryReceipt.Result
                                (PagedBetreeRefinement.__default.BuildQueryReceipt
                                  ($LS $LZ)
                                  |betreeNode#0@@1|
                                  |key#0@@8|)))))
                (let ((a!3 (and (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                  |betreeNode#0@@1|
                                  |key#0@@8|)
                                (|PagedBetree.QueryReceipt.Result#canCall|
                                  (PagedBetreeRefinement.__default.BuildQueryReceipt
                                    ($LS $LZ)
                                    |betreeNode#0@@1|
                                    |key#0@@8|))
                                a!2)))
                  (=> (and (= (type |betreeNode#0@@1|) DatatypeTypeType)
                           (= (type |key#0@@8|) (SeqType BoxType))
                           a!1)
                      a!3)))
                :pattern ((PagedBetreeRefinement.__default.INodeAt
                            |betreeNode#0@@1|
                            |key#0@@8|))
                :skolemid |1310|
                :qid |PagedBetreeRefinementidfy.45:20|))))
  (=> (<= 5 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|betreeNode#0@@2| T@U) (|key#0@@9| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit |betreeNode#0@@2|)))))
                      (a!3 (|PagedBetree.QueryReceipt.Result#canCall|
                             (Lit (PagedBetreeRefinement.__default.BuildQueryReceipt
                                    ($LS $LZ)
                                    (Lit |betreeNode#0@@2|)
                                    (Lit |key#0@@9|)))))
                      (a!4 (PagedBetree.QueryReceipt.Result
                             (Lit (PagedBetreeRefinement.__default.BuildQueryReceipt
                                    ($LS $LZ)
                                    (Lit |betreeNode#0@@2|)
                                    (Lit |key#0@@9|))))))
                (let ((a!2 (or (|PagedBetreeRefinement.__default.INodeAt#canCall|
                                 (Lit |betreeNode#0@@2|)
                                 (Lit |key#0@@9|))
                               (and (not (= 5 $FunctionContextHeight))
                                    ($Is |betreeNode#0@@2|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@9| Tclass.KeyType.Key)
                                    (U_2_bool a!1))))
                      (a!5 (and (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall|
                                  (Lit |betreeNode#0@@2|)
                                  (Lit |key#0@@9|))
                                a!3
                                (= (PagedBetreeRefinement.__default.INodeAt
                                     (Lit |betreeNode#0@@2|)
                                     (Lit |key#0@@9|))
                                   (Lit a!4)))))
                  (=> (and (= (type |betreeNode#0@@2|) DatatypeTypeType)
                           (= (type |key#0@@9|) (SeqType BoxType))
                           a!2)
                      a!5)))
                :pattern ((PagedBetreeRefinement.__default.INodeAt
                            (Lit |betreeNode#0@@2|)
                            (Lit |key#0@@9|)))
                :weight 3
                :skolemid |1311|
                :qid |PagedBetreeRefinementidfy.45:20|))))
  (=> (<= 5 $FunctionContextHeight) a!1)))
(assert (forall ((arg0@@375 T@U) (arg1@@150 T@U))
  (! (= (type (PagedBetreeRefinement.__default.INode arg0@@375 arg1@@150))
        (IMapType BoxType BoxType))
     :pattern ((PagedBetreeRefinement.__default.INode arg0@@375 arg1@@150))
     :qid |funType:PagedBetreeRefinement.__default.INode|)))
(assert (forall (($ly@@6 T@U) (|betreeNode#0@@3| T@U))
  (! (=> (and (= (type $ly@@6) LayerTypeType)
              (= (type |betreeNode#0@@3|) DatatypeTypeType))
         (= (PagedBetreeRefinement.__default.INode
              ($LS $ly@@6)
              |betreeNode#0@@3|)
            (PagedBetreeRefinement.__default.INode $ly@@6 |betreeNode#0@@3|)))
     :pattern ((PagedBetreeRefinement.__default.INode
                 ($LS $ly@@6)
                 |betreeNode#0@@3|))
     :skolemid |1318|
     :qid |PagedBetreeRefinementidfy.51:22|)))
(assert (forall (($ly@@7 T@U) (|betreeNode#0@@4| T@U))
  (! (=> (and (= (type $ly@@7) LayerTypeType)
              (= (type |betreeNode#0@@4|) DatatypeTypeType))
         (= (PagedBetreeRefinement.__default.INode $ly@@7 |betreeNode#0@@4|)
            (PagedBetreeRefinement.__default.INode $LZ |betreeNode#0@@4|)))
     :pattern ((PagedBetreeRefinement.__default.INode
                 (AsFuelBottom $ly@@7)
                 |betreeNode#0@@4|))
     :skolemid |1319|
     :qid |PagedBetreeRefinementidfy.51:22|)))
(assert (= (type Tclass.TotalKMMapMod.TotalMap) TyType))
(assert (= (Tag Tclass.TotalKMMapMod.TotalMap) Tagclass.TotalKMMapMod.TotalMap))
(assert (= (TagFamily Tclass.TotalKMMapMod.TotalMap) tytagFamily$TotalMap))
(assert (forall ((bx@@114 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@114)) bx@@114)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (IMapType BoxType BoxType) bx@@114)
                          Tclass.TotalKMMapMod.TotalMap))))
       (=> (and (= (type bx@@114) BoxType)
                ($IsBox bx@@114 Tclass.TotalKMMapMod.TotalMap))
           a!2)))
     :pattern (($IsBox bx@@114 Tclass.TotalKMMapMod.TotalMap))
     :skolemid |1320|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall (($ly@@8 T@U) (|betreeNode#0@@5| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.INode#canCall|
                                 |betreeNode#0@@5|)
                               (and (not (= 7 $FunctionContextHeight))
                                    ($Is |betreeNode#0@@5|
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |betreeNode#0@@5|)))))
                  (=> (and (= (type $ly@@8) LayerTypeType)
                           (= (type |betreeNode#0@@5|) DatatypeTypeType)
                           a!1)
                      ($Is (PagedBetreeRefinement.__default.INode
                             $ly@@8
                             |betreeNode#0@@5|)
                           Tclass.TotalKMMapMod.TotalMap)))
                :pattern ((PagedBetreeRefinement.__default.INode
                            $ly@@8
                            |betreeNode#0@@5|))
                :skolemid |1321|
                :qid |PagedBetreeRefinementidfy.51:22|))))
  (=> (<= 7 $FunctionContextHeight) a!1)))
(assert (forall (($ly@@9 T@U) (|betreeNode#0@@6| T@U))
  (! (=> (and (= (type $ly@@9) LayerTypeType)
              (= (type |betreeNode#0@@6|) DatatypeTypeType)
              ($Is |betreeNode#0@@6| Tclass.PagedBetree.BetreeNode))
         (= (|PagedBetreeRefinement.__default.INode#requires|
              $ly@@9
              |betreeNode#0@@6|)
            (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0@@6|)))
     :pattern ((|PagedBetreeRefinement.__default.INode#requires|
                 $ly@@9
                 |betreeNode#0@@6|))
     :skolemid |1322|
     :qid |PagedBetreeRefinementidfy.51:22|)))
(assert (let ((a!1 (forall ((arg0@@376 T@U))
             (! (= (type (|lambda#4| arg0@@376))
                   (MapType0Type BoxType boolType))
                :pattern ((|lambda#4| arg0@@376))
                :qid |funType:lambda#4|)))
      (a!2 (forall ((arg0@@377 T@U))
             (! (= (type (|lambda#5| arg0@@377)) (MapType0Type BoxType BoxType))
                :pattern ((|lambda#5| arg0@@377))
                :qid |funType:lambda#5|))))
  (and a!1 a!2)))
(assert (let ((a!1 (forall (($ly@@10 T@U) (|betreeNode#0@@7| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.INode#canCall|
                                 |betreeNode#0@@7|)
                               (and (not (= 7 $FunctionContextHeight))
                                    ($Is |betreeNode#0@@7|
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |betreeNode#0@@7|))))
                      (a!2 (forall ((|key#0@@10| T@U))
                             (! (=> (and (= (type |key#0@@10|)
                                            (SeqType BoxType))
                                         ($Is |key#0@@10| Tclass.KeyType.Key))
                                    (and (|TotalKMMapMod.__default.AnyKey#canCall|
                                           |key#0@@10|)
                                         (=> (TotalKMMapMod.__default.AnyKey
                                               |key#0@@10|)
                                             (|PagedBetreeRefinement.__default.INodeAt#canCall|
                                               |betreeNode#0@@7|
                                               |key#0@@10|))))
                                :pattern ((PagedBetreeRefinement.__default.INodeAt
                                            |betreeNode#0@@7|
                                            |key#0@@10|))
                                :pattern ((TotalKMMapMod.__default.AnyKey
                                            |key#0@@10|))
                                :skolemid |1323|
                                :qid |PagedBetreeRefinementidfy.54:10|))))
                (let ((a!3 (and a!2
                                (= (PagedBetreeRefinement.__default.INode
                                     ($LS $ly@@10)
                                     |betreeNode#0@@7|)
                                   (|IMap#Glue| (|lambda#4| Tclass.KeyType.Key)
                                                (|lambda#5| |betreeNode#0@@7|)
                                                (TIMap Tclass.KeyType.Key
                                                       Tclass.ValueMessage.Message))))))
                  (=> (and (= (type $ly@@10) LayerTypeType)
                           (= (type |betreeNode#0@@7|) DatatypeTypeType)
                           a!1)
                      a!3)))
                :pattern ((PagedBetreeRefinement.__default.INode
                            ($LS $ly@@10)
                            |betreeNode#0@@7|))
                :skolemid |1324|
                :qid |PagedBetreeRefinementidfy.51:22|))))
  (=> (<= 7 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall (($ly@@11 T@U) (|betreeNode#0@@8| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit |betreeNode#0@@8|)))))
                      (a!3 (forall ((|key#0@@11| T@U))
                             (! (let ((a!1 (and (|TotalKMMapMod.__default.AnyKey#canCall|
                                                  |key#0@@11|)
                                                (=> (TotalKMMapMod.__default.AnyKey
                                                      |key#0@@11|)
                                                    (|PagedBetreeRefinement.__default.INodeAt#canCall|
                                                      (Lit |betreeNode#0@@8|)
                                                      |key#0@@11|)))))
                                  (=> (and (= (type |key#0@@11|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@11| Tclass.KeyType.Key))
                                      a!1))
                                :pattern ((PagedBetreeRefinement.__default.INodeAt
                                            |betreeNode#0@@8|
                                            |key#0@@11|))
                                :pattern ((TotalKMMapMod.__default.AnyKey
                                            |key#0@@11|))
                                :skolemid |1325|
                                :qid |PagedBetreeRefinementidfy.54:10|)))
                      (a!4 (= (PagedBetreeRefinement.__default.INode
                                ($LS $ly@@11)
                                (Lit |betreeNode#0@@8|))
                              (|IMap#Glue| (|lambda#4| Tclass.KeyType.Key)
                                           (|lambda#5| (Lit |betreeNode#0@@8|))
                                           (TIMap Tclass.KeyType.Key
                                                  Tclass.ValueMessage.Message)))))
                (let ((a!2 (or (|PagedBetreeRefinement.__default.INode#canCall|
                                 (Lit |betreeNode#0@@8|))
                               (and (not (= 7 $FunctionContextHeight))
                                    ($Is |betreeNode#0@@8|
                                         Tclass.PagedBetree.BetreeNode)
                                    (U_2_bool a!1)))))
                  (=> (and (= (type $ly@@11) LayerTypeType)
                           (= (type |betreeNode#0@@8|) DatatypeTypeType)
                           a!2)
                      (and a!3 a!4))))
                :pattern ((PagedBetreeRefinement.__default.INode
                            ($LS $ly@@11)
                            (Lit |betreeNode#0@@8|)))
                :weight 3
                :skolemid |1326|
                :qid |PagedBetreeRefinementidfy.51:22|))))
  (=> (<= 7 $FunctionContextHeight) a!1)))
(assert (forall ((arg0@@378 T@U))
  (! (= (type (Tclass.StampedMod.Stamped arg0@@378)) TyType)
     :pattern ((Tclass.StampedMod.Stamped arg0@@378))
     :qid |funType:Tclass.StampedMod.Stamped|)))
(assert (forall ((StampedMod.Stamped$T T@U))
  (! (let ((a!1 (and (= (Tag (Tclass.StampedMod.Stamped StampedMod.Stamped$T))
                        Tagclass.StampedMod.Stamped)
                     (= (TagFamily (Tclass.StampedMod.Stamped
                                     StampedMod.Stamped$T))
                        tytagFamily$Stamped))))
       (=> (= (type StampedMod.Stamped$T) TyType) a!1))
     :pattern ((Tclass.StampedMod.Stamped StampedMod.Stamped$T))
     :skolemid |1331|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@379 T@U))
  (! (= (type (Tclass.StampedMod.Stamped_0 arg0@@379)) TyType)
     :pattern ((Tclass.StampedMod.Stamped_0 arg0@@379))
     :qid |funType:Tclass.StampedMod.Stamped_0|)))
(assert (forall ((StampedMod.Stamped$T@@0 T@U))
  (! (=> (= (type StampedMod.Stamped$T@@0) TyType)
         (= (Tclass.StampedMod.Stamped_0
              (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@0))
            StampedMod.Stamped$T@@0))
     :pattern ((Tclass.StampedMod.Stamped StampedMod.Stamped$T@@0))
     :skolemid |1332|
     :qid |unknown.0:0|)))
(assert (forall ((StampedMod.Stamped$T@@1 T@U) (bx@@115 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@115)) bx@@115)
                     ($Is ($Unbox DatatypeTypeType bx@@115)
                          (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1)))))
       (=> (and (= (type StampedMod.Stamped$T@@1) TyType)
                (= (type bx@@115) BoxType)
                ($IsBox bx@@115
                        (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1)))
           a!1))
     :pattern (($IsBox bx@@115
                       (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1)))
     :skolemid |1333|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@380 T@U))
             (! (= (type (PagedBetreeRefinement.__default.IStampedBetree
                           arg0@@380))
                   DatatypeTypeType)
                :pattern ((PagedBetreeRefinement.__default.IStampedBetree
                            arg0@@380))
                :qid |funType:PagedBetreeRefinement.__default.IStampedBetree|)))
      (a!2 (forall ((arg0@@381 T@U))
             (! (= (type (StampedMod.Stamped.value arg0@@381)) BoxType)
                :pattern ((StampedMod.Stamped.value arg0@@381))
                :qid |funType:StampedMod.Stamped.value|))))
  (and a!1 a!2)))
(assert (let ((a!1 (forall ((|stampedBetree#0| T@U))
             (! (let ((a!1 (and (not (= 10 $FunctionContextHeight))
                                ($Is |stampedBetree#0|
                                     (Tclass.StampedMod.Stamped
                                       Tclass.PagedBetree.BetreeNode))
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  ($Unbox DatatypeTypeType
                                          (StampedMod.Stamped.value
                                            |stampedBetree#0|))))))
                  (=> (and (= (type |stampedBetree#0|) DatatypeTypeType)
                           (or (|PagedBetreeRefinement.__default.IStampedBetree#canCall|
                                 |stampedBetree#0|)
                               a!1))
                      ($Is (PagedBetreeRefinement.__default.IStampedBetree
                             |stampedBetree#0|)
                           (Tclass.StampedMod.Stamped
                             Tclass.TotalKMMapMod.TotalMap))))
                :pattern ((PagedBetreeRefinement.__default.IStampedBetree
                            |stampedBetree#0|))
                :skolemid |1334|
                :qid |PagedBetreeRefinementidfy.57:27|))))
  (=> (<= 10 $FunctionContextHeight) a!1)))
(assert (forall ((|stampedBetree#0@@0| T@U))
  (! (let ((a!1 (= (|PagedBetreeRefinement.__default.IStampedBetree#requires|
                     |stampedBetree#0@@0|)
                   (PagedBetree.BetreeNode.WF
                     ($LS $LZ)
                     ($Unbox DatatypeTypeType
                             (StampedMod.Stamped.value |stampedBetree#0@@0|))))))
       (=> (and (= (type |stampedBetree#0@@0|) DatatypeTypeType)
                ($Is |stampedBetree#0@@0|
                     (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)))
           a!1))
     :pattern ((|PagedBetreeRefinement.__default.IStampedBetree#requires|
                 |stampedBetree#0@@0|))
     :skolemid |1335|
     :qid |PagedBetreeRefinementidfy.57:27|)))
(assert (let ((a!1 (forall ((arg0@@382 T@U) (arg1@@151 Int))
             (! (= (type (|#StampedMod.Stamped.Stamped| arg0@@382 arg1@@151))
                   DatatypeTypeType)
                :pattern ((|#StampedMod.Stamped.Stamped| arg0@@382 arg1@@151))
                :qid |funType:#StampedMod.Stamped.Stamped|))))
  (and a!1
       (= (type StartFuel_PagedBetreeRefinement._default.INode) LayerTypeType))))
(assert (let ((a!1 (forall ((|stampedBetree#0@@1| T@U))
             (! (let ((a!1 (and (not (= 10 $FunctionContextHeight))
                                ($Is |stampedBetree#0@@1|
                                     (Tclass.StampedMod.Stamped
                                       Tclass.PagedBetree.BetreeNode))
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  ($Unbox DatatypeTypeType
                                          (StampedMod.Stamped.value
                                            |stampedBetree#0@@1|)))))
                      (a!2 ($Box (PagedBetreeRefinement.__default.INode
                                   StartFuel_PagedBetreeRefinement._default.INode
                                   ($Unbox DatatypeTypeType
                                           (StampedMod.Stamped.value
                                             |stampedBetree#0@@1|))))))
                (let ((a!3 (and (StampedMod.Stamped.Stamped_q
                                  |stampedBetree#0@@1|)
                                (|PagedBetreeRefinement.__default.INode#canCall|
                                  ($Unbox DatatypeTypeType
                                          (StampedMod.Stamped.value
                                            |stampedBetree#0@@1|)))
                                (StampedMod.Stamped.Stamped_q
                                  |stampedBetree#0@@1|)
                                (= (PagedBetreeRefinement.__default.IStampedBetree
                                     |stampedBetree#0@@1|)
                                   (|#StampedMod.Stamped.Stamped|
                                     a!2
                                     (StampedMod.Stamped.seqEnd
                                       |stampedBetree#0@@1|))))))
                  (=> (and (= (type |stampedBetree#0@@1|) DatatypeTypeType)
                           (or (|PagedBetreeRefinement.__default.IStampedBetree#canCall|
                                 |stampedBetree#0@@1|)
                               a!1))
                      a!3)))
                :pattern ((PagedBetreeRefinement.__default.IStampedBetree
                            |stampedBetree#0@@1|))
                :skolemid |1336|
                :qid |PagedBetreeRefinementidfy.57:27|))))
  (=> (<= 10 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|stampedBetree#0@@2| T@U))
             (! (let ((a!1 (Lit ($Unbox DatatypeTypeType
                                        (StampedMod.Stamped.value
                                          (Lit |stampedBetree#0@@2|))))))
                (let ((a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            a!1))))
                      (a!4 (|#StampedMod.Stamped.Stamped|
                             ($Box (PagedBetreeRefinement.__default.INode
                                     StartFuel_PagedBetreeRefinement._default.INode
                                     a!1))
                             (LitInt (StampedMod.Stamped.seqEnd
                                       (Lit |stampedBetree#0@@2|))))))
                (let ((a!3 (or (|PagedBetreeRefinement.__default.IStampedBetree#canCall|
                                 (Lit |stampedBetree#0@@2|))
                               (and (not (= 10 $FunctionContextHeight))
                                    ($Is |stampedBetree#0@@2|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.PagedBetree.BetreeNode))
                                    (U_2_bool a!2))))
                      (a!5 (and (StampedMod.Stamped.Stamped_q
                                  (Lit |stampedBetree#0@@2|))
                                (|PagedBetreeRefinement.__default.INode#canCall|
                                  a!1)
                                (StampedMod.Stamped.Stamped_q
                                  (Lit |stampedBetree#0@@2|))
                                (= (PagedBetreeRefinement.__default.IStampedBetree
                                     (Lit |stampedBetree#0@@2|))
                                   a!4))))
                  (=> (and (= (type |stampedBetree#0@@2|) DatatypeTypeType) a!3)
                      a!5))))
                :pattern ((PagedBetreeRefinement.__default.IStampedBetree
                            (Lit |stampedBetree#0@@2|)))
                :weight 3
                :skolemid |1337|
                :qid |PagedBetreeRefinementidfy.57:27|))))
  (=> (<= 10 $FunctionContextHeight) a!1)))
(assert (= (type Tclass.PagedBetree.TransitionLabel) TyType))
(assert (= (Tag Tclass.PagedBetree.TransitionLabel)
   Tagclass.PagedBetree.TransitionLabel))
(assert (= (TagFamily Tclass.PagedBetree.TransitionLabel) tytagFamily$TransitionLabel))
(assert (forall ((bx@@116 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@116)) bx@@116)
                     ($Is ($Unbox DatatypeTypeType bx@@116)
                          Tclass.PagedBetree.TransitionLabel))))
       (=> (and (= (type bx@@116) BoxType)
                ($IsBox bx@@116 Tclass.PagedBetree.TransitionLabel))
           a!1))
     :pattern (($IsBox bx@@116 Tclass.PagedBetree.TransitionLabel))
     :skolemid |1340|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.AbstractMap.TransitionLabel) TyType))
(assert (= (Tag Tclass.AbstractMap.TransitionLabel)
   Tagclass.AbstractMap.TransitionLabel))
(assert (= (TagFamily Tclass.AbstractMap.TransitionLabel) tytagFamily$TransitionLabel))
(assert (forall ((bx@@117 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@117)) bx@@117)
                     ($Is ($Unbox DatatypeTypeType bx@@117)
                          Tclass.AbstractMap.TransitionLabel))))
       (=> (and (= (type bx@@117) BoxType)
                ($IsBox bx@@117 Tclass.AbstractMap.TransitionLabel))
           a!1))
     :pattern (($IsBox bx@@117 Tclass.AbstractMap.TransitionLabel))
     :skolemid |1341|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@383 T@U))
  (! (= (type (PagedBetreeRefinement.__default.ILbl arg0@@383))
        DatatypeTypeType)
     :pattern ((PagedBetreeRefinement.__default.ILbl arg0@@383))
     :qid |funType:PagedBetreeRefinement.__default.ILbl|)))
(assert (let ((a!1 (forall ((|lbl#0| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.ILbl#canCall|
                                 |lbl#0|)
                               (and (not (= 13 $FunctionContextHeight))
                                    ($Is |lbl#0|
                                         Tclass.PagedBetree.TransitionLabel)))))
                  (=> (and (= (type |lbl#0|) DatatypeTypeType) a!1)
                      ($Is (PagedBetreeRefinement.__default.ILbl |lbl#0|)
                           Tclass.AbstractMap.TransitionLabel)))
                :pattern ((PagedBetreeRefinement.__default.ILbl |lbl#0|))
                :skolemid |1342|
                :qid |PagedBetreeRefinementidfy.63:17|))))
  (=> (<= 13 $FunctionContextHeight) a!1)))
(assert (forall ((|lbl#0@@0| T@U))
  (! (=> (and (= (type |lbl#0@@0|) DatatypeTypeType)
              ($Is |lbl#0@@0| Tclass.PagedBetree.TransitionLabel))
         (= (|PagedBetreeRefinement.__default.ILbl#requires| |lbl#0@@0|) true))
     :pattern ((|PagedBetreeRefinement.__default.ILbl#requires| |lbl#0@@0|))
     :skolemid |1343|
     :qid |PagedBetreeRefinementidfy.63:17|)))
(assert (let ((a!1 (forall ((arg0@@384 T@U))
             (! (= (type (PagedBetree.TransitionLabel.stampedBetree arg0@@384))
                   DatatypeTypeType)
                :pattern ((PagedBetree.TransitionLabel.stampedBetree arg0@@384))
                :qid |funType:PagedBetree.TransitionLabel.stampedBetree|)))
      (a!2 (forall ((arg0@@385 T@U))
             (! (= (type (PagedBetree.TransitionLabel.value arg0@@385))
                   (SeqType BoxType))
                :pattern ((PagedBetree.TransitionLabel.value arg0@@385))
                :qid |funType:PagedBetree.TransitionLabel.value|)))
      (a!3 (forall ((arg0@@386 T@U))
             (! (= (type (PagedBetree.TransitionLabel.key arg0@@386))
                   (SeqType BoxType))
                :pattern ((PagedBetree.TransitionLabel.key arg0@@386))
                :qid |funType:PagedBetree.TransitionLabel.key|)))
      (a!4 (forall ((arg0@@387 Int) (arg1@@152 T@U) (arg2@@81 T@U))
             (! (= (type (|#AbstractMap.TransitionLabel.QueryLabel|
                           arg0@@387
                           arg1@@152
                           arg2@@81))
                   DatatypeTypeType)
                :pattern ((|#AbstractMap.TransitionLabel.QueryLabel|
                            arg0@@387
                            arg1@@152
                            arg2@@81))
                :qid |funType:#AbstractMap.TransitionLabel.QueryLabel|)))
      (a!5 (forall ((arg0@@388 T@U))
             (! (= (type (PagedBetree.TransitionLabel.puts arg0@@388))
                   DatatypeTypeType)
                :pattern ((PagedBetree.TransitionLabel.puts arg0@@388))
                :qid |funType:PagedBetree.TransitionLabel.puts|)))
      (a!6 (forall ((arg0@@389 T@U))
             (! (= (type (|#AbstractMap.TransitionLabel.PutLabel| arg0@@389))
                   DatatypeTypeType)
                :pattern ((|#AbstractMap.TransitionLabel.PutLabel| arg0@@389))
                :qid |funType:#AbstractMap.TransitionLabel.PutLabel|)))
      (a!7 (forall ((arg0@@390 Int))
             (! (= (type (|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                           arg0@@390))
                   DatatypeTypeType)
                :pattern ((|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                            arg0@@390))
                :qid |funType:#AbstractMap.TransitionLabel.QueryEndLsnLabel|)))
      (a!8 (forall ((arg0@@391 T@U))
             (! (= (type (|#AbstractMap.TransitionLabel.FreezeAsLabel|
                           arg0@@391))
                   DatatypeTypeType)
                :pattern ((|#AbstractMap.TransitionLabel.FreezeAsLabel|
                            arg0@@391))
                :qid |funType:#AbstractMap.TransitionLabel.FreezeAsLabel|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (= (type StampedMod.__default.Empty) DatatypeTypeType)
       (= (type |#AbstractMap.TransitionLabel.InternalLabel|) DatatypeTypeType))))
(assert (let ((a!1 (forall ((|lbl#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.ILbl#canCall|
                                 |lbl#0@@1|)
                               (and (not (= 13 $FunctionContextHeight))
                                    ($Is |lbl#0@@1|
                                         Tclass.PagedBetree.TransitionLabel))))
                      (a!2 (|PagedBetree.BetreeNode.WF#canCall|
                             ($Unbox DatatypeTypeType
                                     (StampedMod.Stamped.value
                                       (PagedBetree.TransitionLabel.stampedBetree
                                         |lbl#0@@1|)))))
                      (a!3 (PagedBetree.BetreeNode.WF
                             ($LS $LZ)
                             ($Unbox DatatypeTypeType
                                     (StampedMod.Stamped.value
                                       (PagedBetree.TransitionLabel.stampedBetree
                                         |lbl#0@@1|))))))
                (let ((a!4 (and (StampedMod.Stamped.Stamped_q
                                  (PagedBetree.TransitionLabel.stampedBetree
                                    |lbl#0@@1|))
                                a!2
                                (=> a!3
                                    (|PagedBetreeRefinement.__default.IStampedBetree#canCall|
                                      (PagedBetree.TransitionLabel.stampedBetree
                                        |lbl#0@@1|)))
                                (=> (not a!3)
                                    |StampedMod.__default.Empty#canCall|)))
                      (a!6 (|#AbstractMap.TransitionLabel.FreezeAsLabel|
                             (ite a!3
                                  (PagedBetreeRefinement.__default.IStampedBetree
                                    (PagedBetree.TransitionLabel.stampedBetree
                                      |lbl#0@@1|))
                                  StampedMod.__default.Empty))))
                (let ((a!5 (=> (not (PagedBetree.TransitionLabel.PutLabel_q
                                      |lbl#0@@1|))
                               (=> (not (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                                          |lbl#0@@1|))
                                   (=> (PagedBetree.TransitionLabel.FreezeAsLabel_q
                                         |lbl#0@@1|)
                                       a!4))))
                      (a!7 (ite (PagedBetree.TransitionLabel.PutLabel_q
                                  |lbl#0@@1|)
                                (|#AbstractMap.TransitionLabel.PutLabel|
                                  (PagedBetree.TransitionLabel.puts |lbl#0@@1|))
                                (ite (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                                       |lbl#0@@1|)
                                     (|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                                       (PagedBetree.TransitionLabel.endLsn
                                         |lbl#0@@1|))
                                     (ite (PagedBetree.TransitionLabel.FreezeAsLabel_q
                                            |lbl#0@@1|)
                                          a!6
                                          |#AbstractMap.TransitionLabel.InternalLabel|)))))
                (let ((a!8 (= (PagedBetreeRefinement.__default.ILbl |lbl#0@@1|)
                              (ite (PagedBetree.TransitionLabel.QueryLabel_q
                                     |lbl#0@@1|)
                                   (|#AbstractMap.TransitionLabel.QueryLabel|
                                     (PagedBetree.TransitionLabel.endLsn
                                       |lbl#0@@1|)
                                     (PagedBetree.TransitionLabel.key
                                       |lbl#0@@1|)
                                     (PagedBetree.TransitionLabel.value
                                       |lbl#0@@1|))
                                   a!7))))
                (let ((a!9 (and (=> (not (PagedBetree.TransitionLabel.QueryLabel_q
                                           |lbl#0@@1|))
                                    a!5)
                                a!8)))
                  (=> (and (= (type |lbl#0@@1|) DatatypeTypeType) a!1) a!9))))))
                :pattern ((PagedBetreeRefinement.__default.ILbl |lbl#0@@1|))
                :skolemid |1344|
                :qid |PagedBetreeRefinementidfy.63:17|))))
  (=> (<= 13 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|lbl#0@@2| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.ILbl#canCall|
                                 (Lit |lbl#0@@2|))
                               (and (not (= 13 $FunctionContextHeight))
                                    ($Is |lbl#0@@2|
                                         Tclass.PagedBetree.TransitionLabel))))
                      (a!2 (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryLabel_q
                                            (Lit |lbl#0@@2|)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.TransitionLabel.PutLabel_q
                                            (Lit |lbl#0@@2|)))))
                      (a!4 (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                                            (Lit |lbl#0@@2|)))))
                      (a!5 (Lit (bool_2_U (PagedBetree.TransitionLabel.FreezeAsLabel_q
                                            (Lit |lbl#0@@2|)))))
                      (a!6 (StampedMod.Stamped.Stamped_q
                             (Lit (PagedBetree.TransitionLabel.stampedBetree
                                    (Lit |lbl#0@@2|)))))
                      (a!7 (StampedMod.Stamped.value
                             (Lit (PagedBetree.TransitionLabel.stampedBetree
                                    (Lit |lbl#0@@2|)))))
                      (a!8 (|PagedBetreeRefinement.__default.IStampedBetree#canCall|
                             (Lit (PagedBetree.TransitionLabel.stampedBetree
                                    (Lit |lbl#0@@2|)))))
                      (a!12 (|#AbstractMap.TransitionLabel.QueryLabel|
                              (LitInt (PagedBetree.TransitionLabel.endLsn
                                        (Lit |lbl#0@@2|)))
                              (Lit (PagedBetree.TransitionLabel.key
                                     (Lit |lbl#0@@2|)))
                              (Lit (PagedBetree.TransitionLabel.value
                                     (Lit |lbl#0@@2|)))))
                      (a!13 (|#AbstractMap.TransitionLabel.PutLabel|
                              (Lit (PagedBetree.TransitionLabel.puts
                                     (Lit |lbl#0@@2|)))))
                      (a!14 (|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                              (LitInt (PagedBetree.TransitionLabel.endLsn
                                        (Lit |lbl#0@@2|)))))
                      (a!15 (PagedBetreeRefinement.__default.IStampedBetree
                              (Lit (PagedBetree.TransitionLabel.stampedBetree
                                     (Lit |lbl#0@@2|))))))
                (let ((a!9 (=> (not (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      ($Unbox DatatypeTypeType a!7)))
                               |StampedMod.__default.Empty#canCall|))
                      (a!16 (ite (PagedBetree.BetreeNode.WF
                                   ($LS $LZ)
                                   (Lit ($Unbox DatatypeTypeType a!7)))
                                 a!15
                                 StampedMod.__default.Empty)))
                (let ((a!10 (and a!6
                                 (|PagedBetree.BetreeNode.WF#canCall|
                                   ($Unbox DatatypeTypeType a!7))
                                 (=> (PagedBetree.BetreeNode.WF
                                       ($LS $LZ)
                                       ($Unbox DatatypeTypeType a!7))
                                     a!8)
                                 a!9))
                      (a!17 (ite (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                                   (Lit |lbl#0@@2|))
                                 (Lit a!14)
                                 (ite (PagedBetree.TransitionLabel.FreezeAsLabel_q
                                        (Lit |lbl#0@@2|))
                                      (|#AbstractMap.TransitionLabel.FreezeAsLabel|
                                        a!16)
                                      |#AbstractMap.TransitionLabel.InternalLabel|))))
                (let ((a!11 (=> (not (U_2_bool a!3))
                                (=> (not (U_2_bool a!4))
                                    (=> (U_2_bool a!5) a!10))))
                      (a!18 (ite (PagedBetree.TransitionLabel.QueryLabel_q
                                   (Lit |lbl#0@@2|))
                                 (Lit a!12)
                                 (ite (PagedBetree.TransitionLabel.PutLabel_q
                                        (Lit |lbl#0@@2|))
                                      (Lit a!13)
                                      a!17))))
                (let ((a!19 (and (=> (not (U_2_bool a!2)) a!11)
                                 (= (PagedBetreeRefinement.__default.ILbl
                                      (Lit |lbl#0@@2|))
                                    a!18))))
                  (=> (and (= (type |lbl#0@@2|) DatatypeTypeType) a!1) a!19))))))
                :pattern ((PagedBetreeRefinement.__default.ILbl
                            (Lit |lbl#0@@2|)))
                :weight 3
                :skolemid |1345|
                :qid |PagedBetreeRefinementidfy.63:17|))))
  (=> (<= 13 $FunctionContextHeight) a!1)))
(assert (= (type Tclass.MsgHistoryMod.MsgHistory) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.MsgHistory) Tagclass.MsgHistoryMod.MsgHistory))
(assert (= (TagFamily Tclass.MsgHistoryMod.MsgHistory) tytagFamily$MsgHistory))
(assert (forall ((bx@@118 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@118)) bx@@118)
                     ($Is ($Unbox DatatypeTypeType bx@@118)
                          Tclass.MsgHistoryMod.MsgHistory))))
       (=> (and (= (type bx@@118) BoxType)
                ($IsBox bx@@118 Tclass.MsgHistoryMod.MsgHistory))
           a!1))
     :pattern (($IsBox bx@@118 Tclass.MsgHistoryMod.MsgHistory))
     :skolemid |1349|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.ValueType.Value) TyType))
(assert (= (Tag Tclass.ValueType.Value) Tagclass.ValueType.Value))
(assert (= (TagFamily Tclass.ValueType.Value) tytagFamily$Value))
(assert (forall ((bx@@119 T@U))
  (! (let ((a!1 (= ($Box ($Unbox (SeqType BoxType) bx@@119)) bx@@119)))
     (let ((a!2 (and a!1
                     ($Is ($Unbox (SeqType BoxType) bx@@119)
                          Tclass.ValueType.Value))))
       (=> (and (= (type bx@@119) BoxType)
                ($IsBox bx@@119 Tclass.ValueType.Value))
           a!2)))
     :pattern (($IsBox bx@@119 Tclass.ValueType.Value))
     :skolemid |1350|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.byte) TyType))
(assert (= (Tag Tclass.NativeTypes.byte) Tagclass.NativeTypes.byte))
(assert (= (TagFamily Tclass.NativeTypes.byte) tytagFamily$byte))
(assert (forall ((bx@@120 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@120)) bx@@120)
                     ($Is ($Unbox intType bx@@120) Tclass.NativeTypes.byte))))
       (=> (and (= (type bx@@120) BoxType)
                ($IsBox bx@@120 Tclass.NativeTypes.byte))
           a!1))
     :pattern (($IsBox bx@@120 Tclass.NativeTypes.byte))
     :skolemid |1351|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.PagedBetree.Variables) TyType))
(assert (= (Tag Tclass.PagedBetree.Variables) Tagclass.PagedBetree.Variables))
(assert (= (TagFamily Tclass.PagedBetree.Variables) tytagFamily$Variables))
(assert (forall ((bx@@121 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@121)) bx@@121)
                     ($Is ($Unbox DatatypeTypeType bx@@121)
                          Tclass.PagedBetree.Variables))))
       (=> (and (= (type bx@@121) BoxType)
                ($IsBox bx@@121 Tclass.PagedBetree.Variables))
           a!1))
     :pattern (($IsBox bx@@121 Tclass.PagedBetree.Variables))
     :skolemid |1352|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.AbstractMap.Variables) TyType))
(assert (= (Tag Tclass.AbstractMap.Variables) Tagclass.AbstractMap.Variables))
(assert (= (TagFamily Tclass.AbstractMap.Variables) tytagFamily$Variables))
(assert (forall ((bx@@122 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@122)) bx@@122)
                     ($Is ($Unbox DatatypeTypeType bx@@122)
                          Tclass.AbstractMap.Variables))))
       (=> (and (= (type bx@@122) BoxType)
                ($IsBox bx@@122 Tclass.AbstractMap.Variables))
           a!1))
     :pattern (($IsBox bx@@122 Tclass.AbstractMap.Variables))
     :skolemid |1353|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@392 T@U))
  (! (= (type (PagedBetreeRefinement.__default.I arg0@@392)) DatatypeTypeType)
     :pattern ((PagedBetreeRefinement.__default.I arg0@@392))
     :qid |funType:PagedBetreeRefinement.__default.I|)))
(assert (let ((a!1 (forall ((|v#0| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.I#canCall|
                                 |v#0|)
                               (and (not (= 16 $FunctionContextHeight))
                                    ($Is |v#0| Tclass.PagedBetree.Variables)
                                    (PagedBetree.Variables.WF |v#0|)))))
                  (=> (and (= (type |v#0|) DatatypeTypeType) a!1)
                      ($Is (PagedBetreeRefinement.__default.I |v#0|)
                           Tclass.AbstractMap.Variables)))
                :pattern ((PagedBetreeRefinement.__default.I |v#0|))
                :skolemid |1354|
                :qid |PagedBetreeRefinementidfy.74:14|))))
  (=> (<= 16 $FunctionContextHeight) a!1)))
(assert (forall ((|v#0@@0| T@U))
  (! (=> (and (= (type |v#0@@0|) DatatypeTypeType)
              ($Is |v#0@@0| Tclass.PagedBetree.Variables))
         (= (|PagedBetreeRefinement.__default.I#requires| |v#0@@0|)
            (PagedBetree.Variables.WF |v#0@@0|)))
     :pattern ((|PagedBetreeRefinement.__default.I#requires| |v#0@@0|))
     :skolemid |1355|
     :qid |PagedBetreeRefinementidfy.74:14|)))
(assert (let ((a!1 (forall ((arg0@@393 T@U))
             (! (= (type (PagedBetree.Variables.root arg0@@393))
                   DatatypeTypeType)
                :pattern ((PagedBetree.Variables.root arg0@@393))
                :qid |funType:PagedBetree.Variables.root|)))
      (a!2 (forall ((arg0@@394 T@U))
             (! (= (type (PagedBetree.Variables.memtable arg0@@394))
                   DatatypeTypeType)
                :pattern ((PagedBetree.Variables.memtable arg0@@394))
                :qid |funType:PagedBetree.Variables.memtable|)))
      (a!3 (forall ((arg0@@395 T@U) (arg1@@153 T@U))
             (! (= (type (PagedBetree.BetreeNode.PushMemtable
                           arg0@@395
                           arg1@@153))
                   DatatypeTypeType)
                :pattern ((PagedBetree.BetreeNode.PushMemtable
                            arg0@@395
                            arg1@@153))
                :qid |funType:PagedBetree.BetreeNode.PushMemtable|)))
      (a!4 (forall ((arg0@@396 T@U))
             (! (= (type (|#AbstractMap.Variables.Variables| arg0@@396))
                   DatatypeTypeType)
                :pattern ((|#AbstractMap.Variables.Variables| arg0@@396))
                :qid |funType:#AbstractMap.Variables.Variables|))))
  (and a!1 a!2 a!3 a!4)))
(assert (let ((a!1 (forall ((|v#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.I#canCall|
                                 |v#0@@1|)
                               (and (not (= 16 $FunctionContextHeight))
                                    ($Is |v#0@@1| Tclass.PagedBetree.Variables)
                                    (PagedBetree.Variables.WF |v#0@@1|))))
                      (a!2 (|#AbstractMap.Variables.Variables|
                             (PagedBetreeRefinement.__default.IStampedBetree
                               (PagedBetree.BetreeNode.PushMemtable
                                 (PagedBetree.Variables.root |v#0@@1|)
                                 (PagedBetree.Variables.memtable |v#0@@1|))))))
                (let ((a!3 (and (PagedBetree.Variables.Variables_q |v#0@@1|)
                                (PagedBetree.Variables.Variables_q |v#0@@1|)
                                (|PagedBetree.BetreeNode.PushMemtable#canCall|
                                  (PagedBetree.Variables.root |v#0@@1|)
                                  (PagedBetree.Variables.memtable |v#0@@1|))
                                (|PagedBetreeRefinement.__default.IStampedBetree#canCall|
                                  (PagedBetree.BetreeNode.PushMemtable
                                    (PagedBetree.Variables.root |v#0@@1|)
                                    (PagedBetree.Variables.memtable |v#0@@1|)))
                                (= (PagedBetreeRefinement.__default.I |v#0@@1|)
                                   a!2))))
                  (=> (and (= (type |v#0@@1|) DatatypeTypeType) a!1) a!3)))
                :pattern ((PagedBetreeRefinement.__default.I |v#0@@1|))
                :skolemid |1356|
                :qid |PagedBetreeRefinementidfy.74:14|))))
  (=> (<= 16 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|v#0@@2| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.Variables.WF
                                            (Lit |v#0@@2|)))))
                      (a!3 (|PagedBetree.BetreeNode.PushMemtable#canCall|
                             (Lit (PagedBetree.Variables.root (Lit |v#0@@2|)))
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@2|)))))
                      (a!4 (PagedBetree.BetreeNode.PushMemtable
                             (Lit (PagedBetree.Variables.root (Lit |v#0@@2|)))
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@2|))))))
                (let ((a!2 (or (|PagedBetreeRefinement.__default.I#canCall|
                                 (Lit |v#0@@2|))
                               (and (not (= 16 $FunctionContextHeight))
                                    ($Is |v#0@@2| Tclass.PagedBetree.Variables)
                                    (U_2_bool a!1))))
                      (a!5 (|#AbstractMap.Variables.Variables|
                             (Lit (PagedBetreeRefinement.__default.IStampedBetree
                                    (Lit a!4))))))
                (let ((a!6 (and (PagedBetree.Variables.Variables_q
                                  (Lit |v#0@@2|))
                                (PagedBetree.Variables.Variables_q
                                  (Lit |v#0@@2|))
                                a!3
                                (|PagedBetreeRefinement.__default.IStampedBetree#canCall|
                                  (Lit a!4))
                                (= (PagedBetreeRefinement.__default.I
                                     (Lit |v#0@@2|))
                                   (Lit a!5)))))
                  (=> (and (= (type |v#0@@2|) DatatypeTypeType) a!2) a!6))))
                :pattern ((PagedBetreeRefinement.__default.I (Lit |v#0@@2|)))
                :weight 3
                :skolemid |1357|
                :qid |PagedBetreeRefinementidfy.74:14|))))
  (=> (<= 16 $FunctionContextHeight) a!1)))
(assert (= (type Tclass.MemtableMod.Memtable) TyType))
(assert (= (Tag Tclass.MemtableMod.Memtable) Tagclass.MemtableMod.Memtable))
(assert (= (TagFamily Tclass.MemtableMod.Memtable) tytagFamily$Memtable))
(assert (forall ((bx@@123 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@123)) bx@@123)
                     ($Is ($Unbox DatatypeTypeType bx@@123)
                          Tclass.MemtableMod.Memtable))))
       (=> (and (= (type bx@@123) BoxType)
                ($IsBox bx@@123 Tclass.MemtableMod.Memtable))
           a!1))
     :pattern (($IsBox bx@@123 Tclass.MemtableMod.Memtable))
     :skolemid |1359|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.Buffers.Buffer) TyType))
(assert (= (Tag Tclass.Buffers.Buffer) Tagclass.Buffers.Buffer))
(assert (= (TagFamily Tclass.Buffers.Buffer) tytagFamily$Buffer))
(assert (forall ((bx@@124 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@124)) bx@@124)
                     ($Is ($Unbox DatatypeTypeType bx@@124)
                          Tclass.Buffers.Buffer))))
       (=> (and (= (type bx@@124) BoxType)
                ($IsBox bx@@124 Tclass.Buffers.Buffer))
           a!1))
     :pattern (($IsBox bx@@124 Tclass.Buffers.Buffer))
     :skolemid |1362|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@397 T@U) (arg1@@154 T@U) (arg2@@82 T@U))
  (! (= (type (PagedBetreeRefinement.__default.MapApply
                arg0@@397
                arg1@@154
                arg2@@82))
        (IMapType BoxType BoxType))
     :pattern ((PagedBetreeRefinement.__default.MapApply
                 arg0@@397
                 arg1@@154
                 arg2@@82))
     :qid |funType:PagedBetreeRefinement.__default.MapApply|)))
(assert (forall (($ly@@12 T@U) (|memtable#0| T@U) (|base#0| T@U))
  (! (=> (and (= (type $ly@@12) LayerTypeType)
              (= (type |memtable#0|) DatatypeTypeType)
              (= (type |base#0|) (IMapType BoxType BoxType)))
         (= (PagedBetreeRefinement.__default.MapApply
              ($LS $ly@@12)
              |memtable#0|
              |base#0|)
            (PagedBetreeRefinement.__default.MapApply
              $ly@@12
              |memtable#0|
              |base#0|)))
     :pattern ((PagedBetreeRefinement.__default.MapApply
                 ($LS $ly@@12)
                 |memtable#0|
                 |base#0|))
     :skolemid |1370|
     :qid |PagedBetreeRefinementidfy.115:22|)))
(assert (forall (($ly@@13 T@U) (|memtable#0@@0| T@U) (|base#0@@0| T@U))
  (! (=> (and (= (type $ly@@13) LayerTypeType)
              (= (type |memtable#0@@0|) DatatypeTypeType)
              (= (type |base#0@@0|) (IMapType BoxType BoxType)))
         (= (PagedBetreeRefinement.__default.MapApply
              $ly@@13
              |memtable#0@@0|
              |base#0@@0|)
            (PagedBetreeRefinement.__default.MapApply
              $LZ
              |memtable#0@@0|
              |base#0@@0|)))
     :pattern ((PagedBetreeRefinement.__default.MapApply
                 (AsFuelBottom $ly@@13)
                 |memtable#0@@0|
                 |base#0@@0|))
     :skolemid |1371|
     :qid |PagedBetreeRefinementidfy.115:22|)))
(assert (let ((a!1 (forall (($ly@@14 T@U) (|memtable#0@@1| T@U) (|base#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.MapApply#canCall|
                                 |memtable#0@@1|
                                 |base#0@@1|)
                               (and (not (= 24 $FunctionContextHeight))
                                    ($Is |memtable#0@@1|
                                         Tclass.MemtableMod.Memtable)
                                    ($Is |base#0@@1|
                                         Tclass.TotalKMMapMod.TotalMap)))))
                  (=> (and (= (type $ly@@14) LayerTypeType)
                           (= (type |memtable#0@@1|) DatatypeTypeType)
                           (= (type |base#0@@1|) (IMapType BoxType BoxType))
                           a!1)
                      ($Is (PagedBetreeRefinement.__default.MapApply
                             $ly@@14
                             |memtable#0@@1|
                             |base#0@@1|)
                           Tclass.TotalKMMapMod.TotalMap)))
                :pattern ((PagedBetreeRefinement.__default.MapApply
                            $ly@@14
                            |memtable#0@@1|
                            |base#0@@1|))
                :skolemid |1372|
                :qid |PagedBetreeRefinementidfy.115:22|))))
  (=> (<= 24 $FunctionContextHeight) a!1)))
(assert (forall (($ly@@15 T@U) (|memtable#0@@2| T@U) (|base#0@@2| T@U))
  (! (=> (and (= (type $ly@@15) LayerTypeType)
              (= (type |memtable#0@@2|) DatatypeTypeType)
              (= (type |base#0@@2|) (IMapType BoxType BoxType))
              ($Is |memtable#0@@2| Tclass.MemtableMod.Memtable)
              ($Is |base#0@@2| Tclass.TotalKMMapMod.TotalMap))
         (= (|PagedBetreeRefinement.__default.MapApply#requires|
              $ly@@15
              |memtable#0@@2|
              |base#0@@2|)
            true))
     :pattern ((|PagedBetreeRefinement.__default.MapApply#requires|
                 $ly@@15
                 |memtable#0@@2|
                 |base#0@@2|))
     :skolemid |1373|
     :qid |PagedBetreeRefinementidfy.115:22|)))
(assert (let ((a!1 (forall ((arg0@@398 T@U) (arg1@@155 T@U))
             (! (= (type (MemtableMod.Memtable.Get arg0@@398 arg1@@155))
                   DatatypeTypeType)
                :pattern ((MemtableMod.Memtable.Get arg0@@398 arg1@@155))
                :qid |funType:MemtableMod.Memtable.Get|)))
      (a!2 (forall ((arg0@@399 T@U) (arg1@@156 T@U))
             (! (= (type (|lambda#23| arg0@@399 arg1@@156))
                   (MapType0Type BoxType BoxType))
                :pattern ((|lambda#23| arg0@@399 arg1@@156))
                :qid |funType:lambda#23|))))
  (and a!1 a!2)))
(assert (let ((a!1 (forall (($ly@@16 T@U) (|memtable#0@@3| T@U) (|base#0@@3| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.MapApply#canCall|
                                 |memtable#0@@3|
                                 |base#0@@3|)
                               (and (not (= 24 $FunctionContextHeight))
                                    ($Is |memtable#0@@3|
                                         Tclass.MemtableMod.Memtable)
                                    ($Is |base#0@@3|
                                         Tclass.TotalKMMapMod.TotalMap))))
                      (a!2 (forall ((|k#0| T@U))
                             (! (let ((a!1 (|ValueMessage.__default.Merge#canCall|
                                             (MemtableMod.Memtable.Get
                                               |memtable#0@@3|
                                               |k#0|)
                                             ($Unbox DatatypeTypeType
                                                     (MapType0Select (|IMap#Elements| |base#0@@3|)
                                                                     ($Box |k#0|))))))
                                (let ((a!2 (and (|TotalKMMapMod.__default.AnyKey#canCall|
                                                  |k#0|)
                                                (=> (TotalKMMapMod.__default.AnyKey
                                                      |k#0|)
                                                    (and (|MemtableMod.Memtable.Get#canCall|
                                                           |memtable#0@@3|
                                                           |k#0|)
                                                         a!1)))))
                                  (=> (and (= (type |k#0|) (SeqType BoxType))
                                           ($Is |k#0| Tclass.KeyType.Key))
                                      a!2)))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| |base#0@@3|)
                                                                  ($Box |k#0|))))
                                :pattern ((MemtableMod.Memtable.Get
                                            |memtable#0@@3|
                                            |k#0|))
                                :pattern ((TotalKMMapMod.__default.AnyKey |k#0|))
                                :skolemid |1374|
                                :qid |PagedBetreeRefinementidfy.117:10|)))
                      (a!3 (= (PagedBetreeRefinement.__default.MapApply
                                ($LS $ly@@16)
                                |memtable#0@@3|
                                |base#0@@3|)
                              (|IMap#Glue| (|lambda#4| Tclass.KeyType.Key)
                                           (|lambda#23| |memtable#0@@3|
                                                        (|IMap#Elements| |base#0@@3|))
                                           (TIMap Tclass.KeyType.Key
                                                  Tclass.ValueMessage.Message)))))
                  (=> (and (= (type $ly@@16) LayerTypeType)
                           (= (type |memtable#0@@3|) DatatypeTypeType)
                           (= (type |base#0@@3|) (IMapType BoxType BoxType))
                           a!1)
                      (and a!2 a!3)))
                :pattern ((PagedBetreeRefinement.__default.MapApply
                            ($LS $ly@@16)
                            |memtable#0@@3|
                            |base#0@@3|))
                :skolemid |1375|
                :qid |PagedBetreeRefinementidfy.115:22|))))
  (=> (<= 24 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall (($ly@@17 T@U) (|memtable#0@@4| T@U) (|base#0@@4| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.MapApply#canCall|
                                 (Lit |memtable#0@@4|)
                                 |base#0@@4|)
                               (and (not (= 24 $FunctionContextHeight))
                                    ($Is |memtable#0@@4|
                                         Tclass.MemtableMod.Memtable)
                                    ($Is |base#0@@4|
                                         Tclass.TotalKMMapMod.TotalMap))))
                      (a!2 (forall ((|k#0@@0| T@U))
                             (! (let ((a!1 (|ValueMessage.__default.Merge#canCall|
                                             (MemtableMod.Memtable.Get
                                               (Lit |memtable#0@@4|)
                                               |k#0@@0|)
                                             ($Unbox DatatypeTypeType
                                                     (MapType0Select (|IMap#Elements| |base#0@@4|)
                                                                     ($Box |k#0@@0|))))))
                                (let ((a!2 (=> (TotalKMMapMod.__default.AnyKey
                                                 |k#0@@0|)
                                               (and (|MemtableMod.Memtable.Get#canCall|
                                                      (Lit |memtable#0@@4|)
                                                      |k#0@@0|)
                                                    a!1))))
                                  (=> (and (= (type |k#0@@0|) (SeqType BoxType))
                                           ($Is |k#0@@0| Tclass.KeyType.Key))
                                      (and (|TotalKMMapMod.__default.AnyKey#canCall|
                                             |k#0@@0|)
                                           a!2))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| |base#0@@4|)
                                                                  ($Box |k#0@@0|))))
                                :pattern ((MemtableMod.Memtable.Get
                                            |memtable#0@@4|
                                            |k#0@@0|))
                                :pattern ((TotalKMMapMod.__default.AnyKey
                                            |k#0@@0|))
                                :skolemid |1376|
                                :qid |PagedBetreeRefinementidfy.117:10|)))
                      (a!3 (= (PagedBetreeRefinement.__default.MapApply
                                ($LS $ly@@17)
                                (Lit |memtable#0@@4|)
                                |base#0@@4|)
                              (|IMap#Glue| (|lambda#4| Tclass.KeyType.Key)
                                           (|lambda#23| (Lit |memtable#0@@4|)
                                                        (|IMap#Elements| |base#0@@4|))
                                           (TIMap Tclass.KeyType.Key
                                                  Tclass.ValueMessage.Message)))))
                  (=> (and (= (type $ly@@17) LayerTypeType)
                           (= (type |memtable#0@@4|) DatatypeTypeType)
                           (= (type |base#0@@4|) (IMapType BoxType BoxType))
                           a!1)
                      (and a!2 a!3)))
                :pattern ((PagedBetreeRefinement.__default.MapApply
                            ($LS $ly@@17)
                            (Lit |memtable#0@@4|)
                            |base#0@@4|))
                :weight 3
                :skolemid |1377|
                :qid |PagedBetreeRefinementidfy.115:22|))))
  (=> (<= 24 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall (($ly@@18 T@U) (|memtable#0@@5| T@U) (|base#0@@5| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.MapApply#canCall|
                                 (Lit |memtable#0@@5|)
                                 (Lit |base#0@@5|))
                               (and (not (= 24 $FunctionContextHeight))
                                    ($Is |memtable#0@@5|
                                         Tclass.MemtableMod.Memtable)
                                    ($Is |base#0@@5|
                                         Tclass.TotalKMMapMod.TotalMap))))
                      (a!2 (forall ((|k#0@@1| T@U))
                             (! (let ((a!1 ($Unbox DatatypeTypeType
                                                   (MapType0Select (|IMap#Elements| (Lit |base#0@@5|))
                                                                   ($Box |k#0@@1|)))))
                                (let ((a!2 (and (|MemtableMod.Memtable.Get#canCall|
                                                  (Lit |memtable#0@@5|)
                                                  |k#0@@1|)
                                                (|ValueMessage.__default.Merge#canCall|
                                                  (MemtableMod.Memtable.Get
                                                    (Lit |memtable#0@@5|)
                                                    |k#0@@1|)
                                                  a!1))))
                                  (=> (and (= (type |k#0@@1|) (SeqType BoxType))
                                           ($Is |k#0@@1| Tclass.KeyType.Key))
                                      (and (|TotalKMMapMod.__default.AnyKey#canCall|
                                             |k#0@@1|)
                                           (=> (TotalKMMapMod.__default.AnyKey
                                                 |k#0@@1|)
                                               a!2)))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| |base#0@@5|)
                                                                  ($Box |k#0@@1|))))
                                :pattern ((MemtableMod.Memtable.Get
                                            |memtable#0@@5|
                                            |k#0@@1|))
                                :pattern ((TotalKMMapMod.__default.AnyKey
                                            |k#0@@1|))
                                :skolemid |1378|
                                :qid |PagedBetreeRefinementidfy.117:10|)))
                      (a!3 (|IMap#Glue| (|lambda#4| Tclass.KeyType.Key)
                                        (|lambda#23| (Lit |memtable#0@@5|)
                                                     (|IMap#Elements| (Lit |base#0@@5|)))
                                        (TIMap Tclass.KeyType.Key
                                               Tclass.ValueMessage.Message))))
                (let ((a!4 (and a!2
                                (= (PagedBetreeRefinement.__default.MapApply
                                     ($LS $ly@@18)
                                     (Lit |memtable#0@@5|)
                                     (Lit |base#0@@5|))
                                   a!3))))
                  (=> (and (= (type $ly@@18) LayerTypeType)
                           (= (type |memtable#0@@5|) DatatypeTypeType)
                           (= (type |base#0@@5|) (IMapType BoxType BoxType))
                           a!1)
                      a!4)))
                :pattern ((PagedBetreeRefinement.__default.MapApply
                            ($LS $ly@@18)
                            (Lit |memtable#0@@5|)
                            (Lit |base#0@@5|)))
                :weight 3
                :skolemid |1379|
                :qid |PagedBetreeRefinementidfy.115:22|))))
  (=> (<= 24 $FunctionContextHeight) a!1)))
(assert (= (type Tclass.PagedBetree.Path) TyType))
(assert (= (Tag Tclass.PagedBetree.Path) Tagclass.PagedBetree.Path))
(assert (= (TagFamily Tclass.PagedBetree.Path) tytagFamily$Path))
(assert (forall ((bx@@125 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@125)) bx@@125)
                     ($Is ($Unbox DatatypeTypeType bx@@125)
                          Tclass.PagedBetree.Path))))
       (=> (and (= (type bx@@125) BoxType)
                ($IsBox bx@@125 Tclass.PagedBetree.Path))
           a!1))
     :pattern (($IsBox bx@@125 Tclass.PagedBetree.Path))
     :skolemid |1395|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@400 T@U))
  (! (= (type (PagedBetreeRefinement.__default.ReceiptDropFirst arg0@@400))
        DatatypeTypeType)
     :pattern ((PagedBetreeRefinement.__default.ReceiptDropFirst arg0@@400))
     :qid |funType:PagedBetreeRefinement.__default.ReceiptDropFirst|)))
(assert (let ((a!1 (forall ((|receipt#0@@0| T@U))
             (! (let ((a!1 (and (not (= 32 $FunctionContextHeight))
                                ($Is |receipt#0@@0|
                                     Tclass.PagedBetree.QueryReceipt)
                                (PagedBetree.QueryReceipt.Valid |receipt#0@@0|)
                                (INTERNAL_lt_boogie
                                  1
                                  (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                  |receipt#0@@0|))))))
                  (=> (and (= (type |receipt#0@@0|) DatatypeTypeType)
                           (or (|PagedBetreeRefinement.__default.ReceiptDropFirst#canCall|
                                 |receipt#0@@0|)
                               a!1))
                      ($Is (PagedBetreeRefinement.__default.ReceiptDropFirst
                             |receipt#0@@0|)
                           Tclass.PagedBetree.QueryReceipt)))
                :pattern ((PagedBetreeRefinement.__default.ReceiptDropFirst
                            |receipt#0@@0|))
                :skolemid |1414|
                :qid |PagedBetreeRefinementidfy.173:29|))))
  (=> (<= 32 $FunctionContextHeight) a!1)))
(assert (forall ((|receipt#0@@1| T@U))
  (! (let ((a!1 (and (PagedBetree.QueryReceipt.Valid |receipt#0@@1|)
                     (INTERNAL_lt_boogie
                       1
                       (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                       |receipt#0@@1|))))))
       (=> (and (= (type |receipt#0@@1|) DatatypeTypeType)
                ($Is |receipt#0@@1| Tclass.PagedBetree.QueryReceipt))
           (= (|PagedBetreeRefinement.__default.ReceiptDropFirst#requires|
                |receipt#0@@1|)
              a!1)))
     :pattern ((|PagedBetreeRefinement.__default.ReceiptDropFirst#requires|
                 |receipt#0@@1|))
     :skolemid |1415|
     :qid |PagedBetreeRefinementidfy.173:29|)))
(assert (forall ((arg0@@401 T@U))
  (! (= (type (PagedBetree.QueryReceipt.root arg0@@401)) DatatypeTypeType)
     :pattern ((PagedBetree.QueryReceipt.root arg0@@401))
     :qid |funType:PagedBetree.QueryReceipt.root|)))
(assert (let ((a!1 (forall ((|receipt#0@@2| T@U))
             (! (let ((a!1 (and (not (= 32 $FunctionContextHeight))
                                ($Is |receipt#0@@2|
                                     Tclass.PagedBetree.QueryReceipt)
                                (PagedBetree.QueryReceipt.Valid |receipt#0@@2|)
                                (INTERNAL_lt_boogie
                                  1
                                  (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                  |receipt#0@@2|)))))
                      (a!2 (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                              (PagedBetree.BetreeNode.children
                                                (PagedBetree.QueryReceipt.root
                                                  |receipt#0@@2|))))))
                (let ((a!3 ($Unbox DatatypeTypeType
                                   (MapType0Select a!2
                                                   ($Box (PagedBetree.QueryReceipt.key
                                                           |receipt#0@@2|))))))
                (let ((a!4 (= (PagedBetreeRefinement.__default.ReceiptDropFirst
                                |receipt#0@@2|)
                              (|#PagedBetree.QueryReceipt.QueryReceipt|
                                (PagedBetree.QueryReceipt.key |receipt#0@@2|)
                                a!3
                                (|Seq#Drop| (PagedBetree.QueryReceipt.lines
                                              |receipt#0@@2|)
                                            (LitInt 1))))))
                (let ((a!5 (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                  |receipt#0@@2|)
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  |receipt#0@@2|)
                                (PagedBetree.ChildMap.ChildMap_q
                                  (PagedBetree.BetreeNode.children
                                    (PagedBetree.QueryReceipt.root
                                      |receipt#0@@2|)))
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  |receipt#0@@2|)
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  |receipt#0@@2|)
                                a!4)))
                  (=> (and (= (type |receipt#0@@2|) DatatypeTypeType)
                           (or (|PagedBetreeRefinement.__default.ReceiptDropFirst#canCall|
                                 |receipt#0@@2|)
                               a!1))
                      a!5)))))
                :pattern ((PagedBetreeRefinement.__default.ReceiptDropFirst
                            |receipt#0@@2|))
                :skolemid |1416|
                :qid |PagedBetreeRefinementidfy.173:29|))))
  (=> (<= 32 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|receipt#0@@3| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.QueryReceipt.Valid
                                            (Lit |receipt#0@@3|)))))
                      (a!2 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                (Lit |receipt#0@@3|)))))
                      (a!4 (PagedBetree.BetreeNode.children
                             (Lit (PagedBetree.QueryReceipt.root
                                    (Lit |receipt#0@@3|)))))
                      (a!6 ($Box (Lit (PagedBetree.QueryReceipt.key
                                        (Lit |receipt#0@@3|)))))
                      (a!7 (|Seq#Drop| (Lit (PagedBetree.QueryReceipt.lines
                                              (Lit |receipt#0@@3|)))
                                       (LitInt 1))))
                (let ((a!3 (or (|PagedBetreeRefinement.__default.ReceiptDropFirst#canCall|
                                 (Lit |receipt#0@@3|))
                               (and (not (= 32 $FunctionContextHeight))
                                    ($Is |receipt#0@@3|
                                         Tclass.PagedBetree.QueryReceipt)
                                    (U_2_bool a!1)
                                    (INTERNAL_lt_boogie 1 a!2))))
                      (a!5 (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp
                                                   (Lit a!4))))))
                (let ((a!8 (|#PagedBetree.QueryReceipt.QueryReceipt|
                             (Lit (PagedBetree.QueryReceipt.key
                                    (Lit |receipt#0@@3|)))
                             ($Unbox DatatypeTypeType (MapType0Select a!5 a!6))
                             (Lit a!7))))
                (let ((a!9 (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit |receipt#0@@3|))
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit |receipt#0@@3|))
                                (PagedBetree.ChildMap.ChildMap_q (Lit a!4))
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit |receipt#0@@3|))
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit |receipt#0@@3|))
                                (= (PagedBetreeRefinement.__default.ReceiptDropFirst
                                     (Lit |receipt#0@@3|))
                                   a!8))))
                  (=> (and (= (type |receipt#0@@3|) DatatypeTypeType) a!3) a!9)))))
                :pattern ((PagedBetreeRefinement.__default.ReceiptDropFirst
                            (Lit |receipt#0@@3|)))
                :weight 3
                :skolemid |1417|
                :qid |PagedBetreeRefinementidfy.173:29|))))
  (=> (<= 32 $FunctionContextHeight) a!1)))
(assert (= (type Tclass.PagedBetree.Step) TyType))
(assert (= (Tag Tclass.PagedBetree.Step) Tagclass.PagedBetree.Step))
(assert (= (TagFamily Tclass.PagedBetree.Step) tytagFamily$Step))
(assert (forall ((bx@@126 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@126)) bx@@126)
                     ($Is ($Unbox DatatypeTypeType bx@@126)
                          Tclass.PagedBetree.Step))))
       (=> (and (= (type bx@@126) BoxType)
                ($IsBox bx@@126 Tclass.PagedBetree.Step))
           a!1))
     :pattern (($IsBox bx@@126 Tclass.PagedBetree.Step))
     :skolemid |1640|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((|node#0@@6| T@U) (|other#0| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall|
                                 |node#0@@6|
                                 |other#0|)
                               (and (not (= 47 $FunctionContextHeight))
                                    ($Is |node#0@@6|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |other#0|
                                         Tclass.PagedBetree.BetreeNode)))))
                  (=> (and (= (type |node#0@@6|) DatatypeTypeType)
                           (= (type |other#0|) DatatypeTypeType)
                           a!1)
                      true))
                :pattern ((PagedBetreeRefinement.__default.EquivalentBufferCompaction
                            |node#0@@6|
                            |other#0|))
                :skolemid |1675|
                :qid |PagedBetreeRefinementidfy.395:40|))))
  (=> (<= 47 $FunctionContextHeight) a!1)))
(assert (forall ((|node#0@@7| T@U) (|other#0@@0| T@U))
  (! (=> (and (= (type |node#0@@7|) DatatypeTypeType)
              (= (type |other#0@@0|) DatatypeTypeType)
              ($Is |node#0@@7| Tclass.PagedBetree.BetreeNode)
              ($Is |other#0@@0| Tclass.PagedBetree.BetreeNode))
         (= (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#requires|
              |node#0@@7|
              |other#0@@0|)
            true))
     :pattern ((|PagedBetreeRefinement.__default.EquivalentBufferCompaction#requires|
                 |node#0@@7|
                 |other#0@@0|))
     :skolemid |1676|
     :qid |PagedBetreeRefinementidfy.395:40|)))
(assert (let ((a!1 (forall ((|node#0@@8| T@U) (|other#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall|
                                 |node#0@@8|
                                 |other#0@@1|)
                               (and (not (= 47 $FunctionContextHeight))
                                    ($Is |node#0@@8|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |other#0@@1|
                                         Tclass.PagedBetree.BetreeNode))))
                      (a!2 (=> (Buffers.BufferStack.Equivalent
                                 (PagedBetree.BetreeNode.buffers |node#0@@8|)
                                 (PagedBetree.BetreeNode.buffers |other#0@@1|))
                               (and (|$IsA#PagedBetree.ChildMap|
                                      (PagedBetree.BetreeNode.children
                                        |node#0@@8|))
                                    (|$IsA#PagedBetree.ChildMap|
                                      (PagedBetree.BetreeNode.children
                                        |other#0@@1|)))))
                      (a!5 (= (PagedBetreeRefinement.__default.EquivalentBufferCompaction
                                |node#0@@8|
                                |other#0@@1|)
                              (and (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     |node#0@@8|)
                                   (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     |other#0@@1|)
                                   (PagedBetree.BetreeNode.BetreeNode_q
                                     |node#0@@8|)
                                   (PagedBetree.BetreeNode.BetreeNode_q
                                     |other#0@@1|)
                                   (Buffers.BufferStack.Equivalent
                                     (PagedBetree.BetreeNode.buffers
                                       |node#0@@8|)
                                     (PagedBetree.BetreeNode.buffers
                                       |other#0@@1|))
                                   (|PagedBetree.ChildMap#Equal|
                                     (PagedBetree.BetreeNode.children
                                       |node#0@@8|)
                                     (PagedBetree.BetreeNode.children
                                       |other#0@@1|))))))
                (let ((a!3 (=> (PagedBetree.BetreeNode.BetreeNode_q
                                 |other#0@@1|)
                               (and (|Buffers.BufferStack.Equivalent#canCall|
                                      (PagedBetree.BetreeNode.buffers
                                        |node#0@@8|)
                                      (PagedBetree.BetreeNode.buffers
                                        |other#0@@1|))
                                    a!2))))
                (let ((a!4 (and (|PagedBetree.BetreeNode.WF#canCall|
                                  |other#0@@1|)
                                (=> (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |other#0@@1|)
                                    (=> (PagedBetree.BetreeNode.BetreeNode_q
                                          |node#0@@8|)
                                        a!3)))))
                (let ((a!6 (and (|PagedBetree.BetreeNode.WF#canCall|
                                  |node#0@@8|)
                                (=> (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |node#0@@8|)
                                    a!4)
                                a!5)))
                  (=> (and (= (type |node#0@@8|) DatatypeTypeType)
                           (= (type |other#0@@1|) DatatypeTypeType)
                           a!1)
                      a!6)))))
                :pattern ((PagedBetreeRefinement.__default.EquivalentBufferCompaction
                            |node#0@@8|
                            |other#0@@1|))
                :skolemid |1677|
                :qid |PagedBetreeRefinementidfy.395:40|))))
  (=> (<= 47 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|node#0@@9| T@U) (|other#0@@2| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall|
                                 (Lit |node#0@@9|)
                                 (Lit |other#0@@2|))
                               (and (not (= 47 $FunctionContextHeight))
                                    ($Is |node#0@@9|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |other#0@@2|
                                         Tclass.PagedBetree.BetreeNode))))
                      (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit |node#0@@9|)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit |other#0@@2|)))))
                      (a!4 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                            (Lit |node#0@@9|)))))
                      (a!5 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                            (Lit |other#0@@2|)))))
                      (a!6 (|Buffers.BufferStack.Equivalent#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |node#0@@9|)))
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |other#0@@2|)))))
                      (a!7 (Buffers.BufferStack.Equivalent
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |node#0@@9|)))
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |other#0@@2|)))))
                      (a!8 (|$IsA#PagedBetree.ChildMap|
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit |node#0@@9|)))))
                      (a!9 (|$IsA#PagedBetree.ChildMap|
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit |other#0@@2|))))))
                (let ((a!10 (=> (U_2_bool (Lit (bool_2_U a!7))) (and a!8 a!9)))
                      (a!13 (and (PagedBetree.BetreeNode.WF
                                   ($LS $LZ)
                                   (Lit |node#0@@9|))
                                 (PagedBetree.BetreeNode.WF
                                   ($LS $LZ)
                                   (Lit |other#0@@2|))
                                 (PagedBetree.BetreeNode.BetreeNode_q
                                   (Lit |node#0@@9|))
                                 (PagedBetree.BetreeNode.BetreeNode_q
                                   (Lit |other#0@@2|))
                                 a!7
                                 (|PagedBetree.ChildMap#Equal|
                                   (PagedBetree.BetreeNode.children
                                     (Lit |node#0@@9|))
                                   (PagedBetree.BetreeNode.children
                                     (Lit |other#0@@2|))))))
                (let ((a!11 (=> (U_2_bool a!3)
                                (=> (U_2_bool a!4)
                                    (=> (U_2_bool a!5) (and a!6 a!10))))))
                (let ((a!12 (=> (U_2_bool a!2)
                                (and (|PagedBetree.BetreeNode.WF#canCall|
                                       (Lit |other#0@@2|))
                                     a!11))))
                (let ((a!14 (and (|PagedBetree.BetreeNode.WF#canCall|
                                   (Lit |node#0@@9|))
                                 a!12
                                 (= (PagedBetreeRefinement.__default.EquivalentBufferCompaction
                                      (Lit |node#0@@9|)
                                      (Lit |other#0@@2|))
                                    a!13))))
                  (=> (and (= (type |node#0@@9|) DatatypeTypeType)
                           (= (type |other#0@@2|) DatatypeTypeType)
                           a!1)
                      a!14))))))
                :pattern ((PagedBetreeRefinement.__default.EquivalentBufferCompaction
                            (Lit |node#0@@9|)
                            (Lit |other#0@@2|)))
                :weight 3
                :skolemid |1678|
                :qid |PagedBetreeRefinementidfy.395:40|))))
  (=> (<= 47 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|v#0@@3| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.Inv#canCall|
                                 |v#0@@3|)
                               (and (not (= 49 $FunctionContextHeight))
                                    ($Is |v#0@@3| Tclass.PagedBetree.Variables)))))
                  (=> (and (= (type |v#0@@3|) DatatypeTypeType) a!1) true))
                :pattern ((PagedBetreeRefinement.__default.Inv |v#0@@3|))
                :skolemid |1691|
                :qid |PagedBetreeRefinementidfy.421:17|))))
  (=> (<= 49 $FunctionContextHeight) a!1)))
(assert (forall ((|v#0@@4| T@U))
  (! (=> (and (= (type |v#0@@4|) DatatypeTypeType)
              ($Is |v#0@@4| Tclass.PagedBetree.Variables))
         (= (|PagedBetreeRefinement.__default.Inv#requires| |v#0@@4|) true))
     :pattern ((|PagedBetreeRefinement.__default.Inv#requires| |v#0@@4|))
     :skolemid |1692|
     :qid |PagedBetreeRefinementidfy.421:17|)))
(assert (let ((a!1 (forall ((|v#0@@5| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.Inv#canCall|
                                 |v#0@@5|)
                               (and (not (= 49 $FunctionContextHeight))
                                    ($Is |v#0@@5| Tclass.PagedBetree.Variables))))
                      (a!2 (=> (U_2_bool (Lit (bool_2_U true)))
                               (|PagedBetree.Variables.WF#canCall| |v#0@@5|))))
                (let ((a!3 (and a!2
                                (= (PagedBetreeRefinement.__default.Inv
                                     |v#0@@5|)
                                   (and true
                                        (PagedBetree.Variables.WF |v#0@@5|))))))
                  (=> (and (= (type |v#0@@5|) DatatypeTypeType) a!1) a!3)))
                :pattern ((PagedBetreeRefinement.__default.Inv |v#0@@5|))
                :skolemid |1693|
                :qid |PagedBetreeRefinementidfy.421:17|))))
  (=> (<= 49 $FunctionContextHeight) a!1)))
(assert (let ((a!1 (forall ((|v#0@@6| T@U))
             (! (let ((a!1 (or (|PagedBetreeRefinement.__default.Inv#canCall|
                                 (Lit |v#0@@6|))
                               (and (not (= 49 $FunctionContextHeight))
                                    ($Is |v#0@@6| Tclass.PagedBetree.Variables))))
                      (a!2 (=> (U_2_bool (Lit (bool_2_U true)))
                               (|PagedBetree.Variables.WF#canCall|
                                 (Lit |v#0@@6|))))
                      (a!3 (bool_2_U (and true
                                          (PagedBetree.Variables.WF
                                            (Lit |v#0@@6|))))))
                (let ((a!4 (and a!2
                                (= (PagedBetreeRefinement.__default.Inv
                                     (Lit |v#0@@6|))
                                   (U_2_bool (Lit a!3))))))
                  (=> (and (= (type |v#0@@6|) DatatypeTypeType) a!1) a!4)))
                :pattern ((PagedBetreeRefinement.__default.Inv (Lit |v#0@@6|)))
                :weight 3
                :skolemid |1694|
                :qid |PagedBetreeRefinementidfy.421:17|))))
  (=> (<= 49 $FunctionContextHeight) a!1)))
(assert (= (type Tclass.MsgHistoryMod.KeyedMessage) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.KeyedMessage) Tagclass.MsgHistoryMod.KeyedMessage))
(assert (= (TagFamily Tclass.MsgHistoryMod.KeyedMessage) tytagFamily$KeyedMessage))
(assert (forall ((bx@@127 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@127)) bx@@127)
                     ($Is ($Unbox DatatypeTypeType bx@@127)
                          Tclass.MsgHistoryMod.KeyedMessage))))
       (=> (and (= (type bx@@127) BoxType)
                ($IsBox bx@@127 Tclass.MsgHistoryMod.KeyedMessage))
           a!1))
     :pattern (($IsBox bx@@127 Tclass.MsgHistoryMod.KeyedMessage))
     :skolemid |1734|
     :qid |unknown.0:0|)))
(assert (= (type |#Options.Option.None|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#Options.Option.None|) |##Options.Option.None|))
(assert (forall ((d@@16 T@U))
  (! (=> (= (type d@@16) DatatypeTypeType)
         (= (Options.Option.None_q d@@16)
            (= (DatatypeCtorId d@@16) |##Options.Option.None|)))
     :pattern ((Options.Option.None_q d@@16))
     :skolemid |1816|
     :qid |unknown.0:0|)))
(assert (forall ((d@@17 T@U))
  (! (=> (and (= (type d@@17) DatatypeTypeType) (Options.Option.None_q d@@17))
         (= d@@17 |#Options.Option.None|))
     :pattern ((Options.Option.None_q d@@17))
     :skolemid |1817|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@402 T@U))
  (! (= (type (Tclass.Options.Option arg0@@402)) TyType)
     :pattern ((Tclass.Options.Option arg0@@402))
     :qid |funType:Tclass.Options.Option|)))
(assert (forall ((Options.Option$V T@U))
  (! (let ((a!1 (and (= (Tag (Tclass.Options.Option Options.Option$V))
                        Tagclass.Options.Option)
                     (= (TagFamily (Tclass.Options.Option Options.Option$V))
                        tytagFamily$Option))))
       (=> (= (type Options.Option$V) TyType) a!1))
     :pattern ((Tclass.Options.Option Options.Option$V))
     :skolemid |1818|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@403 T@U))
  (! (= (type (Tclass.Options.Option_0 arg0@@403)) TyType)
     :pattern ((Tclass.Options.Option_0 arg0@@403))
     :qid |funType:Tclass.Options.Option_0|)))
(assert (forall ((Options.Option$V@@0 T@U))
  (! (=> (= (type Options.Option$V@@0) TyType)
         (= (Tclass.Options.Option_0
              (Tclass.Options.Option Options.Option$V@@0))
            Options.Option$V@@0))
     :pattern ((Tclass.Options.Option Options.Option$V@@0))
     :skolemid |1819|
     :qid |unknown.0:0|)))
(assert (forall ((Options.Option$V@@1 T@U) (bx@@128 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@128)) bx@@128)
                     ($Is ($Unbox DatatypeTypeType bx@@128)
                          (Tclass.Options.Option Options.Option$V@@1)))))
       (=> (and (= (type Options.Option$V@@1) TyType)
                (= (type bx@@128) BoxType)
                ($IsBox bx@@128 (Tclass.Options.Option Options.Option$V@@1)))
           a!1))
     :pattern (($IsBox bx@@128 (Tclass.Options.Option Options.Option$V@@1)))
     :skolemid |1820|
     :qid |unknown.0:0|)))
(assert (forall ((Options.Option$V@@2 T@U))
  (! (=> (= (type Options.Option$V@@2) TyType)
         ($Is |#Options.Option.None|
              (Tclass.Options.Option Options.Option$V@@2)))
     :pattern (($Is |#Options.Option.None|
                    (Tclass.Options.Option Options.Option$V@@2)))
     :skolemid |1821|
     :qid |unknown.0:0|)))
(assert (forall ((Options.Option$V@@3 T@U) ($h@@50 T@U))
  (! (=> (and (= (type Options.Option$V@@3) TyType)
              (= (type $h@@50) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@50))
         ($IsAlloc |#Options.Option.None|
                   (Tclass.Options.Option Options.Option$V@@3)
                   $h@@50))
     :pattern (($IsAlloc |#Options.Option.None|
                         (Tclass.Options.Option Options.Option$V@@3)
                         $h@@50))
     :skolemid |1822|
     :qid |unknown.0:0|)))
(assert (= |#Options.Option.None| (Lit |#Options.Option.None|)))
(assert (forall ((arg0@@404 T@U))
  (! (= (type (|#Options.Option.Some| arg0@@404)) DatatypeTypeType)
     :pattern ((|#Options.Option.Some| arg0@@404))
     :qid |funType:#Options.Option.Some|)))
(assert (forall ((|a#5#0#0@@0| T@U))
  (! (=> (= (type |a#5#0#0@@0|) BoxType)
         (= (DatatypeCtorId (|#Options.Option.Some| |a#5#0#0@@0|))
            |##Options.Option.Some|))
     :pattern ((|#Options.Option.Some| |a#5#0#0@@0|))
     :skolemid |1823|
     :qid |Optionsdfy.5:36|)))
(assert (forall ((d@@18 T@U))
  (! (=> (= (type d@@18) DatatypeTypeType)
         (= (Options.Option.Some_q d@@18)
            (= (DatatypeCtorId d@@18) |##Options.Option.Some|)))
     :pattern ((Options.Option.Some_q d@@18))
     :skolemid |1824|
     :qid |unknown.0:0|)))
(assert (forall ((d@@19 T@U))
  (! (let ((a!1 (exists ((|a#6#0#0@@0| T@U))
                  (! (and (= (type |a#6#0#0@@0|) BoxType)
                          (= d@@19 (|#Options.Option.Some| |a#6#0#0@@0|)))
                     :no-pattern (type |a#6#0#0@@0|)
                     :no-pattern (U_2_int |a#6#0#0@@0|)
                     :no-pattern (U_2_bool |a#6#0#0@@0|)
                     :skolemid |1825|
                     :qid |Optionsdfy.5:36|))))
       (=> (and (= (type d@@19) DatatypeTypeType) (Options.Option.Some_q d@@19))
           a!1))
     :pattern ((Options.Option.Some_q d@@19))
     :skolemid |1826|
     :qid |unknown.0:0|)))
(assert (forall ((Options.Option$V@@4 T@U) (|a#7#0#0@@0| T@U))
  (! (=> (and (= (type Options.Option$V@@4) TyType)
              (= (type |a#7#0#0@@0|) BoxType))
         (= ($Is (|#Options.Option.Some| |a#7#0#0@@0|)
                 (Tclass.Options.Option Options.Option$V@@4))
            ($IsBox |a#7#0#0@@0| Options.Option$V@@4)))
     :pattern (($Is (|#Options.Option.Some| |a#7#0#0@@0|)
                    (Tclass.Options.Option Options.Option$V@@4)))
     :skolemid |1827|
     :qid |unknown.0:0|)))
(assert (forall ((Options.Option$V@@5 T@U) (|a#8#0#0@@0| T@U) ($h@@51 T@U))
  (! (=> (and (= (type Options.Option$V@@5) TyType)
              (= (type |a#8#0#0@@0|) BoxType)
              (= (type $h@@51) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@51))
         (= ($IsAlloc (|#Options.Option.Some| |a#8#0#0@@0|)
                      (Tclass.Options.Option Options.Option$V@@5)
                      $h@@51)
            ($IsAllocBox |a#8#0#0@@0| Options.Option$V@@5 $h@@51)))
     :pattern (($IsAlloc (|#Options.Option.Some| |a#8#0#0@@0|)
                         (Tclass.Options.Option Options.Option$V@@5)
                         $h@@51))
     :skolemid |1828|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@405 T@U))
  (! (= (type (Options.Option.value arg0@@405)) BoxType)
     :pattern ((Options.Option.value arg0@@405))
     :qid |funType:Options.Option.value|)))
(assert (forall ((d@@20 T@U) (Options.Option$V@@6 T@U) ($h@@52 T@U))
  (! (=> (and (= (type d@@20) DatatypeTypeType)
              (= (type Options.Option$V@@6) TyType)
              (= (type $h@@52) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@52)
              (Options.Option.Some_q d@@20)
              ($IsAlloc d@@20
                        (Tclass.Options.Option Options.Option$V@@6)
                        $h@@52))
         ($IsAllocBox (Options.Option.value d@@20) Options.Option$V@@6 $h@@52))
     :pattern (($IsAllocBox (Options.Option.value d@@20)
                            Options.Option$V@@6
                            $h@@52))
     :skolemid |1829|
     :qid |unknown.0:0|)))
(assert (forall ((|a#9#0#0| T@U))
  (! (=> (= (type |a#9#0#0|) BoxType)
         (= (|#Options.Option.Some| (Lit |a#9#0#0|))
            (Lit (|#Options.Option.Some| |a#9#0#0|))))
     :pattern ((|#Options.Option.Some| (Lit |a#9#0#0|)))
     :skolemid |1830|
     :qid |Optionsdfy.5:36|)))
(assert (forall ((|a#10#0#0| T@U))
  (! (=> (= (type |a#10#0#0|) BoxType)
         (= (Options.Option.value (|#Options.Option.Some| |a#10#0#0|))
            |a#10#0#0|))
     :pattern ((|#Options.Option.Some| |a#10#0#0|))
     :skolemid |1831|
     :qid |Optionsdfy.5:36|)))
(assert (forall ((|a#11#0#0| T@U))
  (! (=> (= (type |a#11#0#0|) BoxType)
         (< (BoxRank |a#11#0#0|) (DtRank (|#Options.Option.Some| |a#11#0#0|))))
     :pattern ((|#Options.Option.Some| |a#11#0#0|))
     :skolemid |1832|
     :qid |Optionsdfy.5:36|)))
(assert (forall ((d@@21 T@U))
  (! (=> (and (= (type d@@21) DatatypeTypeType) (|$IsA#Options.Option| d@@21))
         (or (Options.Option.None_q d@@21) (Options.Option.Some_q d@@21)))
     :pattern ((|$IsA#Options.Option| d@@21))
     :skolemid |1833|
     :qid |unknown.0:0|)))
(assert (forall ((Options.Option$V@@7 T@U) (d@@22 T@U))
  (! (=> (and (= (type Options.Option$V@@7) TyType)
              (= (type d@@22) DatatypeTypeType)
              ($Is d@@22 (Tclass.Options.Option Options.Option$V@@7)))
         (or (Options.Option.None_q d@@22) (Options.Option.Some_q d@@22)))
     :pattern ((Options.Option.Some_q d@@22)
               ($Is d@@22 (Tclass.Options.Option Options.Option$V@@7)))
     :pattern ((Options.Option.None_q d@@22)
               ($Is d@@22 (Tclass.Options.Option Options.Option$V@@7)))
     :skolemid |1834|
     :qid |unknown.0:0|)))
(assert (forall ((a@@118 T@U) (b@@67 T@U))
  (! (=> (and (= (type a@@118) DatatypeTypeType)
              (= (type b@@67) DatatypeTypeType)
              (Options.Option.None_q a@@118)
              (Options.Option.None_q b@@67))
         (= (|Options.Option#Equal| a@@118 b@@67) true))
     :pattern ((|Options.Option#Equal| a@@118 b@@67)
               (Options.Option.None_q a@@118))
     :pattern ((|Options.Option#Equal| a@@118 b@@67)
               (Options.Option.None_q b@@67))
     :skolemid |1835|
     :qid |unknown.0:0|)))
(assert (forall ((a@@119 T@U) (b@@68 T@U))
  (! (=> (and (= (type a@@119) DatatypeTypeType)
              (= (type b@@68) DatatypeTypeType)
              (Options.Option.Some_q a@@119)
              (Options.Option.Some_q b@@68))
         (= (|Options.Option#Equal| a@@119 b@@68)
            (= (Options.Option.value a@@119) (Options.Option.value b@@68))))
     :pattern ((|Options.Option#Equal| a@@119 b@@68)
               (Options.Option.Some_q a@@119))
     :pattern ((|Options.Option#Equal| a@@119 b@@68)
               (Options.Option.Some_q b@@68))
     :skolemid |1836|
     :qid |unknown.0:0|)))
(assert (forall ((a@@120 T@U) (b@@69 T@U))
  (! (=> (and (= (type a@@120) DatatypeTypeType)
              (= (type b@@69) DatatypeTypeType))
         (= (|Options.Option#Equal| a@@120 b@@69) (= a@@120 b@@69)))
     :pattern ((|Options.Option#Equal| a@@120 b@@69))
     :skolemid |1837|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.Options.__default) TyType))
(assert (= (Tag Tclass.Options.__default) Tagclass.Options.__default))
(assert (= (TagFamily Tclass.Options.__default) tytagFamily$_default))
(assert (forall ((bx@@129 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@129)) bx@@129)
                     ($Is ($Unbox refType bx@@129) Tclass.Options.__default))))
       (=> (and (= (type bx@@129) BoxType)
                ($IsBox bx@@129 Tclass.Options.__default))
           a!1))
     :pattern (($IsBox bx@@129 Tclass.Options.__default))
     :skolemid |1838|
     :qid |unknown.0:0|)))
(assert (forall (($o@@11 T@U))
  (! (let ((a!1 (= ($Is $o@@11 Tclass.Options.__default)
                   (or (= $o@@11 null)
                       (= (dtype $o@@11) Tclass.Options.__default)))))
       (=> (= (type $o@@11) refType) a!1))
     :pattern (($Is $o@@11 Tclass.Options.__default))
     :skolemid |1839|
     :qid |unknown.0:0|)))
(assert (forall (($o@@12 T@U) ($h@@53 T@U))
  (! (let ((a!1 (or (= $o@@12 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@53 $o@@12)
                                              alloc)))))
       (=> (and (= (type $o@@12) refType)
                (= (type $h@@53) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@12 Tclass.Options.__default $h@@53) a!1)))
     :pattern (($IsAlloc $o@@12 Tclass.Options.__default $h@@53))
     :skolemid |1840|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@406 T@U)
         (arg1@@157 T@U)
         (arg2@@83 T@U)
         (arg3@@45 T@U)
         (arg4@@28 T@U))
  (! (= (type (Options.__default.MapOption
                arg0@@406
                arg1@@157
                arg2@@83
                arg3@@45
                arg4@@28))
        DatatypeTypeType)
     :pattern ((Options.__default.MapOption
                 arg0@@406
                 arg1@@157
                 arg2@@83
                 arg3@@45
                 arg4@@28))
     :qid |funType:Options.__default.MapOption|)))
(assert (forall ((Options._default.MapOption$V0 T@U)
         (Options._default.MapOption$V1 T@U)
         ($h0 T@U)
         ($h1 T@U)
         (|opt#0| T@U)
         (|f#0@@67| T@U))
  (! (let ((a!1 (or (|Options.__default.MapOption#canCall|
                      Options._default.MapOption$V0
                      Options._default.MapOption$V1
                      $h0
                      |opt#0|
                      |f#0@@67|)
                    (and ($Is |opt#0|
                              (Tclass.Options.Option
                                Options._default.MapOption$V0))
                         ($Is |f#0@@67|
                              (Tclass._System.___hFunc1
                                Options._default.MapOption$V0
                                Options._default.MapOption$V1)))))
           (a!2 (forall (($o@@13 T@U) ($f T@U))
                  (! (let ((a!1 (= (type $f)
                                   (FieldType (FieldTypeInv0 (type $f)))))
                           (a!2 (MapType0Select (ite (Options.Option.Some_q
                                                       |opt#0|)
                                                     (Reads1 Options._default.MapOption$V0
                                                             Options._default.MapOption$V1
                                                             $h0
                                                             |f#0@@67|
                                                             (Options.Option.value
                                                               |opt#0|))
                                                     (|Set#Empty| BoxType))
                                                ($Box $o@@13))))
                       (=> (and (= (type $o@@13) refType)
                                a!1
                                (not (= $o@@13 null))
                                (U_2_bool a!2))
                           (= (MapType1Select (MapType0Select $h0 $o@@13) $f)
                              (MapType1Select (MapType0Select $h1 $o@@13) $f))))
                     :no-pattern (type $o@@13)
                     :no-pattern (type $f)
                     :no-pattern (U_2_int $o@@13)
                     :no-pattern (U_2_bool $o@@13)
                     :no-pattern (U_2_int $f)
                     :no-pattern (U_2_bool $f)
                     :skolemid |1841|
                     :qid |unknown.0:0|))))
       (=> (and (= (type Options._default.MapOption$V0) TyType)
                (= (type Options._default.MapOption$V1) TyType)
                (= (type $h0) (MapType0Type refType MapType1Type))
                (= (type $h1) (MapType0Type refType MapType1Type))
                (= (type |opt#0|) DatatypeTypeType)
                (= (type |f#0@@67|) HandleTypeType)
                ($IsGoodHeap $h0)
                ($IsGoodHeap $h1)
                a!1
                ($IsHeapAnchor $h0)
                ($HeapSucc $h0 $h1)
                a!2)
           (= (Options.__default.MapOption
                Options._default.MapOption$V0
                Options._default.MapOption$V1
                $h0
                |opt#0|
                |f#0@@67|)
              (Options.__default.MapOption
                Options._default.MapOption$V0
                Options._default.MapOption$V1
                $h1
                |opt#0|
                |f#0@@67|))))
     :pattern (($IsHeapAnchor $h0)
               ($HeapSucc $h0 $h1)
               (Options.__default.MapOption
                 Options._default.MapOption$V0
                 Options._default.MapOption$V1
                 $h1
                 |opt#0|
                 |f#0@@67|))
     :skolemid |1842|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Options._default.MapOption$V0@@0 T@U)
                    (Options._default.MapOption$V1@@0 T@U)
                    ($Heap T@U)
                    (|opt#0@@0| T@U)
                    (|f#0@@68| T@U))
             (! (let ((a!1 (and ($IsGoodHeap $Heap)
                                ($Is |opt#0@@0|
                                     (Tclass.Options.Option
                                       Options._default.MapOption$V0@@0))
                                ($Is |f#0@@68|
                                     (Tclass._System.___hFunc1
                                       Options._default.MapOption$V0@@0
                                       Options._default.MapOption$V1@@0))
                                (=> (Options.Option.Some_q |opt#0@@0|)
                                    (Requires1 Options._default.MapOption$V0@@0
                                               Options._default.MapOption$V1@@0
                                               $Heap
                                               |f#0@@68|
                                               (Options.Option.value |opt#0@@0|)))))
                      (a!2 (=> (Options.Option.Some_q
                                 (Options.__default.MapOption
                                   Options._default.MapOption$V0@@0
                                   Options._default.MapOption$V1@@0
                                   $Heap
                                   |opt#0@@0|
                                   |f#0@@68|))
                               (= (Options.Option.value
                                    (Options.__default.MapOption
                                      Options._default.MapOption$V0@@0
                                      Options._default.MapOption$V1@@0
                                      $Heap
                                      |opt#0@@0|
                                      |f#0@@68|))
                                  (Apply1 Options._default.MapOption$V0@@0
                                          Options._default.MapOption$V1@@0
                                          $Heap
                                          |f#0@@68|
                                          (Options.Option.value |opt#0@@0|))))))
                (let ((a!3 (and (= (Options.Option.Some_q |opt#0@@0|)
                                   (Options.Option.Some_q
                                     (Options.__default.MapOption
                                       Options._default.MapOption$V0@@0
                                       Options._default.MapOption$V1@@0
                                       $Heap
                                       |opt#0@@0|
                                       |f#0@@68|)))
                                a!2
                                ($Is (Options.__default.MapOption
                                       Options._default.MapOption$V0@@0
                                       Options._default.MapOption$V1@@0
                                       $Heap
                                       |opt#0@@0|
                                       |f#0@@68|)
                                     (Tclass.Options.Option
                                       Options._default.MapOption$V1@@0)))))
                  (=> (and (= (type Options._default.MapOption$V0@@0) TyType)
                           (= (type Options._default.MapOption$V1@@0) TyType)
                           (= (type $Heap) (MapType0Type refType MapType1Type))
                           (= (type |opt#0@@0|) DatatypeTypeType)
                           (= (type |f#0@@68|) HandleTypeType)
                           (or (|Options.__default.MapOption#canCall|
                                 Options._default.MapOption$V0@@0
                                 Options._default.MapOption$V1@@0
                                 $Heap
                                 |opt#0@@0|
                                 |f#0@@68|)
                               a!1))
                      a!3)))
                :pattern ((Options.__default.MapOption
                            Options._default.MapOption$V0@@0
                            Options._default.MapOption$V1@@0
                            $Heap
                            |opt#0@@0|
                            |f#0@@68|))
                :skolemid |1843|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Options._default.MapOption$V0@@1 T@U)
         (Options._default.MapOption$V1@@1 T@U)
         ($Heap@@0 T@U)
         (|opt#0@@1| T@U)
         (|f#0@@69| T@U))
  (! (let ((a!1 (= (|Options.__default.MapOption#requires|
                     Options._default.MapOption$V0@@1
                     Options._default.MapOption$V1@@1
                     $Heap@@0
                     |opt#0@@1|
                     |f#0@@69|)
                   (=> (Options.Option.Some_q |opt#0@@1|)
                       (Requires1 Options._default.MapOption$V0@@1
                                  Options._default.MapOption$V1@@1
                                  $Heap@@0
                                  |f#0@@69|
                                  (Options.Option.value |opt#0@@1|))))))
       (=> (and (= (type Options._default.MapOption$V0@@1) TyType)
                (= (type Options._default.MapOption$V1@@1) TyType)
                (= (type $Heap@@0) (MapType0Type refType MapType1Type))
                (= (type |opt#0@@1|) DatatypeTypeType)
                (= (type |f#0@@69|) HandleTypeType)
                ($IsGoodHeap $Heap@@0)
                ($Is |opt#0@@1|
                     (Tclass.Options.Option Options._default.MapOption$V0@@1))
                ($Is |f#0@@69|
                     (Tclass._System.___hFunc1
                       Options._default.MapOption$V0@@1
                       Options._default.MapOption$V1@@1)))
           a!1))
     :pattern ((|Options.__default.MapOption#requires|
                 Options._default.MapOption$V0@@1
                 Options._default.MapOption$V1@@1
                 $Heap@@0
                 |opt#0@@1|
                 |f#0@@69|)
               ($IsGoodHeap $Heap@@0))
     :skolemid |1844|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Options._default.MapOption$V0@@2 T@U)
                    (Options._default.MapOption$V1@@2 T@U)
                    ($Heap@@1 T@U)
                    (|opt#0@@2| T@U)
                    (|f#0@@70| T@U))
             (! (let ((a!1 (and ($IsGoodHeap $Heap@@1)
                                ($Is |opt#0@@2|
                                     (Tclass.Options.Option
                                       Options._default.MapOption$V0@@2))
                                ($Is |f#0@@70|
                                     (Tclass._System.___hFunc1
                                       Options._default.MapOption$V0@@2
                                       Options._default.MapOption$V1@@2))
                                (=> (Options.Option.Some_q |opt#0@@2|)
                                    (Requires1 Options._default.MapOption$V0@@2
                                               Options._default.MapOption$V1@@2
                                               $Heap@@1
                                               |f#0@@70|
                                               (Options.Option.value |opt#0@@2|)))))
                      (a!2 (ite (Options.Option.None_q |opt#0@@2|)
                                |#Options.Option.None|
                                (|#Options.Option.Some|
                                  (Apply1 Options._default.MapOption$V0@@2
                                          Options._default.MapOption$V1@@2
                                          $Heap@@1
                                          |f#0@@70|
                                          (Options.Option.value |opt#0@@2|))))))
                  (=> (and (= (type Options._default.MapOption$V0@@2) TyType)
                           (= (type Options._default.MapOption$V1@@2) TyType)
                           (= (type $Heap@@1)
                              (MapType0Type refType MapType1Type))
                           (= (type |opt#0@@2|) DatatypeTypeType)
                           (= (type |f#0@@70|) HandleTypeType)
                           (or (|Options.__default.MapOption#canCall|
                                 Options._default.MapOption$V0@@2
                                 Options._default.MapOption$V1@@2
                                 $Heap@@1
                                 |opt#0@@2|
                                 |f#0@@70|)
                               a!1))
                      (= (Options.__default.MapOption
                           Options._default.MapOption$V0@@2
                           Options._default.MapOption$V1@@2
                           $Heap@@1
                           |opt#0@@2|
                           |f#0@@70|)
                         a!2)))
                :pattern ((Options.__default.MapOption
                            Options._default.MapOption$V0@@2
                            Options._default.MapOption$V1@@2
                            $Heap@@1
                            |opt#0@@2|
                            |f#0@@70|)
                          ($IsGoodHeap $Heap@@1))
                :skolemid |1845|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@407 T@U)
         (arg1@@158 T@U)
         (arg2@@84 T@U)
         (arg3@@46 T@U)
         (arg4@@29 T@U))
  (! (= (type (Options.__default.FlatMapOption
                arg0@@407
                arg1@@158
                arg2@@84
                arg3@@46
                arg4@@29))
        DatatypeTypeType)
     :pattern ((Options.__default.FlatMapOption
                 arg0@@407
                 arg1@@158
                 arg2@@84
                 arg3@@46
                 arg4@@29))
     :qid |funType:Options.__default.FlatMapOption|)))
(assert (forall ((Options._default.FlatMapOption$V0 T@U)
         (Options._default.FlatMapOption$V1 T@U)
         ($h0@@0 T@U)
         ($h1@@0 T@U)
         (|opt#0@@3| T@U)
         (|f#0@@71| T@U))
  (! (let ((a!1 (and ($Is |opt#0@@3|
                          (Tclass.Options.Option
                            Options._default.FlatMapOption$V0))
                     ($Is |f#0@@71|
                          (Tclass._System.___hFunc1
                            Options._default.FlatMapOption$V0
                            (Tclass.Options.Option
                              Options._default.FlatMapOption$V1)))))
           (a!2 (forall (($o@@14 T@U) ($f@@0 T@U))
                  (! (let ((a!1 (= (type $f@@0)
                                   (FieldType (FieldTypeInv0 (type $f@@0)))))
                           (a!2 (MapType0Select (ite (Options.Option.Some_q
                                                       |opt#0@@3|)
                                                     (Reads1 Options._default.FlatMapOption$V0
                                                             (Tclass.Options.Option
                                                               Options._default.FlatMapOption$V1)
                                                             $h0@@0
                                                             |f#0@@71|
                                                             (Options.Option.value
                                                               |opt#0@@3|))
                                                     (|Set#Empty| BoxType))
                                                ($Box $o@@14))))
                       (=> (and (= (type $o@@14) refType)
                                a!1
                                (not (= $o@@14 null))
                                (U_2_bool a!2))
                           (= (MapType1Select (MapType0Select $h0@@0 $o@@14)
                                              $f@@0)
                              (MapType1Select (MapType0Select $h1@@0 $o@@14)
                                              $f@@0))))
                     :no-pattern (type $o@@14)
                     :no-pattern (type $f@@0)
                     :no-pattern (U_2_int $o@@14)
                     :no-pattern (U_2_bool $o@@14)
                     :no-pattern (U_2_int $f@@0)
                     :no-pattern (U_2_bool $f@@0)
                     :skolemid |1846|
                     :qid |unknown.0:0|))))
       (=> (and (= (type Options._default.FlatMapOption$V0) TyType)
                (= (type Options._default.FlatMapOption$V1) TyType)
                (= (type $h0@@0) (MapType0Type refType MapType1Type))
                (= (type $h1@@0) (MapType0Type refType MapType1Type))
                (= (type |opt#0@@3|) DatatypeTypeType)
                (= (type |f#0@@71|) HandleTypeType)
                ($IsGoodHeap $h0@@0)
                ($IsGoodHeap $h1@@0)
                (or (|Options.__default.FlatMapOption#canCall|
                      Options._default.FlatMapOption$V0
                      Options._default.FlatMapOption$V1
                      $h0@@0
                      |opt#0@@3|
                      |f#0@@71|)
                    a!1)
                ($IsHeapAnchor $h0@@0)
                ($HeapSucc $h0@@0 $h1@@0)
                a!2)
           (= (Options.__default.FlatMapOption
                Options._default.FlatMapOption$V0
                Options._default.FlatMapOption$V1
                $h0@@0
                |opt#0@@3|
                |f#0@@71|)
              (Options.__default.FlatMapOption
                Options._default.FlatMapOption$V0
                Options._default.FlatMapOption$V1
                $h1@@0
                |opt#0@@3|
                |f#0@@71|))))
     :pattern (($IsHeapAnchor $h0@@0)
               ($HeapSucc $h0@@0 $h1@@0)
               (Options.__default.FlatMapOption
                 Options._default.FlatMapOption$V0
                 Options._default.FlatMapOption$V1
                 $h1@@0
                 |opt#0@@3|
                 |f#0@@71|))
     :skolemid |1847|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Options._default.FlatMapOption$V0@@0 T@U)
                    (Options._default.FlatMapOption$V1@@0 T@U)
                    ($Heap@@2 T@U)
                    (|opt#0@@4| T@U)
                    (|f#0@@72| T@U))
             (! (let ((a!1 (and ($IsGoodHeap $Heap@@2)
                                ($Is |opt#0@@4|
                                     (Tclass.Options.Option
                                       Options._default.FlatMapOption$V0@@0))
                                ($Is |f#0@@72|
                                     (Tclass._System.___hFunc1
                                       Options._default.FlatMapOption$V0@@0
                                       (Tclass.Options.Option
                                         Options._default.FlatMapOption$V1@@0)))
                                (=> (Options.Option.Some_q |opt#0@@4|)
                                    (Requires1 Options._default.FlatMapOption$V0@@0
                                               (Tclass.Options.Option
                                                 Options._default.FlatMapOption$V1@@0)
                                               $Heap@@2
                                               |f#0@@72|
                                               (Options.Option.value |opt#0@@4|)))))
                      (a!2 ($Unbox DatatypeTypeType
                                   (Apply1 Options._default.FlatMapOption$V0@@0
                                           (Tclass.Options.Option
                                             Options._default.FlatMapOption$V1@@0)
                                           $Heap@@2
                                           |f#0@@72|
                                           (Options.Option.value |opt#0@@4|)))))
                (let ((a!3 (=> (and (Options.Option.Some_q |opt#0@@4|)
                                    (Options.Option.Some_q a!2))
                               (= (Options.Option.value
                                    (Options.__default.FlatMapOption
                                      Options._default.FlatMapOption$V0@@0
                                      Options._default.FlatMapOption$V1@@0
                                      $Heap@@2
                                      |opt#0@@4|
                                      |f#0@@72|))
                                  (Options.Option.value a!2)))))
                (let ((a!4 (and (=> (and (Options.Option.Some_q |opt#0@@4|)
                                         (Options.Option.Some_q a!2))
                                    (Options.Option.Some_q
                                      (Options.__default.FlatMapOption
                                        Options._default.FlatMapOption$V0@@0
                                        Options._default.FlatMapOption$V1@@0
                                        $Heap@@2
                                        |opt#0@@4|
                                        |f#0@@72|)))
                                a!3
                                ($Is (Options.__default.FlatMapOption
                                       Options._default.FlatMapOption$V0@@0
                                       Options._default.FlatMapOption$V1@@0
                                       $Heap@@2
                                       |opt#0@@4|
                                       |f#0@@72|)
                                     (Tclass.Options.Option
                                       Options._default.FlatMapOption$V1@@0)))))
                  (=> (and (= (type Options._default.FlatMapOption$V0@@0)
                              TyType)
                           (= (type Options._default.FlatMapOption$V1@@0)
                              TyType)
                           (= (type $Heap@@2)
                              (MapType0Type refType MapType1Type))
                           (= (type |opt#0@@4|) DatatypeTypeType)
                           (= (type |f#0@@72|) HandleTypeType)
                           (or (|Options.__default.FlatMapOption#canCall|
                                 Options._default.FlatMapOption$V0@@0
                                 Options._default.FlatMapOption$V1@@0
                                 $Heap@@2
                                 |opt#0@@4|
                                 |f#0@@72|)
                               a!1))
                      a!4))))
                :pattern ((Options.__default.FlatMapOption
                            Options._default.FlatMapOption$V0@@0
                            Options._default.FlatMapOption$V1@@0
                            $Heap@@2
                            |opt#0@@4|
                            |f#0@@72|))
                :skolemid |1848|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Options._default.FlatMapOption$V0@@1 T@U)
         (Options._default.FlatMapOption$V1@@1 T@U)
         ($Heap@@3 T@U)
         (|opt#0@@5| T@U)
         (|f#0@@73| T@U))
  (! (let ((a!1 (and (= (type Options._default.FlatMapOption$V0@@1) TyType)
                     (= (type Options._default.FlatMapOption$V1@@1) TyType)
                     (= (type $Heap@@3) (MapType0Type refType MapType1Type))
                     (= (type |opt#0@@5|) DatatypeTypeType)
                     (= (type |f#0@@73|) HandleTypeType)
                     ($IsGoodHeap $Heap@@3)
                     ($Is |opt#0@@5|
                          (Tclass.Options.Option
                            Options._default.FlatMapOption$V0@@1))
                     ($Is |f#0@@73|
                          (Tclass._System.___hFunc1
                            Options._default.FlatMapOption$V0@@1
                            (Tclass.Options.Option
                              Options._default.FlatMapOption$V1@@1)))))
           (a!2 (= (|Options.__default.FlatMapOption#requires|
                     Options._default.FlatMapOption$V0@@1
                     Options._default.FlatMapOption$V1@@1
                     $Heap@@3
                     |opt#0@@5|
                     |f#0@@73|)
                   (=> (Options.Option.Some_q |opt#0@@5|)
                       (Requires1 Options._default.FlatMapOption$V0@@1
                                  (Tclass.Options.Option
                                    Options._default.FlatMapOption$V1@@1)
                                  $Heap@@3
                                  |f#0@@73|
                                  (Options.Option.value |opt#0@@5|))))))
       (=> a!1 a!2))
     :pattern ((|Options.__default.FlatMapOption#requires|
                 Options._default.FlatMapOption$V0@@1
                 Options._default.FlatMapOption$V1@@1
                 $Heap@@3
                 |opt#0@@5|
                 |f#0@@73|)
               ($IsGoodHeap $Heap@@3))
     :skolemid |1849|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Options._default.FlatMapOption$V0@@2 T@U)
                    (Options._default.FlatMapOption$V1@@2 T@U)
                    ($Heap@@4 T@U)
                    (|opt#0@@6| T@U)
                    (|f#0@@74| T@U))
             (! (let ((a!1 (and ($IsGoodHeap $Heap@@4)
                                ($Is |opt#0@@6|
                                     (Tclass.Options.Option
                                       Options._default.FlatMapOption$V0@@2))
                                ($Is |f#0@@74|
                                     (Tclass._System.___hFunc1
                                       Options._default.FlatMapOption$V0@@2
                                       (Tclass.Options.Option
                                         Options._default.FlatMapOption$V1@@2)))
                                (=> (Options.Option.Some_q |opt#0@@6|)
                                    (Requires1 Options._default.FlatMapOption$V0@@2
                                               (Tclass.Options.Option
                                                 Options._default.FlatMapOption$V1@@2)
                                               $Heap@@4
                                               |f#0@@74|
                                               (Options.Option.value |opt#0@@6|)))))
                      (a!2 (ite (Options.Option.None_q |opt#0@@6|)
                                |#Options.Option.None|
                                ($Unbox DatatypeTypeType
                                        (Apply1 Options._default.FlatMapOption$V0@@2
                                                (Tclass.Options.Option
                                                  Options._default.FlatMapOption$V1@@2)
                                                $Heap@@4
                                                |f#0@@74|
                                                (Options.Option.value
                                                  |opt#0@@6|))))))
                  (=> (and (= (type Options._default.FlatMapOption$V0@@2)
                              TyType)
                           (= (type Options._default.FlatMapOption$V1@@2)
                              TyType)
                           (= (type $Heap@@4)
                              (MapType0Type refType MapType1Type))
                           (= (type |opt#0@@6|) DatatypeTypeType)
                           (= (type |f#0@@74|) HandleTypeType)
                           (or (|Options.__default.FlatMapOption#canCall|
                                 Options._default.FlatMapOption$V0@@2
                                 Options._default.FlatMapOption$V1@@2
                                 $Heap@@4
                                 |opt#0@@6|
                                 |f#0@@74|)
                               a!1))
                      (= (Options.__default.FlatMapOption
                           Options._default.FlatMapOption$V0@@2
                           Options._default.FlatMapOption$V1@@2
                           $Heap@@4
                           |opt#0@@6|
                           |f#0@@74|)
                         a!2)))
                :pattern ((Options.__default.FlatMapOption
                            Options._default.FlatMapOption$V0@@2
                            Options._default.FlatMapOption$V1@@2
                            $Heap@@4
                            |opt#0@@6|
                            |f#0@@74|)
                          ($IsGoodHeap $Heap@@4))
                :skolemid |1850|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type Tclass.NativeTypes.sbyte) TyType))
(assert (= (Tag Tclass.NativeTypes.sbyte) Tagclass.NativeTypes.sbyte))
(assert (= (TagFamily Tclass.NativeTypes.sbyte) tytagFamily$sbyte))
(assert (forall ((bx@@130 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@130)) bx@@130)
                     ($Is ($Unbox intType bx@@130) Tclass.NativeTypes.sbyte))))
       (=> (and (= (type bx@@130) BoxType)
                ($IsBox bx@@130 Tclass.NativeTypes.sbyte))
           a!1))
     :pattern (($IsBox bx@@130 Tclass.NativeTypes.sbyte))
     :skolemid |1851|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0| T@U))
  (! (let ((a!1 (= ($Is |i#0| Tclass.NativeTypes.sbyte)
                   (and (INTERNAL_le_boogie (- 0 128) (U_2_int |i#0|))
                        (INTERNAL_lt_boogie (U_2_int |i#0|) 128)))))
       (=> (= (type |i#0|) intType) a!1))
     :pattern (($Is |i#0| Tclass.NativeTypes.sbyte))
     :skolemid |1852|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@0| T@U) ($h@@54 T@U))
  (! (=> (and (= (type |i#0@@0|) intType)
              (= (type $h@@54) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@0| Tclass.NativeTypes.sbyte $h@@54))
     :pattern (($IsAlloc |i#0@@0| Tclass.NativeTypes.sbyte $h@@54))
     :skolemid |1853|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@1| T@U))
  (! (let ((a!1 (= ($Is |i#0@@1| Tclass.NativeTypes.byte)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@1|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@1|) 256)))))
       (=> (= (type |i#0@@1|) intType) a!1))
     :pattern (($Is |i#0@@1| Tclass.NativeTypes.byte))
     :skolemid |1854|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@2| T@U) ($h@@55 T@U))
  (! (=> (and (= (type |i#0@@2|) intType)
              (= (type $h@@55) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@2| Tclass.NativeTypes.byte $h@@55))
     :pattern (($IsAlloc |i#0@@2| Tclass.NativeTypes.byte $h@@55))
     :skolemid |1855|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.int16) TyType))
(assert (= (Tag Tclass.NativeTypes.int16) Tagclass.NativeTypes.int16))
(assert (= (TagFamily Tclass.NativeTypes.int16) tytagFamily$int16))
(assert (forall ((bx@@131 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@131)) bx@@131)
                     ($Is ($Unbox intType bx@@131) Tclass.NativeTypes.int16))))
       (=> (and (= (type bx@@131) BoxType)
                ($IsBox bx@@131 Tclass.NativeTypes.int16))
           a!1))
     :pattern (($IsBox bx@@131 Tclass.NativeTypes.int16))
     :skolemid |1856|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@3| T@U))
  (! (let ((a!1 (= ($Is |i#0@@3| Tclass.NativeTypes.int16)
                   (and (INTERNAL_le_boogie (- 0 32768) (U_2_int |i#0@@3|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@3|) 32768)))))
       (=> (= (type |i#0@@3|) intType) a!1))
     :pattern (($Is |i#0@@3| Tclass.NativeTypes.int16))
     :skolemid |1857|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@4| T@U) ($h@@56 T@U))
  (! (=> (and (= (type |i#0@@4|) intType)
              (= (type $h@@56) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@4| Tclass.NativeTypes.int16 $h@@56))
     :pattern (($IsAlloc |i#0@@4| Tclass.NativeTypes.int16 $h@@56))
     :skolemid |1858|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.uint16) TyType))
(assert (= (Tag Tclass.NativeTypes.uint16) Tagclass.NativeTypes.uint16))
(assert (= (TagFamily Tclass.NativeTypes.uint16) tytagFamily$uint16))
(assert (forall ((bx@@132 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@132)) bx@@132)
                     ($Is ($Unbox intType bx@@132) Tclass.NativeTypes.uint16))))
       (=> (and (= (type bx@@132) BoxType)
                ($IsBox bx@@132 Tclass.NativeTypes.uint16))
           a!1))
     :pattern (($IsBox bx@@132 Tclass.NativeTypes.uint16))
     :skolemid |1859|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@5| T@U))
  (! (let ((a!1 (= ($Is |i#0@@5| Tclass.NativeTypes.uint16)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@5|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@5|) 65536)))))
       (=> (= (type |i#0@@5|) intType) a!1))
     :pattern (($Is |i#0@@5| Tclass.NativeTypes.uint16))
     :skolemid |1860|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@6| T@U) ($h@@57 T@U))
  (! (=> (and (= (type |i#0@@6|) intType)
              (= (type $h@@57) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@6| Tclass.NativeTypes.uint16 $h@@57))
     :pattern (($IsAlloc |i#0@@6| Tclass.NativeTypes.uint16 $h@@57))
     :skolemid |1861|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.int32) TyType))
(assert (= (Tag Tclass.NativeTypes.int32) Tagclass.NativeTypes.int32))
(assert (= (TagFamily Tclass.NativeTypes.int32) tytagFamily$int32))
(assert (forall ((bx@@133 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@133)) bx@@133)
                     ($Is ($Unbox intType bx@@133) Tclass.NativeTypes.int32))))
       (=> (and (= (type bx@@133) BoxType)
                ($IsBox bx@@133 Tclass.NativeTypes.int32))
           a!1))
     :pattern (($IsBox bx@@133 Tclass.NativeTypes.int32))
     :skolemid |1862|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@7| T@U))
  (! (let ((a!1 (= ($Is |i#0@@7| Tclass.NativeTypes.int32)
                   (and (INTERNAL_le_boogie (- 0 2147483648) (U_2_int |i#0@@7|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@7|) 2147483648)))))
       (=> (= (type |i#0@@7|) intType) a!1))
     :pattern (($Is |i#0@@7| Tclass.NativeTypes.int32))
     :skolemid |1863|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@8| T@U) ($h@@58 T@U))
  (! (=> (and (= (type |i#0@@8|) intType)
              (= (type $h@@58) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@8| Tclass.NativeTypes.int32 $h@@58))
     :pattern (($IsAlloc |i#0@@8| Tclass.NativeTypes.int32 $h@@58))
     :skolemid |1864|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.uint32) TyType))
(assert (= (Tag Tclass.NativeTypes.uint32) Tagclass.NativeTypes.uint32))
(assert (= (TagFamily Tclass.NativeTypes.uint32) tytagFamily$uint32))
(assert (forall ((bx@@134 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@134)) bx@@134)
                     ($Is ($Unbox intType bx@@134) Tclass.NativeTypes.uint32))))
       (=> (and (= (type bx@@134) BoxType)
                ($IsBox bx@@134 Tclass.NativeTypes.uint32))
           a!1))
     :pattern (($IsBox bx@@134 Tclass.NativeTypes.uint32))
     :skolemid |1865|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@9| T@U))
  (! (let ((a!1 (= ($Is |i#0@@9| Tclass.NativeTypes.uint32)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@9|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@9|) 4294967296)))))
       (=> (= (type |i#0@@9|) intType) a!1))
     :pattern (($Is |i#0@@9| Tclass.NativeTypes.uint32))
     :skolemid |1866|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@10| T@U) ($h@@59 T@U))
  (! (=> (and (= (type |i#0@@10|) intType)
              (= (type $h@@59) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@10| Tclass.NativeTypes.uint32 $h@@59))
     :pattern (($IsAlloc |i#0@@10| Tclass.NativeTypes.uint32 $h@@59))
     :skolemid |1867|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.int64) TyType))
(assert (= (Tag Tclass.NativeTypes.int64) Tagclass.NativeTypes.int64))
(assert (= (TagFamily Tclass.NativeTypes.int64) tytagFamily$int64))
(assert (forall ((bx@@135 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@135)) bx@@135)
                     ($Is ($Unbox intType bx@@135) Tclass.NativeTypes.int64))))
       (=> (and (= (type bx@@135) BoxType)
                ($IsBox bx@@135 Tclass.NativeTypes.int64))
           a!1))
     :pattern (($IsBox bx@@135 Tclass.NativeTypes.int64))
     :skolemid |1868|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@11| T@U))
  (! (let ((a!1 (= ($Is |i#0@@11| Tclass.NativeTypes.int64)
                   (and (INTERNAL_le_boogie
                          (- 0 9223372036854775808)
                          (U_2_int |i#0@@11|))
                        (INTERNAL_lt_boogie
                          (U_2_int |i#0@@11|)
                          9223372036854775808)))))
       (=> (= (type |i#0@@11|) intType) a!1))
     :pattern (($Is |i#0@@11| Tclass.NativeTypes.int64))
     :skolemid |1869|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@12| T@U) ($h@@60 T@U))
  (! (=> (and (= (type |i#0@@12|) intType)
              (= (type $h@@60) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@12| Tclass.NativeTypes.int64 $h@@60))
     :pattern (($IsAlloc |i#0@@12| Tclass.NativeTypes.int64 $h@@60))
     :skolemid |1870|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.uint64) TyType))
(assert (= (Tag Tclass.NativeTypes.uint64) Tagclass.NativeTypes.uint64))
(assert (= (TagFamily Tclass.NativeTypes.uint64) tytagFamily$uint64))
(assert (forall ((bx@@136 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@136)) bx@@136)
                     ($Is ($Unbox intType bx@@136) Tclass.NativeTypes.uint64))))
       (=> (and (= (type bx@@136) BoxType)
                ($IsBox bx@@136 Tclass.NativeTypes.uint64))
           a!1))
     :pattern (($IsBox bx@@136 Tclass.NativeTypes.uint64))
     :skolemid |1871|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@13| T@U))
  (! (let ((a!1 (= ($Is |i#0@@13| Tclass.NativeTypes.uint64)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@13|))
                        (INTERNAL_lt_boogie
                          (U_2_int |i#0@@13|)
                          18446744073709551616)))))
       (=> (= (type |i#0@@13|) intType) a!1))
     :pattern (($Is |i#0@@13| Tclass.NativeTypes.uint64))
     :skolemid |1872|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@14| T@U) ($h@@61 T@U))
  (! (=> (and (= (type |i#0@@14|) intType)
              (= (type $h@@61) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@14| Tclass.NativeTypes.uint64 $h@@61))
     :pattern (($IsAlloc |i#0@@14| Tclass.NativeTypes.uint64 $h@@61))
     :skolemid |1873|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.nat8) TyType))
(assert (= (Tag Tclass.NativeTypes.nat8) Tagclass.NativeTypes.nat8))
(assert (= (TagFamily Tclass.NativeTypes.nat8) tytagFamily$nat8))
(assert (forall ((bx@@137 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@137)) bx@@137)
                     ($Is ($Unbox intType bx@@137) Tclass.NativeTypes.nat8))))
       (=> (and (= (type bx@@137) BoxType)
                ($IsBox bx@@137 Tclass.NativeTypes.nat8))
           a!1))
     :pattern (($IsBox bx@@137 Tclass.NativeTypes.nat8))
     :skolemid |1874|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@15| T@U))
  (! (let ((a!1 (= ($Is |i#0@@15| Tclass.NativeTypes.nat8)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@15|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@15|) 128)))))
       (=> (= (type |i#0@@15|) intType) a!1))
     :pattern (($Is |i#0@@15| Tclass.NativeTypes.nat8))
     :skolemid |1875|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@16| T@U) ($h@@62 T@U))
  (! (=> (and (= (type |i#0@@16|) intType)
              (= (type $h@@62) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@16| Tclass.NativeTypes.nat8 $h@@62))
     :pattern (($IsAlloc |i#0@@16| Tclass.NativeTypes.nat8 $h@@62))
     :skolemid |1876|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.nat16) TyType))
(assert (= (Tag Tclass.NativeTypes.nat16) Tagclass.NativeTypes.nat16))
(assert (= (TagFamily Tclass.NativeTypes.nat16) tytagFamily$nat16))
(assert (forall ((bx@@138 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@138)) bx@@138)
                     ($Is ($Unbox intType bx@@138) Tclass.NativeTypes.nat16))))
       (=> (and (= (type bx@@138) BoxType)
                ($IsBox bx@@138 Tclass.NativeTypes.nat16))
           a!1))
     :pattern (($IsBox bx@@138 Tclass.NativeTypes.nat16))
     :skolemid |1877|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@17| T@U))
  (! (let ((a!1 (= ($Is |i#0@@17| Tclass.NativeTypes.nat16)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@17|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@17|) 32768)))))
       (=> (= (type |i#0@@17|) intType) a!1))
     :pattern (($Is |i#0@@17| Tclass.NativeTypes.nat16))
     :skolemid |1878|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@18| T@U) ($h@@63 T@U))
  (! (=> (and (= (type |i#0@@18|) intType)
              (= (type $h@@63) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@18| Tclass.NativeTypes.nat16 $h@@63))
     :pattern (($IsAlloc |i#0@@18| Tclass.NativeTypes.nat16 $h@@63))
     :skolemid |1879|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.nat32) TyType))
(assert (= (Tag Tclass.NativeTypes.nat32) Tagclass.NativeTypes.nat32))
(assert (= (TagFamily Tclass.NativeTypes.nat32) tytagFamily$nat32))
(assert (forall ((bx@@139 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@139)) bx@@139)
                     ($Is ($Unbox intType bx@@139) Tclass.NativeTypes.nat32))))
       (=> (and (= (type bx@@139) BoxType)
                ($IsBox bx@@139 Tclass.NativeTypes.nat32))
           a!1))
     :pattern (($IsBox bx@@139 Tclass.NativeTypes.nat32))
     :skolemid |1880|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@19| T@U))
  (! (let ((a!1 (= ($Is |i#0@@19| Tclass.NativeTypes.nat32)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@19|))
                        (INTERNAL_lt_boogie (U_2_int |i#0@@19|) 2147483648)))))
       (=> (= (type |i#0@@19|) intType) a!1))
     :pattern (($Is |i#0@@19| Tclass.NativeTypes.nat32))
     :skolemid |1881|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@20| T@U) ($h@@64 T@U))
  (! (=> (and (= (type |i#0@@20|) intType)
              (= (type $h@@64) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@20| Tclass.NativeTypes.nat32 $h@@64))
     :pattern (($IsAlloc |i#0@@20| Tclass.NativeTypes.nat32 $h@@64))
     :skolemid |1882|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.nat64) TyType))
(assert (= (Tag Tclass.NativeTypes.nat64) Tagclass.NativeTypes.nat64))
(assert (= (TagFamily Tclass.NativeTypes.nat64) tytagFamily$nat64))
(assert (forall ((bx@@140 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@140)) bx@@140)
                     ($Is ($Unbox intType bx@@140) Tclass.NativeTypes.nat64))))
       (=> (and (= (type bx@@140) BoxType)
                ($IsBox bx@@140 Tclass.NativeTypes.nat64))
           a!1))
     :pattern (($IsBox bx@@140 Tclass.NativeTypes.nat64))
     :skolemid |1883|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@21| T@U))
  (! (let ((a!1 (= ($Is |i#0@@21| Tclass.NativeTypes.nat64)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@21|))
                        (INTERNAL_lt_boogie
                          (U_2_int |i#0@@21|)
                          9223372036854775808)))))
       (=> (= (type |i#0@@21|) intType) a!1))
     :pattern (($Is |i#0@@21| Tclass.NativeTypes.nat64))
     :skolemid |1884|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@22| T@U) ($h@@65 T@U))
  (! (=> (and (= (type |i#0@@22|) intType)
              (= (type $h@@65) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@22| Tclass.NativeTypes.nat64 $h@@65))
     :pattern (($IsAlloc |i#0@@22| Tclass.NativeTypes.nat64 $h@@65))
     :skolemid |1885|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.uint128) TyType))
(assert (= (Tag Tclass.NativeTypes.uint128) Tagclass.NativeTypes.uint128))
(assert (= (TagFamily Tclass.NativeTypes.uint128) tytagFamily$uint128))
(assert (forall ((bx@@141 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox intType bx@@141)) bx@@141)
                     ($Is ($Unbox intType bx@@141) Tclass.NativeTypes.uint128))))
       (=> (and (= (type bx@@141) BoxType)
                ($IsBox bx@@141 Tclass.NativeTypes.uint128))
           a!1))
     :pattern (($IsBox bx@@141 Tclass.NativeTypes.uint128))
     :skolemid |1886|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@23| T@U))
  (! (let ((a!1 (= ($Is |i#0@@23| Tclass.NativeTypes.uint128)
                   (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@23|))
                        (INTERNAL_lt_boogie
                          (U_2_int |i#0@@23|)
                          340282366920938463463374607431768211456)))))
       (=> (= (type |i#0@@23|) intType) a!1))
     :pattern (($Is |i#0@@23| Tclass.NativeTypes.uint128))
     :skolemid |1887|
     :qid |unknown.0:0|)))
(assert (forall ((|i#0@@24| T@U) ($h@@66 T@U))
  (! (=> (and (= (type |i#0@@24|) intType)
              (= (type $h@@66) (MapType0Type refType MapType1Type)))
         ($IsAlloc |i#0@@24| Tclass.NativeTypes.uint128 $h@@66))
     :pattern (($IsAlloc |i#0@@24| Tclass.NativeTypes.uint128 $h@@66))
     :skolemid |1888|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.NativeTypes.__default) TyType))
(assert (= (Tag Tclass.NativeTypes.__default) Tagclass.NativeTypes.__default))
(assert (= (TagFamily Tclass.NativeTypes.__default) tytagFamily$_default))
(assert (forall ((bx@@142 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@142)) bx@@142)
                     ($Is ($Unbox refType bx@@142) Tclass.NativeTypes.__default))))
       (=> (and (= (type bx@@142) BoxType)
                ($IsBox bx@@142 Tclass.NativeTypes.__default))
           a!1))
     :pattern (($IsBox bx@@142 Tclass.NativeTypes.__default))
     :skolemid |1889|
     :qid |unknown.0:0|)))
(assert (forall (($o@@15 T@U))
  (! (let ((a!1 (= ($Is $o@@15 Tclass.NativeTypes.__default)
                   (or (= $o@@15 null)
                       (= (dtype $o@@15) Tclass.NativeTypes.__default)))))
       (=> (= (type $o@@15) refType) a!1))
     :pattern (($Is $o@@15 Tclass.NativeTypes.__default))
     :skolemid |1890|
     :qid |unknown.0:0|)))
(assert (forall (($o@@16 T@U) ($h@@67 T@U))
  (! (let ((a!1 (or (= $o@@16 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@67 $o@@16)
                                              alloc)))))
       (=> (and (= (type $o@@16) refType)
                (= (type $h@@67) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@16 Tclass.NativeTypes.__default $h@@67) a!1)))
     :pattern (($IsAlloc $o@@16 Tclass.NativeTypes.__default $h@@67))
     :skolemid |1891|
     :qid |unknown.0:0|)))
(assert (=> true
    (=> true
        (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint64Size)
             (INTERNAL_lt_boogie
               NativeTypes.__default.Uint64Size
               18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint64Size#requires| true))
(assert (=> true (=> true (= NativeTypes.__default.Uint64Size (LitInt 8)))))
(assert (=> true (=> true (= NativeTypes.__default.Uint64Size (LitInt 8)))))
(assert (=> true
    (=> true
        (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint32Size)
             (INTERNAL_lt_boogie
               NativeTypes.__default.Uint32Size
               18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint32Size#requires| true))
(assert (=> true (=> true (= NativeTypes.__default.Uint32Size (LitInt 4)))))
(assert (=> true (=> true (= NativeTypes.__default.Uint32Size (LitInt 4)))))
(assert (=> true
    (=> true
        (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint16Size)
             (INTERNAL_lt_boogie
               NativeTypes.__default.Uint16Size
               18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint16Size#requires| true))
(assert (=> true (=> true (= NativeTypes.__default.Uint16Size (LitInt 2)))))
(assert (=> true (=> true (= NativeTypes.__default.Uint16Size (LitInt 2)))))
(assert (=> true (=> true true)))
(assert (= |NativeTypes.__default.Uint64UpperBound#requires| true))
(assert (=> true
    (=> true
        (= NativeTypes.__default.Uint64UpperBound (LitInt 18446744073709551616)))))
(assert (=> true
    (=> true
        (= NativeTypes.__default.Uint64UpperBound (LitInt 18446744073709551616)))))
(assert (=> true (=> true true)))
(assert (= |NativeTypes.__default.Uint32UpperBound#requires| true))
(assert (=> true
    (=> true (= NativeTypes.__default.Uint32UpperBound (LitInt 4294967296)))))
(assert (=> true
    (=> true (= NativeTypes.__default.Uint32UpperBound (LitInt 4294967296)))))
(assert (=> true
    (=> true
        (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint8UpperBound)
             (INTERNAL_lt_boogie
               NativeTypes.__default.Uint8UpperBound
               18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint8UpperBound#requires| true))
(assert (=> true (=> true (= NativeTypes.__default.Uint8UpperBound (LitInt 256)))))
(assert (=> true (=> true (= NativeTypes.__default.Uint8UpperBound (LitInt 256)))))
(assert (forall ((|s#0| T@U))
  (! (let ((a!1 (= ($Is |s#0| Tclass.KeyType.Key)
                   (and ($Is |s#0| (TSeq Tclass.NativeTypes.byte))
                        (INTERNAL_le_boogie (|Seq#Length| |s#0|) 1024)))))
       (=> (= (type |s#0|) (SeqType BoxType)) a!1))
     :pattern (($Is |s#0| Tclass.KeyType.Key))
     :skolemid |1892|
     :qid |unknown.0:0|)))
(assert (forall ((|s#0@@0| T@U) ($h@@68 T@U))
  (! (=> (and (= (type |s#0@@0|) (SeqType BoxType))
              (= (type $h@@68) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |s#0@@0| Tclass.KeyType.Key $h@@68)
            ($IsAlloc |s#0@@0| (TSeq Tclass.NativeTypes.byte) $h@@68)))
     :pattern (($IsAlloc |s#0@@0| Tclass.KeyType.Key $h@@68))
     :skolemid |1893|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.KeyType.__default) TyType))
(assert (= (Tag Tclass.KeyType.__default) Tagclass.KeyType.__default))
(assert (= (TagFamily Tclass.KeyType.__default) tytagFamily$_default))
(assert (forall ((bx@@143 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@143)) bx@@143)
                     ($Is ($Unbox refType bx@@143) Tclass.KeyType.__default))))
       (=> (and (= (type bx@@143) BoxType)
                ($IsBox bx@@143 Tclass.KeyType.__default))
           a!1))
     :pattern (($IsBox bx@@143 Tclass.KeyType.__default))
     :skolemid |1894|
     :qid |unknown.0:0|)))
(assert (forall (($o@@17 T@U))
  (! (let ((a!1 (= ($Is $o@@17 Tclass.KeyType.__default)
                   (or (= $o@@17 null)
                       (= (dtype $o@@17) Tclass.KeyType.__default)))))
       (=> (= (type $o@@17) refType) a!1))
     :pattern (($Is $o@@17 Tclass.KeyType.__default))
     :skolemid |1895|
     :qid |unknown.0:0|)))
(assert (forall (($o@@18 T@U) ($h@@69 T@U))
  (! (let ((a!1 (or (= $o@@18 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@69 $o@@18)
                                              alloc)))))
       (=> (and (= (type $o@@18) refType)
                (= (type $h@@69) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@18 Tclass.KeyType.__default $h@@69) a!1)))
     :pattern (($IsAlloc $o@@18 Tclass.KeyType.__default $h@@69))
     :skolemid |1896|
     :qid |unknown.0:0|)))
(assert (=> true
    (=> true
        (and (INTERNAL_le_boogie 0 KeyType.__default.MaxLen)
             (INTERNAL_lt_boogie KeyType.__default.MaxLen 18446744073709551616)))))
(assert (= |KeyType.__default.MaxLen#requires| true))
(assert (=> true (=> true (= KeyType.__default.MaxLen (LitInt 1024)))))
(assert (=> true (=> true (= KeyType.__default.MaxLen (LitInt 1024)))))
(assert (forall ((|s#0@@1| T@U))
  (! (let ((a!1 (= ($Is |s#0@@1| Tclass.ValueType.Value)
                   (and ($Is |s#0@@1| (TSeq Tclass.NativeTypes.byte))
                        (INTERNAL_le_boogie (|Seq#Length| |s#0@@1|) 1024)))))
       (=> (= (type |s#0@@1|) (SeqType BoxType)) a!1))
     :pattern (($Is |s#0@@1| Tclass.ValueType.Value))
     :skolemid |1897|
     :qid |unknown.0:0|)))
(assert (forall ((|s#0@@2| T@U) ($h@@70 T@U))
  (! (=> (and (= (type |s#0@@2|) (SeqType BoxType))
              (= (type $h@@70) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |s#0@@2| Tclass.ValueType.Value $h@@70)
            ($IsAlloc |s#0@@2| (TSeq Tclass.NativeTypes.byte) $h@@70)))
     :pattern (($IsAlloc |s#0@@2| Tclass.ValueType.Value $h@@70))
     :skolemid |1898|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.ValueType.__default) TyType))
(assert (= (Tag Tclass.ValueType.__default) Tagclass.ValueType.__default))
(assert (= (TagFamily Tclass.ValueType.__default) tytagFamily$_default))
(assert (forall (($o@@19 T@U))
  (! (let ((a!1 (= ($Is $o@@19 Tclass.ValueType.__default)
                   (or (= $o@@19 null)
                       (= (dtype $o@@19) Tclass.ValueType.__default)))))
       (=> (= (type $o@@19) refType) a!1))
     :pattern (($Is $o@@19 Tclass.ValueType.__default))
     :skolemid |1899|
     :qid |unknown.0:0|)))
(assert (forall (($o@@20 T@U) ($h@@71 T@U))
  (! (let ((a!1 (or (= $o@@20 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@71 $o@@20)
                                              alloc)))))
       (=> (and (= (type $o@@20) refType)
                (= (type $h@@71) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@20 Tclass.ValueType.__default $h@@71) a!1)))
     :pattern (($IsAlloc $o@@20 Tclass.ValueType.__default $h@@71))
     :skolemid |1900|
     :qid |unknown.0:0|)))
(assert (=> true
    (=> true
        (and (INTERNAL_le_boogie 0 ValueType.__default.MaxLen)
             (INTERNAL_lt_boogie
               ValueType.__default.MaxLen
               18446744073709551616)))))
(assert (= |ValueType.__default.MaxLen#requires| true))
(assert (=> true (=> true (= ValueType.__default.MaxLen (LitInt 1024)))))
(assert (=> true (=> true (= ValueType.__default.MaxLen (LitInt 1024)))))
(assert (= (type ValueType.__default.DefaultValue) (SeqType BoxType)))
(assert (=> true
    (=> true ($Is ValueType.__default.DefaultValue Tclass.ValueType.Value))))
(assert (= |ValueType.__default.DefaultValue#requires| true))
(assert (let ((a!1 (=> true
               (= ValueType.__default.DefaultValue (Lit (|Seq#Empty| BoxType))))))
  (=> true a!1)))
(assert (let ((a!1 (=> true
               (= ValueType.__default.DefaultValue (Lit (|Seq#Empty| BoxType))))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@9| T@U))
             (! (=> (and (= (type |v#0@@9|) (SeqType BoxType))
                         (or (|ValueType.__default.Len#canCall| |v#0@@9|)
                             ($Is |v#0@@9| Tclass.ValueType.Value)))
                    (INTERNAL_le_boogie 0 (ValueType.__default.Len |v#0@@9|)))
                :pattern ((ValueType.__default.Len |v#0@@9|))
                :skolemid |1901|
                :qid |KeyTypesdfy.20:15|))))
  (=> true a!1)))
(assert (forall ((|v#0@@10| T@U))
  (! (=> (and (= (type |v#0@@10|) (SeqType BoxType))
              ($Is |v#0@@10| Tclass.ValueType.Value))
         (= (|ValueType.__default.Len#requires| |v#0@@10|) true))
     :pattern ((|ValueType.__default.Len#requires| |v#0@@10|))
     :skolemid |1902|
     :qid |KeyTypesdfy.20:15|)))
(assert (let ((a!1 (forall ((|v#0@@11| T@U))
             (! (=> (and (= (type |v#0@@11|) (SeqType BoxType))
                         (or (|ValueType.__default.Len#canCall| |v#0@@11|)
                             ($Is |v#0@@11| Tclass.ValueType.Value)))
                    (= (ValueType.__default.Len |v#0@@11|)
                       (|Seq#Length| |v#0@@11|)))
                :pattern ((ValueType.__default.Len |v#0@@11|))
                :skolemid |1903|
                :qid |KeyTypesdfy.20:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@12| T@U))
             (! (let ((a!1 (and (= (type |v#0@@12|) (SeqType BoxType))
                                (or (|ValueType.__default.Len#canCall|
                                      (Lit |v#0@@12|))
                                    ($Is |v#0@@12| Tclass.ValueType.Value)))))
                  (=> a!1
                      (= (ValueType.__default.Len (Lit |v#0@@12|))
                         (|Seq#Length| (Lit |v#0@@12|)))))
                :pattern ((ValueType.__default.Len (Lit |v#0@@12|)))
                :weight 3
                :skolemid |1904|
                :qid |KeyTypesdfy.20:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|s#0@@3| T@U))
      (! (let ((a!1 (and (= (type |s#0@@3|) (SeqType BoxType))
                         (or (|ValueType.__default.ValidMessageBytestring#canCall|
                               |s#0@@3|)
                             ($Is |s#0@@3| (TSeq Tclass.NativeTypes.byte))))))
           (=> a!1 true))
         :pattern ((ValueType.__default.ValidMessageBytestring |s#0@@3|))
         :skolemid |1905|
         :qid |KeyTypesdfy.22:36|))))
(assert (forall ((|s#0@@4| T@U))
  (! (=> (and (= (type |s#0@@4|) (SeqType BoxType))
              ($Is |s#0@@4| (TSeq Tclass.NativeTypes.byte)))
         (= (|ValueType.__default.ValidMessageBytestring#requires| |s#0@@4|)
            true))
     :pattern ((|ValueType.__default.ValidMessageBytestring#requires| |s#0@@4|))
     :skolemid |1906|
     :qid |KeyTypesdfy.22:36|)))
(assert (=> true
    (forall ((|s#0@@5| T@U))
      (! (let ((a!1 (and (= (type |s#0@@5|) (SeqType BoxType))
                         (or (|ValueType.__default.ValidMessageBytestring#canCall|
                               |s#0@@5|)
                             ($Is |s#0@@5| (TSeq Tclass.NativeTypes.byte)))))
               (a!2 (and |ValueType.__default.MaxLen#canCall|
                         (= (ValueType.__default.ValidMessageBytestring
                              |s#0@@5|)
                            (INTERNAL_le_boogie
                              (|Seq#Length| |s#0@@5|)
                              ValueType.__default.MaxLen)))))
           (=> a!1 a!2))
         :pattern ((ValueType.__default.ValidMessageBytestring |s#0@@5|))
         :skolemid |1907|
         :qid |KeyTypesdfy.22:36|))))
(assert (=> true
    (forall ((|s#0@@6| T@U))
      (! (let ((a!1 (and (= (type |s#0@@6|) (SeqType BoxType))
                         (or (|ValueType.__default.ValidMessageBytestring#canCall|
                               (Lit |s#0@@6|))
                             ($Is |s#0@@6| (TSeq Tclass.NativeTypes.byte)))))
               (a!2 (= (ValueType.__default.ValidMessageBytestring
                         (Lit |s#0@@6|))
                       (INTERNAL_le_boogie
                         (|Seq#Length| (Lit |s#0@@6|))
                         ValueType.__default.MaxLen))))
           (=> a!1 (and |ValueType.__default.MaxLen#canCall| a!2)))
         :pattern ((ValueType.__default.ValidMessageBytestring (Lit |s#0@@6|)))
         :weight 3
         :skolemid |1908|
         :qid |KeyTypesdfy.22:36|))))
(assert (let ((a!1 (forall ((|strs#0| T@U))
             (! (let ((a!1 (or (|ValueType.__default.ValidMessageBytestrings#canCall|
                                 |strs#0|)
                               ($Is |strs#0|
                                    (TSeq (TSeq Tclass.NativeTypes.byte))))))
                  (=> (and (= (type |strs#0|) (SeqType BoxType)) a!1) true))
                :pattern ((ValueType.__default.ValidMessageBytestrings |strs#0|))
                :skolemid |1909|
                :qid |KeyTypesdfy.27:37|))))
  (=> true a!1)))
(assert (forall ((|strs#0@@0| T@U))
  (! (let ((a!1 (and (= (type |strs#0@@0|) (SeqType BoxType))
                     ($Is |strs#0@@0| (TSeq (TSeq Tclass.NativeTypes.byte))))))
       (=> a!1
           (= (|ValueType.__default.ValidMessageBytestrings#requires|
                |strs#0@@0|)
              true)))
     :pattern ((|ValueType.__default.ValidMessageBytestrings#requires|
                 |strs#0@@0|))
     :skolemid |1910|
     :qid |KeyTypesdfy.27:37|)))
(assert (let ((a!1 (forall ((|strs#0@@1| T@U))
             (! (let ((a!1 (or (|ValueType.__default.ValidMessageBytestrings#canCall|
                                 |strs#0@@1|)
                               ($Is |strs#0@@1|
                                    (TSeq (TSeq Tclass.NativeTypes.byte)))))
                      (a!2 (forall ((|i#0@@25| Int))
                             (! (=> (and (INTERNAL_le_boogie 0 |i#0@@25|)
                                         (INTERNAL_lt_boogie
                                           |i#0@@25|
                                           (|Seq#Length| |strs#0@@1|)))
                                    (|ValueType.__default.ValidMessageBytestring#canCall|
                                      ($Unbox (SeqType BoxType)
                                              (|Seq#Index| |strs#0@@1|
                                                           |i#0@@25|))))
                                :pattern (($Unbox (SeqType BoxType)
                                                  (|Seq#Index| |strs#0@@1|
                                                               |i#0@@25|)))
                                :skolemid |1912|
                                :qid |KeyTypesdfy.29:12|)))
                      (a!3 (forall ((|i#0@@26| Int))
                             (! (=> (and (INTERNAL_le_boogie 0 |i#0@@26|)
                                         (INTERNAL_lt_boogie
                                           |i#0@@26|
                                           (|Seq#Length| |strs#0@@1|)))
                                    (ValueType.__default.ValidMessageBytestring
                                      ($Unbox (SeqType BoxType)
                                              (|Seq#Index| |strs#0@@1|
                                                           |i#0@@26|))))
                                :pattern (($Unbox (SeqType BoxType)
                                                  (|Seq#Index| |strs#0@@1|
                                                               |i#0@@26|)))
                                :skolemid |1911|
                                :qid |KeyTypesdfy.29:12|))))
                  (=> (and (= (type |strs#0@@1|) (SeqType BoxType)) a!1)
                      (and a!2
                           (= (ValueType.__default.ValidMessageBytestrings
                                |strs#0@@1|)
                              a!3))))
                :pattern ((ValueType.__default.ValidMessageBytestrings
                            |strs#0@@1|))
                :skolemid |1913|
                :qid |KeyTypesdfy.27:37|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|strs#0@@2| T@U))
             (! (let ((a!1 (or (|ValueType.__default.ValidMessageBytestrings#canCall|
                                 (Lit |strs#0@@2|))
                               ($Is |strs#0@@2|
                                    (TSeq (TSeq Tclass.NativeTypes.byte)))))
                      (a!2 (and (forall ((|i#1| Int))
                                  (! (let ((a!1 (and (INTERNAL_le_boogie
                                                       0
                                                       |i#1|)
                                                     (INTERNAL_lt_boogie
                                                       |i#1|
                                                       (|Seq#Length| (Lit |strs#0@@2|)))))
                                           (a!2 (|ValueType.__default.ValidMessageBytestring#canCall|
                                                  ($Unbox (SeqType BoxType)
                                                          (|Seq#Index| (Lit |strs#0@@2|)
                                                                       |i#1|)))))
                                       (=> a!1 a!2))
                                     :pattern (($Unbox (SeqType BoxType)
                                                       (|Seq#Index| |strs#0@@2|
                                                                    |i#1|)))
                                     :skolemid |1915|
                                     :qid |KeyTypesdfy.29:12|))
                                (= (ValueType.__default.ValidMessageBytestrings
                                     (Lit |strs#0@@2|))
                                   (forall ((|i#1@@0| Int))
                                     (! (let ((a!1 (and (INTERNAL_le_boogie
                                                          0
                                                          |i#1@@0|)
                                                        (INTERNAL_lt_boogie
                                                          |i#1@@0|
                                                          (|Seq#Length| (Lit |strs#0@@2|)))))
                                              (a!2 (ValueType.__default.ValidMessageBytestring
                                                     ($Unbox (SeqType BoxType)
                                                             (|Seq#Index| (Lit |strs#0@@2|)
                                                                          |i#1@@0|)))))
                                          (=> a!1 a!2))
                                        :pattern (($Unbox (SeqType BoxType)
                                                          (|Seq#Index| |strs#0@@2|
                                                                       |i#1@@0|)))
                                        :skolemid |1914|
                                        :qid |KeyTypesdfy.29:12|))))))
                  (=> (and (= (type |strs#0@@2|) (SeqType BoxType)) a!1) a!2))
                :pattern ((ValueType.__default.ValidMessageBytestrings
                            (Lit |strs#0@@2|)))
                :weight 3
                :skolemid |1916|
                :qid |KeyTypesdfy.27:37|))))
  (=> true a!1)))
(assert (= (type Tclass.LinearMaybe.__default) TyType))
(assert (= (Tag Tclass.LinearMaybe.__default) Tagclass.LinearMaybe.__default))
(assert (= (TagFamily Tclass.LinearMaybe.__default) tytagFamily$_default))
(assert (forall ((bx@@144 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@144)) bx@@144)
                     ($Is ($Unbox refType bx@@144) Tclass.LinearMaybe.__default))))
       (=> (and (= (type bx@@144) BoxType)
                ($IsBox bx@@144 Tclass.LinearMaybe.__default))
           a!1))
     :pattern (($IsBox bx@@144 Tclass.LinearMaybe.__default))
     :skolemid |1917|
     :qid |unknown.0:0|)))
(assert (forall (($o@@21 T@U))
  (! (let ((a!1 (= ($Is $o@@21 Tclass.LinearMaybe.__default)
                   (or (= $o@@21 null)
                       (= (dtype $o@@21) Tclass.LinearMaybe.__default)))))
       (=> (= (type $o@@21) refType) a!1))
     :pattern (($Is $o@@21 Tclass.LinearMaybe.__default))
     :skolemid |1918|
     :qid |unknown.0:0|)))
(assert (forall (($o@@22 T@U) ($h@@72 T@U))
  (! (let ((a!1 (or (= $o@@22 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@72 $o@@22)
                                              alloc)))))
       (=> (and (= (type $o@@22) refType)
                (= (type $h@@72) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@22 Tclass.LinearMaybe.__default $h@@72) a!1)))
     :pattern (($IsAlloc $o@@22 Tclass.LinearMaybe.__default $h@@72))
     :skolemid |1919|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@408 T@U))
  (! (= (type (|#$maybe| arg0@@408)) TyType)
     :pattern ((|#$maybe| arg0@@408))
     :qid |funType:#$maybe|)))
(assert (=> true
    (forall ((LinearMaybe._default.has$A T@U) (|m#0| T@U))
      (! (let ((a!1 (and (= (type LinearMaybe._default.has$A) TyType)
                         (= (type |m#0|) BoxType)
                         (or (|LinearMaybe.__default.has#canCall|
                               LinearMaybe._default.has$A
                               |m#0|)
                             ($IsBox |m#0|
                                     (|#$maybe| LinearMaybe._default.has$A))))))
           (=> a!1 true))
         :pattern ((LinearMaybe.__default.has LinearMaybe._default.has$A |m#0|))
         :skolemid |1920|
         :qid |unknown.0:0|))))
(assert (forall ((LinearMaybe._default.has$A@@0 T@U) (|m#0@@0| T@U))
  (! (=> (and (= (type LinearMaybe._default.has$A@@0) TyType)
              (= (type |m#0@@0|) BoxType)
              ($IsBox |m#0@@0| (|#$maybe| LinearMaybe._default.has$A@@0)))
         (= (|LinearMaybe.__default.has#requires|
              LinearMaybe._default.has$A@@0
              |m#0@@0|)
            true))
     :pattern ((|LinearMaybe.__default.has#requires|
                 LinearMaybe._default.has$A@@0
                 |m#0@@0|))
     :skolemid |1921|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@409 T@U) (arg1@@159 T@U))
  (! (= (type (LinearMaybe.__default.read arg0@@409 arg1@@159)) BoxType)
     :pattern ((LinearMaybe.__default.read arg0@@409 arg1@@159))
     :qid |funType:LinearMaybe.__default.read|)))
(assert (let ((a!1 (forall ((LinearMaybe._default.read$A T@U) (|m#0@@1| T@U))
             (! (let ((a!1 (and (= (type LinearMaybe._default.read$A) TyType)
                                (= (type |m#0@@1|) BoxType)
                                (or (|LinearMaybe.__default.read#canCall|
                                      LinearMaybe._default.read$A
                                      |m#0@@1|)
                                    ($IsBox |m#0@@1|
                                            (|#$maybe| LinearMaybe._default.read$A))))))
                  (=> a!1
                      ($IsBox (LinearMaybe.__default.read
                                LinearMaybe._default.read$A
                                |m#0@@1|)
                              LinearMaybe._default.read$A)))
                :pattern ((LinearMaybe.__default.read
                            LinearMaybe._default.read$A
                            |m#0@@1|))
                :skolemid |1922|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearMaybe._default.read$A@@0 T@U) (|m#0@@2| T@U))
  (! (=> (and (= (type LinearMaybe._default.read$A@@0) TyType)
              (= (type |m#0@@2|) BoxType)
              ($IsBox |m#0@@2| (|#$maybe| LinearMaybe._default.read$A@@0)))
         (= (|LinearMaybe.__default.read#requires|
              LinearMaybe._default.read$A@@0
              |m#0@@2|)
            true))
     :pattern ((|LinearMaybe.__default.read#requires|
                 LinearMaybe._default.read$A@@0
                 |m#0@@2|))
     :skolemid |1923|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@410 T@U) (arg1@@160 T@U))
  (! (= (type (LinearMaybe.__default.peek arg0@@410 arg1@@160)) BoxType)
     :pattern ((LinearMaybe.__default.peek arg0@@410 arg1@@160))
     :qid |funType:LinearMaybe.__default.peek|)))
(assert (let ((a!1 (forall ((LinearMaybe._default.peek$A T@U) (|m#0@@3| T@U))
             (! (let ((a!1 (or (|LinearMaybe.__default.peek#canCall|
                                 LinearMaybe._default.peek$A
                                 |m#0@@3|)
                               (and ($IsBox |m#0@@3|
                                            (|#$maybe| LinearMaybe._default.peek$A))
                                    (LinearMaybe.__default.has
                                      LinearMaybe._default.peek$A
                                      |m#0@@3|)))))
                  (=> (and (= (type LinearMaybe._default.peek$A) TyType)
                           (= (type |m#0@@3|) BoxType)
                           a!1)
                      (and (= (LinearMaybe.__default.peek
                                LinearMaybe._default.peek$A
                                |m#0@@3|)
                              (LinearMaybe.__default.read
                                LinearMaybe._default.peek$A
                                |m#0@@3|))
                           ($IsBox (LinearMaybe.__default.peek
                                     LinearMaybe._default.peek$A
                                     |m#0@@3|)
                                   LinearMaybe._default.peek$A))))
                :pattern ((LinearMaybe.__default.peek
                            LinearMaybe._default.peek$A
                            |m#0@@3|))
                :skolemid |1924|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearMaybe._default.peek$A@@0 T@U) (|m#0@@4| T@U))
  (! (=> (and (= (type LinearMaybe._default.peek$A@@0) TyType)
              (= (type |m#0@@4|) BoxType)
              ($IsBox |m#0@@4| (|#$maybe| LinearMaybe._default.peek$A@@0)))
         (= (|LinearMaybe.__default.peek#requires|
              LinearMaybe._default.peek$A@@0
              |m#0@@4|)
            (LinearMaybe.__default.has LinearMaybe._default.peek$A@@0 |m#0@@4|)))
     :pattern ((|LinearMaybe.__default.peek#requires|
                 LinearMaybe._default.peek$A@@0
                 |m#0@@4|))
     :skolemid |1925|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@411 T@U) (arg1@@161 T@U))
  (! (= (type (LinearMaybe.__default.unwrap arg0@@411 arg1@@161)) BoxType)
     :pattern ((LinearMaybe.__default.unwrap arg0@@411 arg1@@161))
     :qid |funType:LinearMaybe.__default.unwrap|)))
(assert (let ((a!1 (forall ((LinearMaybe._default.unwrap$A T@U) (|m#0@@5| T@U))
             (! (let ((a!1 (or (|LinearMaybe.__default.unwrap#canCall|
                                 LinearMaybe._default.unwrap$A
                                 |m#0@@5|)
                               (and ($IsBox |m#0@@5|
                                            (|#$maybe| LinearMaybe._default.unwrap$A))
                                    (LinearMaybe.__default.has
                                      LinearMaybe._default.unwrap$A
                                      |m#0@@5|)))))
                  (=> (and (= (type LinearMaybe._default.unwrap$A) TyType)
                           (= (type |m#0@@5|) BoxType)
                           a!1)
                      (and (= (LinearMaybe.__default.unwrap
                                LinearMaybe._default.unwrap$A
                                |m#0@@5|)
                              (LinearMaybe.__default.read
                                LinearMaybe._default.unwrap$A
                                |m#0@@5|))
                           ($IsBox (LinearMaybe.__default.unwrap
                                     LinearMaybe._default.unwrap$A
                                     |m#0@@5|)
                                   LinearMaybe._default.unwrap$A))))
                :pattern ((LinearMaybe.__default.unwrap
                            LinearMaybe._default.unwrap$A
                            |m#0@@5|))
                :skolemid |1926|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearMaybe._default.unwrap$A@@0 T@U) (|m#0@@6| T@U))
  (! (=> (and (= (type LinearMaybe._default.unwrap$A@@0) TyType)
              (= (type |m#0@@6|) BoxType)
              ($IsBox |m#0@@6| (|#$maybe| LinearMaybe._default.unwrap$A@@0)))
         (= (|LinearMaybe.__default.unwrap#requires|
              LinearMaybe._default.unwrap$A@@0
              |m#0@@6|)
            (LinearMaybe.__default.has
              LinearMaybe._default.unwrap$A@@0
              |m#0@@6|)))
     :pattern ((|LinearMaybe.__default.unwrap#requires|
                 LinearMaybe._default.unwrap$A@@0
                 |m#0@@6|))
     :skolemid |1927|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@412 T@U) (arg1@@162 T@U) (arg2@@85 T@U))
  (! (= (type (LinearMaybe.__default.give arg0@@412 arg1@@162 arg2@@85))
        BoxType)
     :pattern ((LinearMaybe.__default.give arg0@@412 arg1@@162 arg2@@85))
     :qid |funType:LinearMaybe.__default.give|)))
(assert (forall ((LinearMaybe._default.give$A T@U) ($ly@@19 T@U) (|a#0@@1| T@U))
  (! (=> (and (= (type LinearMaybe._default.give$A) TyType)
              (= (type $ly@@19) LayerTypeType)
              (= (type |a#0@@1|) BoxType))
         (= (LinearMaybe.__default.give
              LinearMaybe._default.give$A
              ($LS $ly@@19)
              |a#0@@1|)
            (LinearMaybe.__default.give
              LinearMaybe._default.give$A
              $ly@@19
              |a#0@@1|)))
     :pattern ((LinearMaybe.__default.give
                 LinearMaybe._default.give$A
                 ($LS $ly@@19)
                 |a#0@@1|))
     :skolemid |1928|
     :qid |unknown.0:0|)))
(assert (forall ((LinearMaybe._default.give$A@@0 T@U) ($ly@@20 T@U) (|a#0@@2| T@U))
  (! (=> (and (= (type LinearMaybe._default.give$A@@0) TyType)
              (= (type $ly@@20) LayerTypeType)
              (= (type |a#0@@2|) BoxType))
         (= (LinearMaybe.__default.give
              LinearMaybe._default.give$A@@0
              $ly@@20
              |a#0@@2|)
            (LinearMaybe.__default.give
              LinearMaybe._default.give$A@@0
              $LZ
              |a#0@@2|)))
     :pattern ((LinearMaybe.__default.give
                 LinearMaybe._default.give$A@@0
                 (AsFuelBottom $ly@@20)
                 |a#0@@2|))
     :skolemid |1929|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((LinearMaybe._default.give$A@@1 T@U)
                    ($ly@@21 T@U)
                    (|a#0@@3| T@U))
             (! (let ((a!1 (forall ((|x#0@@1| T@U))
                             (! (let ((a!1 (=> (and ($IsBox |x#0@@1|
                                                            (|#$maybe| LinearMaybe._default.give$A@@1))
                                                    (LinearMaybe.__default.has
                                                      LinearMaybe._default.give$A@@1
                                                      |x#0@@1|)
                                                    (= |a#0@@3|
                                                       (LinearMaybe.__default.read
                                                         LinearMaybe._default.give$A@@1
                                                         |x#0@@1|)))
                                               (= (LinearMaybe.__default.give
                                                    LinearMaybe._default.give$A@@1
                                                    $ly@@21
                                                    |a#0@@3|)
                                                  |x#0@@1|))))
                                  (=> (= (type |x#0@@1|) BoxType) a!1))
                                :pattern ((LinearMaybe.__default.give
                                            LinearMaybe._default.give$A@@1
                                            $ly@@21
                                            (LinearMaybe.__default.read
                                              LinearMaybe._default.give$A@@1
                                              |x#0@@1|)))
                                :skolemid |1930|
                                :qid |LinearMaybesdfy.25:20|))))
                (let ((a!2 (and (LinearMaybe.__default.has
                                  LinearMaybe._default.give$A@@1
                                  (LinearMaybe.__default.give
                                    LinearMaybe._default.give$A@@1
                                    $ly@@21
                                    |a#0@@3|))
                                (= (LinearMaybe.__default.read
                                     LinearMaybe._default.give$A@@1
                                     (LinearMaybe.__default.give
                                       LinearMaybe._default.give$A@@1
                                       $ly@@21
                                       |a#0@@3|))
                                   |a#0@@3|)
                                a!1
                                ($IsBox (LinearMaybe.__default.give
                                          LinearMaybe._default.give$A@@1
                                          $ly@@21
                                          |a#0@@3|)
                                        (|#$maybe| LinearMaybe._default.give$A@@1)))))
                  (=> (and (= (type LinearMaybe._default.give$A@@1) TyType)
                           (= (type $ly@@21) LayerTypeType)
                           (= (type |a#0@@3|) BoxType)
                           (or (|LinearMaybe.__default.give#canCall|
                                 LinearMaybe._default.give$A@@1
                                 |a#0@@3|)
                               ($IsBox |a#0@@3| LinearMaybe._default.give$A@@1)))
                      a!2)))
                :pattern ((LinearMaybe.__default.give
                            LinearMaybe._default.give$A@@1
                            $ly@@21
                            |a#0@@3|))
                :skolemid |1931|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearMaybe._default.give$A@@2 T@U) ($ly@@22 T@U) (|a#0@@4| T@U))
  (! (=> (and (= (type LinearMaybe._default.give$A@@2) TyType)
              (= (type $ly@@22) LayerTypeType)
              (= (type |a#0@@4|) BoxType)
              ($IsBox |a#0@@4| LinearMaybe._default.give$A@@2))
         (= (|LinearMaybe.__default.give#requires|
              LinearMaybe._default.give$A@@2
              $ly@@22
              |a#0@@4|)
            true))
     :pattern ((|LinearMaybe.__default.give#requires|
                 LinearMaybe._default.give$A@@2
                 $ly@@22
                 |a#0@@4|))
     :skolemid |1932|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@413 T@U))
  (! (= (type (LinearMaybe.__default.empty arg0@@413)) BoxType)
     :pattern ((LinearMaybe.__default.empty arg0@@413))
     :qid |funType:LinearMaybe.__default.empty|)))
(assert (let ((a!1 (forall ((LinearMaybe._default.empty$A T@U))
             (! (let ((a!1 (and (not (LinearMaybe.__default.has
                                       LinearMaybe._default.empty$A
                                       (LinearMaybe.__default.empty
                                         LinearMaybe._default.empty$A)))
                                ($IsBox (LinearMaybe.__default.empty
                                          LinearMaybe._default.empty$A)
                                        (|#$maybe| LinearMaybe._default.empty$A)))))
                  (=> (and (= (type LinearMaybe._default.empty$A) TyType) true)
                      a!1))
                :pattern ((LinearMaybe.__default.empty
                            LinearMaybe._default.empty$A))
                :skolemid |1933|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearMaybe._default.empty$A@@0 T@U))
  (! (=> (= (type LinearMaybe._default.empty$A@@0) TyType)
         (= (|LinearMaybe.__default.empty#requires|
              LinearMaybe._default.empty$A@@0)
            true))
     :pattern ((|LinearMaybe.__default.empty#requires|
                 LinearMaybe._default.empty$A@@0))
     :skolemid |1934|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@414 T@U) (arg1@@163 T@U))
  (! (= (type (LinearMaybe.__default.discard arg0@@414 arg1@@163))
        DatatypeTypeType)
     :pattern ((LinearMaybe.__default.discard arg0@@414 arg1@@163))
     :qid |funType:LinearMaybe.__default.discard|)))
(assert (let ((a!1 (forall ((LinearMaybe._default.discard$A T@U) (|m#0@@7| T@U))
             (! (let ((a!1 (or (|LinearMaybe.__default.discard#canCall|
                                 LinearMaybe._default.discard$A
                                 |m#0@@7|)
                               (and ($IsBox |m#0@@7|
                                            (|#$maybe| LinearMaybe._default.discard$A))
                                    (not (LinearMaybe.__default.has
                                           LinearMaybe._default.discard$A
                                           |m#0@@7|))))))
                  (=> (and (= (type LinearMaybe._default.discard$A) TyType)
                           (= (type |m#0@@7|) BoxType)
                           a!1)
                      ($Is (LinearMaybe.__default.discard
                             LinearMaybe._default.discard$A
                             |m#0@@7|)
                           Tclass._System.Tuple0)))
                :pattern ((LinearMaybe.__default.discard
                            LinearMaybe._default.discard$A
                            |m#0@@7|))
                :skolemid |1935|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearMaybe._default.discard$A@@0 T@U) (|m#0@@8| T@U))
  (! (=> (and (= (type LinearMaybe._default.discard$A@@0) TyType)
              (= (type |m#0@@8|) BoxType)
              ($IsBox |m#0@@8| (|#$maybe| LinearMaybe._default.discard$A@@0)))
         (= (|LinearMaybe.__default.discard#requires|
              LinearMaybe._default.discard$A@@0
              |m#0@@8|)
            (not (LinearMaybe.__default.has
                   LinearMaybe._default.discard$A@@0
                   |m#0@@8|))))
     :pattern ((|LinearMaybe.__default.discard#requires|
                 LinearMaybe._default.discard$A@@0
                 |m#0@@8|))
     :skolemid |1936|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@415 T@U) (arg1@@164 Bool) (arg2@@86 T@U))
  (! (= (type (LinearMaybe.__default.imagine arg0@@415 arg1@@164 arg2@@86))
        BoxType)
     :pattern ((LinearMaybe.__default.imagine arg0@@415 arg1@@164 arg2@@86))
     :qid |funType:LinearMaybe.__default.imagine|)))
(assert (let ((a!1 (forall ((LinearMaybe._default.imagine$A T@U)
                    (|h#0| Bool)
                    (|a#0@@5| T@U))
             (! (let ((a!1 (and (= (LinearMaybe.__default.has
                                     LinearMaybe._default.imagine$A
                                     (LinearMaybe.__default.imagine
                                       LinearMaybe._default.imagine$A
                                       |h#0|
                                       |a#0@@5|))
                                   |h#0|)
                                (= (LinearMaybe.__default.read
                                     LinearMaybe._default.imagine$A
                                     (LinearMaybe.__default.imagine
                                       LinearMaybe._default.imagine$A
                                       |h#0|
                                       |a#0@@5|))
                                   |a#0@@5|)
                                ($IsBox (LinearMaybe.__default.imagine
                                          LinearMaybe._default.imagine$A
                                          |h#0|
                                          |a#0@@5|)
                                        (|#$maybe| LinearMaybe._default.imagine$A)))))
                  (=> (and (= (type LinearMaybe._default.imagine$A) TyType)
                           (= (type |a#0@@5|) BoxType)
                           (or (|LinearMaybe.__default.imagine#canCall|
                                 LinearMaybe._default.imagine$A
                                 |h#0|
                                 |a#0@@5|)
                               ($IsBox |a#0@@5| LinearMaybe._default.imagine$A)))
                      a!1))
                :pattern ((LinearMaybe.__default.imagine
                            LinearMaybe._default.imagine$A
                            |h#0|
                            |a#0@@5|))
                :skolemid |1937|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearMaybe._default.imagine$A@@0 T@U) (|h#0@@0| Bool) (|a#0@@6| T@U))
  (! (=> (and (= (type LinearMaybe._default.imagine$A@@0) TyType)
              (= (type |a#0@@6|) BoxType)
              ($IsBox |a#0@@6| LinearMaybe._default.imagine$A@@0))
         (= (|LinearMaybe.__default.imagine#requires|
              LinearMaybe._default.imagine$A@@0
              |h#0@@0|
              |a#0@@6|)
            true))
     :pattern ((|LinearMaybe.__default.imagine#requires|
                 LinearMaybe._default.imagine$A@@0
                 |h#0@@0|
                 |a#0@@6|))
     :skolemid |1938|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.LinearExtern.__default) TyType))
(assert (= (Tag Tclass.LinearExtern.__default) Tagclass.LinearExtern.__default))
(assert (= (TagFamily Tclass.LinearExtern.__default) tytagFamily$_default))
(assert (forall ((bx@@145 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@145)) bx@@145)
                     ($Is ($Unbox refType bx@@145)
                          Tclass.LinearExtern.__default))))
       (=> (and (= (type bx@@145) BoxType)
                ($IsBox bx@@145 Tclass.LinearExtern.__default))
           a!1))
     :pattern (($IsBox bx@@145 Tclass.LinearExtern.__default))
     :skolemid |1939|
     :qid |unknown.0:0|)))
(assert (forall (($o@@23 T@U))
  (! (let ((a!1 (= ($Is $o@@23 Tclass.LinearExtern.__default)
                   (or (= $o@@23 null)
                       (= (dtype $o@@23) Tclass.LinearExtern.__default)))))
       (=> (= (type $o@@23) refType) a!1))
     :pattern (($Is $o@@23 Tclass.LinearExtern.__default))
     :skolemid |1940|
     :qid |unknown.0:0|)))
(assert (forall (($o@@24 T@U) ($h@@73 T@U))
  (! (let ((a!1 (or (= $o@@24 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@73 $o@@24)
                                              alloc)))))
       (=> (and (= (type $o@@24) refType)
                (= (type $h@@73) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@24 Tclass.LinearExtern.__default $h@@73) a!1)))
     :pattern (($IsAlloc $o@@24 Tclass.LinearExtern.__default $h@@73))
     :skolemid |1941|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@416 T@U) (arg1@@165 T@U) (arg2@@87 Int))
  (! (= (type (LinearExtern.__default.seq_get arg0@@416 arg1@@165 arg2@@87))
        BoxType)
     :pattern ((LinearExtern.__default.seq_get arg0@@416 arg1@@165 arg2@@87))
     :qid |funType:LinearExtern.__default.seq_get|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.seq_get$A T@U)
                    (|s#0@@7| T@U)
                    (|i#0@@27| Int))
             (! (let ((a!1 (or (|LinearExtern.__default.seq_get#canCall|
                                 LinearSequence_s._default.seq_get$A
                                 |s#0@@7|
                                 |i#0@@27|)
                               (and ($Is |s#0@@7|
                                         (TSeq LinearSequence_s._default.seq_get$A))
                                    (INTERNAL_le_boogie 0 |i#0@@27|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@27|
                                      18446744073709551616)
                                    (INTERNAL_lt_boogie
                                      |i#0@@27|
                                      (|Seq#Length| |s#0@@7|))))))
                  (=> (and (= (type LinearSequence_s._default.seq_get$A) TyType)
                           (= (type |s#0@@7|) (SeqType BoxType))
                           a!1)
                      (and (= (LinearExtern.__default.seq_get
                                LinearSequence_s._default.seq_get$A
                                |s#0@@7|
                                |i#0@@27|)
                              (|Seq#Index| |s#0@@7| |i#0@@27|))
                           ($IsBox (LinearExtern.__default.seq_get
                                     LinearSequence_s._default.seq_get$A
                                     |s#0@@7|
                                     |i#0@@27|)
                                   LinearSequence_s._default.seq_get$A))))
                :pattern ((LinearExtern.__default.seq_get
                            LinearSequence_s._default.seq_get$A
                            |s#0@@7|
                            |i#0@@27|))
                :skolemid |1942|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.seq_get$A@@0 T@U)
         (|s#0@@8| T@U)
         (|i#0@@28| Int))
  (! (=> (and (= (type LinearSequence_s._default.seq_get$A@@0) TyType)
              (= (type |s#0@@8|) (SeqType BoxType))
              ($Is |s#0@@8| (TSeq LinearSequence_s._default.seq_get$A@@0))
              (INTERNAL_le_boogie 0 |i#0@@28|)
              (INTERNAL_lt_boogie |i#0@@28| 18446744073709551616))
         (= (|LinearExtern.__default.seq_get#requires|
              LinearSequence_s._default.seq_get$A@@0
              |s#0@@8|
              |i#0@@28|)
            (INTERNAL_lt_boogie |i#0@@28| (|Seq#Length| |s#0@@8|))))
     :pattern ((|LinearExtern.__default.seq_get#requires|
                 LinearSequence_s._default.seq_get$A@@0
                 |s#0@@8|
                 |i#0@@28|))
     :skolemid |1943|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@417 T@U) (arg1@@166 T@U) (arg2@@88 Int) (arg3@@47 T@U))
  (! (= (type (LinearExtern.__default.seq_set
                arg0@@417
                arg1@@166
                arg2@@88
                arg3@@47))
        (SeqType BoxType))
     :pattern ((LinearExtern.__default.seq_set
                 arg0@@417
                 arg1@@166
                 arg2@@88
                 arg3@@47))
     :qid |funType:LinearExtern.__default.seq_set|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.seq_set$A T@U)
                    (|s1#0| T@U)
                    (|i#0@@29| Int)
                    (|a#0@@7| T@U))
             (! (let ((a!1 (or (|LinearExtern.__default.seq_set#canCall|
                                 LinearSequence_s._default.seq_set$A
                                 |s1#0|
                                 |i#0@@29|
                                 |a#0@@7|)
                               (and ($Is |s1#0|
                                         (TSeq LinearSequence_s._default.seq_set$A))
                                    (INTERNAL_le_boogie 0 |i#0@@29|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@29|
                                      18446744073709551616)
                                    ($IsBox |a#0@@7|
                                            LinearSequence_s._default.seq_set$A)
                                    (INTERNAL_lt_boogie
                                      |i#0@@29|
                                      (|Seq#Length| |s1#0|))))))
                  (=> (and (= (type LinearSequence_s._default.seq_set$A) TyType)
                           (= (type |s1#0|) (SeqType BoxType))
                           (= (type |a#0@@7|) BoxType)
                           a!1)
                      (and (|Seq#Equal| (LinearExtern.__default.seq_set
                                          LinearSequence_s._default.seq_set$A
                                          |s1#0|
                                          |i#0@@29|
                                          |a#0@@7|)
                                        (|Seq#Update| |s1#0| |i#0@@29| |a#0@@7|))
                           ($Is (LinearExtern.__default.seq_set
                                  LinearSequence_s._default.seq_set$A
                                  |s1#0|
                                  |i#0@@29|
                                  |a#0@@7|)
                                (TSeq LinearSequence_s._default.seq_set$A)))))
                :pattern ((LinearExtern.__default.seq_set
                            LinearSequence_s._default.seq_set$A
                            |s1#0|
                            |i#0@@29|
                            |a#0@@7|))
                :skolemid |1944|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.seq_set$A@@0 T@U)
         (|s1#0@@0| T@U)
         (|i#0@@30| Int)
         (|a#0@@8| T@U))
  (! (=> (and (= (type LinearSequence_s._default.seq_set$A@@0) TyType)
              (= (type |s1#0@@0|) (SeqType BoxType))
              (= (type |a#0@@8|) BoxType)
              ($Is |s1#0@@0| (TSeq LinearSequence_s._default.seq_set$A@@0))
              (INTERNAL_le_boogie 0 |i#0@@30|)
              (INTERNAL_lt_boogie |i#0@@30| 18446744073709551616)
              ($IsBox |a#0@@8| LinearSequence_s._default.seq_set$A@@0))
         (= (|LinearExtern.__default.seq_set#requires|
              LinearSequence_s._default.seq_set$A@@0
              |s1#0@@0|
              |i#0@@30|
              |a#0@@8|)
            (INTERNAL_lt_boogie |i#0@@30| (|Seq#Length| |s1#0@@0|))))
     :pattern ((|LinearExtern.__default.seq_set#requires|
                 LinearSequence_s._default.seq_set$A@@0
                 |s1#0@@0|
                 |i#0@@30|
                 |a#0@@8|))
     :skolemid |1945|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.seq_length$A T@U) (|s#0@@9| T@U))
             (! (let ((a!1 (or (|LinearExtern.__default.seq_length#canCall|
                                 LinearSequence_s._default.seq_length$A
                                 |s#0@@9|)
                               (and ($Is |s#0@@9|
                                         (TSeq LinearSequence_s._default.seq_length$A))
                                    (INTERNAL_le_boogie
                                      (|Seq#Length| |s#0@@9|)
                                      18446744073709551615)))))
                  (=> (and (= (type LinearSequence_s._default.seq_length$A)
                              TyType)
                           (= (type |s#0@@9|) (SeqType BoxType))
                           a!1)
                      (and (= (LinearExtern.__default.seq_length
                                LinearSequence_s._default.seq_length$A
                                |s#0@@9|)
                              (|Seq#Length| |s#0@@9|))
                           (INTERNAL_le_boogie
                             0
                             (LinearExtern.__default.seq_length
                               LinearSequence_s._default.seq_length$A
                               |s#0@@9|))
                           (INTERNAL_lt_boogie
                             (LinearExtern.__default.seq_length
                               LinearSequence_s._default.seq_length$A
                               |s#0@@9|)
                             18446744073709551616))))
                :pattern ((LinearExtern.__default.seq_length
                            LinearSequence_s._default.seq_length$A
                            |s#0@@9|))
                :skolemid |1946|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.seq_length$A@@0 T@U) (|s#0@@10| T@U))
  (! (=> (and (= (type LinearSequence_s._default.seq_length$A@@0) TyType)
              (= (type |s#0@@10|) (SeqType BoxType))
              ($Is |s#0@@10| (TSeq LinearSequence_s._default.seq_length$A@@0)))
         (= (|LinearExtern.__default.seq_length#requires|
              LinearSequence_s._default.seq_length$A@@0
              |s#0@@10|)
            (INTERNAL_le_boogie (|Seq#Length| |s#0@@10|) 18446744073709551615)))
     :pattern ((|LinearExtern.__default.seq_length#requires|
                 LinearSequence_s._default.seq_length$A@@0
                 |s#0@@10|))
     :skolemid |1947|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@418 T@U))
  (! (= (type (LinearExtern.__default.seq_empty arg0@@418)) (SeqType BoxType))
     :pattern ((LinearExtern.__default.seq_empty arg0@@418))
     :qid |funType:LinearExtern.__default.seq_empty|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.seq_empty$A T@U))
             (! (let ((a!1 (and (= (|Seq#Length| (LinearExtern.__default.seq_empty
                                                   LinearSequence_s._default.seq_empty$A))
                                   (LitInt 0))
                                ($Is (LinearExtern.__default.seq_empty
                                       LinearSequence_s._default.seq_empty$A)
                                     (TSeq LinearSequence_s._default.seq_empty$A)))))
                  (=> (and (= (type LinearSequence_s._default.seq_empty$A)
                              TyType)
                           true)
                      a!1))
                :pattern ((LinearExtern.__default.seq_empty
                            LinearSequence_s._default.seq_empty$A))
                :skolemid |1948|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.seq_empty$A@@0 T@U))
  (! (=> (= (type LinearSequence_s._default.seq_empty$A@@0) TyType)
         (= (|LinearExtern.__default.seq_empty#requires|
              LinearSequence_s._default.seq_empty$A@@0)
            true))
     :pattern ((|LinearExtern.__default.seq_empty#requires|
                 LinearSequence_s._default.seq_empty$A@@0))
     :skolemid |1949|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@419 T@U) (arg1@@167 Int) (arg2@@89 T@U))
  (! (= (type (LinearExtern.__default.seq_alloc arg0@@419 arg1@@167 arg2@@89))
        (SeqType BoxType))
     :pattern ((LinearExtern.__default.seq_alloc arg0@@419 arg1@@167 arg2@@89))
     :qid |funType:LinearExtern.__default.seq_alloc|)))
(assert (=> true
    (forall ((LinearSequence_s._default.seq_alloc$A T@U)
             (|length#0| Int)
             (|a#0@@9| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_s._default.seq_alloc$A) TyType)
                         (= (type |a#0@@9|) BoxType)
                         (or (|LinearExtern.__default.seq_alloc#canCall|
                               LinearSequence_s._default.seq_alloc$A
                               |length#0|
                               |a#0@@9|)
                             (and (INTERNAL_le_boogie 0 |length#0|)
                                  (INTERNAL_lt_boogie
                                    |length#0|
                                    18446744073709551616)
                                  ($IsBox |a#0@@9|
                                          LinearSequence_s._default.seq_alloc$A)))))
               (a!2 (and (= (|Seq#Length| (LinearExtern.__default.seq_alloc
                                            LinearSequence_s._default.seq_alloc$A
                                            |length#0|
                                            |a#0@@9|))
                            |length#0|)
                         (forall ((|i#0@@31| Int))
                           (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#0@@31|)
                                              (INTERNAL_lt_boogie
                                                |i#0@@31|
                                                (|Seq#Length| (LinearExtern.__default.seq_alloc
                                                                LinearSequence_s._default.seq_alloc$A
                                                                |length#0|
                                                                |a#0@@9|))))))
                              (let ((a!2 (=> a!1
                                             (= (|Seq#Index| (LinearExtern.__default.seq_alloc
                                                               LinearSequence_s._default.seq_alloc$A
                                                               |length#0|
                                                               |a#0@@9|)
                                                             |i#0@@31|)
                                                |a#0@@9|))))
                                (=> true a!2)))
                              :pattern ((|Seq#Index| (LinearExtern.__default.seq_alloc
                                                       LinearSequence_s._default.seq_alloc$A
                                                       |length#0|
                                                       |a#0@@9|)
                                                     |i#0@@31|))
                              :skolemid |1950|
                              :qid |LinearSequencesdfy.32:20|))
                         ($Is (LinearExtern.__default.seq_alloc
                                LinearSequence_s._default.seq_alloc$A
                                |length#0|
                                |a#0@@9|)
                              (TSeq LinearSequence_s._default.seq_alloc$A)))))
           (=> a!1 a!2))
         :pattern ((LinearExtern.__default.seq_alloc
                     LinearSequence_s._default.seq_alloc$A
                     |length#0|
                     |a#0@@9|))
         :skolemid |1951|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_s._default.seq_alloc$A@@0 T@U)
         (|length#0@@0| Int)
         (|a#0@@10| T@U))
  (! (=> (and (= (type LinearSequence_s._default.seq_alloc$A@@0) TyType)
              (= (type |a#0@@10|) BoxType))
         (=> (and (INTERNAL_le_boogie 0 |length#0@@0|)
                  (INTERNAL_lt_boogie |length#0@@0| 18446744073709551616)
                  ($IsBox |a#0@@10| LinearSequence_s._default.seq_alloc$A@@0))
             (= (|LinearExtern.__default.seq_alloc#requires|
                  LinearSequence_s._default.seq_alloc$A@@0
                  |length#0@@0|
                  |a#0@@10|)
                true)))
     :pattern ((|LinearExtern.__default.seq_alloc#requires|
                 LinearSequence_s._default.seq_alloc$A@@0
                 |length#0@@0|
                 |a#0@@10|))
     :skolemid |1952|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@420 T@U) (arg1@@168 T@U))
  (! (= (type (LinearExtern.__default.seq_free arg0@@420 arg1@@168))
        DatatypeTypeType)
     :pattern ((LinearExtern.__default.seq_free arg0@@420 arg1@@168))
     :qid |funType:LinearExtern.__default.seq_free|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.seq_free$A T@U) (|s#0@@11| T@U))
             (! (let ((a!1 (and (= (type LinearSequence_s._default.seq_free$A)
                                   TyType)
                                (= (type |s#0@@11|) (SeqType BoxType))
                                (or (|LinearExtern.__default.seq_free#canCall|
                                      LinearSequence_s._default.seq_free$A
                                      |s#0@@11|)
                                    ($Is |s#0@@11|
                                         (TSeq LinearSequence_s._default.seq_free$A))))))
                  (=> a!1
                      ($Is (LinearExtern.__default.seq_free
                             LinearSequence_s._default.seq_free$A
                             |s#0@@11|)
                           Tclass._System.Tuple0)))
                :pattern ((LinearExtern.__default.seq_free
                            LinearSequence_s._default.seq_free$A
                            |s#0@@11|))
                :skolemid |1953|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.seq_free$A@@0 T@U) (|s#0@@12| T@U))
  (! (=> (and (= (type LinearSequence_s._default.seq_free$A@@0) TyType)
              (= (type |s#0@@12|) (SeqType BoxType))
              ($Is |s#0@@12| (TSeq LinearSequence_s._default.seq_free$A@@0)))
         (= (|LinearExtern.__default.seq_free#requires|
              LinearSequence_s._default.seq_free$A@@0
              |s#0@@12|)
            true))
     :pattern ((|LinearExtern.__default.seq_free#requires|
                 LinearSequence_s._default.seq_free$A@@0
                 |s#0@@12|))
     :skolemid |1954|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@421 T@U) (arg1@@169 T@U))
  (! (= (type (LinearExtern.__default.seq_unleash arg0@@421 arg1@@169))
        (SeqType BoxType))
     :pattern ((LinearExtern.__default.seq_unleash arg0@@421 arg1@@169))
     :qid |funType:LinearExtern.__default.seq_unleash|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.seq_unleash$A T@U)
                    (|s1#0@@1| T@U))
             (! (let ((a!1 (and (= (type LinearSequence_s._default.seq_unleash$A)
                                   TyType)
                                (= (type |s1#0@@1|) (SeqType BoxType))
                                (or (|LinearExtern.__default.seq_unleash#canCall|
                                      LinearSequence_s._default.seq_unleash$A
                                      |s1#0@@1|)
                                    ($Is |s1#0@@1|
                                         (TSeq LinearSequence_s._default.seq_unleash$A))))))
                  (=> a!1
                      (and (|Seq#Equal| |s1#0@@1|
                                        (LinearExtern.__default.seq_unleash
                                          LinearSequence_s._default.seq_unleash$A
                                          |s1#0@@1|))
                           ($Is (LinearExtern.__default.seq_unleash
                                  LinearSequence_s._default.seq_unleash$A
                                  |s1#0@@1|)
                                (TSeq LinearSequence_s._default.seq_unleash$A)))))
                :pattern ((LinearExtern.__default.seq_unleash
                            LinearSequence_s._default.seq_unleash$A
                            |s1#0@@1|))
                :skolemid |1955|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.seq_unleash$A@@0 T@U) (|s1#0@@2| T@U))
  (! (=> (and (= (type LinearSequence_s._default.seq_unleash$A@@0) TyType)
              (= (type |s1#0@@2|) (SeqType BoxType))
              ($Is |s1#0@@2| (TSeq LinearSequence_s._default.seq_unleash$A@@0)))
         (= (|LinearExtern.__default.seq_unleash#requires|
              LinearSequence_s._default.seq_unleash$A@@0
              |s1#0@@2|)
            true))
     :pattern ((|LinearExtern.__default.seq_unleash#requires|
                 LinearSequence_s._default.seq_unleash$A@@0
                 |s1#0@@2|))
     :skolemid |1956|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@422 T@U) (arg1@@170 T@U))
             (! (= (type (LinearExtern.__default.lseqs__raw arg0@@422 arg1@@170))
                   (SeqType BoxType))
                :pattern ((LinearExtern.__default.lseqs__raw
                            arg0@@422
                            arg1@@170))
                :qid |funType:LinearExtern.__default.lseqs__raw|)))
      (a!2 (forall ((arg0@@423 T@U))
             (! (= (type (|#$lseq| arg0@@423)) TyType)
                :pattern ((|#$lseq| arg0@@423))
                :qid |funType:#$lseq|))))
  (and a!1 a!2)))
(assert (=> true
    (forall ((LinearSequence_s._default.lseqs_raw$A T@U) (|l#0| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_s._default.lseqs_raw$A) TyType)
                         (= (type |l#0|) BoxType)
                         (or (|LinearExtern.__default.lseqs__raw#canCall|
                               LinearSequence_s._default.lseqs_raw$A
                               |l#0|)
                             ($IsBox |l#0|
                                     (|#$lseq| LinearSequence_s._default.lseqs_raw$A)))))
               (a!2 (and (_System.__default.rank__is__less__than
                           (TSeq (|#$maybe| LinearSequence_s._default.lseqs_raw$A))
                           (|#$lseq| LinearSequence_s._default.lseqs_raw$A)
                           ($Box (LinearExtern.__default.lseqs__raw
                                   LinearSequence_s._default.lseqs_raw$A
                                   |l#0|))
                           |l#0|)
                         ($Is (LinearExtern.__default.lseqs__raw
                                LinearSequence_s._default.lseqs_raw$A
                                |l#0|)
                              (TSeq (|#$maybe| LinearSequence_s._default.lseqs_raw$A))))))
           (=> a!1 a!2))
         :pattern ((LinearExtern.__default.lseqs__raw
                     LinearSequence_s._default.lseqs_raw$A
                     |l#0|))
         :skolemid |1957|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_s._default.lseqs_raw$A@@0 T@U) (|l#0@@0| T@U))
  (! (=> (and (= (type LinearSequence_s._default.lseqs_raw$A@@0) TyType)
              (= (type |l#0@@0|) BoxType)
              ($IsBox |l#0@@0|
                      (|#$lseq| LinearSequence_s._default.lseqs_raw$A@@0)))
         (= (|LinearExtern.__default.lseqs__raw#requires|
              LinearSequence_s._default.lseqs_raw$A@@0
              |l#0@@0|)
            true))
     :pattern ((|LinearExtern.__default.lseqs__raw#requires|
                 LinearSequence_s._default.lseqs_raw$A@@0
                 |l#0@@0|))
     :skolemid |1958|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@424 T@U) (arg1@@171 T@U))
  (! (= (type (LinearExtern.__default.lseq__has arg0@@424 arg1@@171))
        (SeqType BoxType))
     :pattern ((LinearExtern.__default.lseq__has arg0@@424 arg1@@171))
     :qid |funType:LinearExtern.__default.lseq__has|)))
(assert (=> true
    (forall ((LinearSequence_s._default.lseq_has$A T@U) (|l#0@@1| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_s._default.lseq_has$A) TyType)
                         (= (type |l#0@@1|) BoxType)
                         (or (|LinearExtern.__default.lseq__has#canCall|
                               LinearSequence_s._default.lseq_has$A
                               |l#0@@1|)
                             ($IsBox |l#0@@1|
                                     (|#$lseq| LinearSequence_s._default.lseq_has$A)))))
               (a!2 (and (= (|Seq#Length| (LinearExtern.__default.lseq__has
                                            LinearSequence_s._default.lseq_has$A
                                            |l#0@@1|))
                            (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                            LinearSequence_s._default.lseq_has$A
                                            |l#0@@1|)))
                         ($Is (LinearExtern.__default.lseq__has
                                LinearSequence_s._default.lseq_has$A
                                |l#0@@1|)
                              (TSeq TBool)))))
           (=> a!1 a!2))
         :pattern ((LinearExtern.__default.lseq__has
                     LinearSequence_s._default.lseq_has$A
                     |l#0@@1|))
         :skolemid |1959|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_s._default.lseq_has$A@@0 T@U)
         ($Heap@@5 T@U)
         (|l#0@@2| T@U))
  (! (=> (and (= (type LinearSequence_s._default.lseq_has$A@@0) TyType)
              (= (type $Heap@@5) (MapType0Type refType MapType1Type))
              (= (type |l#0@@2|) BoxType)
              ($IsGoodHeap $Heap@@5)
              ($IsBox |l#0@@2|
                      (|#$lseq| LinearSequence_s._default.lseq_has$A@@0)))
         (= (|LinearExtern.__default.lseq__has#requires|
              LinearSequence_s._default.lseq_has$A@@0
              |l#0@@2|)
            true))
     :pattern ((|LinearExtern.__default.lseq__has#requires|
                 LinearSequence_s._default.lseq_has$A@@0
                 |l#0@@2|)
               ($IsGoodHeap $Heap@@5))
     :skolemid |1960|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@425 T@U))
             (! (= (type (|lambda#94| arg0@@425))
                   (MapType0Type LayerTypeType HandleTypeType))
                :pattern ((|lambda#94| arg0@@425))
                :qid |funType:lambda#94|)))
      (a!2 (forall ((arg0@@426 T@U) (arg1@@172 T@U))
             (! (= (type (|lambda#90| arg0@@426 arg1@@172))
                   (MapType2Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 BoxType))
                :pattern ((|lambda#90| arg0@@426 arg1@@172))
                :qid |funType:lambda#90|)))
      (a!3 (forall ((arg0@@427 T@U) (arg1@@173 Int) (arg2@@90 Int))
             (! (= (type (|lambda#91| arg0@@427 arg1@@173 arg2@@90))
                   (MapType2Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 boolType))
                :pattern ((|lambda#91| arg0@@427 arg1@@173 arg2@@90))
                :qid |funType:lambda#91|)))
      (a!4 (forall ((arg0@@428 T@U))
             (! (= (type (|lambda#93| arg0@@428))
                   (MapType2Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 (MapType0Type BoxType boolType)))
                :pattern ((|lambda#93| arg0@@428))
                :qid |funType:lambda#93|)))
      (a!5 (forall ((arg0@@429 Bool))
             (! (= (type (|lambda#92| arg0@@429))
                   (MapType0Type refType boolType))
                :pattern ((|lambda#92| arg0@@429))
                :qid |funType:lambda#92|))))
  (and a!1 a!2 a!3 a!4 a!5)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.lseq_has$A@@1 T@U)
                    ($Heap@@6 T@U)
                    (|l#0@@3| T@U))
             (! (let ((a!1 (or (|LinearExtern.__default.lseq__has#canCall|
                                 LinearSequence_s._default.lseq_has$A@@1
                                 |l#0@@3|)
                               (and ($IsGoodHeap $Heap@@6)
                                    ($IsBox |l#0@@3|
                                            (|#$lseq| LinearSequence_s._default.lseq_has$A@@1)))))
                      (a!2 (forall ((|$l#1#i#0| Int))
                             (! (let ((a!1 (and (INTERNAL_le_boogie
                                                  0
                                                  |$l#1#i#0|)
                                                (INTERNAL_lt_boogie
                                                  |$l#1#i#0|
                                                  (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                                  LinearSequence_s._default.lseq_has$A@@1
                                                                  |l#0@@3|)))))
                                      (a!2 (and (|LinearExtern.__default.lseqs__raw#canCall|
                                                  LinearSequence_s._default.lseq_has$A@@1
                                                  |l#0@@3|)
                                                (|LinearMaybe.__default.has#canCall|
                                                  LinearSequence_s._default.lseq_has$A@@1
                                                  (|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                                 LinearSequence_s._default.lseq_has$A@@1
                                                                 |l#0@@3|)
                                                               |$l#1#i#0|)))))
                                  (and (=> (INTERNAL_le_boogie 0 |$l#1#i#0|)
                                           (|LinearExtern.__default.lseqs__raw#canCall|
                                             LinearSequence_s._default.lseq_has$A@@1
                                             |l#0@@3|))
                                       (=> a!1 a!2)))
                                :no-pattern (INTERNAL_lt_boogie
                                              |$l#1#i#0|
                                              (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                              LinearSequence_s._default.lseq_has$A@@1
                                                              |l#0@@3|)))
                                :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0|)
                                :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0|)
                                :skolemid |1961|
                                :qid |unknown.0:0|)))
                      (a!3 (Handle1 (|lambda#90| LinearSequence_s._default.lseq_has$A@@1
                                                 (LinearExtern.__default.lseqs__raw
                                                   LinearSequence_s._default.lseq_has$A@@1
                                                   |l#0@@3|))
                                    (|lambda#91| TInt
                                                 0
                                                 (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                                 LinearSequence_s._default.lseq_has$A@@1
                                                                 |l#0@@3|)))
                                    (|lambda#93| (SetRef_to_SetBox (|lambda#92| false))))))
                (let ((a!4 (|Seq#Create| TBool
                                         $Heap@@6
                                         (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                         LinearSequence_s._default.lseq_has$A@@1
                                                         |l#0@@3|))
                                         (Lit (AtLayer (|lambda#94| a!3)
                                                       ($LS $LZ))))))
                  (=> (and (= (type LinearSequence_s._default.lseq_has$A@@1)
                              TyType)
                           (= (type $Heap@@6)
                              (MapType0Type refType MapType1Type))
                           (= (type |l#0@@3|) BoxType)
                           a!1)
                      (and (|LinearExtern.__default.lseqs__raw#canCall|
                             LinearSequence_s._default.lseq_has$A@@1
                             |l#0@@3|)
                           a!2
                           (= (LinearExtern.__default.lseq__has
                                LinearSequence_s._default.lseq_has$A@@1
                                |l#0@@3|)
                              a!4)))))
                :pattern ((LinearExtern.__default.lseq__has
                            LinearSequence_s._default.lseq_has$A@@1
                            |l#0@@3|)
                          ($IsGoodHeap $Heap@@6))
                :skolemid |1962|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.lseq_has$A@@2 T@U)
                    ($Heap@@7 T@U)
                    (|l#0@@4| T@U))
             (! (let ((a!1 (or (|LinearExtern.__default.lseq__has#canCall|
                                 LinearSequence_s._default.lseq_has$A@@2
                                 (Lit |l#0@@4|))
                               (and ($IsGoodHeap $Heap@@7)
                                    ($IsBox |l#0@@4|
                                            (|#$lseq| LinearSequence_s._default.lseq_has$A@@2)))))
                      (a!2 (forall ((|$l#3#i#0| Int))
                             (! (let ((a!1 (INTERNAL_lt_boogie
                                             |$l#3#i#0|
                                             (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                             LinearSequence_s._default.lseq_has$A@@2
                                                             (Lit |l#0@@4|)))))
                                      (a!2 (|LinearMaybe.__default.has#canCall|
                                             LinearSequence_s._default.lseq_has$A@@2
                                             (|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                            LinearSequence_s._default.lseq_has$A@@2
                                                            (Lit |l#0@@4|))
                                                          |$l#3#i#0|))))
                                (let ((a!3 (=> (and (INTERNAL_le_boogie
                                                      0
                                                      |$l#3#i#0|)
                                                    a!1)
                                               (and (|LinearExtern.__default.lseqs__raw#canCall|
                                                      LinearSequence_s._default.lseq_has$A@@2
                                                      (Lit |l#0@@4|))
                                                    a!2))))
                                  (and (=> (INTERNAL_le_boogie 0 |$l#3#i#0|)
                                           (|LinearExtern.__default.lseqs__raw#canCall|
                                             LinearSequence_s._default.lseq_has$A@@2
                                             (Lit |l#0@@4|)))
                                       a!3)))
                                :no-pattern (INTERNAL_lt_boogie
                                              |$l#3#i#0|
                                              (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                              LinearSequence_s._default.lseq_has$A@@2
                                                              (Lit |l#0@@4|))))
                                :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0|)
                                :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0|)
                                :skolemid |1963|
                                :qid |unknown.0:0|)))
                      (a!3 (|lambda#91| TInt
                                        0
                                        (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                        LinearSequence_s._default.lseq_has$A@@2
                                                        (Lit |l#0@@4|))))))
                (let ((a!4 (Handle1 (|lambda#90| LinearSequence_s._default.lseq_has$A@@2
                                                 (LinearExtern.__default.lseqs__raw
                                                   LinearSequence_s._default.lseq_has$A@@2
                                                   (Lit |l#0@@4|)))
                                    a!3
                                    (|lambda#93| (SetRef_to_SetBox (|lambda#92| false))))))
                (let ((a!5 (|Seq#Create| TBool
                                         $Heap@@7
                                         (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                         LinearSequence_s._default.lseq_has$A@@2
                                                         (Lit |l#0@@4|)))
                                         (Lit (AtLayer (|lambda#94| a!4)
                                                       ($LS $LZ))))))
                (let ((a!6 (and (|LinearExtern.__default.lseqs__raw#canCall|
                                  LinearSequence_s._default.lseq_has$A@@2
                                  (Lit |l#0@@4|))
                                a!2
                                (= (LinearExtern.__default.lseq__has
                                     LinearSequence_s._default.lseq_has$A@@2
                                     (Lit |l#0@@4|))
                                   a!5))))
                  (=> (and (= (type LinearSequence_s._default.lseq_has$A@@2)
                              TyType)
                           (= (type $Heap@@7)
                              (MapType0Type refType MapType1Type))
                           (= (type |l#0@@4|) BoxType)
                           a!1)
                      a!6)))))
                :pattern ((LinearExtern.__default.lseq__has
                            LinearSequence_s._default.lseq_has$A@@2
                            (Lit |l#0@@4|))
                          ($IsGoodHeap $Heap@@7))
                :weight 3
                :skolemid |1964|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@430 T@U) (arg1@@174 T@U))
  (! (= (type (LinearExtern.__default.imagine__lseq__raw arg0@@430 arg1@@174))
        BoxType)
     :pattern ((LinearExtern.__default.imagine__lseq__raw arg0@@430 arg1@@174))
     :qid |funType:LinearExtern.__default.imagine__lseq__raw|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.imagine_lseq_raw$A T@U)
                    (|s#0@@13| T@U))
             (! (let ((a!1 (or (|LinearExtern.__default.imagine__lseq__raw#canCall|
                                 LinearSequence_s._default.imagine_lseq_raw$A
                                 |s#0@@13|)
                               ($Is |s#0@@13|
                                    (TSeq (|#$maybe| LinearSequence_s._default.imagine_lseq_raw$A)))))
                      (a!2 (and (|Seq#Equal| (LinearExtern.__default.lseqs__raw
                                               LinearSequence_s._default.imagine_lseq_raw$A
                                               (LinearExtern.__default.imagine__lseq__raw
                                                 LinearSequence_s._default.imagine_lseq_raw$A
                                                 |s#0@@13|))
                                             |s#0@@13|)
                                ($IsBox (LinearExtern.__default.imagine__lseq__raw
                                          LinearSequence_s._default.imagine_lseq_raw$A
                                          |s#0@@13|)
                                        (|#$lseq| LinearSequence_s._default.imagine_lseq_raw$A)))))
                  (=> (and (= (type LinearSequence_s._default.imagine_lseq_raw$A)
                              TyType)
                           (= (type |s#0@@13|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((LinearExtern.__default.imagine__lseq__raw
                            LinearSequence_s._default.imagine_lseq_raw$A
                            |s#0@@13|))
                :skolemid |1965|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.imagine_lseq_raw$A@@0 T@U) (|s#0@@14| T@U))
  (! (let ((a!1 (and (= (type LinearSequence_s._default.imagine_lseq_raw$A@@0)
                        TyType)
                     (= (type |s#0@@14|) (SeqType BoxType))
                     ($Is |s#0@@14|
                          (TSeq (|#$maybe| LinearSequence_s._default.imagine_lseq_raw$A@@0))))))
       (=> a!1
           (= (|LinearExtern.__default.imagine__lseq__raw#requires|
                LinearSequence_s._default.imagine_lseq_raw$A@@0
                |s#0@@14|)
              true)))
     :pattern ((|LinearExtern.__default.imagine__lseq__raw#requires|
                 LinearSequence_s._default.imagine_lseq_raw$A@@0
                 |s#0@@14|))
     :skolemid |1966|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.lseq_length_raw$A T@U)
                    (|s#0@@15| T@U))
             (! (let ((a!1 (and ($IsBox |s#0@@15|
                                        (|#$lseq| LinearSequence_s._default.lseq_length_raw$A))
                                (INTERNAL_le_boogie
                                  (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                  LinearSequence_s._default.lseq_length_raw$A
                                                  |s#0@@15|))
                                  18446744073709551615)))
                      (a!2 (and (= (LinearExtern.__default.lseq_length_raw
                                     LinearSequence_s._default.lseq_length_raw$A
                                     |s#0@@15|)
                                   (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                   LinearSequence_s._default.lseq_length_raw$A
                                                   |s#0@@15|)))
                                (INTERNAL_le_boogie
                                  0
                                  (LinearExtern.__default.lseq_length_raw
                                    LinearSequence_s._default.lseq_length_raw$A
                                    |s#0@@15|))
                                (INTERNAL_lt_boogie
                                  (LinearExtern.__default.lseq_length_raw
                                    LinearSequence_s._default.lseq_length_raw$A
                                    |s#0@@15|)
                                  18446744073709551616))))
                  (=> (and (= (type LinearSequence_s._default.lseq_length_raw$A)
                              TyType)
                           (= (type |s#0@@15|) BoxType)
                           (or (|LinearExtern.__default.lseq_length_raw#canCall|
                                 LinearSequence_s._default.lseq_length_raw$A
                                 |s#0@@15|)
                               a!1))
                      a!2))
                :pattern ((LinearExtern.__default.lseq_length_raw
                            LinearSequence_s._default.lseq_length_raw$A
                            |s#0@@15|))
                :skolemid |1967|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.lseq_length_raw$A@@0 T@U) (|s#0@@16| T@U))
  (! (let ((a!1 (= (|LinearExtern.__default.lseq_length_raw#requires|
                     LinearSequence_s._default.lseq_length_raw$A@@0
                     |s#0@@16|)
                   (INTERNAL_le_boogie
                     (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                     LinearSequence_s._default.lseq_length_raw$A@@0
                                     |s#0@@16|))
                     18446744073709551615))))
       (=> (and (= (type LinearSequence_s._default.lseq_length_raw$A@@0) TyType)
                (= (type |s#0@@16|) BoxType)
                ($IsBox |s#0@@16|
                        (|#$lseq| LinearSequence_s._default.lseq_length_raw$A@@0)))
           a!1))
     :pattern ((|LinearExtern.__default.lseq_length_raw#requires|
                 LinearSequence_s._default.lseq_length_raw$A@@0
                 |s#0@@16|))
     :skolemid |1968|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@431 T@U) (arg1@@175 Int))
  (! (= (type (LinearExtern.__default.lseq_alloc_raw arg0@@431 arg1@@175))
        BoxType)
     :pattern ((LinearExtern.__default.lseq_alloc_raw arg0@@431 arg1@@175))
     :qid |funType:LinearExtern.__default.lseq_alloc_raw|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.lseq_alloc_raw$A T@U)
                    (|length#0@@1| Int))
             (! (let ((a!1 (and (= (type LinearSequence_s._default.lseq_alloc_raw$A)
                                   TyType)
                                (or (|LinearExtern.__default.lseq_alloc_raw#canCall|
                                      LinearSequence_s._default.lseq_alloc_raw$A
                                      |length#0@@1|)
                                    (and (INTERNAL_le_boogie 0 |length#0@@1|)
                                         (INTERNAL_lt_boogie
                                           |length#0@@1|
                                           18446744073709551616)))))
                      (a!2 (= (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                              LinearSequence_s._default.lseq_alloc_raw$A
                                              (LinearExtern.__default.lseq_alloc_raw
                                                LinearSequence_s._default.lseq_alloc_raw$A
                                                |length#0@@1|)))
                              |length#0@@1|))
                      (a!3 (forall ((|i#0@@32| Int))
                             (! (let ((a!1 (LinearMaybe.__default.has
                                             LinearSequence_s._default.lseq_alloc_raw$A
                                             (|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                            LinearSequence_s._default.lseq_alloc_raw$A
                                                            (LinearExtern.__default.lseq_alloc_raw
                                                              LinearSequence_s._default.lseq_alloc_raw$A
                                                              |length#0@@1|))
                                                          |i#0@@32|))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#0@@32|)
                                           (INTERNAL_lt_boogie
                                             |i#0@@32|
                                             |length#0@@1|))
                                      (not a!1)))
                                :pattern ((|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                         LinearSequence_s._default.lseq_alloc_raw$A
                                                         (LinearExtern.__default.lseq_alloc_raw
                                                           LinearSequence_s._default.lseq_alloc_raw$A
                                                           |length#0@@1|))
                                                       |i#0@@32|))
                                :skolemid |1969|
                                :qid |LinearSequencesdfy.92:22|))))
                  (=> a!1
                      (and a!2
                           a!3
                           ($IsBox (LinearExtern.__default.lseq_alloc_raw
                                     LinearSequence_s._default.lseq_alloc_raw$A
                                     |length#0@@1|)
                                   (|#$lseq| LinearSequence_s._default.lseq_alloc_raw$A)))))
                :pattern ((LinearExtern.__default.lseq_alloc_raw
                            LinearSequence_s._default.lseq_alloc_raw$A
                            |length#0@@1|))
                :skolemid |1970|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.lseq_alloc_raw$A@@0 T@U)
         (|length#0@@2| Int))
  (! (=> (= (type LinearSequence_s._default.lseq_alloc_raw$A@@0) TyType)
         (=> (and (INTERNAL_le_boogie 0 |length#0@@2|)
                  (INTERNAL_lt_boogie |length#0@@2| 18446744073709551616))
             (= (|LinearExtern.__default.lseq_alloc_raw#requires|
                  LinearSequence_s._default.lseq_alloc_raw$A@@0
                  |length#0@@2|)
                true)))
     :pattern ((|LinearExtern.__default.lseq_alloc_raw#requires|
                 LinearSequence_s._default.lseq_alloc_raw$A@@0
                 |length#0@@2|))
     :skolemid |1971|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@432 T@U) (arg1@@176 T@U))
  (! (= (type (LinearExtern.__default.lseq_free_raw arg0@@432 arg1@@176))
        DatatypeTypeType)
     :pattern ((LinearExtern.__default.lseq_free_raw arg0@@432 arg1@@176))
     :qid |funType:LinearExtern.__default.lseq_free_raw|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.lseq_free_raw$A T@U)
                    (|s#0@@17| T@U))
             (! (let ((a!1 (or (|LinearExtern.__default.lseq_free_raw#canCall|
                                 LinearSequence_s._default.lseq_free_raw$A
                                 |s#0@@17|)
                               (and ($IsBox |s#0@@17|
                                            (|#$lseq| LinearSequence_s._default.lseq_free_raw$A))
                                    (forall ((|i#0@@33| Int))
                                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                                           0
                                                           |i#0@@33|)
                                                         (INTERNAL_lt_boogie
                                                           |i#0@@33|
                                                           (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                                           LinearSequence_s._default.lseq_free_raw$A
                                                                           |s#0@@17|)))))
                                               (a!2 (not (LinearMaybe.__default.has
                                                           LinearSequence_s._default.lseq_free_raw$A
                                                           (|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                                          LinearSequence_s._default.lseq_free_raw$A
                                                                          |s#0@@17|)
                                                                        |i#0@@33|)))))
                                           (=> a!1 a!2))
                                         :pattern ((|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                                  LinearSequence_s._default.lseq_free_raw$A
                                                                  |s#0@@17|)
                                                                |i#0@@33|))
                                         :skolemid |1972|
                                         :qid |LinearSequencesdfy.95:23|))))))
                  (=> (and (= (type LinearSequence_s._default.lseq_free_raw$A)
                              TyType)
                           (= (type |s#0@@17|) BoxType)
                           a!1)
                      ($Is (LinearExtern.__default.lseq_free_raw
                             LinearSequence_s._default.lseq_free_raw$A
                             |s#0@@17|)
                           Tclass._System.Tuple0)))
                :pattern ((LinearExtern.__default.lseq_free_raw
                            LinearSequence_s._default.lseq_free_raw$A
                            |s#0@@17|))
                :skolemid |1973|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.lseq_free_raw$A@@0 T@U) (|s#0@@18| T@U))
  (! (=> (and (= (type LinearSequence_s._default.lseq_free_raw$A@@0) TyType)
              (= (type |s#0@@18|) BoxType)
              ($IsBox |s#0@@18|
                      (|#$lseq| LinearSequence_s._default.lseq_free_raw$A@@0)))
         (= (|LinearExtern.__default.lseq_free_raw#requires|
              LinearSequence_s._default.lseq_free_raw$A@@0
              |s#0@@18|)
            (forall ((|i#1@@1| Int))
              (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#1@@1|)
                                 (INTERNAL_lt_boogie
                                   |i#1@@1|
                                   (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                   LinearSequence_s._default.lseq_free_raw$A@@0
                                                   |s#0@@18|)))))
                       (a!2 (not (LinearMaybe.__default.has
                                   LinearSequence_s._default.lseq_free_raw$A@@0
                                   (|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                  LinearSequence_s._default.lseq_free_raw$A@@0
                                                  |s#0@@18|)
                                                |i#1@@1|)))))
                   (=> a!1 a!2))
                 :pattern ((|Seq#Index| (LinearExtern.__default.lseqs__raw
                                          LinearSequence_s._default.lseq_free_raw$A@@0
                                          |s#0@@18|)
                                        |i#1@@1|))
                 :skolemid |1974|
                 :qid |LinearSequencesdfy.95:23|))))
     :pattern ((|LinearExtern.__default.lseq_free_raw#requires|
                 LinearSequence_s._default.lseq_free_raw$A@@0
                 |s#0@@18|))
     :skolemid |1975|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@433 T@U) (arg1@@177 T@U) (arg2@@91 Int) (arg3@@48 T@U))
  (! (= (type (LinearExtern.__default.lseq_swap_raw_fun
                arg0@@433
                arg1@@177
                arg2@@91
                arg3@@48))
        DatatypeTypeType)
     :pattern ((LinearExtern.__default.lseq_swap_raw_fun
                 arg0@@433
                 arg1@@177
                 arg2@@91
                 arg3@@48))
     :qid |funType:LinearExtern.__default.lseq_swap_raw_fun|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.lseq_swap_raw_fun$A T@U)
                    (|s1#0@@3| T@U)
                    (|i#0@@34| Int)
                    (|a1#0| T@U))
             (! (let ((a!1 (and ($IsBox |s1#0@@3|
                                        (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A))
                                (INTERNAL_le_boogie 0 |i#0@@34|)
                                (INTERNAL_lt_boogie
                                  |i#0@@34|
                                  18446744073709551616)
                                ($IsBox |a1#0|
                                        (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A))
                                (INTERNAL_lt_boogie
                                  |i#0@@34|
                                  (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                  LinearSequence_s._default.lseq_swap_raw_fun$A
                                                  |s1#0@@3|)))))
                      (a!2 (|Seq#Equal| (LinearExtern.__default.lseqs__raw
                                          LinearSequence_s._default.lseq_swap_raw_fun$A
                                          (_System.Tuple2OLL._0
                                            (LinearExtern.__default.lseq_swap_raw_fun
                                              LinearSequence_s._default.lseq_swap_raw_fun$A
                                              |s1#0@@3|
                                              |i#0@@34|
                                              |a1#0|)))
                                        (|Seq#Update| (LinearExtern.__default.lseqs__raw
                                                        LinearSequence_s._default.lseq_swap_raw_fun$A
                                                        |s1#0@@3|)
                                                      |i#0@@34|
                                                      |a1#0|))))
                (let ((a!3 (and (= (_System.Tuple2OLL._1
                                     (LinearExtern.__default.lseq_swap_raw_fun
                                       LinearSequence_s._default.lseq_swap_raw_fun$A
                                       |s1#0@@3|
                                       |i#0@@34|
                                       |a1#0|))
                                   (|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                  LinearSequence_s._default.lseq_swap_raw_fun$A
                                                  |s1#0@@3|)
                                                |i#0@@34|))
                                a!2
                                ($Is (LinearExtern.__default.lseq_swap_raw_fun
                                       LinearSequence_s._default.lseq_swap_raw_fun$A
                                       |s1#0@@3|
                                       |i#0@@34|
                                       |a1#0|)
                                     (Tclass._System.Tuple2OLL
                                       (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A)
                                       (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A))))))
                  (=> (and (= (type LinearSequence_s._default.lseq_swap_raw_fun$A)
                              TyType)
                           (= (type |s1#0@@3|) BoxType)
                           (= (type |a1#0|) BoxType)
                           (or (|LinearExtern.__default.lseq_swap_raw_fun#canCall|
                                 LinearSequence_s._default.lseq_swap_raw_fun$A
                                 |s1#0@@3|
                                 |i#0@@34|
                                 |a1#0|)
                               a!1))
                      a!3)))
                :pattern ((LinearExtern.__default.lseq_swap_raw_fun
                            LinearSequence_s._default.lseq_swap_raw_fun$A
                            |s1#0@@3|
                            |i#0@@34|
                            |a1#0|))
                :skolemid |1976|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.lseq_swap_raw_fun$A@@0 T@U)
         (|s1#0@@4| T@U)
         (|i#0@@35| Int)
         (|a1#0@@0| T@U))
  (! (let ((a!1 (= (|LinearExtern.__default.lseq_swap_raw_fun#requires|
                     LinearSequence_s._default.lseq_swap_raw_fun$A@@0
                     |s1#0@@4|
                     |i#0@@35|
                     |a1#0@@0|)
                   (INTERNAL_lt_boogie
                     |i#0@@35|
                     (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                     LinearSequence_s._default.lseq_swap_raw_fun$A@@0
                                     |s1#0@@4|))))))
       (=> (and (= (type LinearSequence_s._default.lseq_swap_raw_fun$A@@0)
                   TyType)
                (= (type |s1#0@@4|) BoxType)
                (= (type |a1#0@@0|) BoxType)
                ($IsBox |s1#0@@4|
                        (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A@@0))
                (INTERNAL_le_boogie 0 |i#0@@35|)
                (INTERNAL_lt_boogie |i#0@@35| 18446744073709551616)
                ($IsBox |a1#0@@0|
                        (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A@@0)))
           a!1))
     :pattern ((|LinearExtern.__default.lseq_swap_raw_fun#requires|
                 LinearSequence_s._default.lseq_swap_raw_fun$A@@0
                 |s1#0@@4|
                 |i#0@@35|
                 |a1#0@@0|))
     :skolemid |1977|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@434 T@U) (arg1@@178 T@U) (arg2@@92 Int))
  (! (= (type (LinearExtern.__default.lseq_share_raw
                arg0@@434
                arg1@@178
                arg2@@92))
        BoxType)
     :pattern ((LinearExtern.__default.lseq_share_raw
                 arg0@@434
                 arg1@@178
                 arg2@@92))
     :qid |funType:LinearExtern.__default.lseq_share_raw|)))
(assert (let ((a!1 (forall ((LinearSequence_s._default.lseq_share_raw$A T@U)
                    (|s#0@@19| T@U)
                    (|i#0@@36| Int))
             (! (let ((a!1 (and ($IsBox |s#0@@19|
                                        (|#$lseq| LinearSequence_s._default.lseq_share_raw$A))
                                (INTERNAL_le_boogie 0 |i#0@@36|)
                                (INTERNAL_lt_boogie
                                  |i#0@@36|
                                  18446744073709551616)
                                (INTERNAL_lt_boogie
                                  |i#0@@36|
                                  (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                                  LinearSequence_s._default.lseq_share_raw$A
                                                  |s#0@@19|)))))
                      (a!2 (and (= (LinearExtern.__default.lseq_share_raw
                                     LinearSequence_s._default.lseq_share_raw$A
                                     |s#0@@19|
                                     |i#0@@36|)
                                   (|Seq#Index| (LinearExtern.__default.lseqs__raw
                                                  LinearSequence_s._default.lseq_share_raw$A
                                                  |s#0@@19|)
                                                |i#0@@36|))
                                ($IsBox (LinearExtern.__default.lseq_share_raw
                                          LinearSequence_s._default.lseq_share_raw$A
                                          |s#0@@19|
                                          |i#0@@36|)
                                        (|#$maybe| LinearSequence_s._default.lseq_share_raw$A)))))
                  (=> (and (= (type LinearSequence_s._default.lseq_share_raw$A)
                              TyType)
                           (= (type |s#0@@19|) BoxType)
                           (or (|LinearExtern.__default.lseq_share_raw#canCall|
                                 LinearSequence_s._default.lseq_share_raw$A
                                 |s#0@@19|
                                 |i#0@@36|)
                               a!1))
                      a!2))
                :pattern ((LinearExtern.__default.lseq_share_raw
                            LinearSequence_s._default.lseq_share_raw$A
                            |s#0@@19|
                            |i#0@@36|))
                :skolemid |1978|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_s._default.lseq_share_raw$A@@0 T@U)
         (|s#0@@20| T@U)
         (|i#0@@37| Int))
  (! (let ((a!1 (= (|LinearExtern.__default.lseq_share_raw#requires|
                     LinearSequence_s._default.lseq_share_raw$A@@0
                     |s#0@@20|
                     |i#0@@37|)
                   (INTERNAL_lt_boogie
                     |i#0@@37|
                     (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                     LinearSequence_s._default.lseq_share_raw$A@@0
                                     |s#0@@20|))))))
       (=> (and (= (type LinearSequence_s._default.lseq_share_raw$A@@0) TyType)
                (= (type |s#0@@20|) BoxType)
                ($IsBox |s#0@@20|
                        (|#$lseq| LinearSequence_s._default.lseq_share_raw$A@@0))
                (INTERNAL_le_boogie 0 |i#0@@37|)
                (INTERNAL_lt_boogie |i#0@@37| 18446744073709551616))
           a!1))
     :pattern ((|LinearExtern.__default.lseq_share_raw#requires|
                 LinearSequence_s._default.lseq_share_raw$A@@0
                 |s#0@@20|
                 |i#0@@37|))
     :skolemid |1979|
     :qid |unknown.0:0|)))
(assert (= (type |#ValueMessage.Delta.NoDelta|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#ValueMessage.Delta.NoDelta|)
   |##ValueMessage.Delta.NoDelta|))
(assert (forall ((d@@23 T@U))
  (! (=> (= (type d@@23) DatatypeTypeType)
         (= (ValueMessage.Delta.NoDelta_q d@@23)
            (= (DatatypeCtorId d@@23) |##ValueMessage.Delta.NoDelta|)))
     :pattern ((ValueMessage.Delta.NoDelta_q d@@23))
     :skolemid |1980|
     :qid |unknown.0:0|)))
(assert (forall ((d@@24 T@U))
  (! (=> (and (= (type d@@24) DatatypeTypeType)
              (ValueMessage.Delta.NoDelta_q d@@24))
         (= d@@24 |#ValueMessage.Delta.NoDelta|))
     :pattern ((ValueMessage.Delta.NoDelta_q d@@24))
     :skolemid |1981|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.ValueMessage.Delta) TyType))
(assert (= (Tag Tclass.ValueMessage.Delta) Tagclass.ValueMessage.Delta))
(assert (= (TagFamily Tclass.ValueMessage.Delta) tytagFamily$Delta))
(assert (forall ((bx@@146 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox DatatypeTypeType bx@@146)) bx@@146)
                     ($Is ($Unbox DatatypeTypeType bx@@146)
                          Tclass.ValueMessage.Delta))))
       (=> (and (= (type bx@@146) BoxType)
                ($IsBox bx@@146 Tclass.ValueMessage.Delta))
           a!1))
     :pattern (($IsBox bx@@146 Tclass.ValueMessage.Delta))
     :skolemid |1982|
     :qid |unknown.0:0|)))
(assert ($Is |#ValueMessage.Delta.NoDelta| Tclass.ValueMessage.Delta))
(assert (forall (($h@@74 T@U))
  (! (=> (and (= (type $h@@74) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@74))
         ($IsAlloc |#ValueMessage.Delta.NoDelta|
                   Tclass.ValueMessage.Delta
                   $h@@74))
     :pattern (($IsAlloc |#ValueMessage.Delta.NoDelta|
                         Tclass.ValueMessage.Delta
                         $h@@74))
     :skolemid |1983|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#ValueMessage.Delta.NoDelta| (Lit |#ValueMessage.Delta.NoDelta|)))
(assert (forall ((d@@25 T@U))
  (! (=> (and (= (type d@@25) DatatypeTypeType)
              (|$IsA#ValueMessage.Delta| d@@25))
         (ValueMessage.Delta.NoDelta_q d@@25))
     :pattern ((|$IsA#ValueMessage.Delta| d@@25))
     :skolemid |1984|
     :qid |unknown.0:0|)))
(assert (forall ((d@@26 T@U))
  (! (=> (and (= (type d@@26) DatatypeTypeType)
              ($Is d@@26 Tclass.ValueMessage.Delta))
         (ValueMessage.Delta.NoDelta_q d@@26))
     :pattern ((ValueMessage.Delta.NoDelta_q d@@26)
               ($Is d@@26 Tclass.ValueMessage.Delta))
     :skolemid |1985|
     :qid |unknown.0:0|)))
(assert (forall ((a@@121 T@U) (b@@70 T@U))
  (! (=> (and (= (type a@@121) DatatypeTypeType)
              (= (type b@@70) DatatypeTypeType)
              true)
         (= (|ValueMessage.Delta#Equal| a@@121 b@@70) true))
     :pattern ((|ValueMessage.Delta#Equal| a@@121 b@@70))
     :skolemid |1986|
     :qid |unknown.0:0|)))
(assert (forall ((a@@122 T@U) (b@@71 T@U))
  (! (=> (and (= (type a@@122) DatatypeTypeType)
              (= (type b@@71) DatatypeTypeType))
         (= (|ValueMessage.Delta#Equal| a@@122 b@@71) (= a@@122 b@@71)))
     :pattern ((|ValueMessage.Delta#Equal| a@@122 b@@71))
     :skolemid |1987|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.ValueMessage.__default) TyType))
(assert (= (Tag Tclass.ValueMessage.__default) Tagclass.ValueMessage.__default))
(assert (= (TagFamily Tclass.ValueMessage.__default) tytagFamily$_default))
(assert (forall ((bx@@147 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@147)) bx@@147)
                     ($Is ($Unbox refType bx@@147)
                          Tclass.ValueMessage.__default))))
       (=> (and (= (type bx@@147) BoxType)
                ($IsBox bx@@147 Tclass.ValueMessage.__default))
           a!1))
     :pattern (($IsBox bx@@147 Tclass.ValueMessage.__default))
     :skolemid |1988|
     :qid |unknown.0:0|)))
(assert (forall (($o@@25 T@U))
  (! (let ((a!1 (= ($Is $o@@25 Tclass.ValueMessage.__default)
                   (or (= $o@@25 null)
                       (= (dtype $o@@25) Tclass.ValueMessage.__default)))))
       (=> (= (type $o@@25) refType) a!1))
     :pattern (($Is $o@@25 Tclass.ValueMessage.__default))
     :skolemid |1989|
     :qid |unknown.0:0|)))
(assert (forall (($o@@26 T@U) ($h@@75 T@U))
  (! (let ((a!1 (or (= $o@@26 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@75 $o@@26)
                                              alloc)))))
       (=> (and (= (type $o@@26) refType)
                (= (type $h@@75) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@26 Tclass.ValueMessage.__default $h@@75) a!1)))
     :pattern (($IsAlloc $o@@26 Tclass.ValueMessage.__default $h@@75))
     :skolemid |1990|
     :qid |unknown.0:0|)))
(assert (= (type ValueMessage.__default.NopDelta) DatatypeTypeType))
(assert (=> true
    (=> true ($Is ValueMessage.__default.NopDelta Tclass.ValueMessage.Delta))))
(assert (= |ValueMessage.__default.NopDelta#requires| true))
(assert (=> true
    (=> true
        (= ValueMessage.__default.NopDelta (Lit |#ValueMessage.Delta.NoDelta|)))))
(assert (=> true
    (=> true
        (= ValueMessage.__default.NopDelta (Lit |#ValueMessage.Delta.NoDelta|)))))
(assert (=> true
    (=> true ($Is ValueMessage.__default.DefaultValue Tclass.ValueType.Value))))
(assert (= |ValueMessage.__default.DefaultValue#requires| true))
(assert (let ((a!1 (=> true
               (and |ValueType.__default.DefaultValue#canCall|
                    (= ValueMessage.__default.DefaultValue
                       (Lit ValueType.__default.DefaultValue))))))
  (=> true a!1)))
(assert (let ((a!1 (=> true
               (and |ValueType.__default.DefaultValue#canCall|
                    (= ValueMessage.__default.DefaultValue
                       (Lit ValueType.__default.DefaultValue))))))
  (=> true a!1)))
(assert (forall ((arg0@@435 T@U) (arg1@@179 T@U))
  (! (= (type (ValueMessage.__default.CombineDeltas arg0@@435 arg1@@179))
        DatatypeTypeType)
     :pattern ((ValueMessage.__default.CombineDeltas arg0@@435 arg1@@179))
     :qid |funType:ValueMessage.__default.CombineDeltas|)))
(assert (=> true
    (forall ((|newdelta#0| T@U) (|olddelta#0| T@U))
      (! (let ((a!1 (and (= (type |newdelta#0|) DatatypeTypeType)
                         (= (type |olddelta#0|) DatatypeTypeType)
                         (or (|ValueMessage.__default.CombineDeltas#canCall|
                               |newdelta#0|
                               |olddelta#0|)
                             (and ($Is |newdelta#0| Tclass.ValueMessage.Delta)
                                  ($Is |olddelta#0| Tclass.ValueMessage.Delta)))))
               (a!2 (and (=> (|ValueMessage.Delta#Equal|
                               |newdelta#0|
                               ValueMessage.__default.NopDelta)
                             (|ValueMessage.Delta#Equal|
                               (ValueMessage.__default.CombineDeltas
                                 |newdelta#0|
                                 |olddelta#0|)
                               |olddelta#0|))
                         (=> (|ValueMessage.Delta#Equal|
                               |olddelta#0|
                               ValueMessage.__default.NopDelta)
                             (|ValueMessage.Delta#Equal|
                               (ValueMessage.__default.CombineDeltas
                                 |newdelta#0|
                                 |olddelta#0|)
                               |newdelta#0|))
                         ($Is (ValueMessage.__default.CombineDeltas
                                |newdelta#0|
                                |olddelta#0|)
                              Tclass.ValueMessage.Delta))))
           (=> a!1 a!2))
         :pattern ((ValueMessage.__default.CombineDeltas
                     |newdelta#0|
                     |olddelta#0|))
         :skolemid |1991|
         :qid |MessagesdfyValueMessage.20:33|))))
(assert (forall ((|newdelta#0@@0| T@U) (|olddelta#0@@0| T@U))
  (! (=> (and (= (type |newdelta#0@@0|) DatatypeTypeType)
              (= (type |olddelta#0@@0|) DatatypeTypeType)
              ($Is |newdelta#0@@0| Tclass.ValueMessage.Delta)
              ($Is |olddelta#0@@0| Tclass.ValueMessage.Delta))
         (= (|ValueMessage.__default.CombineDeltas#requires|
              |newdelta#0@@0|
              |olddelta#0@@0|)
            true))
     :pattern ((|ValueMessage.__default.CombineDeltas#requires|
                 |newdelta#0@@0|
                 |olddelta#0@@0|))
     :skolemid |1992|
     :qid |MessagesdfyValueMessage.20:33|)))
(assert (let ((a!1 (forall ((|newdelta#0@@1| T@U) (|olddelta#0@@1| T@U))
             (! (let ((a!1 (and (= (type |newdelta#0@@1|) DatatypeTypeType)
                                (= (type |olddelta#0@@1|) DatatypeTypeType)
                                (or (|ValueMessage.__default.CombineDeltas#canCall|
                                      |newdelta#0@@1|
                                      |olddelta#0@@1|)
                                    (and ($Is |newdelta#0@@1|
                                              Tclass.ValueMessage.Delta)
                                         ($Is |olddelta#0@@1|
                                              Tclass.ValueMessage.Delta))))))
                  (=> a!1
                      (= (ValueMessage.__default.CombineDeltas
                           |newdelta#0@@1|
                           |olddelta#0@@1|)
                         (Lit |#ValueMessage.Delta.NoDelta|))))
                :pattern ((ValueMessage.__default.CombineDeltas
                            |newdelta#0@@1|
                            |olddelta#0@@1|))
                :skolemid |1993|
                :qid |MessagesdfyValueMessage.20:33|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|newdelta#0@@2| T@U) (|olddelta#0@@2| T@U))
             (! (let ((a!1 (and (= (type |newdelta#0@@2|) DatatypeTypeType)
                                (= (type |olddelta#0@@2|) DatatypeTypeType)
                                (or (|ValueMessage.__default.CombineDeltas#canCall|
                                      (Lit |newdelta#0@@2|)
                                      (Lit |olddelta#0@@2|))
                                    (and ($Is |newdelta#0@@2|
                                              Tclass.ValueMessage.Delta)
                                         ($Is |olddelta#0@@2|
                                              Tclass.ValueMessage.Delta))))))
                  (=> a!1
                      (= (ValueMessage.__default.CombineDeltas
                           (Lit |newdelta#0@@2|)
                           (Lit |olddelta#0@@2|))
                         (Lit |#ValueMessage.Delta.NoDelta|))))
                :pattern ((ValueMessage.__default.CombineDeltas
                            (Lit |newdelta#0@@2|)
                            (Lit |olddelta#0@@2|)))
                :weight 3
                :skolemid |1994|
                :qid |MessagesdfyValueMessage.20:33|))))
  (=> true a!1)))
(assert (forall ((arg0@@436 T@U) (arg1@@180 T@U))
  (! (= (type (ValueMessage.__default.ApplyDelta arg0@@436 arg1@@180))
        (SeqType BoxType))
     :pattern ((ValueMessage.__default.ApplyDelta arg0@@436 arg1@@180))
     :qid |funType:ValueMessage.__default.ApplyDelta|)))
(assert (=> true
    (forall ((|delta#0| T@U) (|value#0@@0| T@U))
      (! (let ((a!1 (and (= (type |delta#0|) DatatypeTypeType)
                         (= (type |value#0@@0|) (SeqType BoxType))
                         (or (|ValueMessage.__default.ApplyDelta#canCall|
                               |delta#0|
                               |value#0@@0|)
                             (and ($Is |delta#0| Tclass.ValueMessage.Delta)
                                  ($Is |value#0@@0| Tclass.ValueType.Value)))))
               (a!2 (and (=> (|ValueMessage.Delta#Equal|
                               |delta#0|
                               ValueMessage.__default.NopDelta)
                             (|Seq#Equal| (ValueMessage.__default.ApplyDelta
                                            |delta#0|
                                            |value#0@@0|)
                                          |value#0@@0|))
                         ($Is (ValueMessage.__default.ApplyDelta
                                |delta#0|
                                |value#0@@0|)
                              Tclass.ValueType.Value))))
           (=> a!1 a!2))
         :pattern ((ValueMessage.__default.ApplyDelta |delta#0| |value#0@@0|))
         :skolemid |1995|
         :qid |MessagesdfyValueMessage.24:30|))))
(assert (forall ((|delta#0@@0| T@U) (|value#0@@1| T@U))
  (! (=> (and (= (type |delta#0@@0|) DatatypeTypeType)
              (= (type |value#0@@1|) (SeqType BoxType))
              ($Is |delta#0@@0| Tclass.ValueMessage.Delta)
              ($Is |value#0@@1| Tclass.ValueType.Value))
         (= (|ValueMessage.__default.ApplyDelta#requires|
              |delta#0@@0|
              |value#0@@1|)
            true))
     :pattern ((|ValueMessage.__default.ApplyDelta#requires|
                 |delta#0@@0|
                 |value#0@@1|))
     :skolemid |1996|
     :qid |MessagesdfyValueMessage.24:30|)))
(assert (let ((a!1 (forall ((|delta#0@@1| T@U) (|value#0@@2| T@U))
             (! (let ((a!1 (and (= (type |delta#0@@1|) DatatypeTypeType)
                                (= (type |value#0@@2|) (SeqType BoxType))
                                (or (|ValueMessage.__default.ApplyDelta#canCall|
                                      |delta#0@@1|
                                      |value#0@@2|)
                                    (and ($Is |delta#0@@1|
                                              Tclass.ValueMessage.Delta)
                                         ($Is |value#0@@2|
                                              Tclass.ValueType.Value))))))
                  (=> a!1
                      (= (ValueMessage.__default.ApplyDelta
                           |delta#0@@1|
                           |value#0@@2|)
                         |value#0@@2|)))
                :pattern ((ValueMessage.__default.ApplyDelta
                            |delta#0@@1|
                            |value#0@@2|))
                :skolemid |1997|
                :qid |MessagesdfyValueMessage.24:30|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|delta#0@@2| T@U) (|value#0@@3| T@U))
             (! (let ((a!1 (and (= (type |delta#0@@2|) DatatypeTypeType)
                                (= (type |value#0@@3|) (SeqType BoxType))
                                (or (|ValueMessage.__default.ApplyDelta#canCall|
                                      (Lit |delta#0@@2|)
                                      (Lit |value#0@@3|))
                                    (and ($Is |delta#0@@2|
                                              Tclass.ValueMessage.Delta)
                                         ($Is |value#0@@3|
                                              Tclass.ValueType.Value))))))
                  (=> a!1
                      (= (ValueMessage.__default.ApplyDelta
                           (Lit |delta#0@@2|)
                           (Lit |value#0@@3|))
                         (Lit |value#0@@3|))))
                :pattern ((ValueMessage.__default.ApplyDelta
                            (Lit |delta#0@@2|)
                            (Lit |value#0@@3|)))
                :weight 3
                :skolemid |1998|
                :qid |MessagesdfyValueMessage.24:30|))))
  (=> true a!1)))
(assert (forall ((arg0@@437 T@U))
  (! (= (type (ValueMessage.__default.MakeValueMessage arg0@@437))
        DatatypeTypeType)
     :pattern ((ValueMessage.__default.MakeValueMessage arg0@@437))
     :qid |funType:ValueMessage.__default.MakeValueMessage|)))
(assert (let ((a!1 (forall ((|value#0@@4| T@U))
             (! (=> (and (= (type |value#0@@4|) (SeqType BoxType))
                         (or (|ValueMessage.__default.MakeValueMessage#canCall|
                               |value#0@@4|)
                             ($Is |value#0@@4| Tclass.ValueType.Value)))
                    ($Is (ValueMessage.__default.MakeValueMessage |value#0@@4|)
                         Tclass.ValueMessage.Message))
                :pattern ((ValueMessage.__default.MakeValueMessage |value#0@@4|))
                :skolemid |1999|
                :qid |Messagesdfy.90:29|))))
  (=> true a!1)))
(assert (forall ((|value#0@@5| T@U))
  (! (=> (and (= (type |value#0@@5|) (SeqType BoxType))
              ($Is |value#0@@5| Tclass.ValueType.Value))
         (= (|ValueMessage.__default.MakeValueMessage#requires| |value#0@@5|)
            true))
     :pattern ((|ValueMessage.__default.MakeValueMessage#requires| |value#0@@5|))
     :skolemid |2000|
     :qid |Messagesdfy.90:29|)))
(assert (let ((a!1 (forall ((|msg#0| T@U))
             (! (=> (and (= (type |msg#0|) DatatypeTypeType)
                         (or (|ValueMessage.__default.EncodableMessage#canCall|
                               |msg#0|)
                             ($Is |msg#0| Tclass.ValueMessage.Message)))
                    true)
                :pattern ((ValueMessage.__default.EncodableMessage |msg#0|))
                :skolemid |2001|
                :qid |Messagesdfy.100:30|))))
  (=> true a!1)))
(assert (forall ((|msg#0@@0| T@U))
  (! (=> (and (= (type |msg#0@@0|) DatatypeTypeType)
              ($Is |msg#0@@0| Tclass.ValueMessage.Message))
         (= (|ValueMessage.__default.EncodableMessage#requires| |msg#0@@0|)
            true))
     :pattern ((|ValueMessage.__default.EncodableMessage#requires| |msg#0@@0|))
     :skolemid |2002|
     :qid |Messagesdfy.100:30|)))
(assert (let ((a!1 (forall ((|msg#0@@1| T@U))
             (! (=> (and (= (type |msg#0@@1|) DatatypeTypeType)
                         (or (|ValueMessage.__default.EncodableMessage#canCall|
                               |msg#0@@1|)
                             ($Is |msg#0@@1| Tclass.ValueMessage.Message)))
                    (= (ValueMessage.__default.EncodableMessage |msg#0@@1|)
                       (and true (ValueMessage.Message.Define_q |msg#0@@1|))))
                :pattern ((ValueMessage.__default.EncodableMessage |msg#0@@1|))
                :skolemid |2003|
                :qid |Messagesdfy.100:30|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|msg#0@@2| T@U))
             (! (let ((a!1 (and (= (type |msg#0@@2|) DatatypeTypeType)
                                (or (|ValueMessage.__default.EncodableMessage#canCall|
                                      (Lit |msg#0@@2|))
                                    ($Is |msg#0@@2| Tclass.ValueMessage.Message))))
                      (a!2 (bool_2_U (and true
                                          (ValueMessage.Message.Define_q
                                            (Lit |msg#0@@2|))))))
                  (=> a!1
                      (= (ValueMessage.__default.EncodableMessage
                           (Lit |msg#0@@2|))
                         (U_2_bool (Lit a!2)))))
                :pattern ((ValueMessage.__default.EncodableMessage
                            (Lit |msg#0@@2|)))
                :weight 3
                :skolemid |2004|
                :qid |Messagesdfy.100:30|))))
  (=> true a!1)))
(assert (forall ((arg0@@438 T@U))
  (! (= (type (ValueMessage.__default.EvaluateMessage arg0@@438))
        (SeqType BoxType))
     :pattern ((ValueMessage.__default.EvaluateMessage arg0@@438))
     :qid |funType:ValueMessage.__default.EvaluateMessage|)))
(assert (let ((a!1 (forall ((|m#0@@9| T@U))
             (! (let ((a!1 (and (= (type |m#0@@9|) DatatypeTypeType)
                                (or (|ValueMessage.__default.EvaluateMessage#canCall|
                                      |m#0@@9|)
                                    (and ($Is |m#0@@9|
                                              Tclass.ValueMessage.Message)
                                         (ValueMessage.Message.Define_q
                                           |m#0@@9|))))))
                  (=> a!1
                      ($Is (ValueMessage.__default.EvaluateMessage |m#0@@9|)
                           Tclass.ValueType.Value)))
                :pattern ((ValueMessage.__default.EvaluateMessage |m#0@@9|))
                :skolemid |2005|
                :qid |Messagesdfy.105:28|))))
  (=> true a!1)))
(assert (forall ((|m#0@@10| T@U))
  (! (=> (and (= (type |m#0@@10|) DatatypeTypeType)
              ($Is |m#0@@10| Tclass.ValueMessage.Message))
         (= (|ValueMessage.__default.EvaluateMessage#requires| |m#0@@10|)
            (ValueMessage.Message.Define_q |m#0@@10|)))
     :pattern ((|ValueMessage.__default.EvaluateMessage#requires| |m#0@@10|))
     :skolemid |2006|
     :qid |Messagesdfy.105:28|)))
(assert (forall ((arg0@@439 T@U))
  (! (= (type (ValueMessage.Message.value arg0@@439)) (SeqType BoxType))
     :pattern ((ValueMessage.Message.value arg0@@439))
     :qid |funType:ValueMessage.Message.value|)))
(assert (let ((a!1 (forall ((|m#0@@11| T@U))
             (! (let ((a!1 (and (= (type |m#0@@11|) DatatypeTypeType)
                                (or (|ValueMessage.__default.EvaluateMessage#canCall|
                                      |m#0@@11|)
                                    (and ($Is |m#0@@11|
                                              Tclass.ValueMessage.Message)
                                         (ValueMessage.Message.Define_q
                                           |m#0@@11|))))))
                  (=> a!1
                      (= (ValueMessage.__default.EvaluateMessage |m#0@@11|)
                         (ValueMessage.Message.value |m#0@@11|))))
                :pattern ((ValueMessage.__default.EvaluateMessage |m#0@@11|))
                :skolemid |2007|
                :qid |Messagesdfy.105:28|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|m#0@@12| T@U))
      (! (let ((a!1 (Lit (bool_2_U (ValueMessage.Message.Define_q
                                     (Lit |m#0@@12|)))))
               (a!3 (= (ValueMessage.__default.EvaluateMessage (Lit |m#0@@12|))
                       (Lit (ValueMessage.Message.value (Lit |m#0@@12|))))))
         (let ((a!2 (and (= (type |m#0@@12|) DatatypeTypeType)
                         (or (|ValueMessage.__default.EvaluateMessage#canCall|
                               (Lit |m#0@@12|))
                             (and ($Is |m#0@@12| Tclass.ValueMessage.Message)
                                  (U_2_bool a!1))))))
           (=> a!2 a!3)))
         :pattern ((ValueMessage.__default.EvaluateMessage (Lit |m#0@@12|)))
         :weight 3
         :skolemid |2008|
         :qid |Messagesdfy.105:28|))))
(assert (let ((a!1 (forall ((|newmessage#0| T@U) (|oldmessage#0| T@U))
             (! (let ((a!1 (and (= (type |newmessage#0|) DatatypeTypeType)
                                (= (type |oldmessage#0|) DatatypeTypeType)
                                (or (|ValueMessage.__default.Merge#canCall|
                                      |newmessage#0|
                                      |oldmessage#0|)
                                    (and ($Is |newmessage#0|
                                              Tclass.ValueMessage.Message)
                                         ($Is |oldmessage#0|
                                              Tclass.ValueMessage.Message))))))
                  (=> a!1
                      ($Is (ValueMessage.__default.Merge
                             |newmessage#0|
                             |oldmessage#0|)
                           Tclass.ValueMessage.Message)))
                :pattern ((ValueMessage.__default.Merge
                            |newmessage#0|
                            |oldmessage#0|))
                :skolemid |2009|
                :qid |MessagesdfyValueMessage.27:25|))))
  (=> true a!1)))
(assert (forall ((|newmessage#0@@0| T@U) (|oldmessage#0@@0| T@U))
  (! (=> (and (= (type |newmessage#0@@0|) DatatypeTypeType)
              (= (type |oldmessage#0@@0|) DatatypeTypeType)
              ($Is |newmessage#0@@0| Tclass.ValueMessage.Message)
              ($Is |oldmessage#0@@0| Tclass.ValueMessage.Message))
         (= (|ValueMessage.__default.Merge#requires|
              |newmessage#0@@0|
              |oldmessage#0@@0|)
            true))
     :pattern ((|ValueMessage.__default.Merge#requires|
                 |newmessage#0@@0|
                 |oldmessage#0@@0|))
     :skolemid |2010|
     :qid |MessagesdfyValueMessage.27:25|)))
(assert (let ((a!1 (forall ((arg0@@440 T@U))
             (! (= (type (ValueMessage.Message.delta arg0@@440))
                   DatatypeTypeType)
                :pattern ((ValueMessage.Message.delta arg0@@440))
                :qid |funType:ValueMessage.Message.delta|)))
      (a!2 (forall ((arg0@@441 T@U))
             (! (= (type (|#ValueMessage.Message.Update| arg0@@441))
                   DatatypeTypeType)
                :pattern ((|#ValueMessage.Message.Update| arg0@@441))
                :qid |funType:#ValueMessage.Message.Update|))))
  (and a!1 a!2)))
(assert (=> true
    (forall ((|newmessage#0@@1| T@U) (|oldmessage#0@@1| T@U))
      (! (let ((a!1 (and (= (type |newmessage#0@@1|) DatatypeTypeType)
                         (= (type |oldmessage#0@@1|) DatatypeTypeType)
                         (or (|ValueMessage.__default.Merge#canCall|
                               |newmessage#0@@1|
                               |oldmessage#0@@1|)
                             (and ($Is |newmessage#0@@1|
                                       Tclass.ValueMessage.Message)
                                  ($Is |oldmessage#0@@1|
                                       Tclass.ValueMessage.Message)))))
               (a!2 ($Unbox DatatypeTypeType
                            (_System.Tuple2._0
                              (|#_System._tuple#2._#Make2|
                                ($Box |newmessage#0@@1|)
                                ($Box |oldmessage#0@@1|)))))
               (a!4 ($Unbox DatatypeTypeType
                            (_System.Tuple2._1
                              (|#_System._tuple#2._#Make2|
                                ($Box |newmessage#0@@1|)
                                ($Box |oldmessage#0@@1|))))))
         (let ((a!3 (=> (ValueMessage.Message.Define_q a!2)
                        (_System.Tuple2.___hMake2_q
                          (|#_System._tuple#2._#Make2|
                            ($Box |newmessage#0@@1|)
                            ($Box |oldmessage#0@@1|)))))
               (a!5 (and (_System.Tuple2.___hMake2_q
                           (|#_System._tuple#2._#Make2|
                             ($Box |newmessage#0@@1|)
                             ($Box |oldmessage#0@@1|)))
                         (_System.Tuple2.___hMake2_q
                           (|#_System._tuple#2._#Make2|
                             ($Box |newmessage#0@@1|)
                             ($Box |oldmessage#0@@1|)))
                         (|ValueMessage.__default.ApplyDelta#canCall|
                           (ValueMessage.Message.delta a!2)
                           (ValueMessage.Message.value a!4))))
               (a!6 (and (_System.Tuple2.___hMake2_q
                           (|#_System._tuple#2._#Make2|
                             ($Box |newmessage#0@@1|)
                             ($Box |oldmessage#0@@1|)))
                         (_System.Tuple2.___hMake2_q
                           (|#_System._tuple#2._#Make2|
                             ($Box |newmessage#0@@1|)
                             ($Box |oldmessage#0@@1|)))
                         (|ValueMessage.__default.CombineDeltas#canCall|
                           (ValueMessage.Message.delta a!2)
                           (ValueMessage.Message.delta a!4))))
               (a!8 (ite (ValueMessage.Message.Define_q a!4)
                         (|#ValueMessage.Message.Define|
                           (ValueMessage.__default.ApplyDelta
                             (ValueMessage.Message.delta a!2)
                             (ValueMessage.Message.value a!4)))
                         (|#ValueMessage.Message.Update|
                           (ValueMessage.__default.CombineDeltas
                             (ValueMessage.Message.delta a!2)
                             (ValueMessage.Message.delta a!4))))))
         (let ((a!7 (and (_System.Tuple2.___hMake2_q
                           (|#_System._tuple#2._#Make2|
                             ($Box |newmessage#0@@1|)
                             ($Box |oldmessage#0@@1|)))
                         (=> (ValueMessage.Message.Define_q a!4) a!5)
                         (=> (not (ValueMessage.Message.Define_q a!4)) a!6)))
               (a!9 (= (ValueMessage.__default.Merge
                         |newmessage#0@@1|
                         |oldmessage#0@@1|)
                       (ite (ValueMessage.Message.Define_q a!2)
                            (|#ValueMessage.Message.Define|
                              (ValueMessage.Message.value a!2))
                            a!8))))
         (let ((a!10 (and (_System.Tuple2.___hMake2_q
                            (|#_System._tuple#2._#Make2|
                              ($Box |newmessage#0@@1|)
                              ($Box |oldmessage#0@@1|)))
                          a!3
                          (=> (not (ValueMessage.Message.Define_q a!2)) a!7)
                          a!9)))
           (=> a!1 a!10)))))
         :pattern ((ValueMessage.__default.Merge
                     |newmessage#0@@1|
                     |oldmessage#0@@1|))
         :skolemid |2011|
         :qid |MessagesdfyValueMessage.27:25|))))
(assert (=> true
    (forall ((|newmessage#0@@2| T@U) (|oldmessage#0@@2| T@U))
      (! (let ((a!1 (and (= (type |newmessage#0@@2|) DatatypeTypeType)
                         (= (type |oldmessage#0@@2|) DatatypeTypeType)
                         (or (|ValueMessage.__default.Merge#canCall|
                               (Lit |newmessage#0@@2|)
                               (Lit |oldmessage#0@@2|))
                             (and ($Is |newmessage#0@@2|
                                       Tclass.ValueMessage.Message)
                                  ($Is |oldmessage#0@@2|
                                       Tclass.ValueMessage.Message)))))
               (a!2 (Lit (|#_System._tuple#2._#Make2|
                           ($Box (Lit |newmessage#0@@2|))
                           ($Box (Lit |oldmessage#0@@2|))))))
         (let ((a!3 (ValueMessage.Message.Define_q
                      (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 a!2)))))
               (a!6 (ValueMessage.Message.Define_q
                      (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 a!2)))))
               (a!7 (ValueMessage.Message.delta
                      (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 a!2)))))
               (a!8 (ValueMessage.Message.value
                      (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 a!2)))))
               (a!11 (ValueMessage.Message.delta
                       (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 a!2)))))
               (a!13 (ValueMessage.Message.value
                       (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 a!2))))))
         (let ((a!4 (=> (U_2_bool (Lit (bool_2_U a!3)))
                        (_System.Tuple2.___hMake2_q a!2)))
               (a!5 (not (U_2_bool (Lit (bool_2_U a!3)))))
               (a!9 (=> (U_2_bool (Lit (bool_2_U a!6)))
                        (and (_System.Tuple2.___hMake2_q a!2)
                             (_System.Tuple2.___hMake2_q a!2)
                             (|ValueMessage.__default.ApplyDelta#canCall|
                               (Lit a!7)
                               (Lit a!8)))))
               (a!10 (not (U_2_bool (Lit (bool_2_U a!6)))))
               (a!14 (|#ValueMessage.Message.Define|
                       (Lit (ValueMessage.__default.ApplyDelta
                              (Lit a!7)
                              (Lit a!8)))))
               (a!15 (|#ValueMessage.Message.Update|
                       (Lit (ValueMessage.__default.CombineDeltas
                              (Lit a!7)
                              (Lit a!11))))))
         (let ((a!12 (=> a!10
                         (and (_System.Tuple2.___hMake2_q a!2)
                              (_System.Tuple2.___hMake2_q a!2)
                              (|ValueMessage.__default.CombineDeltas#canCall|
                                (Lit a!7)
                                (Lit a!11)))))
               (a!16 (ite a!3
                          (Lit (|#ValueMessage.Message.Define| (Lit a!13)))
                          (ite a!6 (Lit a!14) (Lit a!15)))))
         (let ((a!17 (and (_System.Tuple2.___hMake2_q a!2)
                          a!4
                          (=> a!5
                              (and (_System.Tuple2.___hMake2_q a!2) a!9 a!12))
                          (= (ValueMessage.__default.Merge
                               (Lit |newmessage#0@@2|)
                               (Lit |oldmessage#0@@2|))
                             a!16))))
           (=> a!1 a!17))))))
         :pattern ((ValueMessage.__default.Merge
                     (Lit |newmessage#0@@2|)
                     (Lit |oldmessage#0@@2|)))
         :weight 3
         :skolemid |2012|
         :qid |MessagesdfyValueMessage.27:25|))))
(assert (= (type ValueMessage.__default.IdentityMessage) DatatypeTypeType))
(assert (=> true
    (=> true
        ($Is ValueMessage.__default.IdentityMessage Tclass.ValueMessage.Message))))
(assert (= |ValueMessage.__default.IdentityMessage#requires| true))
(assert (let ((a!1 (= ValueMessage.__default.IdentityMessage
              (Lit (|#ValueMessage.Message.Update|
                     (Lit ValueMessage.__default.NopDelta))))))
  (=> true (=> true (and |ValueMessage.__default.NopDelta#canCall| a!1)))))
(assert (let ((a!1 (= ValueMessage.__default.IdentityMessage
              (Lit (|#ValueMessage.Message.Update|
                     (Lit ValueMessage.__default.NopDelta))))))
  (=> true (=> true (and |ValueMessage.__default.NopDelta#canCall| a!1)))))
(assert (= (type ValueMessage.__default.DefaultMessage) DatatypeTypeType))
(assert (=> true
    (=> true
        ($Is ValueMessage.__default.DefaultMessage Tclass.ValueMessage.Message))))
(assert (= |ValueMessage.__default.DefaultMessage#requires| true))
(assert (let ((a!1 (= ValueMessage.__default.DefaultMessage
              (Lit (|#ValueMessage.Message.Define|
                     (Lit ValueMessage.__default.DefaultValue))))))
  (=> true (=> true (and |ValueMessage.__default.DefaultValue#canCall| a!1)))))
(assert (let ((a!1 (= ValueMessage.__default.DefaultMessage
              (Lit (|#ValueMessage.Message.Define|
                     (Lit ValueMessage.__default.DefaultValue))))))
  (=> true (=> true (and |ValueMessage.__default.DefaultValue#canCall| a!1)))))
(assert (forall ((|a#0#0#0@@0| T@U))
  (! (=> (= (type |a#0#0#0@@0|) (SeqType BoxType))
         (= (DatatypeCtorId (|#ValueMessage.Message.Define| |a#0#0#0@@0|))
            |##ValueMessage.Message.Define|))
     :pattern ((|#ValueMessage.Message.Define| |a#0#0#0@@0|))
     :skolemid |2013|
     :qid |MessagesdfyValueMessage.17:14|)))
(assert (forall ((d@@27 T@U))
  (! (=> (= (type d@@27) DatatypeTypeType)
         (= (ValueMessage.Message.Define_q d@@27)
            (= (DatatypeCtorId d@@27) |##ValueMessage.Message.Define|)))
     :pattern ((ValueMessage.Message.Define_q d@@27))
     :skolemid |2014|
     :qid |unknown.0:0|)))
(assert (forall ((d@@28 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@0| T@U))
                  (! (and (= (type |a#1#0#0@@0|) (SeqType BoxType))
                          (= d@@28
                             (|#ValueMessage.Message.Define| |a#1#0#0@@0|)))
                     :no-pattern (type |a#1#0#0@@0|)
                     :no-pattern (U_2_int |a#1#0#0@@0|)
                     :no-pattern (U_2_bool |a#1#0#0@@0|)
                     :skolemid |2015|
                     :qid |MessagesdfyValueMessage.17:14|))))
       (=> (and (= (type d@@28) DatatypeTypeType)
                (ValueMessage.Message.Define_q d@@28))
           a!1))
     :pattern ((ValueMessage.Message.Define_q d@@28))
     :skolemid |2016|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@0| T@U))
  (! (=> (= (type |a#2#0#0@@0|) (SeqType BoxType))
         (= ($Is (|#ValueMessage.Message.Define| |a#2#0#0@@0|)
                 Tclass.ValueMessage.Message)
            ($Is |a#2#0#0@@0| Tclass.ValueType.Value)))
     :pattern (($Is (|#ValueMessage.Message.Define| |a#2#0#0@@0|)
                    Tclass.ValueMessage.Message))
     :skolemid |2017|
     :qid |MessagesdfyValueMessage.17:14|)))
(assert (forall ((|a#3#0#0@@0| T@U) ($h@@76 T@U))
  (! (=> (and (= (type |a#3#0#0@@0|) (SeqType BoxType))
              (= (type $h@@76) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@76))
         (= ($IsAlloc (|#ValueMessage.Message.Define| |a#3#0#0@@0|)
                      Tclass.ValueMessage.Message
                      $h@@76)
            ($IsAlloc |a#3#0#0@@0| Tclass.ValueType.Value $h@@76)))
     :pattern (($IsAlloc (|#ValueMessage.Message.Define| |a#3#0#0@@0|)
                         Tclass.ValueMessage.Message
                         $h@@76))
     :skolemid |2018|
     :qid |MessagesdfyValueMessage.17:14|)))
(assert (forall ((d@@29 T@U) ($h@@77 T@U))
  (! (=> (and (= (type d@@29) DatatypeTypeType)
              (= (type $h@@77) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@77)
              (ValueMessage.Message.Define_q d@@29)
              ($IsAlloc d@@29 Tclass.ValueMessage.Message $h@@77))
         ($IsAlloc (ValueMessage.Message.value d@@29)
                   Tclass.ValueType.Value
                   $h@@77))
     :pattern (($IsAlloc (ValueMessage.Message.value d@@29)
                         Tclass.ValueType.Value
                         $h@@77))
     :skolemid |2019|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@0| T@U))
  (! (=> (= (type |a#4#0#0@@0|) (SeqType BoxType))
         (= (|#ValueMessage.Message.Define| (Lit |a#4#0#0@@0|))
            (Lit (|#ValueMessage.Message.Define| |a#4#0#0@@0|))))
     :pattern ((|#ValueMessage.Message.Define| (Lit |a#4#0#0@@0|)))
     :skolemid |2020|
     :qid |MessagesdfyValueMessage.17:14|)))
(assert (forall ((|a#5#0#0@@1| T@U))
  (! (=> (= (type |a#5#0#0@@1|) (SeqType BoxType))
         (= (ValueMessage.Message.value
              (|#ValueMessage.Message.Define| |a#5#0#0@@1|))
            |a#5#0#0@@1|))
     :pattern ((|#ValueMessage.Message.Define| |a#5#0#0@@1|))
     :skolemid |2021|
     :qid |MessagesdfyValueMessage.17:14|)))
(assert (forall ((|a#6#0#0@@1| T@U))
  (! (=> (= (type |a#6#0#0@@1|) DatatypeTypeType)
         (= (DatatypeCtorId (|#ValueMessage.Message.Update| |a#6#0#0@@1|))
            |##ValueMessage.Message.Update|))
     :pattern ((|#ValueMessage.Message.Update| |a#6#0#0@@1|))
     :skolemid |2022|
     :qid |MessagesdfyValueMessage.18:14|)))
(assert (forall ((d@@30 T@U))
  (! (=> (= (type d@@30) DatatypeTypeType)
         (= (ValueMessage.Message.Update_q d@@30)
            (= (DatatypeCtorId d@@30) |##ValueMessage.Message.Update|)))
     :pattern ((ValueMessage.Message.Update_q d@@30))
     :skolemid |2023|
     :qid |unknown.0:0|)))
(assert (forall ((d@@31 T@U))
  (! (let ((a!1 (exists ((|a#7#0#0@@1| T@U))
                  (! (and (= (type |a#7#0#0@@1|) DatatypeTypeType)
                          (= d@@31
                             (|#ValueMessage.Message.Update| |a#7#0#0@@1|)))
                     :no-pattern (type |a#7#0#0@@1|)
                     :no-pattern (U_2_int |a#7#0#0@@1|)
                     :no-pattern (U_2_bool |a#7#0#0@@1|)
                     :skolemid |2024|
                     :qid |MessagesdfyValueMessage.18:14|))))
       (=> (and (= (type d@@31) DatatypeTypeType)
                (ValueMessage.Message.Update_q d@@31))
           a!1))
     :pattern ((ValueMessage.Message.Update_q d@@31))
     :skolemid |2025|
     :qid |unknown.0:0|)))
(assert (forall ((|a#8#0#0@@1| T@U))
  (! (=> (= (type |a#8#0#0@@1|) DatatypeTypeType)
         (= ($Is (|#ValueMessage.Message.Update| |a#8#0#0@@1|)
                 Tclass.ValueMessage.Message)
            ($Is |a#8#0#0@@1| Tclass.ValueMessage.Delta)))
     :pattern (($Is (|#ValueMessage.Message.Update| |a#8#0#0@@1|)
                    Tclass.ValueMessage.Message))
     :skolemid |2026|
     :qid |MessagesdfyValueMessage.18:14|)))
(assert (forall ((|a#9#0#0@@0| T@U) ($h@@78 T@U))
  (! (=> (and (= (type |a#9#0#0@@0|) DatatypeTypeType)
              (= (type $h@@78) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@78))
         (= ($IsAlloc (|#ValueMessage.Message.Update| |a#9#0#0@@0|)
                      Tclass.ValueMessage.Message
                      $h@@78)
            ($IsAlloc |a#9#0#0@@0| Tclass.ValueMessage.Delta $h@@78)))
     :pattern (($IsAlloc (|#ValueMessage.Message.Update| |a#9#0#0@@0|)
                         Tclass.ValueMessage.Message
                         $h@@78))
     :skolemid |2027|
     :qid |MessagesdfyValueMessage.18:14|)))
(assert (forall ((d@@32 T@U) ($h@@79 T@U))
  (! (=> (and (= (type d@@32) DatatypeTypeType)
              (= (type $h@@79) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@79)
              (ValueMessage.Message.Update_q d@@32)
              ($IsAlloc d@@32 Tclass.ValueMessage.Message $h@@79))
         ($IsAlloc (ValueMessage.Message.delta d@@32)
                   Tclass.ValueMessage.Delta
                   $h@@79))
     :pattern (($IsAlloc (ValueMessage.Message.delta d@@32)
                         Tclass.ValueMessage.Delta
                         $h@@79))
     :skolemid |2028|
     :qid |unknown.0:0|)))
(assert (forall ((|a#10#0#0@@0| T@U))
  (! (=> (= (type |a#10#0#0@@0|) DatatypeTypeType)
         (= (|#ValueMessage.Message.Update| (Lit |a#10#0#0@@0|))
            (Lit (|#ValueMessage.Message.Update| |a#10#0#0@@0|))))
     :pattern ((|#ValueMessage.Message.Update| (Lit |a#10#0#0@@0|)))
     :skolemid |2029|
     :qid |MessagesdfyValueMessage.18:14|)))
(assert (forall ((|a#11#0#0@@0| T@U))
  (! (=> (= (type |a#11#0#0@@0|) DatatypeTypeType)
         (= (ValueMessage.Message.delta
              (|#ValueMessage.Message.Update| |a#11#0#0@@0|))
            |a#11#0#0@@0|))
     :pattern ((|#ValueMessage.Message.Update| |a#11#0#0@@0|))
     :skolemid |2030|
     :qid |MessagesdfyValueMessage.18:14|)))
(assert (forall ((|a#12#0#0| T@U))
  (! (=> (= (type |a#12#0#0|) DatatypeTypeType)
         (< (DtRank |a#12#0#0|)
            (DtRank (|#ValueMessage.Message.Update| |a#12#0#0|))))
     :pattern ((|#ValueMessage.Message.Update| |a#12#0#0|))
     :skolemid |2031|
     :qid |MessagesdfyValueMessage.18:14|)))
(assert (forall ((d@@33 T@U))
  (! (=> (and (= (type d@@33) DatatypeTypeType)
              (|$IsA#ValueMessage.Message| d@@33))
         (or (ValueMessage.Message.Define_q d@@33)
             (ValueMessage.Message.Update_q d@@33)))
     :pattern ((|$IsA#ValueMessage.Message| d@@33))
     :skolemid |2032|
     :qid |unknown.0:0|)))
(assert (forall ((d@@34 T@U))
  (! (=> (and (= (type d@@34) DatatypeTypeType)
              ($Is d@@34 Tclass.ValueMessage.Message))
         (or (ValueMessage.Message.Define_q d@@34)
             (ValueMessage.Message.Update_q d@@34)))
     :pattern ((ValueMessage.Message.Update_q d@@34)
               ($Is d@@34 Tclass.ValueMessage.Message))
     :pattern ((ValueMessage.Message.Define_q d@@34)
               ($Is d@@34 Tclass.ValueMessage.Message))
     :skolemid |2033|
     :qid |unknown.0:0|)))
(assert (forall ((a@@123 T@U) (b@@72 T@U))
  (! (=> (and (= (type a@@123) DatatypeTypeType)
              (= (type b@@72) DatatypeTypeType)
              (ValueMessage.Message.Define_q a@@123)
              (ValueMessage.Message.Define_q b@@72))
         (= (|ValueMessage.Message#Equal| a@@123 b@@72)
            (|Seq#Equal| (ValueMessage.Message.value a@@123)
                         (ValueMessage.Message.value b@@72))))
     :pattern ((|ValueMessage.Message#Equal| a@@123 b@@72)
               (ValueMessage.Message.Define_q a@@123))
     :pattern ((|ValueMessage.Message#Equal| a@@123 b@@72)
               (ValueMessage.Message.Define_q b@@72))
     :skolemid |2034|
     :qid |unknown.0:0|)))
(assert (forall ((a@@124 T@U) (b@@73 T@U))
  (! (=> (and (= (type a@@124) DatatypeTypeType)
              (= (type b@@73) DatatypeTypeType)
              (ValueMessage.Message.Update_q a@@124)
              (ValueMessage.Message.Update_q b@@73))
         (= (|ValueMessage.Message#Equal| a@@124 b@@73)
            (|ValueMessage.Delta#Equal|
              (ValueMessage.Message.delta a@@124)
              (ValueMessage.Message.delta b@@73))))
     :pattern ((|ValueMessage.Message#Equal| a@@124 b@@73)
               (ValueMessage.Message.Update_q a@@124))
     :pattern ((|ValueMessage.Message#Equal| a@@124 b@@73)
               (ValueMessage.Message.Update_q b@@73))
     :skolemid |2035|
     :qid |unknown.0:0|)))
(assert (forall ((a@@125 T@U) (b@@74 T@U))
  (! (=> (and (= (type a@@125) DatatypeTypeType)
              (= (type b@@74) DatatypeTypeType))
         (= (|ValueMessage.Message#Equal| a@@125 b@@74) (= a@@125 b@@74)))
     :pattern ((|ValueMessage.Message#Equal| a@@125 b@@74))
     :skolemid |2036|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.TotalKMMapMod.__default) TyType))
(assert (= (Tag Tclass.TotalKMMapMod.__default) Tagclass.TotalKMMapMod.__default))
(assert (= (TagFamily Tclass.TotalKMMapMod.__default) tytagFamily$_default))
(assert (forall ((bx@@148 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@148)) bx@@148)
                     ($Is ($Unbox refType bx@@148)
                          Tclass.TotalKMMapMod.__default))))
       (=> (and (= (type bx@@148) BoxType)
                ($IsBox bx@@148 Tclass.TotalKMMapMod.__default))
           a!1))
     :pattern (($IsBox bx@@148 Tclass.TotalKMMapMod.__default))
     :skolemid |2037|
     :qid |unknown.0:0|)))
(assert (forall (($o@@27 T@U))
  (! (let ((a!1 (= ($Is $o@@27 Tclass.TotalKMMapMod.__default)
                   (or (= $o@@27 null)
                       (= (dtype $o@@27) Tclass.TotalKMMapMod.__default)))))
       (=> (= (type $o@@27) refType) a!1))
     :pattern (($Is $o@@27 Tclass.TotalKMMapMod.__default))
     :skolemid |2038|
     :qid |unknown.0:0|)))
(assert (forall (($o@@28 T@U) ($h@@80 T@U))
  (! (let ((a!1 (or (= $o@@28 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@80 $o@@28)
                                              alloc)))))
       (=> (and (= (type $o@@28) refType)
                (= (type $h@@80) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@28 Tclass.TotalKMMapMod.__default $h@@80) a!1)))
     :pattern (($IsAlloc $o@@28 Tclass.TotalKMMapMod.__default $h@@80))
     :skolemid |2039|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((|v#0@@13| T@U))
             (! (=> (and (= (type |v#0@@13|) DatatypeTypeType)
                         (or (|TotalKMMapMod.__default.TerminalValue#canCall|
                               |v#0@@13|)
                             ($Is |v#0@@13| Tclass.ValueMessage.Message)))
                    true)
                :pattern ((TotalKMMapMod.__default.TerminalValue |v#0@@13|))
                :skolemid |2040|
                :qid |TotalMapsdfyTotalKMMapMod.11:27|))))
  (=> true a!1)))
(assert (forall ((|v#0@@14| T@U))
  (! (=> (and (= (type |v#0@@14|) DatatypeTypeType)
              ($Is |v#0@@14| Tclass.ValueMessage.Message))
         (= (|TotalKMMapMod.__default.TerminalValue#requires| |v#0@@14|) true))
     :pattern ((|TotalKMMapMod.__default.TerminalValue#requires| |v#0@@14|))
     :skolemid |2041|
     :qid |TotalMapsdfyTotalKMMapMod.11:27|)))
(assert (let ((a!1 (forall ((|v#0@@15| T@U))
             (! (=> (and (= (type |v#0@@15|) DatatypeTypeType)
                         (or (|TotalKMMapMod.__default.TerminalValue#canCall|
                               |v#0@@15|)
                             ($Is |v#0@@15| Tclass.ValueMessage.Message)))
                    (= (TotalKMMapMod.__default.TerminalValue |v#0@@15|)
                       (ValueMessage.Message.Define_q |v#0@@15|)))
                :pattern ((TotalKMMapMod.__default.TerminalValue |v#0@@15|))
                :skolemid |2042|
                :qid |TotalMapsdfyTotalKMMapMod.11:27|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@16| T@U))
             (! (let ((a!1 (and (= (type |v#0@@16|) DatatypeTypeType)
                                (or (|TotalKMMapMod.__default.TerminalValue#canCall|
                                      (Lit |v#0@@16|))
                                    ($Is |v#0@@16| Tclass.ValueMessage.Message))))
                      (a!2 (Lit (bool_2_U (ValueMessage.Message.Define_q
                                            (Lit |v#0@@16|))))))
                  (=> a!1
                      (= (TotalKMMapMod.__default.TerminalValue (Lit |v#0@@16|))
                         (U_2_bool a!2))))
                :pattern ((TotalKMMapMod.__default.TerminalValue
                            (Lit |v#0@@16|)))
                :weight 3
                :skolemid |2043|
                :qid |TotalMapsdfyTotalKMMapMod.11:27|))))
  (=> true a!1)))
(assert (= (type TotalKMMapMod.__default.DefaultV) DatatypeTypeType))
(assert (let ((a!1 (Lit (bool_2_U (TotalKMMapMod.__default.TerminalValue
                            (Lit TotalKMMapMod.__default.DefaultV))))))
  (=> true
      (=> true
          (and (U_2_bool a!1)
               ($Is TotalKMMapMod.__default.DefaultV
                    Tclass.ValueMessage.Message))))))
(assert (= |TotalKMMapMod.__default.DefaultV#requires| true))
(assert (let ((a!1 (=> true
               (and |ValueMessage.__default.DefaultMessage#canCall|
                    (= TotalKMMapMod.__default.DefaultV
                       (Lit ValueMessage.__default.DefaultMessage))))))
  (=> true a!1)))
(assert (let ((a!1 (=> true
               (and |ValueMessage.__default.DefaultMessage#canCall|
                    (= TotalKMMapMod.__default.DefaultV
                       (Lit ValueMessage.__default.DefaultMessage))))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|k#0@@2| T@U))
             (! (=> (and (= (type |k#0@@2|) (SeqType BoxType))
                         (or (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@2|)
                             ($Is |k#0@@2| Tclass.KeyType.Key)))
                    true)
                :pattern ((TotalKMMapMod.__default.AnyKey |k#0@@2|))
                :skolemid |2044|
                :qid |TotalMapsdfyTotalKMMapMod.15:20|))))
  (=> true a!1)))
(assert (forall ((|k#0@@3| T@U))
  (! (=> (and (= (type |k#0@@3|) (SeqType BoxType))
              ($Is |k#0@@3| Tclass.KeyType.Key))
         (= (|TotalKMMapMod.__default.AnyKey#requires| |k#0@@3|) true))
     :pattern ((|TotalKMMapMod.__default.AnyKey#requires| |k#0@@3|))
     :skolemid |2045|
     :qid |TotalMapsdfyTotalKMMapMod.15:20|)))
(assert (let ((a!1 (forall ((|k#0@@4| T@U))
             (! (let ((a!1 (= (TotalKMMapMod.__default.AnyKey |k#0@@4|)
                              (U_2_bool (Lit (bool_2_U true))))))
                  (=> (and (= (type |k#0@@4|) (SeqType BoxType))
                           (or (|TotalKMMapMod.__default.AnyKey#canCall|
                                 |k#0@@4|)
                               ($Is |k#0@@4| Tclass.KeyType.Key)))
                      a!1))
                :pattern ((TotalKMMapMod.__default.AnyKey |k#0@@4|))
                :skolemid |2046|
                :qid |TotalMapsdfyTotalKMMapMod.15:20|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|k#0@@5| T@U))
      (! (let ((a!1 (and (= (type |k#0@@5|) (SeqType BoxType))
                         (or (|TotalKMMapMod.__default.AnyKey#canCall|
                               (Lit |k#0@@5|))
                             ($Is |k#0@@5| Tclass.KeyType.Key))))
               (a!2 (= (TotalKMMapMod.__default.AnyKey (Lit |k#0@@5|))
                       (U_2_bool (Lit (bool_2_U true))))))
           (=> a!1 a!2))
         :pattern ((TotalKMMapMod.__default.AnyKey (Lit |k#0@@5|)))
         :weight 3
         :skolemid |2047|
         :qid |TotalMapsdfyTotalKMMapMod.15:20|))))
(assert (let ((a!1 (forall ((|kvm#0| T@U) (|k#0@@6| T@U))
             (! (let ((a!1 (or (|TotalKMMapMod.__default.Defined#canCall|
                                 |kvm#0|
                                 |k#0@@6|)
                               (and ($Is |kvm#0|
                                         (TIMap Tclass.KeyType.Key
                                                Tclass.ValueMessage.Message))
                                    ($Is |k#0@@6| Tclass.KeyType.Key)))))
                  (=> (and (= (type |kvm#0|) (IMapType BoxType BoxType))
                           (= (type |k#0@@6|) (SeqType BoxType))
                           a!1)
                      true))
                :pattern ((TotalKMMapMod.__default.Defined |kvm#0| |k#0@@6|))
                :skolemid |2048|
                :qid |TotalMapsdfyTotalKMMapMod.17:21|))))
  (=> true a!1)))
(assert (forall ((|kvm#0@@0| T@U) (|k#0@@7| T@U))
  (! (=> (and (= (type |kvm#0@@0|) (IMapType BoxType BoxType))
              (= (type |k#0@@7|) (SeqType BoxType))
              ($Is |kvm#0@@0|
                   (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))
              ($Is |k#0@@7| Tclass.KeyType.Key))
         (= (|TotalKMMapMod.__default.Defined#requires| |kvm#0@@0| |k#0@@7|)
            true))
     :pattern ((|TotalKMMapMod.__default.Defined#requires| |kvm#0@@0| |k#0@@7|))
     :skolemid |2049|
     :qid |TotalMapsdfyTotalKMMapMod.17:21|)))
(assert (let ((a!1 (forall ((|kvm#0@@1| T@U) (|k#0@@8| T@U))
             (! (let ((a!1 (or (|TotalKMMapMod.__default.Defined#canCall|
                                 |kvm#0@@1|
                                 |k#0@@8|)
                               (and ($Is |kvm#0@@1|
                                         (TIMap Tclass.KeyType.Key
                                                Tclass.ValueMessage.Message))
                                    ($Is |k#0@@8| Tclass.KeyType.Key))))
                      (a!2 (|TotalKMMapMod.__default.TerminalValue#canCall|
                             ($Unbox DatatypeTypeType
                                     (MapType0Select (|IMap#Elements| |kvm#0@@1|)
                                                     ($Box |k#0@@8|)))))
                      (a!4 (TotalKMMapMod.__default.TerminalValue
                             ($Unbox DatatypeTypeType
                                     (MapType0Select (|IMap#Elements| |kvm#0@@1|)
                                                     ($Box |k#0@@8|))))))
                (let ((a!3 (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@1|)
                                                         ($Box |k#0@@8|)))
                               a!2))
                      (a!5 (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@1|)
                                                          ($Box |k#0@@8|)))
                                a!4)))
                  (=> (and (= (type |kvm#0@@1|) (IMapType BoxType BoxType))
                           (= (type |k#0@@8|) (SeqType BoxType))
                           a!1)
                      (and a!3
                           (= (TotalKMMapMod.__default.Defined
                                |kvm#0@@1|
                                |k#0@@8|)
                              a!5)))))
                :pattern ((TotalKMMapMod.__default.Defined |kvm#0@@1| |k#0@@8|))
                :skolemid |2050|
                :qid |TotalMapsdfyTotalKMMapMod.17:21|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|kvm#0@@2| T@U) (|k#0@@9| T@U))
             (! (let ((a!1 (or (|TotalKMMapMod.__default.Defined#canCall|
                                 |kvm#0@@2|
                                 (Lit |k#0@@9|))
                               (and ($Is |kvm#0@@2|
                                         (TIMap Tclass.KeyType.Key
                                                Tclass.ValueMessage.Message))
                                    ($Is |k#0@@9| Tclass.KeyType.Key))))
                      (a!2 ($Unbox DatatypeTypeType
                                   (MapType0Select (|IMap#Elements| |kvm#0@@2|)
                                                   ($Box (Lit |k#0@@9|))))))
                (let ((a!3 (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@2|)
                                                         ($Box |k#0@@9|)))
                               (|TotalKMMapMod.__default.TerminalValue#canCall|
                                 a!2)))
                      (a!4 (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@2|)
                                                          ($Box |k#0@@9|)))
                                (TotalKMMapMod.__default.TerminalValue a!2))))
                (let ((a!5 (and a!3
                                (= (TotalKMMapMod.__default.Defined
                                     |kvm#0@@2|
                                     (Lit |k#0@@9|))
                                   a!4))))
                  (=> (and (= (type |kvm#0@@2|) (IMapType BoxType BoxType))
                           (= (type |k#0@@9|) (SeqType BoxType))
                           a!1)
                      a!5))))
                :pattern ((TotalKMMapMod.__default.Defined
                            |kvm#0@@2|
                            (Lit |k#0@@9|)))
                :weight 3
                :skolemid |2051|
                :qid |TotalMapsdfyTotalKMMapMod.17:21|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|kvm#0@@3| T@U) (|k#0@@10| T@U))
             (! (let ((a!1 (or (|TotalKMMapMod.__default.Defined#canCall|
                                 (Lit |kvm#0@@3|)
                                 (Lit |k#0@@10|))
                               (and ($Is |kvm#0@@3|
                                         (TIMap Tclass.KeyType.Key
                                                Tclass.ValueMessage.Message))
                                    ($Is |k#0@@10| Tclass.KeyType.Key))))
                      (a!2 ($Unbox DatatypeTypeType
                                   (MapType0Select (|IMap#Elements| (Lit |kvm#0@@3|))
                                                   ($Box (Lit |k#0@@10|))))))
                (let ((a!3 (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@3|)
                                                         ($Box |k#0@@10|)))
                               (|TotalKMMapMod.__default.TerminalValue#canCall|
                                 a!2)))
                      (a!4 (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@3|)
                                                          ($Box |k#0@@10|)))
                                (TotalKMMapMod.__default.TerminalValue a!2))))
                (let ((a!5 (and a!3
                                (= (TotalKMMapMod.__default.Defined
                                     (Lit |kvm#0@@3|)
                                     (Lit |k#0@@10|))
                                   a!4))))
                  (=> (and (= (type |kvm#0@@3|) (IMapType BoxType BoxType))
                           (= (type |k#0@@10|) (SeqType BoxType))
                           a!1)
                      a!5))))
                :pattern ((TotalKMMapMod.__default.Defined
                            (Lit |kvm#0@@3|)
                            (Lit |k#0@@10|)))
                :weight 3
                :skolemid |2052|
                :qid |TotalMapsdfyTotalKMMapMod.17:21|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|kvm#0@@4| T@U))
      (! (let ((a!1 (and (= (type |kvm#0@@4|) (IMapType BoxType BoxType))
                         (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall|
                               |kvm#0@@4|)
                             ($Is |kvm#0@@4|
                                  (TIMap Tclass.KeyType.Key
                                         Tclass.ValueMessage.Message))))))
           (=> a!1 true))
         :pattern ((TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@4|))
         :skolemid |2053|
         :qid |TotalMapsdfyTotalKMMapMod.21:28|))))
(assert (forall ((|kvm#0@@5| T@U))
  (! (=> (and (= (type |kvm#0@@5|) (IMapType BoxType BoxType))
              ($Is |kvm#0@@5|
                   (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))
         (= (|TotalKMMapMod.__default.TotalMapIsFull#requires| |kvm#0@@5|) true))
     :pattern ((|TotalKMMapMod.__default.TotalMapIsFull#requires| |kvm#0@@5|))
     :skolemid |2054|
     :qid |TotalMapsdfyTotalKMMapMod.21:28|)))
(assert (let ((a!1 (forall ((|kvm#0@@6| T@U))
             (! (let ((a!1 (and (= (type |kvm#0@@6|) (IMapType BoxType BoxType))
                                (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall|
                                      |kvm#0@@6|)
                                    ($Is |kvm#0@@6|
                                         (TIMap Tclass.KeyType.Key
                                                Tclass.ValueMessage.Message)))))
                      (a!2 (forall ((|k#0@@11| T@U))
                             (! (=> (and (= (type |k#0@@11|) (SeqType BoxType))
                                         ($Is |k#0@@11| Tclass.KeyType.Key))
                                    (and (|TotalKMMapMod.__default.AnyKey#canCall|
                                           |k#0@@11|)
                                         (=> (TotalKMMapMod.__default.AnyKey
                                               |k#0@@11|)
                                             (|TotalKMMapMod.__default.Defined#canCall|
                                               |kvm#0@@6|
                                               |k#0@@11|))))
                                :pattern ((TotalKMMapMod.__default.Defined
                                            |kvm#0@@6|
                                            |k#0@@11|))
                                :pattern ((TotalKMMapMod.__default.AnyKey
                                            |k#0@@11|))
                                :skolemid |2056|
                                :qid |TotalMapsdfyTotalKMMapMod.22:12|)))
                      (a!3 (forall ((|k#0@@12| T@U))
                             (! (=> (= (type |k#0@@12|) (SeqType BoxType))
                                    (=> (and ($Is |k#0@@12| Tclass.KeyType.Key)
                                             (TotalKMMapMod.__default.AnyKey
                                               |k#0@@12|))
                                        (TotalKMMapMod.__default.Defined
                                          |kvm#0@@6|
                                          |k#0@@12|)))
                                :pattern ((TotalKMMapMod.__default.Defined
                                            |kvm#0@@6|
                                            |k#0@@12|))
                                :pattern ((TotalKMMapMod.__default.AnyKey
                                            |k#0@@12|))
                                :skolemid |2055|
                                :qid |TotalMapsdfyTotalKMMapMod.22:12|))))
                  (=> a!1
                      (and a!2
                           (= (TotalKMMapMod.__default.TotalMapIsFull
                                |kvm#0@@6|)
                              a!3))))
                :pattern ((TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@6|))
                :skolemid |2057|
                :qid |TotalMapsdfyTotalKMMapMod.21:28|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|kvm#0@@7| T@U))
      (! (let ((a!1 (and (= (type |kvm#0@@7|) (IMapType BoxType BoxType))
                         (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall|
                               (Lit |kvm#0@@7|))
                             ($Is |kvm#0@@7|
                                  (TIMap Tclass.KeyType.Key
                                         Tclass.ValueMessage.Message)))))
               (a!2 (forall ((|k#1| T@U))
                      (! (let ((a!1 (and (|TotalKMMapMod.__default.AnyKey#canCall|
                                           |k#1|)
                                         (=> (TotalKMMapMod.__default.AnyKey
                                               |k#1|)
                                             (|TotalKMMapMod.__default.Defined#canCall|
                                               (Lit |kvm#0@@7|)
                                               |k#1|)))))
                           (=> (and (= (type |k#1|) (SeqType BoxType))
                                    ($Is |k#1| Tclass.KeyType.Key))
                               a!1))
                         :pattern ((TotalKMMapMod.__default.Defined
                                     |kvm#0@@7|
                                     |k#1|))
                         :pattern ((TotalKMMapMod.__default.AnyKey |k#1|))
                         :skolemid |2059|
                         :qid |TotalMapsdfyTotalKMMapMod.22:12|)))
               (a!3 (forall ((|k#1@@0| T@U))
                      (! (=> (= (type |k#1@@0|) (SeqType BoxType))
                             (=> (and ($Is |k#1@@0| Tclass.KeyType.Key)
                                      (TotalKMMapMod.__default.AnyKey |k#1@@0|))
                                 (TotalKMMapMod.__default.Defined
                                   (Lit |kvm#0@@7|)
                                   |k#1@@0|)))
                         :pattern ((TotalKMMapMod.__default.Defined
                                     |kvm#0@@7|
                                     |k#1@@0|))
                         :pattern ((TotalKMMapMod.__default.AnyKey |k#1@@0|))
                         :skolemid |2058|
                         :qid |TotalMapsdfyTotalKMMapMod.22:12|))))
         (let ((a!4 (and a!2
                         (= (TotalKMMapMod.__default.TotalMapIsFull
                              (Lit |kvm#0@@7|))
                            a!3))))
           (=> a!1 a!4)))
         :pattern ((TotalKMMapMod.__default.TotalMapIsFull (Lit |kvm#0@@7|)))
         :weight 3
         :skolemid |2060|
         :qid |TotalMapsdfyTotalKMMapMod.21:28|))))
(assert (= (type TotalKMMapMod.__default.EmptyTotalMap) (IMapType BoxType BoxType)))
(assert (let ((a!1 (Lit (bool_2_U (TotalKMMapMod.__default.TotalMapIsFull
                            (Lit TotalKMMapMod.__default.EmptyTotalMap))))))
(let ((a!2 (=> true
               (and (U_2_bool a!1)
                    ($Is TotalKMMapMod.__default.EmptyTotalMap
                         (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
  (=> true a!2))))
(assert (= |TotalKMMapMod.__default.EmptyTotalMap#requires| true))
(assert (forall ((arg0@@442 T@U))
  (! (= (type (|lambda#101| arg0@@442)) (MapType0Type BoxType BoxType))
     :pattern ((|lambda#101| arg0@@442))
     :qid |funType:lambda#101|)))
(assert (let ((a!1 (forall ((|k#0@@13| T@U))
             (! (=> (and (= (type |k#0@@13|) (SeqType BoxType))
                         ($Is |k#0@@13| Tclass.KeyType.Key))
                    (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@13|)
                         (=> (TotalKMMapMod.__default.AnyKey |k#0@@13|)
                             |TotalKMMapMod.__default.DefaultV#canCall|)))
                :pattern ((TotalKMMapMod.__default.AnyKey |k#0@@13|))
                :skolemid |2061|
                :qid |TotalMapsdfyTotalKMMapMod.28:10|)))
      (a!2 (|IMap#Glue| (|lambda#4| Tclass.KeyType.Key)
                        (|lambda#101| ($Box (Lit TotalKMMapMod.__default.DefaultV)))
                        (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))
  (=> true (=> true (and a!1 (= TotalKMMapMod.__default.EmptyTotalMap a!2))))))
(assert (let ((a!1 (forall ((|k#0@@14| T@U))
             (! (=> (and (= (type |k#0@@14|) (SeqType BoxType))
                         ($Is |k#0@@14| Tclass.KeyType.Key))
                    (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@14|)
                         (=> (TotalKMMapMod.__default.AnyKey |k#0@@14|)
                             |TotalKMMapMod.__default.DefaultV#canCall|)))
                :pattern ((TotalKMMapMod.__default.AnyKey |k#0@@14|))
                :skolemid |2062|
                :qid |TotalMapsdfyTotalKMMapMod.28:10|)))
      (a!2 (|IMap#Glue| (|lambda#4| Tclass.KeyType.Key)
                        (|lambda#101| ($Box (Lit TotalKMMapMod.__default.DefaultV)))
                        (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))
  (=> true (=> true (and a!1 (= TotalKMMapMod.__default.EmptyTotalMap a!2))))))
(assert (= (type TotalKMMapMod.__default.Witness) (IMapType BoxType BoxType)))
(assert (let ((a!1 (=> true
               (and (|IMap#Equal| TotalKMMapMod.__default.Witness
                                  TotalKMMapMod.__default.EmptyTotalMap)
                    ($Is TotalKMMapMod.__default.Witness
                         (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
  (=> true a!1)))
(assert (= |TotalKMMapMod.__default.Witness#requires| true))
(assert (forall ((|ikv#0| T@U))
  (! (let ((a!1 (= ($Is |ikv#0| Tclass.TotalKMMapMod.TotalMap)
                   (and ($Is |ikv#0|
                             (TIMap Tclass.KeyType.Key
                                    Tclass.ValueMessage.Message))
                        (TotalKMMapMod.__default.TotalMapIsFull |ikv#0|)))))
       (=> (= (type |ikv#0|) (IMapType BoxType BoxType)) a!1))
     :pattern (($Is |ikv#0| Tclass.TotalKMMapMod.TotalMap))
     :skolemid |2063|
     :qid |unknown.0:0|)))
(assert (forall ((|ikv#0@@0| T@U) ($h@@81 T@U))
  (! (=> (and (= (type |ikv#0@@0|) (IMapType BoxType BoxType))
              (= (type $h@@81) (MapType0Type refType MapType1Type)))
         (= ($IsAlloc |ikv#0@@0| Tclass.TotalKMMapMod.TotalMap $h@@81)
            ($IsAlloc |ikv#0@@0|
                      (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)
                      $h@@81)))
     :pattern (($IsAlloc |ikv#0@@0| Tclass.TotalKMMapMod.TotalMap $h@@81))
     :skolemid |2064|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.LSNMod.__default) TyType))
(assert (= (Tag Tclass.LSNMod.__default) Tagclass.LSNMod.__default))
(assert (= (TagFamily Tclass.LSNMod.__default) tytagFamily$_default))
(assert (forall ((bx@@149 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@149)) bx@@149)
                     ($Is ($Unbox refType bx@@149) Tclass.LSNMod.__default))))
       (=> (and (= (type bx@@149) BoxType)
                ($IsBox bx@@149 Tclass.LSNMod.__default))
           a!1))
     :pattern (($IsBox bx@@149 Tclass.LSNMod.__default))
     :skolemid |2065|
     :qid |unknown.0:0|)))
(assert (forall (($o@@29 T@U))
  (! (let ((a!1 (= ($Is $o@@29 Tclass.LSNMod.__default)
                   (or (= $o@@29 null)
                       (= (dtype $o@@29) Tclass.LSNMod.__default)))))
       (=> (= (type $o@@29) refType) a!1))
     :pattern (($Is $o@@29 Tclass.LSNMod.__default))
     :skolemid |2066|
     :qid |unknown.0:0|)))
(assert (forall (($o@@30 T@U) ($h@@82 T@U))
  (! (let ((a!1 (or (= $o@@30 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@82 $o@@30)
                                              alloc)))))
       (=> (and (= (type $o@@30) refType)
                (= (type $h@@82) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@30 Tclass.LSNMod.__default $h@@82) a!1)))
     :pattern (($IsAlloc $o@@30 Tclass.LSNMod.__default $h@@82))
     :skolemid |2067|
     :qid |unknown.0:0|)))
(assert (forall ((|a#0#0#0@@1| T@U) (|a#0#1#0@@0| Int))
  (! (=> (= (type |a#0#0#0@@1|) BoxType)
         (= (DatatypeCtorId (|#StampedMod.Stamped.Stamped|
                              |a#0#0#0@@1|
                              |a#0#1#0@@0|))
            |##StampedMod.Stamped.Stamped|))
     :pattern ((|#StampedMod.Stamped.Stamped| |a#0#0#0@@1| |a#0#1#0@@0|))
     :skolemid |2068|
     :qid |StampedMapidfy.18:33|)))
(assert (forall ((d@@35 T@U))
  (! (=> (= (type d@@35) DatatypeTypeType)
         (= (StampedMod.Stamped.Stamped_q d@@35)
            (= (DatatypeCtorId d@@35) |##StampedMod.Stamped.Stamped|)))
     :pattern ((StampedMod.Stamped.Stamped_q d@@35))
     :skolemid |2069|
     :qid |unknown.0:0|)))
(assert (forall ((d@@36 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@1| T@U) (|a#1#1#0@@0| Int))
                  (! (and (= (type |a#1#0#0@@1|) BoxType)
                          (= d@@36
                             (|#StampedMod.Stamped.Stamped|
                               |a#1#0#0@@1|
                               |a#1#1#0@@0|)))
                     :no-pattern (type |a#1#0#0@@1|)
                     :no-pattern (U_2_int |a#1#0#0@@1|)
                     :no-pattern (U_2_bool |a#1#0#0@@1|)
                     :skolemid |2070|
                     :qid |StampedMapidfy.18:33|))))
       (=> (and (= (type d@@36) DatatypeTypeType)
                (StampedMod.Stamped.Stamped_q d@@36))
           a!1))
     :pattern ((StampedMod.Stamped.Stamped_q d@@36))
     :skolemid |2071|
     :qid |unknown.0:0|)))
(assert (forall ((StampedMod.Stamped$T@@2 T@U) (|a#2#0#0@@1| T@U) (|a#2#1#0@@0| Int))
  (! (let ((a!1 (= ($Is (|#StampedMod.Stamped.Stamped|
                          |a#2#0#0@@1|
                          |a#2#1#0@@0|)
                        (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@2))
                   (and ($IsBox |a#2#0#0@@1| StampedMod.Stamped$T@@2)
                        ($Is (int_2_U |a#2#1#0@@0|) Tclass._System.nat)))))
       (=> (and (= (type StampedMod.Stamped$T@@2) TyType)
                (= (type |a#2#0#0@@1|) BoxType))
           a!1))
     :pattern (($Is (|#StampedMod.Stamped.Stamped| |a#2#0#0@@1| |a#2#1#0@@0|)
                    (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@2)))
     :skolemid |2072|
     :qid |unknown.0:0|)))
(assert (forall ((StampedMod.Stamped$T@@3 T@U)
         (|a#3#0#0@@1| T@U)
         (|a#3#1#0@@0| Int)
         ($h@@83 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#StampedMod.Stamped.Stamped|
                               |a#3#0#0@@1|
                               |a#3#1#0@@0|)
                             (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@3)
                             $h@@83)
                   (and ($IsAllocBox |a#3#0#0@@1|
                                     StampedMod.Stamped$T@@3
                                     $h@@83)
                        ($IsAlloc (int_2_U |a#3#1#0@@0|)
                                  Tclass._System.nat
                                  $h@@83)))))
       (=> (and (= (type StampedMod.Stamped$T@@3) TyType)
                (= (type |a#3#0#0@@1|) BoxType)
                (= (type $h@@83) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@83))
           a!1))
     :pattern (($IsAlloc (|#StampedMod.Stamped.Stamped|
                           |a#3#0#0@@1|
                           |a#3#1#0@@0|)
                         (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@3)
                         $h@@83))
     :skolemid |2073|
     :qid |unknown.0:0|)))
(assert (forall ((d@@37 T@U) (StampedMod.Stamped$T@@4 T@U) ($h@@84 T@U))
  (! (=> (and (= (type d@@37) DatatypeTypeType)
              (= (type StampedMod.Stamped$T@@4) TyType)
              (= (type $h@@84) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@84)
              (StampedMod.Stamped.Stamped_q d@@37)
              ($IsAlloc d@@37
                        (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@4)
                        $h@@84))
         ($IsAllocBox (StampedMod.Stamped.value d@@37)
                      StampedMod.Stamped$T@@4
                      $h@@84))
     :pattern (($IsAllocBox (StampedMod.Stamped.value d@@37)
                            StampedMod.Stamped$T@@4
                            $h@@84))
     :skolemid |2074|
     :qid |unknown.0:0|)))
(assert (forall ((d@@38 T@U) ($h@@85 T@U))
  (! (let ((a!1 (exists ((StampedMod.Stamped$T@@5 T@U))
                  (! (and (= (type StampedMod.Stamped$T@@5) TyType)
                          ($IsAlloc d@@38
                                    (Tclass.StampedMod.Stamped
                                      StampedMod.Stamped$T@@5)
                                    $h@@85))
                     :pattern (($IsAlloc d@@38
                                         (Tclass.StampedMod.Stamped
                                           StampedMod.Stamped$T@@5)
                                         $h@@85))
                     :skolemid |2075|
                     :qid |unknown.0:0|))))
       (=> (and (= (type d@@38) DatatypeTypeType)
                (= (type $h@@85) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@85)
                (StampedMod.Stamped.Stamped_q d@@38)
                a!1)
           ($IsAlloc (int_2_U (StampedMod.Stamped.seqEnd d@@38))
                     Tclass._System.nat
                     $h@@85)))
     :pattern (($IsAlloc (int_2_U (StampedMod.Stamped.seqEnd d@@38))
                         Tclass._System.nat
                         $h@@85))
     :skolemid |2076|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@1| T@U) (|a#4#1#0@@0| Int))
  (! (=> (= (type |a#4#0#0@@1|) BoxType)
         (= (|#StampedMod.Stamped.Stamped|
              (Lit |a#4#0#0@@1|)
              (LitInt |a#4#1#0@@0|))
            (Lit (|#StampedMod.Stamped.Stamped| |a#4#0#0@@1| |a#4#1#0@@0|))))
     :pattern ((|#StampedMod.Stamped.Stamped|
                 (Lit |a#4#0#0@@1|)
                 (LitInt |a#4#1#0@@0|)))
     :skolemid |2077|
     :qid |StampedMapidfy.18:33|)))
(assert (forall ((|a#5#0#0@@2| T@U) (|a#5#1#0@@0| Int))
  (! (=> (= (type |a#5#0#0@@2|) BoxType)
         (= (StampedMod.Stamped.value
              (|#StampedMod.Stamped.Stamped| |a#5#0#0@@2| |a#5#1#0@@0|))
            |a#5#0#0@@2|))
     :pattern ((|#StampedMod.Stamped.Stamped| |a#5#0#0@@2| |a#5#1#0@@0|))
     :skolemid |2078|
     :qid |StampedMapidfy.18:33|)))
(assert (forall ((|a#6#0#0@@2| T@U) (|a#6#1#0@@0| Int))
  (! (=> (= (type |a#6#0#0@@2|) BoxType)
         (< (BoxRank |a#6#0#0@@2|)
            (DtRank (|#StampedMod.Stamped.Stamped| |a#6#0#0@@2| |a#6#1#0@@0|))))
     :pattern ((|#StampedMod.Stamped.Stamped| |a#6#0#0@@2| |a#6#1#0@@0|))
     :skolemid |2079|
     :qid |StampedMapidfy.18:33|)))
(assert (forall ((|a#7#0#0@@2| T@U) (|a#7#1#0@@0| Int))
  (! (=> (= (type |a#7#0#0@@2|) BoxType)
         (= (StampedMod.Stamped.seqEnd
              (|#StampedMod.Stamped.Stamped| |a#7#0#0@@2| |a#7#1#0@@0|))
            |a#7#1#0@@0|))
     :pattern ((|#StampedMod.Stamped.Stamped| |a#7#0#0@@2| |a#7#1#0@@0|))
     :skolemid |2080|
     :qid |StampedMapidfy.18:33|)))
(assert (forall ((d@@39 T@U))
  (! (=> (and (= (type d@@39) DatatypeTypeType)
              (|$IsA#StampedMod.Stamped| d@@39))
         (StampedMod.Stamped.Stamped_q d@@39))
     :pattern ((|$IsA#StampedMod.Stamped| d@@39))
     :skolemid |2081|
     :qid |unknown.0:0|)))
(assert (forall ((StampedMod.Stamped$T@@6 T@U) (d@@40 T@U))
  (! (=> (and (= (type StampedMod.Stamped$T@@6) TyType)
              (= (type d@@40) DatatypeTypeType)
              ($Is d@@40 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@6)))
         (StampedMod.Stamped.Stamped_q d@@40))
     :pattern ((StampedMod.Stamped.Stamped_q d@@40)
               ($Is d@@40 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@6)))
     :skolemid |2082|
     :qid |unknown.0:0|)))
(assert (forall ((a@@126 T@U) (b@@75 T@U))
  (! (let ((a!1 (= (|StampedMod.Stamped#Equal| a@@126 b@@75)
                   (and (= (StampedMod.Stamped.value a@@126)
                           (StampedMod.Stamped.value b@@75))
                        (= (StampedMod.Stamped.seqEnd a@@126)
                           (StampedMod.Stamped.seqEnd b@@75))))))
       (=> (and (= (type a@@126) DatatypeTypeType)
                (= (type b@@75) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|StampedMod.Stamped#Equal| a@@126 b@@75))
     :skolemid |2083|
     :qid |unknown.0:0|)))
(assert (forall ((a@@127 T@U) (b@@76 T@U))
  (! (=> (and (= (type a@@127) DatatypeTypeType)
              (= (type b@@76) DatatypeTypeType))
         (= (|StampedMod.Stamped#Equal| a@@127 b@@76) (= a@@127 b@@76)))
     :pattern ((|StampedMod.Stamped#Equal| a@@127 b@@76))
     :skolemid |2084|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.StampedMod.__default) TyType))
(assert (= (Tag Tclass.StampedMod.__default) Tagclass.StampedMod.__default))
(assert (= (TagFamily Tclass.StampedMod.__default) tytagFamily$_default))
(assert (forall ((bx@@150 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@150)) bx@@150)
                     ($Is ($Unbox refType bx@@150) Tclass.StampedMod.__default))))
       (=> (and (= (type bx@@150) BoxType)
                ($IsBox bx@@150 Tclass.StampedMod.__default))
           a!1))
     :pattern (($IsBox bx@@150 Tclass.StampedMod.__default))
     :skolemid |2085|
     :qid |unknown.0:0|)))
(assert (forall (($o@@31 T@U))
  (! (let ((a!1 (= ($Is $o@@31 Tclass.StampedMod.__default)
                   (or (= $o@@31 null)
                       (= (dtype $o@@31) Tclass.StampedMod.__default)))))
       (=> (= (type $o@@31) refType) a!1))
     :pattern (($Is $o@@31 Tclass.StampedMod.__default))
     :skolemid |2086|
     :qid |unknown.0:0|)))
(assert (forall (($o@@32 T@U) ($h@@86 T@U))
  (! (let ((a!1 (or (= $o@@32 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@86 $o@@32)
                                              alloc)))))
       (=> (and (= (type $o@@32) refType)
                (= (type $h@@86) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@32 Tclass.StampedMod.__default $h@@86) a!1)))
     :pattern (($IsAlloc $o@@32 Tclass.StampedMod.__default $h@@86))
     :skolemid |2087|
     :qid |unknown.0:0|)))
(assert (=> true
    (=> true
        ($Is StampedMod.__default.Empty
             (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))))
(assert (= |StampedMod.__default.Empty#requires| true))
(assert (let ((a!1 (Lit (|#StampedMod.Stamped.Stamped|
                  ($Box (Lit TotalKMMapMod.__default.EmptyTotalMap))
                  (LitInt 0)))))
  (=> true
      (=> true
          (and |TotalKMMapMod.__default.EmptyTotalMap#canCall|
               (= StampedMod.__default.Empty a!1))))))
(assert (let ((a!1 (Lit (|#StampedMod.Stamped.Stamped|
                  ($Box (Lit TotalKMMapMod.__default.EmptyTotalMap))
                  (LitInt 0)))))
  (=> true
      (=> true
          (and |TotalKMMapMod.__default.EmptyTotalMap#canCall|
               (= StampedMod.__default.Empty a!1))))))
(assert (= (type Tclass.SequencesLite.__default) TyType))
(assert (= (Tag Tclass.SequencesLite.__default) Tagclass.SequencesLite.__default))
(assert (= (TagFamily Tclass.SequencesLite.__default) tytagFamily$_default))
(assert (forall ((bx@@151 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@151)) bx@@151)
                     ($Is ($Unbox refType bx@@151)
                          Tclass.SequencesLite.__default))))
       (=> (and (= (type bx@@151) BoxType)
                ($IsBox bx@@151 Tclass.SequencesLite.__default))
           a!1))
     :pattern (($IsBox bx@@151 Tclass.SequencesLite.__default))
     :skolemid |2088|
     :qid |unknown.0:0|)))
(assert (forall (($o@@33 T@U))
  (! (let ((a!1 (= ($Is $o@@33 Tclass.SequencesLite.__default)
                   (or (= $o@@33 null)
                       (= (dtype $o@@33) Tclass.SequencesLite.__default)))))
       (=> (= (type $o@@33) refType) a!1))
     :pattern (($Is $o@@33 Tclass.SequencesLite.__default))
     :skolemid |2089|
     :qid |unknown.0:0|)))
(assert (forall (($o@@34 T@U) ($h@@87 T@U))
  (! (let ((a!1 (or (= $o@@34 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@87 $o@@34)
                                              alloc)))))
       (=> (and (= (type $o@@34) refType)
                (= (type $h@@87) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@34 Tclass.SequencesLite.__default $h@@87) a!1)))
     :pattern (($IsAlloc $o@@34 Tclass.SequencesLite.__default $h@@87))
     :skolemid |2090|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@443 T@U) (arg1@@181 T@U))
  (! (= (type (SequencesLite.__default.Last arg0@@443 arg1@@181)) BoxType)
     :pattern ((SequencesLite.__default.Last arg0@@443 arg1@@181))
     :qid |funType:SequencesLite.__default.Last|)))
(assert (let ((a!1 (forall ((SequencesLite._default.Last$E T@U) (|run#0| T@U))
             (! (let ((a!1 (or (|SequencesLite.__default.Last#canCall|
                                 SequencesLite._default.Last$E
                                 |run#0|)
                               (and ($Is |run#0|
                                         (TSeq SequencesLite._default.Last$E))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0|)
                                      0)))))
                  (=> (and (= (type SequencesLite._default.Last$E) TyType)
                           (= (type |run#0|) (SeqType BoxType))
                           a!1)
                      ($IsBox (SequencesLite.__default.Last
                                SequencesLite._default.Last$E
                                |run#0|)
                              SequencesLite._default.Last$E)))
                :pattern ((SequencesLite.__default.Last
                            SequencesLite._default.Last$E
                            |run#0|))
                :skolemid |2091|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((SequencesLite._default.Last$E@@0 T@U) (|run#0@@0| T@U))
  (! (=> (and (= (type SequencesLite._default.Last$E@@0) TyType)
              (= (type |run#0@@0|) (SeqType BoxType))
              ($Is |run#0@@0| (TSeq SequencesLite._default.Last$E@@0)))
         (= (|SequencesLite.__default.Last#requires|
              SequencesLite._default.Last$E@@0
              |run#0@@0|)
            (INTERNAL_gt_boogie (|Seq#Length| |run#0@@0|) 0)))
     :pattern ((|SequencesLite.__default.Last#requires|
                 SequencesLite._default.Last$E@@0
                 |run#0@@0|))
     :skolemid |2092|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((SequencesLite._default.Last$E@@1 T@U) (|run#0@@1| T@U))
             (! (let ((a!1 (or (|SequencesLite.__default.Last#canCall|
                                 SequencesLite._default.Last$E@@1
                                 |run#0@@1|)
                               (and ($Is |run#0@@1|
                                         (TSeq SequencesLite._default.Last$E@@1))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0@@1|)
                                      0))))
                      (a!2 (= (SequencesLite.__default.Last
                                SequencesLite._default.Last$E@@1
                                |run#0@@1|)
                              (|Seq#Index| |run#0@@1|
                                           (INTERNAL_sub_boogie
                                             (|Seq#Length| |run#0@@1|)
                                             1)))))
                  (=> (and (= (type SequencesLite._default.Last$E@@1) TyType)
                           (= (type |run#0@@1|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((SequencesLite.__default.Last
                            SequencesLite._default.Last$E@@1
                            |run#0@@1|))
                :skolemid |2093|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((SequencesLite._default.Last$E@@2 T@U) (|run#0@@2| T@U))
             (! (let ((a!1 (and ($Is |run#0@@2|
                                     (TSeq SequencesLite._default.Last$E@@2))
                                (INTERNAL_gt_boogie
                                  (|Seq#Length| (Lit |run#0@@2|))
                                  0)))
                      (a!3 (|Seq#Index| (Lit |run#0@@2|)
                                        (INTERNAL_sub_boogie
                                          (|Seq#Length| (Lit |run#0@@2|))
                                          1))))
                (let ((a!2 (and (= (type SequencesLite._default.Last$E@@2)
                                   TyType)
                                (= (type |run#0@@2|) (SeqType BoxType))
                                (or (|SequencesLite.__default.Last#canCall|
                                      SequencesLite._default.Last$E@@2
                                      (Lit |run#0@@2|))
                                    a!1))))
                  (=> a!2
                      (= (SequencesLite.__default.Last
                           SequencesLite._default.Last$E@@2
                           (Lit |run#0@@2|))
                         a!3))))
                :pattern ((SequencesLite.__default.Last
                            SequencesLite._default.Last$E@@2
                            (Lit |run#0@@2|)))
                :weight 3
                :skolemid |2094|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@444 T@U) (arg1@@182 T@U))
  (! (= (type (SequencesLite.__default.DropLast arg0@@444 arg1@@182))
        (SeqType BoxType))
     :pattern ((SequencesLite.__default.DropLast arg0@@444 arg1@@182))
     :qid |funType:SequencesLite.__default.DropLast|)))
(assert (let ((a!1 (forall ((SequencesLite._default.DropLast$E T@U) (|run#0@@3| T@U))
             (! (let ((a!1 (or (|SequencesLite.__default.DropLast#canCall|
                                 SequencesLite._default.DropLast$E
                                 |run#0@@3|)
                               (and ($Is |run#0@@3|
                                         (TSeq SequencesLite._default.DropLast$E))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0@@3|)
                                      0)))))
                  (=> (and (= (type SequencesLite._default.DropLast$E) TyType)
                           (= (type |run#0@@3|) (SeqType BoxType))
                           a!1)
                      ($Is (SequencesLite.__default.DropLast
                             SequencesLite._default.DropLast$E
                             |run#0@@3|)
                           (TSeq SequencesLite._default.DropLast$E))))
                :pattern ((SequencesLite.__default.DropLast
                            SequencesLite._default.DropLast$E
                            |run#0@@3|))
                :skolemid |2095|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((SequencesLite._default.DropLast$E@@0 T@U) (|run#0@@4| T@U))
  (! (=> (and (= (type SequencesLite._default.DropLast$E@@0) TyType)
              (= (type |run#0@@4|) (SeqType BoxType))
              ($Is |run#0@@4| (TSeq SequencesLite._default.DropLast$E@@0)))
         (= (|SequencesLite.__default.DropLast#requires|
              SequencesLite._default.DropLast$E@@0
              |run#0@@4|)
            (INTERNAL_gt_boogie (|Seq#Length| |run#0@@4|) 0)))
     :pattern ((|SequencesLite.__default.DropLast#requires|
                 SequencesLite._default.DropLast$E@@0
                 |run#0@@4|))
     :skolemid |2096|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((SequencesLite._default.DropLast$E@@1 T@U) (|run#0@@5| T@U))
             (! (let ((a!1 (or (|SequencesLite.__default.DropLast#canCall|
                                 SequencesLite._default.DropLast$E@@1
                                 |run#0@@5|)
                               (and ($Is |run#0@@5|
                                         (TSeq SequencesLite._default.DropLast$E@@1))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0@@5|)
                                      0))))
                      (a!2 (= (SequencesLite.__default.DropLast
                                SequencesLite._default.DropLast$E@@1
                                |run#0@@5|)
                              (|Seq#Take| |run#0@@5|
                                          (INTERNAL_sub_boogie
                                            (|Seq#Length| |run#0@@5|)
                                            1)))))
                  (=> (and (= (type SequencesLite._default.DropLast$E@@1)
                              TyType)
                           (= (type |run#0@@5|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((SequencesLite.__default.DropLast
                            SequencesLite._default.DropLast$E@@1
                            |run#0@@5|))
                :skolemid |2097|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((SequencesLite._default.DropLast$E@@2 T@U) (|run#0@@6| T@U))
             (! (let ((a!1 (and ($Is |run#0@@6|
                                     (TSeq SequencesLite._default.DropLast$E@@2))
                                (INTERNAL_gt_boogie
                                  (|Seq#Length| (Lit |run#0@@6|))
                                  0)))
                      (a!3 (|Seq#Take| (Lit |run#0@@6|)
                                       (INTERNAL_sub_boogie
                                         (|Seq#Length| (Lit |run#0@@6|))
                                         1))))
                (let ((a!2 (and (= (type SequencesLite._default.DropLast$E@@2)
                                   TyType)
                                (= (type |run#0@@6|) (SeqType BoxType))
                                (or (|SequencesLite.__default.DropLast#canCall|
                                      SequencesLite._default.DropLast$E@@2
                                      (Lit |run#0@@6|))
                                    a!1))))
                  (=> a!2
                      (= (SequencesLite.__default.DropLast
                           SequencesLite._default.DropLast$E@@2
                           (Lit |run#0@@6|))
                         a!3))))
                :pattern ((SequencesLite.__default.DropLast
                            SequencesLite._default.DropLast$E@@2
                            (Lit |run#0@@6|)))
                :weight 3
                :skolemid |2098|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type Tclass.Mathematics.__default) TyType))
(assert (= (Tag Tclass.Mathematics.__default) Tagclass.Mathematics.__default))
(assert (= (TagFamily Tclass.Mathematics.__default) tytagFamily$_default))
(assert (forall ((bx@@152 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@152)) bx@@152)
                     ($Is ($Unbox refType bx@@152) Tclass.Mathematics.__default))))
       (=> (and (= (type bx@@152) BoxType)
                ($IsBox bx@@152 Tclass.Mathematics.__default))
           a!1))
     :pattern (($IsBox bx@@152 Tclass.Mathematics.__default))
     :skolemid |2099|
     :qid |unknown.0:0|)))
(assert (forall (($o@@35 T@U))
  (! (let ((a!1 (= ($Is $o@@35 Tclass.Mathematics.__default)
                   (or (= $o@@35 null)
                       (= (dtype $o@@35) Tclass.Mathematics.__default)))))
       (=> (= (type $o@@35) refType) a!1))
     :pattern (($Is $o@@35 Tclass.Mathematics.__default))
     :skolemid |2100|
     :qid |unknown.0:0|)))
(assert (forall (($o@@36 T@U) ($h@@88 T@U))
  (! (let ((a!1 (or (= $o@@36 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@88 $o@@36)
                                              alloc)))))
       (=> (and (= (type $o@@36) refType)
                (= (type $h@@88) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@36 Tclass.Mathematics.__default $h@@88) a!1)))
     :pattern (($IsAlloc $o@@36 Tclass.Mathematics.__default $h@@88))
     :skolemid |2101|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((|a#0@@11| Int) (|b#0@@1| Int))
      (! (=> true true)
         :pattern ((Mathematics.__default.min |a#0@@11| |b#0@@1|))
         :skolemid |2102|
         :qid |mathematicsidfy.6:15|))))
(assert (forall ((|a#0@@12| Int) (|b#0@@2| Int))
  (! (= (|Mathematics.__default.min#requires| |a#0@@12| |b#0@@2|) true)
     :pattern ((|Mathematics.__default.min#requires| |a#0@@12| |b#0@@2|))
     :skolemid |2103|
     :qid |mathematicsidfy.6:15|)))
(assert (let ((a!1 (forall ((|a#0@@13| Int) (|b#0@@3| Int))
             (! (=> true
                    (= (Mathematics.__default.min |a#0@@13| |b#0@@3|)
                       (ite (INTERNAL_lt_boogie |a#0@@13| |b#0@@3|)
                            |a#0@@13|
                            |b#0@@3|)))
                :pattern ((Mathematics.__default.min |a#0@@13| |b#0@@3|))
                :skolemid |2104|
                :qid |mathematicsidfy.6:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|a#0@@14| Int) (|b#0@@4| Int))
             (! (=> true
                    (= (Mathematics.__default.min
                         (LitInt |a#0@@14|)
                         (LitInt |b#0@@4|))
                       (ite (INTERNAL_lt_boogie |a#0@@14| |b#0@@4|)
                            |a#0@@14|
                            |b#0@@4|)))
                :pattern ((Mathematics.__default.min
                            (LitInt |a#0@@14|)
                            (LitInt |b#0@@4|)))
                :weight 3
                :skolemid |2105|
                :qid |mathematicsidfy.6:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|a#0@@15| Int) (|b#0@@5| Int))
      (! (=> true true)
         :pattern ((Mathematics.__default.max |a#0@@15| |b#0@@5|))
         :skolemid |2106|
         :qid |mathematicsidfy.14:15|))))
(assert (forall ((|a#0@@16| Int) (|b#0@@6| Int))
  (! (= (|Mathematics.__default.max#requires| |a#0@@16| |b#0@@6|) true)
     :pattern ((|Mathematics.__default.max#requires| |a#0@@16| |b#0@@6|))
     :skolemid |2107|
     :qid |mathematicsidfy.14:15|)))
(assert (let ((a!1 (forall ((|a#0@@17| Int) (|b#0@@7| Int))
             (! (=> true
                    (= (Mathematics.__default.max |a#0@@17| |b#0@@7|)
                       (ite (INTERNAL_lt_boogie |a#0@@17| |b#0@@7|)
                            |b#0@@7|
                            |a#0@@17|)))
                :pattern ((Mathematics.__default.max |a#0@@17| |b#0@@7|))
                :skolemid |2108|
                :qid |mathematicsidfy.14:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|a#0@@18| Int) (|b#0@@8| Int))
             (! (=> true
                    (= (Mathematics.__default.max
                         (LitInt |a#0@@18|)
                         (LitInt |b#0@@8|))
                       (ite (INTERNAL_lt_boogie |a#0@@18| |b#0@@8|)
                            |b#0@@8|
                            |a#0@@18|)))
                :pattern ((Mathematics.__default.max
                            (LitInt |a#0@@18|)
                            (LitInt |b#0@@8|)))
                :weight 3
                :skolemid |2109|
                :qid |mathematicsidfy.14:15|))))
  (=> true a!1)))
(assert (forall ((arg0@@445 T@U) (arg1@@183 T@U))
  (! (= (type (Mathematics.__default.Set arg0@@445 arg1@@183))
        (MapType0Type BoxType boolType))
     :pattern ((Mathematics.__default.Set arg0@@445 arg1@@183))
     :qid |funType:Mathematics.__default.Set|)))
(assert (let ((a!1 (forall ((Mathematics._default.Set$T T@U) (|ms#0| T@U))
             (! (let ((a!1 (and (= (type Mathematics._default.Set$T) TyType)
                                (= (type |ms#0|) (MapType0Type BoxType intType))
                                (or (|Mathematics.__default.Set#canCall|
                                      Mathematics._default.Set$T
                                      |ms#0|)
                                    ($Is |ms#0|
                                         (TMultiSet Mathematics._default.Set$T))))))
                  (=> a!1
                      ($Is (Mathematics.__default.Set
                             Mathematics._default.Set$T
                             |ms#0|)
                           (TSet Mathematics._default.Set$T))))
                :pattern ((Mathematics.__default.Set
                            Mathematics._default.Set$T
                            |ms#0|))
                :skolemid |2110|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Mathematics._default.Set$T@@0 T@U) (|ms#0@@0| T@U))
  (! (=> (and (= (type Mathematics._default.Set$T@@0) TyType)
              (= (type |ms#0@@0|) (MapType0Type BoxType intType))
              ($Is |ms#0@@0| (TMultiSet Mathematics._default.Set$T@@0)))
         (= (|Mathematics.__default.Set#requires|
              Mathematics._default.Set$T@@0
              |ms#0@@0|)
            true))
     :pattern ((|Mathematics.__default.Set#requires|
                 Mathematics._default.Set$T@@0
                 |ms#0@@0|))
     :skolemid |2111|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@446 T@U) (arg1@@184 T@U) (arg2@@93 Int))
  (! (= (type (|lambda#104| arg0@@446 arg1@@184 arg2@@93))
        (MapType0Type BoxType boolType))
     :pattern ((|lambda#104| arg0@@446 arg1@@184 arg2@@93))
     :qid |funType:lambda#104|)))
(assert (let ((a!1 (forall ((Mathematics._default.Set$T@@1 T@U) (|ms#0@@1| T@U))
             (! (let ((a!1 (and (= (type Mathematics._default.Set$T@@1) TyType)
                                (= (type |ms#0@@1|)
                                   (MapType0Type BoxType intType))
                                (or (|Mathematics.__default.Set#canCall|
                                      Mathematics._default.Set$T@@1
                                      |ms#0@@1|)
                                    ($Is |ms#0@@1|
                                         (TMultiSet Mathematics._default.Set$T@@1))))))
                  (=> a!1
                      (= (Mathematics.__default.Set
                           Mathematics._default.Set$T@@1
                           |ms#0@@1|)
                         (|lambda#104| Mathematics._default.Set$T@@1
                                       |ms#0@@1|
                                       0))))
                :pattern ((Mathematics.__default.Set
                            Mathematics._default.Set$T@@1
                            |ms#0@@1|))
                :skolemid |2112|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Mathematics._default.Set$T@@2 T@U) (|ms#0@@2| T@U))
             (! (let ((a!1 (and (= (type Mathematics._default.Set$T@@2) TyType)
                                (= (type |ms#0@@2|)
                                   (MapType0Type BoxType intType))
                                (or (|Mathematics.__default.Set#canCall|
                                      Mathematics._default.Set$T@@2
                                      (Lit |ms#0@@2|))
                                    ($Is |ms#0@@2|
                                         (TMultiSet Mathematics._default.Set$T@@2))))))
                  (=> a!1
                      (= (Mathematics.__default.Set
                           Mathematics._default.Set$T@@2
                           (Lit |ms#0@@2|))
                         (|lambda#104| Mathematics._default.Set$T@@2
                                       (Lit |ms#0@@2|)
                                       0))))
                :pattern ((Mathematics.__default.Set
                            Mathematics._default.Set$T@@2
                            (Lit |ms#0@@2|)))
                :weight 3
                :skolemid |2113|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@447 T@U) (arg1@@185 T@U))
  (! (= (type (Mathematics.__default.ISet arg0@@447 arg1@@185))
        (MapType0Type BoxType boolType))
     :pattern ((Mathematics.__default.ISet arg0@@447 arg1@@185))
     :qid |funType:Mathematics.__default.ISet|)))
(assert (let ((a!1 (forall ((Mathematics._default.ISet$T T@U) (|ms#0@@3| T@U))
             (! (let ((a!1 (and (= (type Mathematics._default.ISet$T) TyType)
                                (= (type |ms#0@@3|)
                                   (MapType0Type BoxType boolType))
                                (or (|Mathematics.__default.ISet#canCall|
                                      Mathematics._default.ISet$T
                                      |ms#0@@3|)
                                    ($Is |ms#0@@3|
                                         (TSet Mathematics._default.ISet$T))))))
                  (=> a!1
                      ($Is (Mathematics.__default.ISet
                             Mathematics._default.ISet$T
                             |ms#0@@3|)
                           (TISet Mathematics._default.ISet$T))))
                :pattern ((Mathematics.__default.ISet
                            Mathematics._default.ISet$T
                            |ms#0@@3|))
                :skolemid |2114|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Mathematics._default.ISet$T@@0 T@U) (|ms#0@@4| T@U))
  (! (=> (and (= (type Mathematics._default.ISet$T@@0) TyType)
              (= (type |ms#0@@4|) (MapType0Type BoxType boolType))
              ($Is |ms#0@@4| (TSet Mathematics._default.ISet$T@@0)))
         (= (|Mathematics.__default.ISet#requires|
              Mathematics._default.ISet$T@@0
              |ms#0@@4|)
            true))
     :pattern ((|Mathematics.__default.ISet#requires|
                 Mathematics._default.ISet$T@@0
                 |ms#0@@4|))
     :skolemid |2115|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@448 T@U) (arg1@@186 T@U))
  (! (= (type (|lambda#106| arg0@@448 arg1@@186))
        (MapType0Type BoxType boolType))
     :pattern ((|lambda#106| arg0@@448 arg1@@186))
     :qid |funType:lambda#106|)))
(assert (let ((a!1 (forall ((Mathematics._default.ISet$T@@1 T@U) (|ms#0@@5| T@U))
             (! (let ((a!1 (and (= (type Mathematics._default.ISet$T@@1) TyType)
                                (= (type |ms#0@@5|)
                                   (MapType0Type BoxType boolType))
                                (or (|Mathematics.__default.ISet#canCall|
                                      Mathematics._default.ISet$T@@1
                                      |ms#0@@5|)
                                    ($Is |ms#0@@5|
                                         (TSet Mathematics._default.ISet$T@@1))))))
                  (=> a!1
                      (= (Mathematics.__default.ISet
                           Mathematics._default.ISet$T@@1
                           |ms#0@@5|)
                         (|lambda#106| Mathematics._default.ISet$T@@1 |ms#0@@5|))))
                :pattern ((Mathematics.__default.ISet
                            Mathematics._default.ISet$T@@1
                            |ms#0@@5|))
                :skolemid |2116|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Mathematics._default.ISet$T@@2 T@U) (|ms#0@@6| T@U))
             (! (let ((a!1 (and (= (type Mathematics._default.ISet$T@@2) TyType)
                                (= (type |ms#0@@6|)
                                   (MapType0Type BoxType boolType))
                                (or (|Mathematics.__default.ISet#canCall|
                                      Mathematics._default.ISet$T@@2
                                      (Lit |ms#0@@6|))
                                    ($Is |ms#0@@6|
                                         (TSet Mathematics._default.ISet$T@@2))))))
                  (=> a!1
                      (= (Mathematics.__default.ISet
                           Mathematics._default.ISet$T@@2
                           (Lit |ms#0@@6|))
                         (|lambda#106| Mathematics._default.ISet$T@@2
                                       (Lit |ms#0@@6|)))))
                :pattern ((Mathematics.__default.ISet
                            Mathematics._default.ISet$T@@2
                            (Lit |ms#0@@6|)))
                :weight 3
                :skolemid |2117|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type Tclass.LinearSequence__i.__default) TyType))
(assert (= (Tag Tclass.LinearSequence__i.__default)
   Tagclass.LinearSequence__i.__default))
(assert (= (TagFamily Tclass.LinearSequence__i.__default) tytagFamily$_default))
(assert (forall (($o@@37 T@U))
  (! (let ((a!1 (= ($Is $o@@37 Tclass.LinearSequence__i.__default)
                   (or (= $o@@37 null)
                       (= (dtype $o@@37) Tclass.LinearSequence__i.__default)))))
       (=> (= (type $o@@37) refType) a!1))
     :pattern (($Is $o@@37 Tclass.LinearSequence__i.__default))
     :skolemid |2118|
     :qid |unknown.0:0|)))
(assert (forall (($o@@38 T@U) ($h@@89 T@U))
  (! (let ((a!1 (or (= $o@@38 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@89 $o@@38)
                                              alloc)))))
       (=> (and (= (type $o@@38) refType)
                (= (type $h@@89) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@38 Tclass.LinearSequence__i.__default $h@@89) a!1)))
     :pattern (($IsAlloc $o@@38 Tclass.LinearSequence__i.__default $h@@89))
     :skolemid |2119|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@449 T@U) (arg1@@187 Int) (arg2@@94 T@U))
  (! (= (type (LinearSequence__i.__default.seq__alloc__init
                arg0@@449
                arg1@@187
                arg2@@94))
        (SeqType BoxType))
     :pattern ((LinearSequence__i.__default.seq__alloc__init
                 arg0@@449
                 arg1@@187
                 arg2@@94))
     :qid |funType:LinearSequence__i.__default.seq__alloc__init|)))
(assert (=> true
    (forall ((LinearSequence_i._default.seq_alloc_init$A T@U)
             (|length#0@@3| Int)
             (|a#0@@19| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.seq_alloc_init$A)
                            TyType)
                         (= (type |a#0@@19|) BoxType)
                         (or (|LinearSequence__i.__default.seq__alloc__init#canCall|
                               LinearSequence_i._default.seq_alloc_init$A
                               |length#0@@3|
                               |a#0@@19|)
                             (and (INTERNAL_le_boogie 0 |length#0@@3|)
                                  (INTERNAL_lt_boogie
                                    |length#0@@3|
                                    18446744073709551616)
                                  ($IsBox |a#0@@19|
                                          LinearSequence_i._default.seq_alloc_init$A)))))
               (a!2 (forall ((|i#0@@38| Int))
                      (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#0@@38|)
                                         (INTERNAL_lt_boogie
                                           |i#0@@38|
                                           (|Seq#Length| (LinearSequence__i.__default.seq__alloc__init
                                                           LinearSequence_i._default.seq_alloc_init$A
                                                           |length#0@@3|
                                                           |a#0@@19|))))))
                           (=> a!1
                               (= (|Seq#Index| (LinearSequence__i.__default.seq__alloc__init
                                                 LinearSequence_i._default.seq_alloc_init$A
                                                 |length#0@@3|
                                                 |a#0@@19|)
                                               |i#0@@38|)
                                  |a#0@@19|)))
                         :pattern ((|Seq#Index| (LinearSequence__i.__default.seq__alloc__init
                                                  LinearSequence_i._default.seq_alloc_init$A
                                                  |length#0@@3|
                                                  |a#0@@19|)
                                                |i#0@@38|))
                         :skolemid |2120|
                         :qid |LinearSequenceidfy.22:22|))))
         (let ((a!3 (and (= (|Seq#Length| (LinearSequence__i.__default.seq__alloc__init
                                            LinearSequence_i._default.seq_alloc_init$A
                                            |length#0@@3|
                                            |a#0@@19|))
                            |length#0@@3|)
                         a!2
                         ($Is (LinearSequence__i.__default.seq__alloc__init
                                LinearSequence_i._default.seq_alloc_init$A
                                |length#0@@3|
                                |a#0@@19|)
                              (TSeq LinearSequence_i._default.seq_alloc_init$A)))))
           (=> a!1 a!3)))
         :pattern ((LinearSequence__i.__default.seq__alloc__init
                     LinearSequence_i._default.seq_alloc_init$A
                     |length#0@@3|
                     |a#0@@19|))
         :skolemid |2121|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_i._default.seq_alloc_init$A@@0 T@U)
         (|length#0@@4| Int)
         (|a#0@@20| T@U))
  (! (=> (and (= (type LinearSequence_i._default.seq_alloc_init$A@@0) TyType)
              (= (type |a#0@@20|) BoxType))
         (=> (and (INTERNAL_le_boogie 0 |length#0@@4|)
                  (INTERNAL_lt_boogie |length#0@@4| 18446744073709551616)
                  ($IsBox |a#0@@20|
                          LinearSequence_i._default.seq_alloc_init$A@@0))
             (= (|LinearSequence__i.__default.seq__alloc__init#requires|
                  LinearSequence_i._default.seq_alloc_init$A@@0
                  |length#0@@4|
                  |a#0@@20|)
                true)))
     :pattern ((|LinearSequence__i.__default.seq__alloc__init#requires|
                 LinearSequence_i._default.seq_alloc_init$A@@0
                 |length#0@@4|
                 |a#0@@20|))
     :skolemid |2122|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@450 T@U) (arg1@@188 T@U))
  (! (= (type (LinearSequence__i.__default.lseqs arg0@@450 arg1@@188))
        (SeqType BoxType))
     :pattern ((LinearSequence__i.__default.lseqs arg0@@450 arg1@@188))
     :qid |funType:LinearSequence__i.__default.lseqs|)))
(assert (=> true
    (forall ((LinearSequence_i._default.lseqs$A T@U) (|l#0@@5| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.lseqs$A) TyType)
                         (= (type |l#0@@5|) BoxType)
                         (or (|LinearSequence__i.__default.lseqs#canCall|
                               LinearSequence_i._default.lseqs$A
                               |l#0@@5|)
                             ($IsBox |l#0@@5|
                                     (|#$lseq| LinearSequence_i._default.lseqs$A)))))
               (a!2 (and (_System.__default.rank__is__less__than
                           (TSeq LinearSequence_i._default.lseqs$A)
                           (|#$lseq| LinearSequence_i._default.lseqs$A)
                           ($Box (LinearSequence__i.__default.lseqs
                                   LinearSequence_i._default.lseqs$A
                                   |l#0@@5|))
                           |l#0@@5|)
                         (= (|Seq#Length| (LinearSequence__i.__default.lseqs
                                            LinearSequence_i._default.lseqs$A
                                            |l#0@@5|))
                            (|Seq#Length| (LinearExtern.__default.lseqs__raw
                                            LinearSequence_i._default.lseqs$A
                                            |l#0@@5|)))
                         ($Is (LinearSequence__i.__default.lseqs
                                LinearSequence_i._default.lseqs$A
                                |l#0@@5|)
                              (TSeq LinearSequence_i._default.lseqs$A)))))
           (=> a!1 a!2))
         :pattern ((LinearSequence__i.__default.lseqs
                     LinearSequence_i._default.lseqs$A
                     |l#0@@5|))
         :skolemid |2123|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_i._default.lseqs$A@@0 T@U) (|l#0@@6| T@U))
  (! (=> (and (= (type LinearSequence_i._default.lseqs$A@@0) TyType)
              (= (type |l#0@@6|) BoxType)
              ($IsBox |l#0@@6| (|#$lseq| LinearSequence_i._default.lseqs$A@@0)))
         (= (|LinearSequence__i.__default.lseqs#requires|
              LinearSequence_i._default.lseqs$A@@0
              |l#0@@6|)
            true))
     :pattern ((|LinearSequence__i.__default.lseqs#requires|
                 LinearSequence_i._default.lseqs$A@@0
                 |l#0@@6|))
     :skolemid |2124|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@451 T@U) (arg1@@189 T@U))
  (! (= (type (LinearSequence__i.__default.imagine__lseq arg0@@451 arg1@@189))
        BoxType)
     :pattern ((LinearSequence__i.__default.imagine__lseq arg0@@451 arg1@@189))
     :qid |funType:LinearSequence__i.__default.imagine__lseq|)))
(assert (=> true
    (forall ((LinearSequence_i._default.imagine_lseq$A T@U) (|s#0@@21| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.imagine_lseq$A)
                            TyType)
                         (= (type |s#0@@21|) (SeqType BoxType))
                         (or (|LinearSequence__i.__default.imagine__lseq#canCall|
                               LinearSequence_i._default.imagine_lseq$A
                               |s#0@@21|)
                             ($Is |s#0@@21|
                                  (TSeq LinearSequence_i._default.imagine_lseq$A)))))
               (a!2 (and (|Seq#Equal| (LinearSequence__i.__default.lseqs
                                        LinearSequence_i._default.imagine_lseq$A
                                        (LinearSequence__i.__default.imagine__lseq
                                          LinearSequence_i._default.imagine_lseq$A
                                          |s#0@@21|))
                                      |s#0@@21|)
                         (forall ((|i#0@@39| Int))
                           (! (let ((a!1 ($Unbox boolType
                                                 (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                LinearSequence_i._default.imagine_lseq$A
                                                                (LinearSequence__i.__default.imagine__lseq
                                                                  LinearSequence_i._default.imagine_lseq$A
                                                                  |s#0@@21|))
                                                              |i#0@@39|))))
                              (let ((a!2 (=> (and (INTERNAL_le_boogie
                                                    0
                                                    |i#0@@39|)
                                                  (INTERNAL_lt_boogie
                                                    |i#0@@39|
                                                    (|Seq#Length| |s#0@@21|)))
                                             (U_2_bool a!1))))
                                (=> true a!2)))
                              :pattern (($Unbox boolType
                                                (|Seq#Index| (LinearExtern.__default.lseq__has
                                                               LinearSequence_i._default.imagine_lseq$A
                                                               (LinearSequence__i.__default.imagine__lseq
                                                                 LinearSequence_i._default.imagine_lseq$A
                                                                 |s#0@@21|))
                                                             |i#0@@39|)))
                              :skolemid |2125|
                              :qid |LinearSequenceidfy.38:20|))
                         ($IsBox (LinearSequence__i.__default.imagine__lseq
                                   LinearSequence_i._default.imagine_lseq$A
                                   |s#0@@21|)
                                 (|#$lseq| LinearSequence_i._default.imagine_lseq$A)))))
           (=> a!1 a!2))
         :pattern ((LinearSequence__i.__default.imagine__lseq
                     LinearSequence_i._default.imagine_lseq$A
                     |s#0@@21|))
         :skolemid |2126|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_i._default.imagine_lseq$A@@0 T@U) (|s#0@@22| T@U))
  (! (=> (and (= (type LinearSequence_i._default.imagine_lseq$A@@0) TyType)
              (= (type |s#0@@22|) (SeqType BoxType))
              ($Is |s#0@@22| (TSeq LinearSequence_i._default.imagine_lseq$A@@0)))
         (= (|LinearSequence__i.__default.imagine__lseq#requires|
              LinearSequence_i._default.imagine_lseq$A@@0
              |s#0@@22|)
            true))
     :pattern ((|LinearSequence__i.__default.imagine__lseq#requires|
                 LinearSequence_i._default.imagine_lseq$A@@0
                 |s#0@@22|))
     :skolemid |2127|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@452 T@U) (arg1@@190 T@U))
  (! (= (type (LinearSequence__i.__default.linLast arg0@@452 arg1@@190))
        BoxType)
     :pattern ((LinearSequence__i.__default.linLast arg0@@452 arg1@@190))
     :qid |funType:LinearSequence__i.__default.linLast|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.linLast$A T@U) (|l#0@@7| T@U))
             (! (let ((a!1 (or (|LinearSequence__i.__default.linLast#canCall|
                                 LinearSequence_i._default.linLast$A
                                 |l#0@@7|)
                               (and ($IsBox |l#0@@7|
                                            (|#$lseq| LinearSequence_i._default.linLast$A))
                                    (INTERNAL_lt_boogie
                                      0
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        LinearSequence_i._default.linLast$A
                                        |l#0@@7|))))))
                  (=> (and (= (type LinearSequence_i._default.linLast$A) TyType)
                           (= (type |l#0@@7|) BoxType)
                           a!1)
                      ($IsBox (LinearSequence__i.__default.linLast
                                LinearSequence_i._default.linLast$A
                                |l#0@@7|)
                              LinearSequence_i._default.linLast$A)))
                :pattern ((LinearSequence__i.__default.linLast
                            LinearSequence_i._default.linLast$A
                            |l#0@@7|))
                :skolemid |2129|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.linLast$A@@0 T@U) (|l#0@@8| T@U))
  (! (=> (and (= (type LinearSequence_i._default.linLast$A@@0) TyType)
              (= (type |l#0@@8|) BoxType)
              ($IsBox |l#0@@8|
                      (|#$lseq| LinearSequence_i._default.linLast$A@@0)))
         (= (|LinearSequence__i.__default.linLast#requires|
              LinearSequence_i._default.linLast$A@@0
              |l#0@@8|)
            (INTERNAL_lt_boogie
              0
              (LinearSequence__i.__default.operator_kcardinality_qlseq
                LinearSequence_i._default.linLast$A@@0
                |l#0@@8|))))
     :pattern ((|LinearSequence__i.__default.linLast#requires|
                 LinearSequence_i._default.linLast$A@@0
                 |l#0@@8|))
     :skolemid |2130|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.linLast$A@@1 T@U) (|l#0@@9| T@U))
             (! (let ((a!1 (or (|LinearSequence__i.__default.linLast#canCall|
                                 LinearSequence_i._default.linLast$A@@1
                                 |l#0@@9|)
                               (and ($IsBox |l#0@@9|
                                            (|#$lseq| LinearSequence_i._default.linLast$A@@1))
                                    (INTERNAL_lt_boogie
                                      0
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        LinearSequence_i._default.linLast$A@@1
                                        |l#0@@9|)))))
                      (a!2 (= (LinearSequence__i.__default.linLast
                                LinearSequence_i._default.linLast$A@@1
                                |l#0@@9|)
                              (|Seq#Index| (LinearSequence__i.__default.lseqs
                                             LinearSequence_i._default.linLast$A@@1
                                             |l#0@@9|)
                                           (INTERNAL_sub_boogie
                                             (LinearSequence__i.__default.operator_kcardinality_qlseq
                                               LinearSequence_i._default.linLast$A@@1
                                               |l#0@@9|)
                                             1)))))
                  (=> (and (= (type LinearSequence_i._default.linLast$A@@1)
                              TyType)
                           (= (type |l#0@@9|) BoxType)
                           a!1)
                      (and (|LinearSequence__i.__default.lseqs#canCall|
                             LinearSequence_i._default.linLast$A@@1
                             |l#0@@9|)
                           (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                             LinearSequence_i._default.linLast$A@@1
                             |l#0@@9|)
                           a!2)))
                :pattern ((LinearSequence__i.__default.linLast
                            LinearSequence_i._default.linLast$A@@1
                            |l#0@@9|))
                :skolemid |2131|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.linLast$A@@2 T@U)
                    (|l#0@@10| T@U))
             (! (let ((a!1 (bool_2_U (INTERNAL_lt_boogie
                                       0
                                       (LinearSequence__i.__default.operator_kcardinality_qlseq
                                         LinearSequence_i._default.linLast$A@@2
                                         (Lit |l#0@@10|)))))
                      (a!3 (LitInt (INTERNAL_sub_boogie
                                     (LinearSequence__i.__default.operator_kcardinality_qlseq
                                       LinearSequence_i._default.linLast$A@@2
                                       (Lit |l#0@@10|))
                                     1))))
                (let ((a!2 (or (|LinearSequence__i.__default.linLast#canCall|
                                 LinearSequence_i._default.linLast$A@@2
                                 (Lit |l#0@@10|))
                               (and ($IsBox |l#0@@10|
                                            (|#$lseq| LinearSequence_i._default.linLast$A@@2))
                                    (U_2_bool (Lit a!1)))))
                      (a!4 (= (LinearSequence__i.__default.linLast
                                LinearSequence_i._default.linLast$A@@2
                                (Lit |l#0@@10|))
                              (|Seq#Index| (LinearSequence__i.__default.lseqs
                                             LinearSequence_i._default.linLast$A@@2
                                             (Lit |l#0@@10|))
                                           a!3))))
                  (=> (and (= (type LinearSequence_i._default.linLast$A@@2)
                              TyType)
                           (= (type |l#0@@10|) BoxType)
                           a!2)
                      (and (|LinearSequence__i.__default.lseqs#canCall|
                             LinearSequence_i._default.linLast$A@@2
                             (Lit |l#0@@10|))
                           (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                             LinearSequence_i._default.linLast$A@@2
                             (Lit |l#0@@10|))
                           a!4))))
                :pattern ((LinearSequence__i.__default.linLast
                            LinearSequence_i._default.linLast$A@@2
                            (Lit |l#0@@10|)))
                :weight 3
                :skolemid |2132|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@453 T@U) (arg1@@191 T@U))
  (! (= (type (LinearSequence__i.__default.ldroplast arg0@@453 arg1@@191))
        BoxType)
     :pattern ((LinearSequence__i.__default.ldroplast arg0@@453 arg1@@191))
     :qid |funType:LinearSequence__i.__default.ldroplast|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.ldroplast$A T@U) (|l#0@@11| T@U))
             (! (let ((a!1 (or (|LinearSequence__i.__default.ldroplast#canCall|
                                 LinearSequence_i._default.ldroplast$A
                                 |l#0@@11|)
                               (and ($IsBox |l#0@@11|
                                            (|#$lseq| LinearSequence_i._default.ldroplast$A))
                                    (INTERNAL_lt_boogie
                                      0
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        LinearSequence_i._default.ldroplast$A
                                        |l#0@@11|)))))
                      (a!2 (= (LinearSequence__i.__default.operator_kcardinality_qlseq
                                LinearSequence_i._default.ldroplast$A
                                |l#0@@11|)
                              (INTERNAL_add_boogie
                                (LinearSequence__i.__default.operator_kcardinality_qlseq
                                  LinearSequence_i._default.ldroplast$A
                                  (LinearSequence__i.__default.ldroplast
                                    LinearSequence_i._default.ldroplast$A
                                    |l#0@@11|))
                                1))))
                (let ((a!3 (and a!2
                                (forall ((|i#0@@40| Int))
                                  (! (let ((a!1 (and (INTERNAL_le_boogie
                                                       0
                                                       |i#0@@40|)
                                                     (INTERNAL_lt_boogie
                                                       |i#0@@40|
                                                       (LinearSequence__i.__default.operator_kcardinality_qlseq
                                                         LinearSequence_i._default.ldroplast$A
                                                         (LinearSequence__i.__default.ldroplast
                                                           LinearSequence_i._default.ldroplast$A
                                                           |l#0@@11|)))))
                                           (a!2 (= (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                                  LinearSequence_i._default.ldroplast$A
                                                                  (LinearSequence__i.__default.ldroplast
                                                                    LinearSequence_i._default.ldroplast$A
                                                                    |l#0@@11|))
                                                                |i#0@@40|)
                                                   (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                                  LinearSequence_i._default.ldroplast$A
                                                                  |l#0@@11|)
                                                                |i#0@@40|))))
                                       (=> true (=> a!1 a!2)))
                                     :pattern ((|Seq#Index| (LinearSequence__i.__default.lseqs
                                                              LinearSequence_i._default.ldroplast$A
                                                              |l#0@@11|)
                                                            |i#0@@40|))
                                     :pattern ((|Seq#Index| (LinearSequence__i.__default.lseqs
                                                              LinearSequence_i._default.ldroplast$A
                                                              (LinearSequence__i.__default.ldroplast
                                                                LinearSequence_i._default.ldroplast$A
                                                                |l#0@@11|))
                                                            |i#0@@40|))
                                     :skolemid |2133|
                                     :qid |LinearSequenceidfy.59:20|))
                                ($IsBox (LinearSequence__i.__default.ldroplast
                                          LinearSequence_i._default.ldroplast$A
                                          |l#0@@11|)
                                        (|#$lseq| LinearSequence_i._default.ldroplast$A)))))
                  (=> (and (= (type LinearSequence_i._default.ldroplast$A)
                              TyType)
                           (= (type |l#0@@11|) BoxType)
                           a!1)
                      a!3)))
                :pattern ((LinearSequence__i.__default.ldroplast
                            LinearSequence_i._default.ldroplast$A
                            |l#0@@11|))
                :skolemid |2134|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.ldroplast$A@@0 T@U) (|l#0@@12| T@U))
  (! (=> (and (= (type LinearSequence_i._default.ldroplast$A@@0) TyType)
              (= (type |l#0@@12|) BoxType)
              ($IsBox |l#0@@12|
                      (|#$lseq| LinearSequence_i._default.ldroplast$A@@0)))
         (= (|LinearSequence__i.__default.ldroplast#requires|
              LinearSequence_i._default.ldroplast$A@@0
              |l#0@@12|)
            (INTERNAL_lt_boogie
              0
              (LinearSequence__i.__default.operator_kcardinality_qlseq
                LinearSequence_i._default.ldroplast$A@@0
                |l#0@@12|))))
     :pattern ((|LinearSequence__i.__default.ldroplast#requires|
                 LinearSequence_i._default.ldroplast$A@@0
                 |l#0@@12|))
     :skolemid |2135|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.ldroplast$A@@1 T@U)
                    (|l#0@@13| T@U))
             (! (let ((a!1 (or (|LinearSequence__i.__default.ldroplast#canCall|
                                 LinearSequence_i._default.ldroplast$A@@1
                                 |l#0@@13|)
                               (and ($IsBox |l#0@@13|
                                            (|#$lseq| LinearSequence_i._default.ldroplast$A@@1))
                                    (INTERNAL_lt_boogie
                                      0
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        LinearSequence_i._default.ldroplast$A@@1
                                        |l#0@@13|)))))
                      (a!2 (|LinearSequence__i.__default.imagine__lseq#canCall|
                             LinearSequence_i._default.ldroplast$A@@1
                             (|Seq#Take| (LinearSequence__i.__default.lseqs
                                           LinearSequence_i._default.ldroplast$A@@1
                                           |l#0@@13|)
                                         (INTERNAL_sub_boogie
                                           (LinearSequence__i.__default.operator_kcardinality_qlseq
                                             LinearSequence_i._default.ldroplast$A@@1
                                             |l#0@@13|)
                                           1))))
                      (a!3 (LinearSequence__i.__default.imagine__lseq
                             LinearSequence_i._default.ldroplast$A@@1
                             (|Seq#Take| (LinearSequence__i.__default.lseqs
                                           LinearSequence_i._default.ldroplast$A@@1
                                           |l#0@@13|)
                                         (INTERNAL_sub_boogie
                                           (LinearSequence__i.__default.operator_kcardinality_qlseq
                                             LinearSequence_i._default.ldroplast$A@@1
                                             |l#0@@13|)
                                           1)))))
                  (=> (and (= (type LinearSequence_i._default.ldroplast$A@@1)
                              TyType)
                           (= (type |l#0@@13|) BoxType)
                           a!1)
                      (and (|LinearSequence__i.__default.lseqs#canCall|
                             LinearSequence_i._default.ldroplast$A@@1
                             |l#0@@13|)
                           (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                             LinearSequence_i._default.ldroplast$A@@1
                             |l#0@@13|)
                           a!2
                           (= (LinearSequence__i.__default.ldroplast
                                LinearSequence_i._default.ldroplast$A@@1
                                |l#0@@13|)
                              a!3))))
                :pattern ((LinearSequence__i.__default.ldroplast
                            LinearSequence_i._default.ldroplast$A@@1
                            |l#0@@13|))
                :skolemid |2136|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.ldroplast$A@@2 T@U)
                    (|l#0@@14| T@U))
             (! (let ((a!1 (bool_2_U (INTERNAL_lt_boogie
                                       0
                                       (LinearSequence__i.__default.operator_kcardinality_qlseq
                                         LinearSequence_i._default.ldroplast$A@@2
                                         (Lit |l#0@@14|)))))
                      (a!3 (LitInt (INTERNAL_sub_boogie
                                     (LinearSequence__i.__default.operator_kcardinality_qlseq
                                       LinearSequence_i._default.ldroplast$A@@2
                                       (Lit |l#0@@14|))
                                     1))))
                (let ((a!2 (or (|LinearSequence__i.__default.ldroplast#canCall|
                                 LinearSequence_i._default.ldroplast$A@@2
                                 (Lit |l#0@@14|))
                               (and ($IsBox |l#0@@14|
                                            (|#$lseq| LinearSequence_i._default.ldroplast$A@@2))
                                    (U_2_bool (Lit a!1)))))
                      (a!4 (|LinearSequence__i.__default.imagine__lseq#canCall|
                             LinearSequence_i._default.ldroplast$A@@2
                             (|Seq#Take| (LinearSequence__i.__default.lseqs
                                           LinearSequence_i._default.ldroplast$A@@2
                                           (Lit |l#0@@14|))
                                         a!3)))
                      (a!5 (LinearSequence__i.__default.imagine__lseq
                             LinearSequence_i._default.ldroplast$A@@2
                             (|Seq#Take| (LinearSequence__i.__default.lseqs
                                           LinearSequence_i._default.ldroplast$A@@2
                                           (Lit |l#0@@14|))
                                         a!3))))
                (let ((a!6 (and (|LinearSequence__i.__default.lseqs#canCall|
                                  LinearSequence_i._default.ldroplast$A@@2
                                  (Lit |l#0@@14|))
                                (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                  LinearSequence_i._default.ldroplast$A@@2
                                  (Lit |l#0@@14|))
                                a!4
                                (= (LinearSequence__i.__default.ldroplast
                                     LinearSequence_i._default.ldroplast$A@@2
                                     (Lit |l#0@@14|))
                                   a!5))))
                  (=> (and (= (type LinearSequence_i._default.ldroplast$A@@2)
                              TyType)
                           (= (type |l#0@@14|) BoxType)
                           a!2)
                      a!6))))
                :pattern ((LinearSequence__i.__default.ldroplast
                            LinearSequence_i._default.ldroplast$A@@2
                            (Lit |l#0@@14|)))
                :weight 3
                :skolemid |2137|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((LinearSequence_i._default.lseq_has_all$A T@U) (|l#0@@15| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_has_all$A)
                            TyType)
                         (= (type |l#0@@15|) BoxType)
                         (or (|LinearSequence__i.__default.lseq__has__all#canCall|
                               LinearSequence_i._default.lseq_has_all$A
                               |l#0@@15|)
                             ($IsBox |l#0@@15|
                                     (|#$lseq| LinearSequence_i._default.lseq_has_all$A))))))
           (=> a!1 true))
         :pattern ((LinearSequence__i.__default.lseq__has__all
                     LinearSequence_i._default.lseq_has_all$A
                     |l#0@@15|))
         :skolemid |2138|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_i._default.lseq_has_all$A@@0 T@U) (|l#0@@16| T@U))
  (! (=> (and (= (type LinearSequence_i._default.lseq_has_all$A@@0) TyType)
              (= (type |l#0@@16|) BoxType)
              ($IsBox |l#0@@16|
                      (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@0)))
         (= (|LinearSequence__i.__default.lseq__has__all#requires|
              LinearSequence_i._default.lseq_has_all$A@@0
              |l#0@@16|)
            true))
     :pattern ((|LinearSequence__i.__default.lseq__has__all#requires|
                 LinearSequence_i._default.lseq_has_all$A@@0
                 |l#0@@16|))
     :skolemid |2139|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((LinearSequence_i._default.lseq_has_all$A@@1 T@U) (|l#0@@17| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_has_all$A@@1)
                            TyType)
                         (= (type |l#0@@17|) BoxType)
                         (or (|LinearSequence__i.__default.lseq__has__all#canCall|
                               LinearSequence_i._default.lseq_has_all$A@@1
                               |l#0@@17|)
                             ($IsBox |l#0@@17|
                                     (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@1)))))
               (a!2 (and (forall ((|i#0@@41| Int))
                           (! (let ((a!1 (and (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                                LinearSequence_i._default.lseq_has_all$A@@1
                                                |l#0@@17|)
                                              (=> (INTERNAL_lt_boogie
                                                    |i#0@@41|
                                                    (LinearSequence__i.__default.operator_kcardinality_qlseq
                                                      LinearSequence_i._default.lseq_has_all$A@@1
                                                      |l#0@@17|))
                                                  (|LinearExtern.__default.lseq__has#canCall|
                                                    LinearSequence_i._default.lseq_has_all$A@@1
                                                    |l#0@@17|)))))
                                (=> (INTERNAL_le_boogie 0 |i#0@@41|) a!1))
                              :pattern (($Unbox boolType
                                                (|Seq#Index| (LinearExtern.__default.lseq__has
                                                               LinearSequence_i._default.lseq_has_all$A@@1
                                                               |l#0@@17|)
                                                             |i#0@@41|)))
                              :skolemid |2141|
                              :qid |LinearSequenceidfy.81:12|))
                         (= (LinearSequence__i.__default.lseq__has__all
                              LinearSequence_i._default.lseq_has_all$A@@1
                              |l#0@@17|)
                            (forall ((|i#0@@42| Int))
                              (! (let ((a!1 (U_2_bool ($Unbox boolType
                                                              (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                             LinearSequence_i._default.lseq_has_all$A@@1
                                                                             |l#0@@17|)
                                                                           |i#0@@42|)))))
                                 (let ((a!2 (=> (and (INTERNAL_le_boogie
                                                       0
                                                       |i#0@@42|)
                                                     (INTERNAL_lt_boogie
                                                       |i#0@@42|
                                                       (LinearSequence__i.__default.operator_kcardinality_qlseq
                                                         LinearSequence_i._default.lseq_has_all$A@@1
                                                         |l#0@@17|)))
                                                a!1)))
                                   (=> true a!2)))
                                 :pattern (($Unbox boolType
                                                   (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                  LinearSequence_i._default.lseq_has_all$A@@1
                                                                  |l#0@@17|)
                                                                |i#0@@42|)))
                                 :skolemid |2140|
                                 :qid |LinearSequenceidfy.81:12|))))))
           (=> a!1 a!2))
         :pattern ((LinearSequence__i.__default.lseq__has__all
                     LinearSequence_i._default.lseq_has_all$A@@1
                     |l#0@@17|))
         :skolemid |2142|
         :qid |unknown.0:0|))))
(assert (=> true
    (forall ((LinearSequence_i._default.lseq_has_all$A@@2 T@U) (|l#0@@18| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_has_all$A@@2)
                            TyType)
                         (= (type |l#0@@18|) BoxType)
                         (or (|LinearSequence__i.__default.lseq__has__all#canCall|
                               LinearSequence_i._default.lseq_has_all$A@@2
                               (Lit |l#0@@18|))
                             ($IsBox |l#0@@18|
                                     (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@2)))))
               (a!2 (forall ((|i#1@@2| Int))
                      (! (let ((a!1 (=> (INTERNAL_lt_boogie
                                          |i#1@@2|
                                          (LinearSequence__i.__default.operator_kcardinality_qlseq
                                            LinearSequence_i._default.lseq_has_all$A@@2
                                            (Lit |l#0@@18|)))
                                        (|LinearExtern.__default.lseq__has#canCall|
                                          LinearSequence_i._default.lseq_has_all$A@@2
                                          (Lit |l#0@@18|)))))
                           (=> (INTERNAL_le_boogie 0 |i#1@@2|)
                               (and (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                      LinearSequence_i._default.lseq_has_all$A@@2
                                      (Lit |l#0@@18|))
                                    a!1)))
                         :pattern (($Unbox boolType
                                           (|Seq#Index| (LinearExtern.__default.lseq__has
                                                          LinearSequence_i._default.lseq_has_all$A@@2
                                                          |l#0@@18|)
                                                        |i#1@@2|)))
                         :skolemid |2144|
                         :qid |LinearSequenceidfy.81:12|)))
               (a!3 (forall ((|i#1@@3| Int))
                      (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#1@@3|)
                                         (INTERNAL_lt_boogie
                                           |i#1@@3|
                                           (LinearSequence__i.__default.operator_kcardinality_qlseq
                                             LinearSequence_i._default.lseq_has_all$A@@2
                                             (Lit |l#0@@18|)))))
                               (a!2 (|Seq#Index| (Lit (LinearExtern.__default.lseq__has
                                                        LinearSequence_i._default.lseq_has_all$A@@2
                                                        (Lit |l#0@@18|)))
                                                 |i#1@@3|)))
                           (=> true (=> a!1 (U_2_bool ($Unbox boolType a!2)))))
                         :pattern (($Unbox boolType
                                           (|Seq#Index| (LinearExtern.__default.lseq__has
                                                          LinearSequence_i._default.lseq_has_all$A@@2
                                                          |l#0@@18|)
                                                        |i#1@@3|)))
                         :skolemid |2143|
                         :qid |LinearSequenceidfy.81:12|))))
         (let ((a!4 (and a!2
                         (= (LinearSequence__i.__default.lseq__has__all
                              LinearSequence_i._default.lseq_has_all$A@@2
                              (Lit |l#0@@18|))
                            a!3))))
           (=> a!1 a!4)))
         :pattern ((LinearSequence__i.__default.lseq__has__all
                     LinearSequence_i._default.lseq_has_all$A@@2
                     (Lit |l#0@@18|)))
         :weight 3
         :skolemid |2145|
         :qid |unknown.0:0|))))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_length_as_uint64$A T@U)
                    (|s#0@@23| T@U))
             (! (let ((a!1 (and ($IsBox |s#0@@23|
                                        (|#$lseq| LinearSequence_i._default.lseq_length_as_uint64$A))
                                (INTERNAL_le_boogie
                                  (|Seq#Length| (LinearSequence__i.__default.lseqs
                                                  LinearSequence_i._default.lseq_length_as_uint64$A
                                                  |s#0@@23|))
                                  18446744073709551615)))
                      (a!2 (and (= (LinearSequence__i.__default.lseq__length__as__uint64
                                     LinearSequence_i._default.lseq_length_as_uint64$A
                                     |s#0@@23|)
                                   (|Seq#Length| (LinearSequence__i.__default.lseqs
                                                   LinearSequence_i._default.lseq_length_as_uint64$A
                                                   |s#0@@23|)))
                                (INTERNAL_le_boogie
                                  0
                                  (LinearSequence__i.__default.lseq__length__as__uint64
                                    LinearSequence_i._default.lseq_length_as_uint64$A
                                    |s#0@@23|))
                                (INTERNAL_lt_boogie
                                  (LinearSequence__i.__default.lseq__length__as__uint64
                                    LinearSequence_i._default.lseq_length_as_uint64$A
                                    |s#0@@23|)
                                  18446744073709551616))))
                  (=> (and (= (type LinearSequence_i._default.lseq_length_as_uint64$A)
                              TyType)
                           (= (type |s#0@@23|) BoxType)
                           (or (|LinearSequence__i.__default.lseq__length__as__uint64#canCall|
                                 LinearSequence_i._default.lseq_length_as_uint64$A
                                 |s#0@@23|)
                               a!1))
                      a!2))
                :pattern ((LinearSequence__i.__default.lseq__length__as__uint64
                            LinearSequence_i._default.lseq_length_as_uint64$A
                            |s#0@@23|))
                :skolemid |2146|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.lseq_length_as_uint64$A@@0 T@U)
         (|s#0@@24| T@U))
  (! (let ((a!1 (= (|LinearSequence__i.__default.lseq__length__as__uint64#requires|
                     LinearSequence_i._default.lseq_length_as_uint64$A@@0
                     |s#0@@24|)
                   (INTERNAL_le_boogie
                     (|Seq#Length| (LinearSequence__i.__default.lseqs
                                     LinearSequence_i._default.lseq_length_as_uint64$A@@0
                                     |s#0@@24|))
                     18446744073709551615))))
       (=> (and (= (type LinearSequence_i._default.lseq_length_as_uint64$A@@0)
                   TyType)
                (= (type |s#0@@24|) BoxType)
                ($IsBox |s#0@@24|
                        (|#$lseq| LinearSequence_i._default.lseq_length_as_uint64$A@@0)))
           a!1))
     :pattern ((|LinearSequence__i.__default.lseq__length__as__uint64#requires|
                 LinearSequence_i._default.lseq_length_as_uint64$A@@0
                 |s#0@@24|))
     :skolemid |2147|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_length$A T@U)
                    (|s#0@@25| T@U))
             (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_length$A)
                                   TyType)
                                (= (type |s#0@@25|) BoxType)
                                (or (|LinearSequence__i.__default.lseq__length#canCall|
                                      LinearSequence_i._default.lseq_length$A
                                      |s#0@@25|)
                                    ($IsBox |s#0@@25|
                                            (|#$lseq| LinearSequence_i._default.lseq_length$A))))))
                  (=> a!1
                      (INTERNAL_le_boogie
                        0
                        (LinearSequence__i.__default.lseq__length
                          LinearSequence_i._default.lseq_length$A
                          |s#0@@25|))))
                :pattern ((LinearSequence__i.__default.lseq__length
                            LinearSequence_i._default.lseq_length$A
                            |s#0@@25|))
                :skolemid |2149|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.lseq_length$A@@0 T@U) (|s#0@@26| T@U))
  (! (=> (and (= (type LinearSequence_i._default.lseq_length$A@@0) TyType)
              (= (type |s#0@@26|) BoxType)
              ($IsBox |s#0@@26|
                      (|#$lseq| LinearSequence_i._default.lseq_length$A@@0)))
         (= (|LinearSequence__i.__default.lseq__length#requires|
              LinearSequence_i._default.lseq_length$A@@0
              |s#0@@26|)
            true))
     :pattern ((|LinearSequence__i.__default.lseq__length#requires|
                 LinearSequence_i._default.lseq_length$A@@0
                 |s#0@@26|))
     :skolemid |2150|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((LinearSequence_i._default.lseq_length$A@@1 T@U) (|s#0@@27| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_length$A@@1)
                            TyType)
                         (= (type |s#0@@27|) BoxType)
                         (or (|LinearSequence__i.__default.lseq__length#canCall|
                               LinearSequence_i._default.lseq_length$A@@1
                               |s#0@@27|)
                             ($IsBox |s#0@@27|
                                     (|#$lseq| LinearSequence_i._default.lseq_length$A@@1)))))
               (a!2 (and (|LinearSequence__i.__default.lseqs#canCall|
                           LinearSequence_i._default.lseq_length$A@@1
                           |s#0@@27|)
                         (= (LinearSequence__i.__default.lseq__length
                              LinearSequence_i._default.lseq_length$A@@1
                              |s#0@@27|)
                            (|Seq#Length| (LinearSequence__i.__default.lseqs
                                            LinearSequence_i._default.lseq_length$A@@1
                                            |s#0@@27|))))))
           (=> a!1 a!2))
         :pattern ((LinearSequence__i.__default.lseq__length
                     LinearSequence_i._default.lseq_length$A@@1
                     |s#0@@27|))
         :skolemid |2151|
         :qid |unknown.0:0|))))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_length$A@@2 T@U)
                    (|s#0@@28| T@U))
             (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_length$A@@2)
                                   TyType)
                                (= (type |s#0@@28|) BoxType)
                                (or (|LinearSequence__i.__default.lseq__length#canCall|
                                      LinearSequence_i._default.lseq_length$A@@2
                                      (Lit |s#0@@28|))
                                    ($IsBox |s#0@@28|
                                            (|#$lseq| LinearSequence_i._default.lseq_length$A@@2)))))
                      (a!2 (= (LinearSequence__i.__default.lseq__length
                                LinearSequence_i._default.lseq_length$A@@2
                                (Lit |s#0@@28|))
                              (|Seq#Length| (LinearSequence__i.__default.lseqs
                                              LinearSequence_i._default.lseq_length$A@@2
                                              (Lit |s#0@@28|))))))
                  (=> a!1
                      (and (|LinearSequence__i.__default.lseqs#canCall|
                             LinearSequence_i._default.lseq_length$A@@2
                             (Lit |s#0@@28|))
                           a!2)))
                :pattern ((LinearSequence__i.__default.lseq__length
                            LinearSequence_i._default.lseq_length$A@@2
                            (Lit |s#0@@28|)))
                :weight 3
                :skolemid |2152|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A| T@U)
                    (|s#0@@29| T@U))
             (! (let ((a!1 (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A|)
                                   TyType)
                                (= (type |s#0@@29|) BoxType)
                                (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                      |LinearSequence_i._default.operator'cardinality?lseq$A|
                                      |s#0@@29|)
                                    ($IsBox |s#0@@29|
                                            (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A|))))))
                  (=> a!1
                      (INTERNAL_le_boogie
                        0
                        (LinearSequence__i.__default.operator_kcardinality_qlseq
                          |LinearSequence_i._default.operator'cardinality?lseq$A|
                          |s#0@@29|))))
                :pattern ((LinearSequence__i.__default.operator_kcardinality_qlseq
                            |LinearSequence_i._default.operator'cardinality?lseq$A|
                            |s#0@@29|))
                :skolemid |2153|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@0| T@U)
         (|s#0@@30| T@U))
  (! (=> (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@0|)
                 TyType)
              (= (type |s#0@@30|) BoxType)
              ($IsBox |s#0@@30|
                      (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@0|)))
         (= (|LinearSequence__i.__default.operator_kcardinality_qlseq#requires|
              |LinearSequence_i._default.operator'cardinality?lseq$A@@0|
              |s#0@@30|)
            true))
     :pattern ((|LinearSequence__i.__default.operator_kcardinality_qlseq#requires|
                 |LinearSequence_i._default.operator'cardinality?lseq$A@@0|
                 |s#0@@30|))
     :skolemid |2154|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@1| T@U)
                    (|s#0@@31| T@U))
             (! (let ((a!1 (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@1|)
                                   TyType)
                                (= (type |s#0@@31|) BoxType)
                                (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                      |LinearSequence_i._default.operator'cardinality?lseq$A@@1|
                                      |s#0@@31|)
                                    ($IsBox |s#0@@31|
                                            (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@1|))))))
                  (=> a!1
                      (and (|LinearSequence__i.__default.lseq__length#canCall|
                             |LinearSequence_i._default.operator'cardinality?lseq$A@@1|
                             |s#0@@31|)
                           (= (LinearSequence__i.__default.operator_kcardinality_qlseq
                                |LinearSequence_i._default.operator'cardinality?lseq$A@@1|
                                |s#0@@31|)
                              (LinearSequence__i.__default.lseq__length
                                |LinearSequence_i._default.operator'cardinality?lseq$A@@1|
                                |s#0@@31|)))))
                :pattern ((LinearSequence__i.__default.operator_kcardinality_qlseq
                            |LinearSequence_i._default.operator'cardinality?lseq$A@@1|
                            |s#0@@31|))
                :skolemid |2155|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@2| T@U)
                    (|s#0@@32| T@U))
             (! (let ((a!1 (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@2|)
                                   TyType)
                                (= (type |s#0@@32|) BoxType)
                                (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                      |LinearSequence_i._default.operator'cardinality?lseq$A@@2|
                                      (Lit |s#0@@32|))
                                    ($IsBox |s#0@@32|
                                            (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@2|)))))
                      (a!2 (= (LinearSequence__i.__default.operator_kcardinality_qlseq
                                |LinearSequence_i._default.operator'cardinality?lseq$A@@2|
                                (Lit |s#0@@32|))
                              (LitInt (LinearSequence__i.__default.lseq__length
                                        |LinearSequence_i._default.operator'cardinality?lseq$A@@2|
                                        (Lit |s#0@@32|))))))
                  (=> a!1
                      (and (|LinearSequence__i.__default.lseq__length#canCall|
                             |LinearSequence_i._default.operator'cardinality?lseq$A@@2|
                             (Lit |s#0@@32|))
                           a!2)))
                :pattern ((LinearSequence__i.__default.operator_kcardinality_qlseq
                            |LinearSequence_i._default.operator'cardinality?lseq$A@@2|
                            (Lit |s#0@@32|)))
                :weight 3
                :skolemid |2156|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@454 T@U) (arg1@@192 T@U) (arg2@@95 Int))
  (! (= (type (LinearSequence__i.__default.operator_ksubscript_qlseq
                arg0@@454
                arg1@@192
                arg2@@95))
        BoxType)
     :pattern ((LinearSequence__i.__default.operator_ksubscript_qlseq
                 arg0@@454
                 arg1@@192
                 arg2@@95))
     :qid |funType:LinearSequence__i.__default.operator_ksubscript_qlseq|)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'subscript?lseq$A| T@U)
                    (|s#0@@33| T@U)
                    (|i#0@@43| Int))
             (! (let ((a!1 (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall|
                                 |LinearSequence_i._default.operator'subscript?lseq$A|
                                 |s#0@@33|
                                 |i#0@@43|)
                               (and ($IsBox |s#0@@33|
                                            (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A|))
                                    (INTERNAL_le_boogie 0 |i#0@@43|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@43|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        |LinearSequence_i._default.operator'subscript?lseq$A|
                                        |s#0@@33|))))))
                  (=> (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A|)
                              TyType)
                           (= (type |s#0@@33|) BoxType)
                           a!1)
                      ($IsBox (LinearSequence__i.__default.operator_ksubscript_qlseq
                                |LinearSequence_i._default.operator'subscript?lseq$A|
                                |s#0@@33|
                                |i#0@@43|)
                              |LinearSequence_i._default.operator'subscript?lseq$A|)))
                :pattern ((LinearSequence__i.__default.operator_ksubscript_qlseq
                            |LinearSequence_i._default.operator'subscript?lseq$A|
                            |s#0@@33|
                            |i#0@@43|))
                :skolemid |2157|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@0| T@U)
         (|s#0@@34| T@U)
         (|i#0@@44| Int))
  (! (=> (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@0|)
                 TyType)
              (= (type |s#0@@34|) BoxType)
              ($IsBox |s#0@@34|
                      (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@0|))
              (INTERNAL_le_boogie 0 |i#0@@44|))
         (= (|LinearSequence__i.__default.operator_ksubscript_qlseq#requires|
              |LinearSequence_i._default.operator'subscript?lseq$A@@0|
              |s#0@@34|
              |i#0@@44|)
            (INTERNAL_lt_boogie
              |i#0@@44|
              (LinearSequence__i.__default.operator_kcardinality_qlseq
                |LinearSequence_i._default.operator'subscript?lseq$A@@0|
                |s#0@@34|))))
     :pattern ((|LinearSequence__i.__default.operator_ksubscript_qlseq#requires|
                 |LinearSequence_i._default.operator'subscript?lseq$A@@0|
                 |s#0@@34|
                 |i#0@@44|))
     :skolemid |2158|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@1| T@U)
                    (|s#0@@35| T@U)
                    (|i#0@@45| Int))
             (! (let ((a!1 (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall|
                                 |LinearSequence_i._default.operator'subscript?lseq$A@@1|
                                 |s#0@@35|
                                 |i#0@@45|)
                               (and ($IsBox |s#0@@35|
                                            (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@1|))
                                    (INTERNAL_le_boogie 0 |i#0@@45|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@45|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        |LinearSequence_i._default.operator'subscript?lseq$A@@1|
                                        |s#0@@35|)))))
                      (a!2 (and (|LinearSequence__i.__default.lseqs#canCall|
                                  |LinearSequence_i._default.operator'subscript?lseq$A@@1|
                                  |s#0@@35|)
                                (= (LinearSequence__i.__default.operator_ksubscript_qlseq
                                     |LinearSequence_i._default.operator'subscript?lseq$A@@1|
                                     |s#0@@35|
                                     |i#0@@45|)
                                   (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                  |LinearSequence_i._default.operator'subscript?lseq$A@@1|
                                                  |s#0@@35|)
                                                |i#0@@45|)))))
                  (=> (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@1|)
                              TyType)
                           (= (type |s#0@@35|) BoxType)
                           a!1)
                      a!2))
                :pattern ((LinearSequence__i.__default.operator_ksubscript_qlseq
                            |LinearSequence_i._default.operator'subscript?lseq$A@@1|
                            |s#0@@35|
                            |i#0@@45|))
                :skolemid |2159|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@2| T@U)
                    (|s#0@@36| T@U)
                    (|i#0@@46| Int))
             (! (let ((a!1 (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall|
                                 |LinearSequence_i._default.operator'subscript?lseq$A@@2|
                                 |s#0@@36|
                                 (LitInt |i#0@@46|))
                               (and ($IsBox |s#0@@36|
                                            (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@2|))
                                    (INTERNAL_le_boogie 0 |i#0@@46|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@46|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        |LinearSequence_i._default.operator'subscript?lseq$A@@2|
                                        |s#0@@36|)))))
                      (a!2 (and (|LinearSequence__i.__default.lseqs#canCall|
                                  |LinearSequence_i._default.operator'subscript?lseq$A@@2|
                                  |s#0@@36|)
                                (= (LinearSequence__i.__default.operator_ksubscript_qlseq
                                     |LinearSequence_i._default.operator'subscript?lseq$A@@2|
                                     |s#0@@36|
                                     (LitInt |i#0@@46|))
                                   (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                  |LinearSequence_i._default.operator'subscript?lseq$A@@2|
                                                  |s#0@@36|)
                                                (LitInt |i#0@@46|))))))
                  (=> (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@2|)
                              TyType)
                           (= (type |s#0@@36|) BoxType)
                           a!1)
                      a!2))
                :pattern ((LinearSequence__i.__default.operator_ksubscript_qlseq
                            |LinearSequence_i._default.operator'subscript?lseq$A@@2|
                            |s#0@@36|
                            (LitInt |i#0@@46|)))
                :weight 3
                :skolemid |2160|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@3| T@U)
                    (|s#0@@37| T@U)
                    (|i#0@@47| Int))
             (! (let ((a!1 (bool_2_U (INTERNAL_lt_boogie
                                       |i#0@@47|
                                       (LinearSequence__i.__default.operator_kcardinality_qlseq
                                         |LinearSequence_i._default.operator'subscript?lseq$A@@3|
                                         (Lit |s#0@@37|)))))
                      (a!3 (= (LinearSequence__i.__default.operator_ksubscript_qlseq
                                |LinearSequence_i._default.operator'subscript?lseq$A@@3|
                                (Lit |s#0@@37|)
                                (LitInt |i#0@@47|))
                              (|Seq#Index| (LinearSequence__i.__default.lseqs
                                             |LinearSequence_i._default.operator'subscript?lseq$A@@3|
                                             (Lit |s#0@@37|))
                                           (LitInt |i#0@@47|)))))
                (let ((a!2 (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall|
                                 |LinearSequence_i._default.operator'subscript?lseq$A@@3|
                                 (Lit |s#0@@37|)
                                 (LitInt |i#0@@47|))
                               (and ($IsBox |s#0@@37|
                                            (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@3|))
                                    (INTERNAL_le_boogie 0 |i#0@@47|)
                                    (U_2_bool (Lit a!1))))))
                  (=> (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@3|)
                              TyType)
                           (= (type |s#0@@37|) BoxType)
                           a!2)
                      (and (|LinearSequence__i.__default.lseqs#canCall|
                             |LinearSequence_i._default.operator'subscript?lseq$A@@3|
                             (Lit |s#0@@37|))
                           a!3))))
                :pattern ((LinearSequence__i.__default.operator_ksubscript_qlseq
                            |LinearSequence_i._default.operator'subscript?lseq$A@@3|
                            (Lit |s#0@@37|)
                            (LitInt |i#0@@47|)))
                :weight 3
                :skolemid |2161|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'in?lseq$A| T@U)
                    (|s#0@@38| T@U)
                    (|i#0@@48| Int))
             (! (let ((a!1 (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall|
                                 |LinearSequence_i._default.operator'in?lseq$A|
                                 |s#0@@38|
                                 |i#0@@48|)
                               (and ($IsBox |s#0@@38|
                                            (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A|))
                                    (INTERNAL_le_boogie 0 |i#0@@48|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@48|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        |LinearSequence_i._default.operator'in?lseq$A|
                                        |s#0@@38|))))))
                  (=> (and (= (type |LinearSequence_i._default.operator'in?lseq$A|)
                              TyType)
                           (= (type |s#0@@38|) BoxType)
                           a!1)
                      true))
                :pattern ((LinearSequence__i.__default.operator_kin_qlseq
                            |LinearSequence_i._default.operator'in?lseq$A|
                            |s#0@@38|
                            |i#0@@48|))
                :skolemid |2162|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((|LinearSequence_i._default.operator'in?lseq$A@@0| T@U)
         (|s#0@@39| T@U)
         (|i#0@@49| Int))
  (! (=> (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@0|)
                 TyType)
              (= (type |s#0@@39|) BoxType)
              ($IsBox |s#0@@39|
                      (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@0|))
              (INTERNAL_le_boogie 0 |i#0@@49|))
         (= (|LinearSequence__i.__default.operator_kin_qlseq#requires|
              |LinearSequence_i._default.operator'in?lseq$A@@0|
              |s#0@@39|
              |i#0@@49|)
            (INTERNAL_lt_boogie
              |i#0@@49|
              (LinearSequence__i.__default.operator_kcardinality_qlseq
                |LinearSequence_i._default.operator'in?lseq$A@@0|
                |s#0@@39|))))
     :pattern ((|LinearSequence__i.__default.operator_kin_qlseq#requires|
                 |LinearSequence_i._default.operator'in?lseq$A@@0|
                 |s#0@@39|
                 |i#0@@49|))
     :skolemid |2163|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'in?lseq$A@@1| T@U)
                    (|s#0@@40| T@U)
                    (|i#0@@50| Int))
             (! (let ((a!1 (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall|
                                 |LinearSequence_i._default.operator'in?lseq$A@@1|
                                 |s#0@@40|
                                 |i#0@@50|)
                               (and ($IsBox |s#0@@40|
                                            (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@1|))
                                    (INTERNAL_le_boogie 0 |i#0@@50|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@50|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        |LinearSequence_i._default.operator'in?lseq$A@@1|
                                        |s#0@@40|)))))
                      (a!2 (U_2_bool ($Unbox boolType
                                             (|Seq#Index| (LinearExtern.__default.lseq__has
                                                            |LinearSequence_i._default.operator'in?lseq$A@@1|
                                                            |s#0@@40|)
                                                          |i#0@@50|)))))
                  (=> (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@1|)
                              TyType)
                           (= (type |s#0@@40|) BoxType)
                           a!1)
                      (and (|LinearExtern.__default.lseq__has#canCall|
                             |LinearSequence_i._default.operator'in?lseq$A@@1|
                             |s#0@@40|)
                           (= (LinearSequence__i.__default.operator_kin_qlseq
                                |LinearSequence_i._default.operator'in?lseq$A@@1|
                                |s#0@@40|
                                |i#0@@50|)
                              a!2))))
                :pattern ((LinearSequence__i.__default.operator_kin_qlseq
                            |LinearSequence_i._default.operator'in?lseq$A@@1|
                            |s#0@@40|
                            |i#0@@50|))
                :skolemid |2164|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'in?lseq$A@@2| T@U)
                    (|s#0@@41| T@U)
                    (|i#0@@51| Int))
             (! (let ((a!1 (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall|
                                 |LinearSequence_i._default.operator'in?lseq$A@@2|
                                 |s#0@@41|
                                 (LitInt |i#0@@51|))
                               (and ($IsBox |s#0@@41|
                                            (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@2|))
                                    (INTERNAL_le_boogie 0 |i#0@@51|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@51|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        |LinearSequence_i._default.operator'in?lseq$A@@2|
                                        |s#0@@41|)))))
                      (a!2 (U_2_bool ($Unbox boolType
                                             (|Seq#Index| (LinearExtern.__default.lseq__has
                                                            |LinearSequence_i._default.operator'in?lseq$A@@2|
                                                            |s#0@@41|)
                                                          (LitInt |i#0@@51|))))))
                (let ((a!3 (and (|LinearExtern.__default.lseq__has#canCall|
                                  |LinearSequence_i._default.operator'in?lseq$A@@2|
                                  |s#0@@41|)
                                (= (LinearSequence__i.__default.operator_kin_qlseq
                                     |LinearSequence_i._default.operator'in?lseq$A@@2|
                                     |s#0@@41|
                                     (LitInt |i#0@@51|))
                                   a!2))))
                  (=> (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@2|)
                              TyType)
                           (= (type |s#0@@41|) BoxType)
                           a!1)
                      a!3)))
                :pattern ((LinearSequence__i.__default.operator_kin_qlseq
                            |LinearSequence_i._default.operator'in?lseq$A@@2|
                            |s#0@@41|
                            (LitInt |i#0@@51|)))
                :weight 3
                :skolemid |2165|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|LinearSequence_i._default.operator'in?lseq$A@@3| T@U)
                    (|s#0@@42| T@U)
                    (|i#0@@52| Int))
             (! (let ((a!1 (bool_2_U (INTERNAL_lt_boogie
                                       |i#0@@52|
                                       (LinearSequence__i.__default.operator_kcardinality_qlseq
                                         |LinearSequence_i._default.operator'in?lseq$A@@3|
                                         (Lit |s#0@@42|)))))
                      (a!3 (|Seq#Index| (Lit (LinearExtern.__default.lseq__has
                                               |LinearSequence_i._default.operator'in?lseq$A@@3|
                                               (Lit |s#0@@42|)))
                                        (LitInt |i#0@@52|))))
                (let ((a!2 (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall|
                                 |LinearSequence_i._default.operator'in?lseq$A@@3|
                                 (Lit |s#0@@42|)
                                 (LitInt |i#0@@52|))
                               (and ($IsBox |s#0@@42|
                                            (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@3|))
                                    (INTERNAL_le_boogie 0 |i#0@@52|)
                                    (U_2_bool (Lit a!1)))))
                      (a!4 (and (|LinearExtern.__default.lseq__has#canCall|
                                  |LinearSequence_i._default.operator'in?lseq$A@@3|
                                  (Lit |s#0@@42|))
                                (= (LinearSequence__i.__default.operator_kin_qlseq
                                     |LinearSequence_i._default.operator'in?lseq$A@@3|
                                     (Lit |s#0@@42|)
                                     (LitInt |i#0@@52|))
                                   (U_2_bool ($Unbox boolType a!3))))))
                  (=> (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@3|)
                              TyType)
                           (= (type |s#0@@42|) BoxType)
                           a!2)
                      a!4)))
                :pattern ((LinearSequence__i.__default.operator_kin_qlseq
                            |LinearSequence_i._default.operator'in?lseq$A@@3|
                            (Lit |s#0@@42|)
                            (LitInt |i#0@@52|)))
                :weight 3
                :skolemid |2166|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@455 T@U) (arg1@@193 T@U) (arg2@@96 T@U))
  (! (= (type (LinearSequence__i.__default.lseq__add
                arg0@@455
                arg1@@193
                arg2@@96))
        BoxType)
     :pattern ((LinearSequence__i.__default.lseq__add
                 arg0@@455
                 arg1@@193
                 arg2@@96))
     :qid |funType:LinearSequence__i.__default.lseq__add|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_add$A T@U)
                    (|l#0@@19| T@U)
                    (|r#0| T@U))
             (! (let ((a!1 (or (|LinearSequence__i.__default.lseq__add#canCall|
                                 LinearSequence_i._default.lseq_add$A
                                 |l#0@@19|
                                 |r#0|)
                               (and ($IsBox |l#0@@19|
                                            (|#$lseq| LinearSequence_i._default.lseq_add$A))
                                    ($IsBox |r#0|
                                            (|#$lseq| LinearSequence_i._default.lseq_add$A))))))
                  (=> (and (= (type LinearSequence_i._default.lseq_add$A)
                              TyType)
                           (= (type |l#0@@19|) BoxType)
                           (= (type |r#0|) BoxType)
                           a!1)
                      ($IsBox (LinearSequence__i.__default.lseq__add
                                LinearSequence_i._default.lseq_add$A
                                |l#0@@19|
                                |r#0|)
                              (|#$lseq| LinearSequence_i._default.lseq_add$A))))
                :pattern ((LinearSequence__i.__default.lseq__add
                            LinearSequence_i._default.lseq_add$A
                            |l#0@@19|
                            |r#0|))
                :skolemid |2167|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.lseq_add$A@@0 T@U)
         (|l#0@@20| T@U)
         (|r#0@@0| T@U))
  (! (=> (and (= (type LinearSequence_i._default.lseq_add$A@@0) TyType)
              (= (type |l#0@@20|) BoxType)
              (= (type |r#0@@0|) BoxType)
              ($IsBox |l#0@@20|
                      (|#$lseq| LinearSequence_i._default.lseq_add$A@@0))
              ($IsBox |r#0@@0|
                      (|#$lseq| LinearSequence_i._default.lseq_add$A@@0)))
         (= (|LinearSequence__i.__default.lseq__add#requires|
              LinearSequence_i._default.lseq_add$A@@0
              |l#0@@20|
              |r#0@@0|)
            true))
     :pattern ((|LinearSequence__i.__default.lseq__add#requires|
                 LinearSequence_i._default.lseq_add$A@@0
                 |l#0@@20|
                 |r#0@@0|))
     :skolemid |2168|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@456 T@U) (arg1@@194 T@U) (arg2@@97 Int))
  (! (= (type (LinearSequence__i.__default.lseq__peek
                arg0@@456
                arg1@@194
                arg2@@97))
        BoxType)
     :pattern ((LinearSequence__i.__default.lseq__peek
                 arg0@@456
                 arg1@@194
                 arg2@@97))
     :qid |funType:LinearSequence__i.__default.lseq__peek|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_peek$A T@U)
                    (|s#0@@43| T@U)
                    (|i#0@@53| Int))
             (! (let ((a!1 (U_2_bool ($Unbox boolType
                                             (|Seq#Index| (LinearExtern.__default.lseq__has
                                                            LinearSequence_i._default.lseq_peek$A
                                                            |s#0@@43|)
                                                          |i#0@@53|))))
                      (a!3 (and (= (LinearSequence__i.__default.lseq__peek
                                     LinearSequence_i._default.lseq_peek$A
                                     |s#0@@43|
                                     |i#0@@53|)
                                   (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                  LinearSequence_i._default.lseq_peek$A
                                                  |s#0@@43|)
                                                |i#0@@53|))
                                ($IsBox (LinearSequence__i.__default.lseq__peek
                                          LinearSequence_i._default.lseq_peek$A
                                          |s#0@@43|
                                          |i#0@@53|)
                                        LinearSequence_i._default.lseq_peek$A))))
                (let ((a!2 (or (|LinearSequence__i.__default.lseq__peek#canCall|
                                 LinearSequence_i._default.lseq_peek$A
                                 |s#0@@43|
                                 |i#0@@53|)
                               (and ($IsBox |s#0@@43|
                                            (|#$lseq| LinearSequence_i._default.lseq_peek$A))
                                    (INTERNAL_le_boogie 0 |i#0@@53|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@53|
                                      18446744073709551616)
                                    (INTERNAL_lt_boogie
                                      |i#0@@53|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        LinearSequence_i._default.lseq_peek$A
                                        |s#0@@43|))
                                    a!1))))
                  (=> (and (= (type LinearSequence_i._default.lseq_peek$A)
                              TyType)
                           (= (type |s#0@@43|) BoxType)
                           a!2)
                      a!3)))
                :pattern ((LinearSequence__i.__default.lseq__peek
                            LinearSequence_i._default.lseq_peek$A
                            |s#0@@43|
                            |i#0@@53|))
                :skolemid |2169|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.lseq_peek$A@@0 T@U)
         (|s#0@@44| T@U)
         (|i#0@@54| Int))
  (! (let ((a!1 (U_2_bool ($Unbox boolType
                                  (|Seq#Index| (LinearExtern.__default.lseq__has
                                                 LinearSequence_i._default.lseq_peek$A@@0
                                                 |s#0@@44|)
                                               |i#0@@54|)))))
     (let ((a!2 (= (|LinearSequence__i.__default.lseq__peek#requires|
                     LinearSequence_i._default.lseq_peek$A@@0
                     |s#0@@44|
                     |i#0@@54|)
                   (and (INTERNAL_lt_boogie
                          |i#0@@54|
                          (LinearSequence__i.__default.operator_kcardinality_qlseq
                            LinearSequence_i._default.lseq_peek$A@@0
                            |s#0@@44|))
                        a!1))))
       (=> (and (= (type LinearSequence_i._default.lseq_peek$A@@0) TyType)
                (= (type |s#0@@44|) BoxType)
                ($IsBox |s#0@@44|
                        (|#$lseq| LinearSequence_i._default.lseq_peek$A@@0))
                (INTERNAL_le_boogie 0 |i#0@@54|)
                (INTERNAL_lt_boogie |i#0@@54| 18446744073709551616))
           a!2)))
     :pattern ((|LinearSequence__i.__default.lseq__peek#requires|
                 LinearSequence_i._default.lseq_peek$A@@0
                 |s#0@@44|
                 |i#0@@54|))
     :skolemid |2170|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@457 T@U) (arg1@@195 T@U))
  (! (= (type (LinearSequence__i.__default.lseq__free__fun arg0@@457 arg1@@195))
        DatatypeTypeType)
     :pattern ((LinearSequence__i.__default.lseq__free__fun arg0@@457 arg1@@195))
     :qid |funType:LinearSequence__i.__default.lseq__free__fun|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_free_fun$A T@U)
                    (|s#0@@45| T@U))
             (! (let ((a!1 (forall ((|i#0@@55| Int))
                             (! (let ((a!1 (U_2_bool ($Unbox boolType
                                                             (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                            LinearSequence_i._default.lseq_free_fun$A
                                                                            |s#0@@45|)
                                                                          |i#0@@55|)))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#0@@55|)
                                           (INTERNAL_lt_boogie
                                             |i#0@@55|
                                             (LinearSequence__i.__default.operator_kcardinality_qlseq
                                               LinearSequence_i._default.lseq_free_fun$A
                                               |s#0@@45|)))
                                      (not a!1)))
                                :pattern (($Unbox boolType
                                                  (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                 LinearSequence_i._default.lseq_free_fun$A
                                                                 |s#0@@45|)
                                                               |i#0@@55|)))
                                :skolemid |2176|
                                :qid |LinearSequenceidfy.147:23|))))
                (let ((a!2 (or (|LinearSequence__i.__default.lseq__free__fun#canCall|
                                 LinearSequence_i._default.lseq_free_fun$A
                                 |s#0@@45|)
                               (and ($IsBox |s#0@@45|
                                            (|#$lseq| LinearSequence_i._default.lseq_free_fun$A))
                                    a!1))))
                  (=> (and (= (type LinearSequence_i._default.lseq_free_fun$A)
                              TyType)
                           (= (type |s#0@@45|) BoxType)
                           a!2)
                      ($Is (LinearSequence__i.__default.lseq__free__fun
                             LinearSequence_i._default.lseq_free_fun$A
                             |s#0@@45|)
                           Tclass._System.Tuple0))))
                :pattern ((LinearSequence__i.__default.lseq__free__fun
                            LinearSequence_i._default.lseq_free_fun$A
                            |s#0@@45|))
                :skolemid |2177|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.lseq_free_fun$A@@0 T@U) (|s#0@@46| T@U))
  (! (let ((a!1 (forall ((|i#1@@4| Int))
                  (! (let ((a!1 (U_2_bool ($Unbox boolType
                                                  (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                 LinearSequence_i._default.lseq_free_fun$A@@0
                                                                 |s#0@@46|)
                                                               |i#1@@4|)))))
                       (=> (and (INTERNAL_le_boogie 0 |i#1@@4|)
                                (INTERNAL_lt_boogie
                                  |i#1@@4|
                                  (LinearSequence__i.__default.operator_kcardinality_qlseq
                                    LinearSequence_i._default.lseq_free_fun$A@@0
                                    |s#0@@46|)))
                           (not a!1)))
                     :pattern (($Unbox boolType
                                       (|Seq#Index| (LinearExtern.__default.lseq__has
                                                      LinearSequence_i._default.lseq_free_fun$A@@0
                                                      |s#0@@46|)
                                                    |i#1@@4|)))
                     :skolemid |2178|
                     :qid |LinearSequenceidfy.147:23|))))
       (=> (and (= (type LinearSequence_i._default.lseq_free_fun$A@@0) TyType)
                (= (type |s#0@@46|) BoxType)
                ($IsBox |s#0@@46|
                        (|#$lseq| LinearSequence_i._default.lseq_free_fun$A@@0)))
           (= (|LinearSequence__i.__default.lseq__free__fun#requires|
                LinearSequence_i._default.lseq_free_fun$A@@0
                |s#0@@46|)
              a!1)))
     :pattern ((|LinearSequence__i.__default.lseq__free__fun#requires|
                 LinearSequence_i._default.lseq_free_fun$A@@0
                 |s#0@@46|))
     :skolemid |2179|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@458 T@U) (arg1@@196 T@U) (arg2@@98 Int))
  (! (= (type (LinearSequence__i.__default.lseq__take__fun
                arg0@@458
                arg1@@196
                arg2@@98))
        DatatypeTypeType)
     :pattern ((LinearSequence__i.__default.lseq__take__fun
                 arg0@@458
                 arg1@@196
                 arg2@@98))
     :qid |funType:LinearSequence__i.__default.lseq__take__fun|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_take_fun$A T@U)
                    (|s1#0@@5| T@U)
                    (|i#0@@56| Int))
             (! (let ((a!1 (U_2_bool ($Unbox boolType
                                             (|Seq#Index| (LinearExtern.__default.lseq__has
                                                            LinearSequence_i._default.lseq_take_fun$A
                                                            |s1#0@@5|)
                                                          |i#0@@56|))))
                      (a!3 (|Seq#Update| (LinearExtern.__default.lseq__has
                                           LinearSequence_i._default.lseq_take_fun$A
                                           |s1#0@@5|)
                                         |i#0@@56|
                                         ($Box (Lit (bool_2_U false)))))
                      (a!5 (forall ((|j#0| Int))
                             (! (let ((a!1 (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                          LinearSequence_i._default.lseq_take_fun$A
                                                          (_System.Tuple2OLL._0
                                                            (LinearSequence__i.__default.lseq__take__fun
                                                              LinearSequence_i._default.lseq_take_fun$A
                                                              |s1#0@@5|
                                                              |i#0@@56|)))
                                                        |j#0|)))
                                  (=> (and (INTERNAL_le_boogie 0 |j#0|)
                                           (INTERNAL_lt_boogie
                                             |j#0|
                                             (LinearSequence__i.__default.operator_kcardinality_qlseq
                                               LinearSequence_i._default.lseq_take_fun$A
                                               |s1#0@@5|))
                                           (not (= |j#0| |i#0@@56|)))
                                      (= a!1
                                         (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                        LinearSequence_i._default.lseq_take_fun$A
                                                        |s1#0@@5|)
                                                      |j#0|))))
                                :pattern ((|Seq#Index| (LinearSequence__i.__default.lseqs
                                                         LinearSequence_i._default.lseq_take_fun$A
                                                         |s1#0@@5|)
                                                       |j#0|))
                                :pattern ((|Seq#Index| (LinearSequence__i.__default.lseqs
                                                         LinearSequence_i._default.lseq_take_fun$A
                                                         (_System.Tuple2OLL._0
                                                           (LinearSequence__i.__default.lseq__take__fun
                                                             LinearSequence_i._default.lseq_take_fun$A
                                                             |s1#0@@5|
                                                             |i#0@@56|)))
                                                       |j#0|))
                                :skolemid |2188|
                                :qid |LinearSequenceidfy.200:22|))))
                (let ((a!2 (or (|LinearSequence__i.__default.lseq__take__fun#canCall|
                                 LinearSequence_i._default.lseq_take_fun$A
                                 |s1#0@@5|
                                 |i#0@@56|)
                               (and ($IsBox |s1#0@@5|
                                            (|#$lseq| LinearSequence_i._default.lseq_take_fun$A))
                                    (INTERNAL_le_boogie 0 |i#0@@56|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@56|
                                      18446744073709551616)
                                    (INTERNAL_lt_boogie
                                      |i#0@@56|
                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                        LinearSequence_i._default.lseq_take_fun$A
                                        |s1#0@@5|))
                                    a!1)))
                      (a!4 (|Seq#Equal| (LinearExtern.__default.lseq__has
                                          LinearSequence_i._default.lseq_take_fun$A
                                          (_System.Tuple2OLL._0
                                            (LinearSequence__i.__default.lseq__take__fun
                                              LinearSequence_i._default.lseq_take_fun$A
                                              |s1#0@@5|
                                              |i#0@@56|)))
                                        a!3)))
                (let ((a!6 (and (= (_System.Tuple2OLL._1
                                     (LinearSequence__i.__default.lseq__take__fun
                                       LinearSequence_i._default.lseq_take_fun$A
                                       |s1#0@@5|
                                       |i#0@@56|))
                                   (|Seq#Index| (LinearSequence__i.__default.lseqs
                                                  LinearSequence_i._default.lseq_take_fun$A
                                                  |s1#0@@5|)
                                                |i#0@@56|))
                                a!4
                                a!5
                                ($Is (LinearSequence__i.__default.lseq__take__fun
                                       LinearSequence_i._default.lseq_take_fun$A
                                       |s1#0@@5|
                                       |i#0@@56|)
                                     (Tclass._System.Tuple2OLL
                                       (|#$lseq| LinearSequence_i._default.lseq_take_fun$A)
                                       LinearSequence_i._default.lseq_take_fun$A)))))
                  (=> (and (= (type LinearSequence_i._default.lseq_take_fun$A)
                              TyType)
                           (= (type |s1#0@@5|) BoxType)
                           a!2)
                      a!6))))
                :pattern ((LinearSequence__i.__default.lseq__take__fun
                            LinearSequence_i._default.lseq_take_fun$A
                            |s1#0@@5|
                            |i#0@@56|))
                :skolemid |2189|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((LinearSequence_i._default.lseq_take_fun$A@@0 T@U)
         (|s1#0@@6| T@U)
         (|i#0@@57| Int))
  (! (let ((a!1 (U_2_bool ($Unbox boolType
                                  (|Seq#Index| (LinearExtern.__default.lseq__has
                                                 LinearSequence_i._default.lseq_take_fun$A@@0
                                                 |s1#0@@6|)
                                               |i#0@@57|)))))
     (let ((a!2 (= (|LinearSequence__i.__default.lseq__take__fun#requires|
                     LinearSequence_i._default.lseq_take_fun$A@@0
                     |s1#0@@6|
                     |i#0@@57|)
                   (and (INTERNAL_lt_boogie
                          |i#0@@57|
                          (LinearSequence__i.__default.operator_kcardinality_qlseq
                            LinearSequence_i._default.lseq_take_fun$A@@0
                            |s1#0@@6|))
                        a!1))))
       (=> (and (= (type LinearSequence_i._default.lseq_take_fun$A@@0) TyType)
                (= (type |s1#0@@6|) BoxType)
                ($IsBox |s1#0@@6|
                        (|#$lseq| LinearSequence_i._default.lseq_take_fun$A@@0))
                (INTERNAL_le_boogie 0 |i#0@@57|)
                (INTERNAL_lt_boogie |i#0@@57| 18446744073709551616))
           a!2)))
     :pattern ((|LinearSequence__i.__default.lseq__take__fun#requires|
                 LinearSequence_i._default.lseq_take_fun$A@@0
                 |s1#0@@6|
                 |i#0@@57|))
     :skolemid |2190|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((LinearSequence_i._default.lseq_full$A T@U) (|s#0@@47| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_full$A) TyType)
                         (= (type |s#0@@47|) BoxType)
                         (or (|LinearSequence__i.__default.lseq__full#canCall|
                               LinearSequence_i._default.lseq_full$A
                               |s#0@@47|)
                             ($IsBox |s#0@@47|
                                     (|#$lseq| LinearSequence_i._default.lseq_full$A))))))
           (=> a!1 true))
         :pattern ((LinearSequence__i.__default.lseq__full
                     LinearSequence_i._default.lseq_full$A
                     |s#0@@47|))
         :skolemid |2193|
         :qid |unknown.0:0|))))
(assert (forall ((LinearSequence_i._default.lseq_full$A@@0 T@U) (|s#0@@48| T@U))
  (! (=> (and (= (type LinearSequence_i._default.lseq_full$A@@0) TyType)
              (= (type |s#0@@48|) BoxType)
              ($IsBox |s#0@@48|
                      (|#$lseq| LinearSequence_i._default.lseq_full$A@@0)))
         (= (|LinearSequence__i.__default.lseq__full#requires|
              LinearSequence_i._default.lseq_full$A@@0
              |s#0@@48|)
            true))
     :pattern ((|LinearSequence__i.__default.lseq__full#requires|
                 LinearSequence_i._default.lseq_full$A@@0
                 |s#0@@48|))
     :skolemid |2194|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((LinearSequence_i._default.lseq_full$A@@1 T@U)
                    (|s#0@@49| T@U))
             (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_full$A@@1)
                                   TyType)
                                (= (type |s#0@@49|) BoxType)
                                (or (|LinearSequence__i.__default.lseq__full#canCall|
                                      LinearSequence_i._default.lseq_full$A@@1
                                      |s#0@@49|)
                                    ($IsBox |s#0@@49|
                                            (|#$lseq| LinearSequence_i._default.lseq_full$A@@1)))))
                      (a!2 (forall ((|i#0@@58| Int))
                             (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                      0
                                                      |i#0@@58|)
                                                    (INTERNAL_lt_boogie
                                                      |i#0@@58|
                                                      (LinearSequence__i.__default.operator_kcardinality_qlseq
                                                        LinearSequence_i._default.lseq_full$A@@1
                                                        |s#0@@49|)))
                                               (|LinearSequence__i.__default.operator_kin_qlseq#canCall|
                                                 LinearSequence_i._default.lseq_full$A@@1
                                                 |s#0@@49|
                                                 |i#0@@58|))))
                                  (and (=> (INTERNAL_le_boogie 0 |i#0@@58|)
                                           (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                             LinearSequence_i._default.lseq_full$A@@1
                                             |s#0@@49|))
                                       a!1))
                                :pattern (($Unbox boolType
                                                  (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                 LinearSequence_i._default.lseq_full$A@@1
                                                                 |s#0@@49|)
                                                               |i#0@@58|)))
                                :skolemid |2196|
                                :qid |LinearSequenceidfy.231:18|)))
                      (a!4 (forall ((|i#0@@59| Int))
                             (! (let ((a!1 (U_2_bool ($Unbox boolType
                                                             (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                            LinearSequence_i._default.lseq_full$A@@1
                                                                            |s#0@@49|)
                                                                          |i#0@@59|)))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#0@@59|)
                                           (INTERNAL_lt_boogie
                                             |i#0@@59|
                                             (LinearSequence__i.__default.operator_kcardinality_qlseq
                                               LinearSequence_i._default.lseq_full$A@@1
                                               |s#0@@49|)))
                                      a!1))
                                :pattern (($Unbox boolType
                                                  (|Seq#Index| (LinearExtern.__default.lseq__has
                                                                 LinearSequence_i._default.lseq_full$A@@1
                                                                 |s#0@@49|)
                                                               |i#0@@59|)))
                                :skolemid |2195|
                                :qid |LinearSequenceidfy.231:18|))))
                (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true))) a!2)))
                  (=> a!1
                      (and a!3
                           (= (LinearSequence__i.__default.lseq__full
                                LinearSequence_i._default.lseq_full$A@@1
                                |s#0@@49|)
                              (and true a!4))))))
                :pattern ((LinearSequence__i.__default.lseq__full
                            LinearSequence_i._default.lseq_full$A@@1
                            |s#0@@49|))
                :skolemid |2197|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((LinearSequence_i._default.lseq_full$A@@2 T@U) (|s#0@@50| T@U))
      (! (let ((a!1 (and (= (type LinearSequence_i._default.lseq_full$A@@2)
                            TyType)
                         (= (type |s#0@@50|) BoxType)
                         (or (|LinearSequence__i.__default.lseq__full#canCall|
                               LinearSequence_i._default.lseq_full$A@@2
                               (Lit |s#0@@50|))
                             ($IsBox |s#0@@50|
                                     (|#$lseq| LinearSequence_i._default.lseq_full$A@@2)))))
               (a!2 (forall ((|i#1@@5| Int))
                      (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#1@@5|)
                                         (INTERNAL_lt_boogie
                                           |i#1@@5|
                                           (LinearSequence__i.__default.operator_kcardinality_qlseq
                                             LinearSequence_i._default.lseq_full$A@@2
                                             (Lit |s#0@@50|))))))
                           (and (=> (INTERNAL_le_boogie 0 |i#1@@5|)
                                    (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall|
                                      LinearSequence_i._default.lseq_full$A@@2
                                      (Lit |s#0@@50|)))
                                (=> a!1
                                    (|LinearSequence__i.__default.operator_kin_qlseq#canCall|
                                      LinearSequence_i._default.lseq_full$A@@2
                                      (Lit |s#0@@50|)
                                      |i#1@@5|))))
                         :pattern (($Unbox boolType
                                           (|Seq#Index| (LinearExtern.__default.lseq__has
                                                          LinearSequence_i._default.lseq_full$A@@2
                                                          |s#0@@50|)
                                                        |i#1@@5|)))
                         :skolemid |2199|
                         :qid |LinearSequenceidfy.231:18|)))
               (a!4 (forall ((|i#1@@6| Int))
                      (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#1@@6|)
                                         (INTERNAL_lt_boogie
                                           |i#1@@6|
                                           (LinearSequence__i.__default.operator_kcardinality_qlseq
                                             LinearSequence_i._default.lseq_full$A@@2
                                             (Lit |s#0@@50|)))))
                               (a!2 (|Seq#Index| (Lit (LinearExtern.__default.lseq__has
                                                        LinearSequence_i._default.lseq_full$A@@2
                                                        (Lit |s#0@@50|)))
                                                 |i#1@@6|)))
                           (=> a!1 (U_2_bool ($Unbox boolType a!2))))
                         :pattern (($Unbox boolType
                                           (|Seq#Index| (LinearExtern.__default.lseq__has
                                                          LinearSequence_i._default.lseq_full$A@@2
                                                          |s#0@@50|)
                                                        |i#1@@6|)))
                         :skolemid |2198|
                         :qid |LinearSequenceidfy.231:18|))))
         (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true))) a!2)))
         (let ((a!5 (and a!3
                         (= (LinearSequence__i.__default.lseq__full
                              LinearSequence_i._default.lseq_full$A@@2
                              (Lit |s#0@@50|))
                            (and true a!4)))))
           (=> a!1 a!5))))
         :pattern ((LinearSequence__i.__default.lseq__full
                     LinearSequence_i._default.lseq_full$A@@2
                     (Lit |s#0@@50|)))
         :weight 3
         :skolemid |2200|
         :qid |unknown.0:0|))))
(assert (= (type Tclass.Sequences.__default) TyType))
(assert (= (Tag Tclass.Sequences.__default) Tagclass.Sequences.__default))
(assert (= (TagFamily Tclass.Sequences.__default) tytagFamily$_default))
(assert (forall ((bx@@153 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@153)) bx@@153)
                     ($Is ($Unbox refType bx@@153) Tclass.Sequences.__default))))
       (=> (and (= (type bx@@153) BoxType)
                ($IsBox bx@@153 Tclass.Sequences.__default))
           a!1))
     :pattern (($IsBox bx@@153 Tclass.Sequences.__default))
     :skolemid |2234|
     :qid |unknown.0:0|)))
(assert (forall (($o@@39 T@U))
  (! (let ((a!1 (= ($Is $o@@39 Tclass.Sequences.__default)
                   (or (= $o@@39 null)
                       (= (dtype $o@@39) Tclass.Sequences.__default)))))
       (=> (= (type $o@@39) refType) a!1))
     :pattern (($Is $o@@39 Tclass.Sequences.__default))
     :skolemid |2235|
     :qid |unknown.0:0|)))
(assert (forall (($o@@40 T@U) ($h@@90 T@U))
  (! (let ((a!1 (or (= $o@@40 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@90 $o@@40)
                                              alloc)))))
       (=> (and (= (type $o@@40) refType)
                (= (type $h@@90) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@40 Tclass.Sequences.__default $h@@90) a!1)))
     :pattern (($IsAlloc $o@@40 Tclass.Sequences.__default $h@@90))
     :skolemid |2236|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@459 T@U) (arg1@@197 T@U))
  (! (= (type (Sequences.__default.Last arg0@@459 arg1@@197)) BoxType)
     :pattern ((Sequences.__default.Last arg0@@459 arg1@@197))
     :qid |funType:Sequences.__default.Last|)))
(assert (let ((a!1 (forall ((Sequences._default.Last$E T@U) (|run#0@@7| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Last#canCall|
                                 Sequences._default.Last$E
                                 |run#0@@7|)
                               (and ($Is |run#0@@7|
                                         (TSeq Sequences._default.Last$E))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0@@7|)
                                      0)))))
                  (=> (and (= (type Sequences._default.Last$E) TyType)
                           (= (type |run#0@@7|) (SeqType BoxType))
                           a!1)
                      ($IsBox (Sequences.__default.Last
                                Sequences._default.Last$E
                                |run#0@@7|)
                              Sequences._default.Last$E)))
                :pattern ((Sequences.__default.Last
                            Sequences._default.Last$E
                            |run#0@@7|))
                :skolemid |2237|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.Last$E@@0 T@U) (|run#0@@8| T@U))
  (! (=> (and (= (type Sequences._default.Last$E@@0) TyType)
              (= (type |run#0@@8|) (SeqType BoxType))
              ($Is |run#0@@8| (TSeq Sequences._default.Last$E@@0)))
         (= (|Sequences.__default.Last#requires|
              Sequences._default.Last$E@@0
              |run#0@@8|)
            (INTERNAL_gt_boogie (|Seq#Length| |run#0@@8|) 0)))
     :pattern ((|Sequences.__default.Last#requires|
                 Sequences._default.Last$E@@0
                 |run#0@@8|))
     :skolemid |2238|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Last$E@@1 T@U) (|run#0@@9| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Last#canCall|
                                 Sequences._default.Last$E@@1
                                 |run#0@@9|)
                               (and ($Is |run#0@@9|
                                         (TSeq Sequences._default.Last$E@@1))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0@@9|)
                                      0))))
                      (a!2 (= (Sequences.__default.Last
                                Sequences._default.Last$E@@1
                                |run#0@@9|)
                              (|Seq#Index| |run#0@@9|
                                           (INTERNAL_sub_boogie
                                             (|Seq#Length| |run#0@@9|)
                                             1)))))
                  (=> (and (= (type Sequences._default.Last$E@@1) TyType)
                           (= (type |run#0@@9|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.Last
                            Sequences._default.Last$E@@1
                            |run#0@@9|))
                :skolemid |2239|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.Last$E@@2 T@U) (|run#0@@10| T@U))
             (! (let ((a!1 (and ($Is |run#0@@10|
                                     (TSeq Sequences._default.Last$E@@2))
                                (INTERNAL_gt_boogie
                                  (|Seq#Length| (Lit |run#0@@10|))
                                  0)))
                      (a!3 (|Seq#Index| (Lit |run#0@@10|)
                                        (INTERNAL_sub_boogie
                                          (|Seq#Length| (Lit |run#0@@10|))
                                          1))))
                (let ((a!2 (and (= (type Sequences._default.Last$E@@2) TyType)
                                (= (type |run#0@@10|) (SeqType BoxType))
                                (or (|Sequences.__default.Last#canCall|
                                      Sequences._default.Last$E@@2
                                      (Lit |run#0@@10|))
                                    a!1))))
                  (=> a!2
                      (= (Sequences.__default.Last
                           Sequences._default.Last$E@@2
                           (Lit |run#0@@10|))
                         a!3))))
                :pattern ((Sequences.__default.Last
                            Sequences._default.Last$E@@2
                            (Lit |run#0@@10|)))
                :weight 3
                :skolemid |2240|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@460 T@U) (arg1@@198 T@U))
  (! (= (type (Sequences.__default.FirstOpt arg0@@460 arg1@@198))
        DatatypeTypeType)
     :pattern ((Sequences.__default.FirstOpt arg0@@460 arg1@@198))
     :qid |funType:Sequences.__default.FirstOpt|)))
(assert (let ((a!1 (forall ((Sequences._default.FirstOpt$E T@U) (|run#0@@11| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.FirstOpt$E) TyType)
                                (= (type |run#0@@11|) (SeqType BoxType))
                                (or (|Sequences.__default.FirstOpt#canCall|
                                      Sequences._default.FirstOpt$E
                                      |run#0@@11|)
                                    ($Is |run#0@@11|
                                         (TSeq Sequences._default.FirstOpt$E))))))
                  (=> a!1
                      ($Is (Sequences.__default.FirstOpt
                             Sequences._default.FirstOpt$E
                             |run#0@@11|)
                           (Tclass.Options.Option Sequences._default.FirstOpt$E))))
                :pattern ((Sequences.__default.FirstOpt
                            Sequences._default.FirstOpt$E
                            |run#0@@11|))
                :skolemid |2241|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.FirstOpt$E@@0 T@U) (|run#0@@12| T@U))
  (! (=> (and (= (type Sequences._default.FirstOpt$E@@0) TyType)
              (= (type |run#0@@12|) (SeqType BoxType))
              ($Is |run#0@@12| (TSeq Sequences._default.FirstOpt$E@@0)))
         (= (|Sequences.__default.FirstOpt#requires|
              Sequences._default.FirstOpt$E@@0
              |run#0@@12|)
            true))
     :pattern ((|Sequences.__default.FirstOpt#requires|
                 Sequences._default.FirstOpt$E@@0
                 |run#0@@12|))
     :skolemid |2242|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FirstOpt$E@@1 T@U) (|run#0@@13| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.FirstOpt$E@@1)
                                   TyType)
                                (= (type |run#0@@13|) (SeqType BoxType))
                                (or (|Sequences.__default.FirstOpt#canCall|
                                      Sequences._default.FirstOpt$E@@1
                                      |run#0@@13|)
                                    ($Is |run#0@@13|
                                         (TSeq Sequences._default.FirstOpt$E@@1)))))
                      (a!2 (ite (= (|Seq#Length| |run#0@@13|) (LitInt 0))
                                |#Options.Option.None|
                                (|#Options.Option.Some|
                                  (|Seq#Index| |run#0@@13| (LitInt 0))))))
                  (=> a!1
                      (= (Sequences.__default.FirstOpt
                           Sequences._default.FirstOpt$E@@1
                           |run#0@@13|)
                         a!2)))
                :pattern ((Sequences.__default.FirstOpt
                            Sequences._default.FirstOpt$E@@1
                            |run#0@@13|))
                :skolemid |2243|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FirstOpt$E@@2 T@U) (|run#0@@14| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.FirstOpt$E@@2)
                                   TyType)
                                (= (type |run#0@@14|) (SeqType BoxType))
                                (or (|Sequences.__default.FirstOpt#canCall|
                                      Sequences._default.FirstOpt$E@@2
                                      (Lit |run#0@@14|))
                                    ($Is |run#0@@14|
                                         (TSeq Sequences._default.FirstOpt$E@@2)))))
                      (a!2 (ite (= (|Seq#Length| (Lit |run#0@@14|)) (LitInt 0))
                                |#Options.Option.None|
                                (|#Options.Option.Some|
                                  (|Seq#Index| (Lit |run#0@@14|) (LitInt 0))))))
                  (=> a!1
                      (= (Sequences.__default.FirstOpt
                           Sequences._default.FirstOpt$E@@2
                           (Lit |run#0@@14|))
                         a!2)))
                :pattern ((Sequences.__default.FirstOpt
                            Sequences._default.FirstOpt$E@@2
                            (Lit |run#0@@14|)))
                :weight 3
                :skolemid |2244|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@461 T@U) (arg1@@199 T@U))
  (! (= (type (Sequences.__default.DropLast arg0@@461 arg1@@199))
        (SeqType BoxType))
     :pattern ((Sequences.__default.DropLast arg0@@461 arg1@@199))
     :qid |funType:Sequences.__default.DropLast|)))
(assert (let ((a!1 (forall ((Sequences._default.DropLast$E T@U) (|run#0@@15| T@U))
             (! (let ((a!1 (or (|Sequences.__default.DropLast#canCall|
                                 Sequences._default.DropLast$E
                                 |run#0@@15|)
                               (and ($Is |run#0@@15|
                                         (TSeq Sequences._default.DropLast$E))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0@@15|)
                                      0)))))
                  (=> (and (= (type Sequences._default.DropLast$E) TyType)
                           (= (type |run#0@@15|) (SeqType BoxType))
                           a!1)
                      ($Is (Sequences.__default.DropLast
                             Sequences._default.DropLast$E
                             |run#0@@15|)
                           (TSeq Sequences._default.DropLast$E))))
                :pattern ((Sequences.__default.DropLast
                            Sequences._default.DropLast$E
                            |run#0@@15|))
                :skolemid |2245|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.DropLast$E@@0 T@U) (|run#0@@16| T@U))
  (! (=> (and (= (type Sequences._default.DropLast$E@@0) TyType)
              (= (type |run#0@@16|) (SeqType BoxType))
              ($Is |run#0@@16| (TSeq Sequences._default.DropLast$E@@0)))
         (= (|Sequences.__default.DropLast#requires|
              Sequences._default.DropLast$E@@0
              |run#0@@16|)
            (INTERNAL_gt_boogie (|Seq#Length| |run#0@@16|) 0)))
     :pattern ((|Sequences.__default.DropLast#requires|
                 Sequences._default.DropLast$E@@0
                 |run#0@@16|))
     :skolemid |2246|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.DropLast$E@@1 T@U) (|run#0@@17| T@U))
             (! (let ((a!1 (or (|Sequences.__default.DropLast#canCall|
                                 Sequences._default.DropLast$E@@1
                                 |run#0@@17|)
                               (and ($Is |run#0@@17|
                                         (TSeq Sequences._default.DropLast$E@@1))
                                    (INTERNAL_gt_boogie
                                      (|Seq#Length| |run#0@@17|)
                                      0))))
                      (a!2 (= (Sequences.__default.DropLast
                                Sequences._default.DropLast$E@@1
                                |run#0@@17|)
                              (|Seq#Take| |run#0@@17|
                                          (INTERNAL_sub_boogie
                                            (|Seq#Length| |run#0@@17|)
                                            1)))))
                  (=> (and (= (type Sequences._default.DropLast$E@@1) TyType)
                           (= (type |run#0@@17|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.DropLast
                            Sequences._default.DropLast$E@@1
                            |run#0@@17|))
                :skolemid |2247|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.DropLast$E@@2 T@U) (|run#0@@18| T@U))
             (! (let ((a!1 (and ($Is |run#0@@18|
                                     (TSeq Sequences._default.DropLast$E@@2))
                                (INTERNAL_gt_boogie
                                  (|Seq#Length| (Lit |run#0@@18|))
                                  0)))
                      (a!3 (|Seq#Take| (Lit |run#0@@18|)
                                       (INTERNAL_sub_boogie
                                         (|Seq#Length| (Lit |run#0@@18|))
                                         1))))
                (let ((a!2 (and (= (type Sequences._default.DropLast$E@@2)
                                   TyType)
                                (= (type |run#0@@18|) (SeqType BoxType))
                                (or (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.DropLast$E@@2
                                      (Lit |run#0@@18|))
                                    a!1))))
                  (=> a!2
                      (= (Sequences.__default.DropLast
                           Sequences._default.DropLast$E@@2
                           (Lit |run#0@@18|))
                         a!3))))
                :pattern ((Sequences.__default.DropLast
                            Sequences._default.DropLast$E@@2
                            (Lit |run#0@@18|)))
                :weight 3
                :skolemid |2248|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@462 T@U) (arg1@@200 T@U))
  (! (= (type (Sequences.__default.Set arg0@@462 arg1@@200))
        (MapType0Type BoxType boolType))
     :pattern ((Sequences.__default.Set arg0@@462 arg1@@200))
     :qid |funType:Sequences.__default.Set|)))
(assert (let ((a!1 (forall ((Sequences._default.Set$T T@U) (|run#0@@19| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.Set$T) TyType)
                                (= (type |run#0@@19|) (SeqType BoxType))
                                (or (|Sequences.__default.Set#canCall|
                                      Sequences._default.Set$T
                                      |run#0@@19|)
                                    ($Is |run#0@@19|
                                         (TSeq Sequences._default.Set$T))))))
                  (=> a!1
                      ($Is (Sequences.__default.Set
                             Sequences._default.Set$T
                             |run#0@@19|)
                           (TSet Sequences._default.Set$T))))
                :pattern ((Sequences.__default.Set
                            Sequences._default.Set$T
                            |run#0@@19|))
                :skolemid |2249|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.Set$T@@0 T@U) (|run#0@@20| T@U))
  (! (=> (and (= (type Sequences._default.Set$T@@0) TyType)
              (= (type |run#0@@20|) (SeqType BoxType))
              ($Is |run#0@@20| (TSeq Sequences._default.Set$T@@0)))
         (= (|Sequences.__default.Set#requires|
              Sequences._default.Set$T@@0
              |run#0@@20|)
            true))
     :pattern ((|Sequences.__default.Set#requires|
                 Sequences._default.Set$T@@0
                 |run#0@@20|))
     :skolemid |2250|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Set$T@@1 T@U) (|run#0@@21| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.Set$T@@1) TyType)
                                (= (type |run#0@@21|) (SeqType BoxType))
                                (or (|Sequences.__default.Set#canCall|
                                      Sequences._default.Set$T@@1
                                      |run#0@@21|)
                                    ($Is |run#0@@21|
                                         (TSeq Sequences._default.Set$T@@1))))))
                  (=> a!1
                      (= (Sequences.__default.Set
                           Sequences._default.Set$T@@1
                           |run#0@@21|)
                         (|lambda#104| Sequences._default.Set$T@@1
                                       (|MultiSet#FromSeq| |run#0@@21|)
                                       0))))
                :pattern ((Sequences.__default.Set
                            Sequences._default.Set$T@@1
                            |run#0@@21|))
                :skolemid |2251|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((Sequences._default.Set$T@@2 T@U) (|run#0@@22| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.Set$T@@2) TyType)
                         (= (type |run#0@@22|) (SeqType BoxType))
                         (or (|Sequences.__default.Set#canCall|
                               Sequences._default.Set$T@@2
                               (Lit |run#0@@22|))
                             ($Is |run#0@@22|
                                  (TSeq Sequences._default.Set$T@@2)))))
               (a!2 (= (Sequences.__default.Set
                         Sequences._default.Set$T@@2
                         (Lit |run#0@@22|))
                       (|lambda#104| Sequences._default.Set$T@@2
                                     (|MultiSet#FromSeq| (Lit |run#0@@22|))
                                     0))))
           (=> a!1 a!2))
         :pattern ((Sequences.__default.Set
                     Sequences._default.Set$T@@2
                     (Lit |run#0@@22|)))
         :weight 3
         :skolemid |2252|
         :qid |unknown.0:0|))))
(assert (forall ((arg0@@463 T@U) (arg1@@201 T@U))
  (! (= (type (Sequences.__default.ISet arg0@@463 arg1@@201))
        (MapType0Type BoxType boolType))
     :pattern ((Sequences.__default.ISet arg0@@463 arg1@@201))
     :qid |funType:Sequences.__default.ISet|)))
(assert (let ((a!1 (forall ((Sequences._default.ISet$T T@U) (|run#0@@23| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.ISet$T) TyType)
                                (= (type |run#0@@23|) (SeqType BoxType))
                                (or (|Sequences.__default.ISet#canCall|
                                      Sequences._default.ISet$T
                                      |run#0@@23|)
                                    ($Is |run#0@@23|
                                         (TSeq Sequences._default.ISet$T))))))
                  (=> a!1
                      ($Is (Sequences.__default.ISet
                             Sequences._default.ISet$T
                             |run#0@@23|)
                           (TISet Sequences._default.ISet$T))))
                :pattern ((Sequences.__default.ISet
                            Sequences._default.ISet$T
                            |run#0@@23|))
                :skolemid |2253|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.ISet$T@@0 T@U) (|run#0@@24| T@U))
  (! (=> (and (= (type Sequences._default.ISet$T@@0) TyType)
              (= (type |run#0@@24|) (SeqType BoxType))
              ($Is |run#0@@24| (TSeq Sequences._default.ISet$T@@0)))
         (= (|Sequences.__default.ISet#requires|
              Sequences._default.ISet$T@@0
              |run#0@@24|)
            true))
     :pattern ((|Sequences.__default.ISet#requires|
                 Sequences._default.ISet$T@@0
                 |run#0@@24|))
     :skolemid |2254|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.ISet$T@@1 T@U) (|run#0@@25| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.ISet$T@@1) TyType)
                                (= (type |run#0@@25|) (SeqType BoxType))
                                (or (|Sequences.__default.ISet#canCall|
                                      Sequences._default.ISet$T@@1
                                      |run#0@@25|)
                                    ($Is |run#0@@25|
                                         (TSeq Sequences._default.ISet$T@@1))))))
                  (=> a!1
                      (= (Sequences.__default.ISet
                           Sequences._default.ISet$T@@1
                           |run#0@@25|)
                         (|lambda#104| Sequences._default.ISet$T@@1
                                       (|MultiSet#FromSeq| |run#0@@25|)
                                       0))))
                :pattern ((Sequences.__default.ISet
                            Sequences._default.ISet$T@@1
                            |run#0@@25|))
                :skolemid |2255|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((Sequences._default.ISet$T@@2 T@U) (|run#0@@26| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.ISet$T@@2) TyType)
                         (= (type |run#0@@26|) (SeqType BoxType))
                         (or (|Sequences.__default.ISet#canCall|
                               Sequences._default.ISet$T@@2
                               (Lit |run#0@@26|))
                             ($Is |run#0@@26|
                                  (TSeq Sequences._default.ISet$T@@2)))))
               (a!2 (= (Sequences.__default.ISet
                         Sequences._default.ISet$T@@2
                         (Lit |run#0@@26|))
                       (|lambda#104| Sequences._default.ISet$T@@2
                                     (|MultiSet#FromSeq| (Lit |run#0@@26|))
                                     0))))
           (=> a!1 a!2))
         :pattern ((Sequences.__default.ISet
                     Sequences._default.ISet$T@@2
                     (Lit |run#0@@26|)))
         :weight 3
         :skolemid |2256|
         :qid |unknown.0:0|))))
(assert (forall ((Sequences._default.NoDupes$T T@U) ($ly@@23 T@U) (|a#0@@21| T@U))
  (! (=> (and (= (type Sequences._default.NoDupes$T) TyType)
              (= (type $ly@@23) LayerTypeType)
              (= (type |a#0@@21|) (SeqType BoxType)))
         (= (Sequences.__default.NoDupes
              Sequences._default.NoDupes$T
              ($LS $ly@@23)
              |a#0@@21|)
            (Sequences.__default.NoDupes
              Sequences._default.NoDupes$T
              $ly@@23
              |a#0@@21|)))
     :pattern ((Sequences.__default.NoDupes
                 Sequences._default.NoDupes$T
                 ($LS $ly@@23)
                 |a#0@@21|))
     :skolemid |2257|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.NoDupes$T@@0 T@U) ($ly@@24 T@U) (|a#0@@22| T@U))
  (! (=> (and (= (type Sequences._default.NoDupes$T@@0) TyType)
              (= (type $ly@@24) LayerTypeType)
              (= (type |a#0@@22|) (SeqType BoxType)))
         (= (Sequences.__default.NoDupes
              Sequences._default.NoDupes$T@@0
              $ly@@24
              |a#0@@22|)
            (Sequences.__default.NoDupes
              Sequences._default.NoDupes$T@@0
              $LZ
              |a#0@@22|)))
     :pattern ((Sequences.__default.NoDupes
                 Sequences._default.NoDupes$T@@0
                 (AsFuelBottom $ly@@24)
                 |a#0@@22|))
     :skolemid |2258|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((Sequences._default.NoDupes$T@@1 T@U)
             ($ly@@25 T@U)
             (|a#0@@23| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.NoDupes$T@@1) TyType)
                         (= (type $ly@@25) LayerTypeType)
                         (= (type |a#0@@23|) (SeqType BoxType))
                         (or (|Sequences.__default.NoDupes#canCall|
                               Sequences._default.NoDupes$T@@1
                               |a#0@@23|)
                             ($Is |a#0@@23|
                                  (TSeq Sequences._default.NoDupes$T@@1))))))
           (=> a!1 true))
         :pattern ((Sequences.__default.NoDupes
                     Sequences._default.NoDupes$T@@1
                     $ly@@25
                     |a#0@@23|))
         :skolemid |2259|
         :qid |unknown.0:0|))))
(assert (forall ((Sequences._default.NoDupes$T@@2 T@U) ($ly@@26 T@U) (|a#0@@24| T@U))
  (! (=> (and (= (type Sequences._default.NoDupes$T@@2) TyType)
              (= (type $ly@@26) LayerTypeType)
              (= (type |a#0@@24|) (SeqType BoxType))
              ($Is |a#0@@24| (TSeq Sequences._default.NoDupes$T@@2)))
         (= (|Sequences.__default.NoDupes#requires|
              Sequences._default.NoDupes$T@@2
              $ly@@26
              |a#0@@24|)
            true))
     :pattern ((|Sequences.__default.NoDupes#requires|
                 Sequences._default.NoDupes$T@@2
                 $ly@@26
                 |a#0@@24|))
     :skolemid |2260|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.NoDupes$T@@3 T@U)
                    ($ly@@27 T@U)
                    (|a#0@@25| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.NoDupes$T@@3)
                                   TyType)
                                (= (type $ly@@27) LayerTypeType)
                                (= (type |a#0@@25|) (SeqType BoxType))
                                (or (|Sequences.__default.NoDupes#canCall|
                                      Sequences._default.NoDupes$T@@3
                                      |a#0@@25|)
                                    ($Is |a#0@@25|
                                         (TSeq Sequences._default.NoDupes$T@@3))))))
                  (=> a!1
                      (= (Sequences.__default.NoDupes
                           Sequences._default.NoDupes$T@@3
                           ($LS $ly@@27)
                           |a#0@@25|)
                         (forall ((|i#0@@60| Int) (|j#0@@0| Int))
                           (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                    0
                                                    |i#0@@60|)
                                                  (INTERNAL_lt_boogie
                                                    |i#0@@60|
                                                    (|Seq#Length| |a#0@@25|))
                                                  (INTERNAL_le_boogie
                                                    0
                                                    |j#0@@0|)
                                                  (INTERNAL_lt_boogie
                                                    |j#0@@0|
                                                    (|Seq#Length| |a#0@@25|))
                                                  (not (= |i#0@@60| |j#0@@0|)))
                                             (not (= (|Seq#Index| |a#0@@25|
                                                                  |i#0@@60|)
                                                     (|Seq#Index| |a#0@@25|
                                                                  |j#0@@0|))))))
                                (=> true a!1))
                              :pattern ((|Seq#Index| |a#0@@25| |j#0@@0|)
                                        (|Seq#Index| |a#0@@25| |i#0@@60|))
                              :skolemid |2261|
                              :qid |Sequencesidfy.70:13|)))))
                :pattern ((Sequences.__default.NoDupes
                            Sequences._default.NoDupes$T@@3
                            ($LS $ly@@27)
                            |a#0@@25|))
                :skolemid |2262|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((Sequences._default.NoDupes$T@@4 T@U)
             ($ly@@28 T@U)
             (|a#0@@26| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.NoDupes$T@@4) TyType)
                         (= (type $ly@@28) LayerTypeType)
                         (= (type |a#0@@26|) (SeqType BoxType))
                         (or (|Sequences.__default.NoDupes#canCall|
                               Sequences._default.NoDupes$T@@4
                               (Lit |a#0@@26|))
                             ($Is |a#0@@26|
                                  (TSeq Sequences._default.NoDupes$T@@4)))))
               (a!2 (= (Sequences.__default.NoDupes
                         Sequences._default.NoDupes$T@@4
                         ($LS $ly@@28)
                         (Lit |a#0@@26|))
                       (forall ((|i#1@@7| Int) (|j#1| Int))
                         (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#1@@7|)
                                            (INTERNAL_lt_boogie
                                              |i#1@@7|
                                              (|Seq#Length| (Lit |a#0@@26|)))
                                            (INTERNAL_le_boogie 0 |j#1|)
                                            (INTERNAL_lt_boogie
                                              |j#1|
                                              (|Seq#Length| (Lit |a#0@@26|)))
                                            (not (= |i#1@@7| |j#1|))))
                                  (a!2 (not (= (|Seq#Index| (Lit |a#0@@26|)
                                                            |i#1@@7|)
                                               (|Seq#Index| (Lit |a#0@@26|)
                                                            |j#1|)))))
                              (=> true (=> a!1 a!2)))
                            :pattern ((|Seq#Index| |a#0@@26| |j#1|)
                                      (|Seq#Index| |a#0@@26| |i#1@@7|))
                            :skolemid |2263|
                            :qid |Sequencesidfy.70:13|)))))
           (=> a!1 a!2))
         :pattern ((Sequences.__default.NoDupes
                     Sequences._default.NoDupes$T@@4
                     ($LS $ly@@28)
                     (Lit |a#0@@26|)))
         :weight 3
         :skolemid |2264|
         :qid |unknown.0:0|))))
(assert (let ((a!1 (forall ((Sequences._default.IndexOf$T T@U)
                    (|s#0@@51| T@U)
                    (|e#0| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IndexOf#canCall|
                                 Sequences._default.IndexOf$T
                                 |s#0@@51|
                                 |e#0|)
                               (and ($Is |s#0@@51|
                                         (TSeq Sequences._default.IndexOf$T))
                                    ($IsBox |e#0| Sequences._default.IndexOf$T)
                                    (|Seq#Contains| |s#0@@51| |e#0|))))
                      (a!2 (and (INTERNAL_le_boogie
                                  0
                                  (Sequences.__default.IndexOf
                                    Sequences._default.IndexOf$T
                                    |s#0@@51|
                                    |e#0|))
                                (INTERNAL_lt_boogie
                                  (Sequences.__default.IndexOf
                                    Sequences._default.IndexOf$T
                                    |s#0@@51|
                                    |e#0|)
                                  (|Seq#Length| |s#0@@51|))
                                (= (|Seq#Index| |s#0@@51|
                                                (Sequences.__default.IndexOf
                                                  Sequences._default.IndexOf$T
                                                  |s#0@@51|
                                                  |e#0|))
                                   |e#0|))))
                  (=> (and (= (type Sequences._default.IndexOf$T) TyType)
                           (= (type |s#0@@51|) (SeqType BoxType))
                           (= (type |e#0|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.IndexOf
                            Sequences._default.IndexOf$T
                            |s#0@@51|
                            |e#0|))
                :skolemid |2265|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.IndexOf$T@@0 T@U)
         ($Heap@@8 T@U)
         (|s#0@@52| T@U)
         (|e#0@@0| T@U))
  (! (=> (and (= (type Sequences._default.IndexOf$T@@0) TyType)
              (= (type $Heap@@8) (MapType0Type refType MapType1Type))
              (= (type |s#0@@52|) (SeqType BoxType))
              (= (type |e#0@@0|) BoxType)
              ($IsGoodHeap $Heap@@8)
              ($Is |s#0@@52| (TSeq Sequences._default.IndexOf$T@@0))
              ($IsBox |e#0@@0| Sequences._default.IndexOf$T@@0))
         (= (|Sequences.__default.IndexOf#requires|
              Sequences._default.IndexOf$T@@0
              |s#0@@52|
              |e#0@@0|)
            (|Seq#Contains| |s#0@@52| |e#0@@0|)))
     :pattern ((|Sequences.__default.IndexOf#requires|
                 Sequences._default.IndexOf$T@@0
                 |s#0@@52|
                 |e#0@@0|)
               ($IsGoodHeap $Heap@@8))
     :skolemid |2266|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.IndexOf$T@@1 T@U) (s@@49 T@U) (e T@U))
  (! (let ((a!1 (and (INTERNAL_le_boogie
                       0
                       (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e))
                     (INTERNAL_lt_boogie
                       (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e)
                       (|Seq#Length| s@@49))
                     (= (|Seq#Index| s@@49
                                     (|$let#0_i| Sequences._default.IndexOf$T@@1
                                                 s@@49
                                                 e))
                        e))))
       (=> (and (= (type Sequences._default.IndexOf$T@@1) TyType)
                (= (type s@@49) (SeqType BoxType))
                (= (type e) BoxType)
                (|$let#0$canCall| Sequences._default.IndexOf$T@@1 s@@49 e))
           a!1))
     :pattern ((|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e))
     :skolemid |2267|
     :qid |Sequencesidfy.121:5|)))
(assert (let ((a!1 (forall ((Sequences._default.IndexOf$T@@2 T@U)
                    ($Heap@@9 T@U)
                    (|s#0@@53| T@U)
                    (|e#0@@1| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IndexOf#canCall|
                                 Sequences._default.IndexOf$T@@2
                                 |s#0@@53|
                                 |e#0@@1|)
                               (and ($IsGoodHeap $Heap@@9)
                                    ($Is |s#0@@53|
                                         (TSeq Sequences._default.IndexOf$T@@2))
                                    ($IsBox |e#0@@1|
                                            Sequences._default.IndexOf$T@@2)
                                    (|Seq#Contains| |s#0@@53| |e#0@@1|)))))
                  (=> (and (= (type Sequences._default.IndexOf$T@@2) TyType)
                           (= (type $Heap@@9)
                              (MapType0Type refType MapType1Type))
                           (= (type |s#0@@53|) (SeqType BoxType))
                           (= (type |e#0@@1|) BoxType)
                           a!1)
                      (and (|$let#0$canCall| Sequences._default.IndexOf$T@@2
                                             |s#0@@53|
                                             |e#0@@1|)
                           (= (Sequences.__default.IndexOf
                                Sequences._default.IndexOf$T@@2
                                |s#0@@53|
                                |e#0@@1|)
                              (|$let#0_i| Sequences._default.IndexOf$T@@2
                                          |s#0@@53|
                                          |e#0@@1|)))))
                :pattern ((Sequences.__default.IndexOf
                            Sequences._default.IndexOf$T@@2
                            |s#0@@53|
                            |e#0@@1|)
                          ($IsGoodHeap $Heap@@9))
                :skolemid |2268|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.IndexOf$T@@3 T@U)
                    ($Heap@@10 T@U)
                    (|s#0@@54| T@U)
                    (|e#0@@2| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IndexOf#canCall|
                                 Sequences._default.IndexOf$T@@3
                                 (Lit |s#0@@54|)
                                 |e#0@@2|)
                               (and ($IsGoodHeap $Heap@@10)
                                    ($Is |s#0@@54|
                                         (TSeq Sequences._default.IndexOf$T@@3))
                                    ($IsBox |e#0@@2|
                                            Sequences._default.IndexOf$T@@3)
                                    (|Seq#Contains| |s#0@@54| |e#0@@2|))))
                      (a!2 (and (|$let#0$canCall| Sequences._default.IndexOf$T@@3
                                                  (Lit |s#0@@54|)
                                                  |e#0@@2|)
                                (= (Sequences.__default.IndexOf
                                     Sequences._default.IndexOf$T@@3
                                     (Lit |s#0@@54|)
                                     |e#0@@2|)
                                   (|$let#0_i| Sequences._default.IndexOf$T@@3
                                               (Lit |s#0@@54|)
                                               |e#0@@2|)))))
                  (=> (and (= (type Sequences._default.IndexOf$T@@3) TyType)
                           (= (type $Heap@@10)
                              (MapType0Type refType MapType1Type))
                           (= (type |s#0@@54|) (SeqType BoxType))
                           (= (type |e#0@@2|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.IndexOf
                            Sequences._default.IndexOf$T@@3
                            (Lit |s#0@@54|)
                            |e#0@@2|)
                          ($IsGoodHeap $Heap@@10))
                :weight 3
                :skolemid |2269|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.IndexOf$T@@4 T@U)
                    ($Heap@@11 T@U)
                    (|s#0@@55| T@U)
                    (|e#0@@3| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IndexOf#canCall|
                                 Sequences._default.IndexOf$T@@4
                                 (Lit |s#0@@55|)
                                 (Lit |e#0@@3|))
                               (and ($IsGoodHeap $Heap@@11)
                                    ($Is |s#0@@55|
                                         (TSeq Sequences._default.IndexOf$T@@4))
                                    ($IsBox |e#0@@3|
                                            Sequences._default.IndexOf$T@@4)
                                    (|Seq#Contains| |s#0@@55| |e#0@@3|))))
                      (a!2 (and (|$let#0$canCall| Sequences._default.IndexOf$T@@4
                                                  (Lit |s#0@@55|)
                                                  (Lit |e#0@@3|))
                                (= (Sequences.__default.IndexOf
                                     Sequences._default.IndexOf$T@@4
                                     (Lit |s#0@@55|)
                                     (Lit |e#0@@3|))
                                   (|$let#0_i| Sequences._default.IndexOf$T@@4
                                               (Lit |s#0@@55|)
                                               (Lit |e#0@@3|))))))
                  (=> (and (= (type Sequences._default.IndexOf$T@@4) TyType)
                           (= (type $Heap@@11)
                              (MapType0Type refType MapType1Type))
                           (= (type |s#0@@55|) (SeqType BoxType))
                           (= (type |e#0@@3|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.IndexOf
                            Sequences._default.IndexOf$T@@4
                            (Lit |s#0@@55|)
                            (Lit |e#0@@3|))
                          ($IsGoodHeap $Heap@@11))
                :weight 3
                :skolemid |2270|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@464 T@U) (arg1@@202 Int))
  (! (= (type (Sequences.__default.Range arg0@@464 arg1@@202))
        (SeqType BoxType))
     :pattern ((Sequences.__default.Range arg0@@464 arg1@@202))
     :qid |funType:Sequences.__default.Range|)))
(assert (forall (($ly@@29 T@U) (|n#0| Int))
  (! (=> (= (type $ly@@29) LayerTypeType)
         (= (Sequences.__default.Range ($LS $ly@@29) |n#0|)
            (Sequences.__default.Range $ly@@29 |n#0|)))
     :pattern ((Sequences.__default.Range ($LS $ly@@29) |n#0|))
     :skolemid |2271|
     :qid |Sequencesidfy.125:22|)))
(assert (forall (($ly@@30 T@U) (|n#0@@0| Int))
  (! (=> (= (type $ly@@30) LayerTypeType)
         (= (Sequences.__default.Range $ly@@30 |n#0@@0|)
            (Sequences.__default.Range $LZ |n#0@@0|)))
     :pattern ((Sequences.__default.Range (AsFuelBottom $ly@@30) |n#0@@0|))
     :skolemid |2272|
     :qid |Sequencesidfy.125:22|)))
(assert (let ((a!1 (forall (($ly@@31 T@U) (|n#0@@1| Int))
             (! (let ((a!1 (forall ((|i#0@@62| Int))
                             (! (let ((a!1 (U_2_int ($Unbox intType
                                                            (|Seq#Index| (Sequences.__default.Range
                                                                           $ly@@31
                                                                           |n#0@@1|)
                                                                         |i#0@@62|)))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#0@@62|)
                                           (INTERNAL_lt_boogie
                                             |i#0@@62|
                                             |n#0@@1|))
                                      (= a!1 |i#0@@62|)))
                                :pattern (($Unbox intType
                                                  (|Seq#Index| (Sequences.__default.Range
                                                                 $ly@@31
                                                                 |n#0@@1|)
                                                               |i#0@@62|)))
                                :skolemid |2273|
                                :qid |Sequencesidfy.128:20|))))
                (let ((a!2 (and (= (|Seq#Length| (Sequences.__default.Range
                                                   $ly@@31
                                                   |n#0@@1|))
                                   |n#0@@1|)
                                a!1
                                ($Is (Sequences.__default.Range
                                       $ly@@31
                                       |n#0@@1|)
                                     (TSeq TInt)))))
                  (=> (and (= (type $ly@@31) LayerTypeType)
                           (or (|Sequences.__default.Range#canCall| |n#0@@1|)
                               (INTERNAL_ge_boogie |n#0@@1| 0)))
                      a!2)))
                :pattern ((Sequences.__default.Range $ly@@31 |n#0@@1|))
                :skolemid |2274|
                :qid |Sequencesidfy.125:22|))))
  (=> true a!1)))
(assert (forall (($ly@@32 T@U) (|n#0@@2| Int))
  (! (=> (= (type $ly@@32) LayerTypeType)
         (= (|Sequences.__default.Range#requires| $ly@@32 |n#0@@2|)
            (INTERNAL_ge_boogie |n#0@@2| 0)))
     :pattern ((|Sequences.__default.Range#requires| $ly@@32 |n#0@@2|))
     :skolemid |2275|
     :qid |Sequencesidfy.125:22|)))
(assert (let ((a!1 (forall (($ly@@33 T@U) (|n#0@@3| Int))
             (! (let ((a!1 (=> (not (= |n#0@@3| (LitInt 0)))
                               (|Sequences.__default.Range#canCall|
                                 (INTERNAL_sub_boogie |n#0@@3| 1))))
                      (a!2 (|Seq#Build| (|Seq#Empty| BoxType)
                                        ($Box (int_2_U (INTERNAL_sub_boogie
                                                         |n#0@@3|
                                                         1))))))
                (let ((a!3 (ite (= |n#0@@3| (LitInt 0))
                                (|Seq#Empty| BoxType)
                                (|Seq#Append| (Sequences.__default.Range
                                                $ly@@33
                                                (INTERNAL_sub_boogie |n#0@@3| 1))
                                              a!2))))
                (let ((a!4 (and a!1
                                (= (Sequences.__default.Range
                                     ($LS $ly@@33)
                                     |n#0@@3|)
                                   a!3))))
                  (=> (and (= (type $ly@@33) LayerTypeType)
                           (or (|Sequences.__default.Range#canCall| |n#0@@3|)
                               (INTERNAL_ge_boogie |n#0@@3| 0)))
                      a!4))))
                :pattern ((Sequences.__default.Range ($LS $ly@@33) |n#0@@3|))
                :skolemid |2276|
                :qid |Sequencesidfy.125:22|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@34 T@U) (|n#0@@4| Int))
      (! (let ((a!1 (and (= (type $ly@@34) LayerTypeType)
                         (or (|Sequences.__default.Range#canCall|
                               (LitInt |n#0@@4|))
                             (INTERNAL_ge_boogie |n#0@@4| 0))))
               (a!2 (=> (not (= (LitInt |n#0@@4|) (LitInt 0)))
                        (|Sequences.__default.Range#canCall|
                          (LitInt (INTERNAL_sub_boogie |n#0@@4| 1)))))
               (a!3 ($Box (int_2_U (LitInt (INTERNAL_sub_boogie |n#0@@4| 1))))))
         (let ((a!4 (|Seq#Append| (Sequences.__default.Range
                                    ($LS $ly@@34)
                                    (LitInt (INTERNAL_sub_boogie |n#0@@4| 1)))
                                  (|Seq#Build| (|Seq#Empty| BoxType) a!3))))
         (let ((a!5 (= (Sequences.__default.Range
                         ($LS $ly@@34)
                         (LitInt |n#0@@4|))
                       (ite (= (LitInt |n#0@@4|) (LitInt 0))
                            (|Seq#Empty| BoxType)
                            a!4))))
           (=> a!1 (and a!2 a!5)))))
         :pattern ((Sequences.__default.Range ($LS $ly@@34) (LitInt |n#0@@4|)))
         :weight 3
         :skolemid |2277|
         :qid |Sequencesidfy.125:22|))))
(assert (forall ((arg0@@465 T@U) (arg1@@203 T@U) (arg2@@99 T@U) (arg3@@49 T@U))
  (! (= (type (Sequences.__default.Apply arg0@@465 arg1@@203 arg2@@99 arg3@@49))
        (SeqType BoxType))
     :pattern ((Sequences.__default.Apply arg0@@465 arg1@@203 arg2@@99 arg3@@49))
     :qid |funType:Sequences.__default.Apply|)))
(assert (let ((a!1 (forall ((Sequences._default.Apply$E T@U)
                    (Sequences._default.Apply$R T@U)
                    ($Heap@@12 T@U)
                    (|f#0@@75| T@U)
                    (|run#0@@27| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Apply#canCall|
                                 Sequences._default.Apply$E
                                 Sequences._default.Apply$R
                                 |f#0@@75|
                                 |run#0@@27|)
                               (and ($IsGoodHeap $Heap@@12)
                                    ($Is |f#0@@75|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Apply$E
                                           Sequences._default.Apply$R))
                                    ($Is |run#0@@27|
                                         (TSeq Sequences._default.Apply$E))
                                    (forall ((|i#0@@63| Int))
                                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                               0
                                                               |i#0@@63|)
                                                             (INTERNAL_lt_boogie
                                                               |i#0@@63|
                                                               (|Seq#Length| |run#0@@27|)))
                                                        (Requires1 Sequences._default.Apply$E
                                                                   Sequences._default.Apply$R
                                                                   $Heap@@12
                                                                   |f#0@@75|
                                                                   (|Seq#Index| |run#0@@27|
                                                                                |i#0@@63|)))))
                                           (=> true a!1))
                                         :pattern ((|Seq#Index| |run#0@@27|
                                                                |i#0@@63|))
                                         :skolemid |2278|
                                         :qid |Sequencesidfy.134:21|)))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.Apply
                                                   Sequences._default.Apply$E
                                                   Sequences._default.Apply$R
                                                   |f#0@@75|
                                                   |run#0@@27|))
                                   (|Seq#Length| |run#0@@27|))
                                (forall ((|i#1@@9| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#1@@9|)
                                                         (INTERNAL_lt_boogie
                                                           |i#1@@9|
                                                           (|Seq#Length| |run#0@@27|)))
                                                    (= (|Seq#Index| (Sequences.__default.Apply
                                                                      Sequences._default.Apply$E
                                                                      Sequences._default.Apply$R
                                                                      |f#0@@75|
                                                                      |run#0@@27|)
                                                                    |i#1@@9|)
                                                       (Apply1 Sequences._default.Apply$E
                                                               Sequences._default.Apply$R
                                                               $Heap@@12
                                                               |f#0@@75|
                                                               (|Seq#Index| |run#0@@27|
                                                                            |i#1@@9|))))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| |run#0@@27|
                                                            |i#1@@9|))
                                     :pattern ((|Seq#Index| (Sequences.__default.Apply
                                                              Sequences._default.Apply$E
                                                              Sequences._default.Apply$R
                                                              |f#0@@75|
                                                              |run#0@@27|)
                                                            |i#1@@9|))
                                     :skolemid |2279|
                                     :qid |Sequencesidfy.136:20|))
                                ($Is (Sequences.__default.Apply
                                       Sequences._default.Apply$E
                                       Sequences._default.Apply$R
                                       |f#0@@75|
                                       |run#0@@27|)
                                     (TSeq Sequences._default.Apply$R)))))
                  (=> (and (= (type Sequences._default.Apply$E) TyType)
                           (= (type Sequences._default.Apply$R) TyType)
                           (= (type $Heap@@12)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@75|) HandleTypeType)
                           (= (type |run#0@@27|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.Apply
                            Sequences._default.Apply$E
                            Sequences._default.Apply$R
                            |f#0@@75|
                            |run#0@@27|)
                          ($IsGoodHeap $Heap@@12))
                :skolemid |2280|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.Apply$E@@0 T@U)
         (Sequences._default.Apply$R@@0 T@U)
         ($Heap@@13 T@U)
         (|f#0@@76| T@U)
         (|run#0@@28| T@U))
  (! (=> (and (= (type Sequences._default.Apply$E@@0) TyType)
              (= (type Sequences._default.Apply$R@@0) TyType)
              (= (type $Heap@@13) (MapType0Type refType MapType1Type))
              (= (type |f#0@@76|) HandleTypeType)
              (= (type |run#0@@28|) (SeqType BoxType))
              ($IsGoodHeap $Heap@@13)
              ($Is |f#0@@76|
                   (Tclass._System.___hPartialFunc1
                     Sequences._default.Apply$E@@0
                     Sequences._default.Apply$R@@0))
              ($Is |run#0@@28| (TSeq Sequences._default.Apply$E@@0)))
         (= (|Sequences.__default.Apply#requires|
              Sequences._default.Apply$E@@0
              Sequences._default.Apply$R@@0
              |f#0@@76|
              |run#0@@28|)
            (forall ((|i#2@@0| Int))
              (! (let ((a!1 (=> (and (INTERNAL_le_boogie 0 |i#2@@0|)
                                     (INTERNAL_lt_boogie
                                       |i#2@@0|
                                       (|Seq#Length| |run#0@@28|)))
                                (Requires1 Sequences._default.Apply$E@@0
                                           Sequences._default.Apply$R@@0
                                           $Heap@@13
                                           |f#0@@76|
                                           (|Seq#Index| |run#0@@28| |i#2@@0|)))))
                   (=> true a!1))
                 :pattern ((|Seq#Index| |run#0@@28| |i#2@@0|))
                 :skolemid |2281|
                 :qid |Sequencesidfy.134:21|))))
     :pattern ((|Sequences.__default.Apply#requires|
                 Sequences._default.Apply$E@@0
                 Sequences._default.Apply$R@@0
                 |f#0@@76|
                 |run#0@@28|)
               ($IsGoodHeap $Heap@@13))
     :skolemid |2282|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@466 T@U)
                    (arg1@@204 T@U)
                    (arg2@@100 T@U)
                    (arg3@@50 T@U))
             (! (= (type (|lambda#112| arg0@@466 arg1@@204 arg2@@100 arg3@@50))
                   (MapType2Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 BoxType))
                :pattern ((|lambda#112| arg0@@466 arg1@@204 arg2@@100 arg3@@50))
                :qid |funType:lambda#112|)))
      (a!2 (forall ((arg0@@467 T@U)
                    (arg1@@205 Int)
                    (arg2@@101 Int)
                    (arg3@@51 T@U)
                    (arg4@@30 T@U)
                    (arg5@@15 T@U)
                    (arg6@@6 T@U))
             (! (= (type (|lambda#113| arg0@@467
                                       arg1@@205
                                       arg2@@101
                                       arg3@@51
                                       arg4@@30
                                       arg5@@15
                                       arg6@@6))
                   (MapType2Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 boolType))
                :pattern ((|lambda#113| arg0@@467
                                        arg1@@205
                                        arg2@@101
                                        arg3@@51
                                        arg4@@30
                                        arg5@@15
                                        arg6@@6))
                :qid |funType:lambda#113|)))
      (a!3 (forall ((arg0@@468 T@U)
                    (arg1@@206 Int)
                    (arg2@@102 Int)
                    (arg3@@52 T@U)
                    (arg4@@31 T@U)
                    (arg5@@16 T@U)
                    (arg6@@7 T@U)
                    (arg7@@3 T@U)
                    (arg8@@3 T@U)
                    (arg9@@1 T@U)
                    (arg10@@1 T@U))
             (! (= (type (|lambda#115| arg0@@468
                                       arg1@@206
                                       arg2@@102
                                       arg3@@52
                                       arg4@@31
                                       arg5@@16
                                       arg6@@7
                                       arg7@@3
                                       arg8@@3
                                       arg9@@1
                                       arg10@@1))
                   (MapType2Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 (MapType0Type BoxType boolType)))
                :pattern ((|lambda#115| arg0@@468
                                        arg1@@206
                                        arg2@@102
                                        arg3@@52
                                        arg4@@31
                                        arg5@@16
                                        arg6@@7
                                        arg7@@3
                                        arg8@@3
                                        arg9@@1
                                        arg10@@1))
                :qid |funType:lambda#115|))))
  (and a!1 a!2 a!3)))
(assert (let ((a!1 (forall ((Sequences._default.Apply$E@@1 T@U)
                    (Sequences._default.Apply$R@@1 T@U)
                    ($Heap@@14 T@U)
                    (|f#0@@77| T@U)
                    (|run#0@@29| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Apply#canCall|
                                 Sequences._default.Apply$E@@1
                                 Sequences._default.Apply$R@@1
                                 |f#0@@77|
                                 |run#0@@29|)
                               (and ($IsGoodHeap $Heap@@14)
                                    ($Is |f#0@@77|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Apply$E@@1
                                           Sequences._default.Apply$R@@1))
                                    ($Is |run#0@@29|
                                         (TSeq Sequences._default.Apply$E@@1))
                                    (forall ((|i#2@@1| Int))
                                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                               0
                                                               |i#2@@1|)
                                                             (INTERNAL_lt_boogie
                                                               |i#2@@1|
                                                               (|Seq#Length| |run#0@@29|)))
                                                        (Requires1 Sequences._default.Apply$E@@1
                                                                   Sequences._default.Apply$R@@1
                                                                   $Heap@@14
                                                                   |f#0@@77|
                                                                   (|Seq#Index| |run#0@@29|
                                                                                |i#2@@1|)))))
                                           (=> true a!1))
                                         :pattern ((|Seq#Index| |run#0@@29|
                                                                |i#2@@1|))
                                         :skolemid |2281|
                                         :qid |Sequencesidfy.134:21|)))))
                      (a!2 (forall ((|$l#1#i#0@@0| Int))
                             (! (=> (INTERNAL_le_boogie 0 |$l#1#i#0@@0|)
                                    (=> (INTERNAL_lt_boogie
                                          |$l#1#i#0@@0|
                                          (|Seq#Length| |run#0@@29|))
                                        true))
                                :no-pattern (INTERNAL_lt_boogie
                                              |$l#1#i#0@@0|
                                              (|Seq#Length| |run#0@@29|))
                                :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@0|)
                                :skolemid |2284|
                                :qid |unknown.0:0|)))
                      (a!3 (|lambda#94| (Handle1 (|lambda#112| Sequences._default.Apply$E@@1
                                                               Sequences._default.Apply$R@@1
                                                               |f#0@@77|
                                                               |run#0@@29|)
                                                 (|lambda#113| TInt
                                                               0
                                                               (|Seq#Length| |run#0@@29|)
                                                               Sequences._default.Apply$E@@1
                                                               Sequences._default.Apply$R@@1
                                                               |f#0@@77|
                                                               |run#0@@29|)
                                                 (|lambda#115| Tclass._System.object?
                                                               0
                                                               (|Seq#Length| |run#0@@29|)
                                                               Sequences._default.Apply$E@@1
                                                               Sequences._default.Apply$R@@1
                                                               |f#0@@77|
                                                               |run#0@@29|
                                                               Sequences._default.Apply$E@@1
                                                               Sequences._default.Apply$R@@1
                                                               |f#0@@77|
                                                               |run#0@@29|)))))
                (let ((a!4 (|Seq#Create| Sequences._default.Apply$R@@1
                                         $Heap@@14
                                         (|Seq#Length| |run#0@@29|)
                                         (Lit (AtLayer a!3 ($LS $LZ))))))
                  (=> (and (= (type Sequences._default.Apply$E@@1) TyType)
                           (= (type Sequences._default.Apply$R@@1) TyType)
                           (= (type $Heap@@14)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@77|) HandleTypeType)
                           (= (type |run#0@@29|) (SeqType BoxType))
                           a!1)
                      (and a!2
                           (= (Sequences.__default.Apply
                                Sequences._default.Apply$E@@1
                                Sequences._default.Apply$R@@1
                                |f#0@@77|
                                |run#0@@29|)
                              a!4)))))
                :pattern ((Sequences.__default.Apply
                            Sequences._default.Apply$E@@1
                            Sequences._default.Apply$R@@1
                            |f#0@@77|
                            |run#0@@29|)
                          ($IsGoodHeap $Heap@@14))
                :skolemid |2285|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.Apply$E@@2 T@U)
                    (Sequences._default.Apply$R@@2 T@U)
                    ($Heap@@15 T@U)
                    (|f#0@@78| T@U)
                    (|run#0@@30| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Apply#canCall|
                                 Sequences._default.Apply$E@@2
                                 Sequences._default.Apply$R@@2
                                 |f#0@@78|
                                 (Lit |run#0@@30|))
                               (and ($IsGoodHeap $Heap@@15)
                                    ($Is |f#0@@78|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Apply$E@@2
                                           Sequences._default.Apply$R@@2))
                                    ($Is |run#0@@30|
                                         (TSeq Sequences._default.Apply$E@@2))
                                    (forall ((|i#4| Int))
                                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                                           0
                                                           |i#4|)
                                                         (INTERNAL_lt_boogie
                                                           |i#4|
                                                           (|Seq#Length| (Lit |run#0@@30|))))))
                                         (let ((a!2 (=> a!1
                                                        (Requires1 Sequences._default.Apply$E@@2
                                                                   Sequences._default.Apply$R@@2
                                                                   $Heap@@15
                                                                   |f#0@@78|
                                                                   (|Seq#Index| (Lit |run#0@@30|)
                                                                                |i#4|)))))
                                           (=> true a!2)))
                                         :pattern ((|Seq#Index| |run#0@@30|
                                                                |i#4|))
                                         :skolemid |2286|
                                         :qid |Sequencesidfy.134:21|)))))
                      (a!2 (Handle1 (|lambda#112| Sequences._default.Apply$E@@2
                                                  Sequences._default.Apply$R@@2
                                                  |f#0@@78|
                                                  (Lit |run#0@@30|))
                                    (|lambda#113| TInt
                                                  0
                                                  (|Seq#Length| (Lit |run#0@@30|))
                                                  Sequences._default.Apply$E@@2
                                                  Sequences._default.Apply$R@@2
                                                  |f#0@@78|
                                                  (Lit |run#0@@30|))
                                    (|lambda#115| Tclass._System.object?
                                                  0
                                                  (|Seq#Length| (Lit |run#0@@30|))
                                                  Sequences._default.Apply$E@@2
                                                  Sequences._default.Apply$R@@2
                                                  |f#0@@78|
                                                  (Lit |run#0@@30|)
                                                  Sequences._default.Apply$E@@2
                                                  Sequences._default.Apply$R@@2
                                                  |f#0@@78|
                                                  |run#0@@30|))))
                (let ((a!3 (|Seq#Create| Sequences._default.Apply$R@@2
                                         $Heap@@15
                                         (|Seq#Length| (Lit |run#0@@30|))
                                         (Lit (AtLayer (|lambda#94| a!2)
                                                       ($LS $LZ))))))
                (let ((a!4 (and (forall ((|$l#3#i#0@@0| Int))
                                  (! (let ((a!1 (=> (INTERNAL_lt_boogie
                                                      |$l#3#i#0@@0|
                                                      (|Seq#Length| (Lit |run#0@@30|)))
                                                    true)))
                                       (=> (INTERNAL_le_boogie 0 |$l#3#i#0@@0|)
                                           a!1))
                                     :no-pattern (INTERNAL_lt_boogie
                                                   |$l#3#i#0@@0|
                                                   (|Seq#Length| (Lit |run#0@@30|)))
                                     :no-pattern (INTERNAL_le_boogie
                                                   0
                                                   |$l#3#i#0@@0|)
                                     :skolemid |2288|
                                     :qid |unknown.0:0|))
                                (= (Sequences.__default.Apply
                                     Sequences._default.Apply$E@@2
                                     Sequences._default.Apply$R@@2
                                     |f#0@@78|
                                     (Lit |run#0@@30|))
                                   a!3))))
                  (=> (and (= (type Sequences._default.Apply$E@@2) TyType)
                           (= (type Sequences._default.Apply$R@@2) TyType)
                           (= (type $Heap@@15)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@78|) HandleTypeType)
                           (= (type |run#0@@30|) (SeqType BoxType))
                           a!1)
                      a!4))))
                :pattern ((Sequences.__default.Apply
                            Sequences._default.Apply$E@@2
                            Sequences._default.Apply$R@@2
                            |f#0@@78|
                            (Lit |run#0@@30|))
                          ($IsGoodHeap $Heap@@15))
                :weight 3
                :skolemid |2289|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.Apply$E@@3 T@U)
                    (Sequences._default.Apply$R@@3 T@U)
                    ($Heap@@16 T@U)
                    (|f#0@@79| T@U)
                    (|run#0@@31| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Apply#canCall|
                                 Sequences._default.Apply$E@@3
                                 Sequences._default.Apply$R@@3
                                 (Lit |f#0@@79|)
                                 (Lit |run#0@@31|))
                               (and ($IsGoodHeap $Heap@@16)
                                    ($Is |f#0@@79|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Apply$E@@3
                                           Sequences._default.Apply$R@@3))
                                    ($Is |run#0@@31|
                                         (TSeq Sequences._default.Apply$E@@3))
                                    (forall ((|i#6| Int))
                                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                                           0
                                                           |i#6|)
                                                         (INTERNAL_lt_boogie
                                                           |i#6|
                                                           (|Seq#Length| (Lit |run#0@@31|))))))
                                         (let ((a!2 (=> a!1
                                                        (Requires1 Sequences._default.Apply$E@@3
                                                                   Sequences._default.Apply$R@@3
                                                                   $Heap@@16
                                                                   (Lit |f#0@@79|)
                                                                   (|Seq#Index| (Lit |run#0@@31|)
                                                                                |i#6|)))))
                                           (=> true a!2)))
                                         :pattern ((|Seq#Index| |run#0@@31|
                                                                |i#6|))
                                         :skolemid |2290|
                                         :qid |Sequencesidfy.134:21|)))))
                      (a!2 (Handle1 (|lambda#112| Sequences._default.Apply$E@@3
                                                  Sequences._default.Apply$R@@3
                                                  (Lit |f#0@@79|)
                                                  (Lit |run#0@@31|))
                                    (|lambda#113| TInt
                                                  0
                                                  (|Seq#Length| (Lit |run#0@@31|))
                                                  Sequences._default.Apply$E@@3
                                                  Sequences._default.Apply$R@@3
                                                  (Lit |f#0@@79|)
                                                  (Lit |run#0@@31|))
                                    (|lambda#115| Tclass._System.object?
                                                  0
                                                  (|Seq#Length| (Lit |run#0@@31|))
                                                  Sequences._default.Apply$E@@3
                                                  Sequences._default.Apply$R@@3
                                                  (Lit |f#0@@79|)
                                                  (Lit |run#0@@31|)
                                                  Sequences._default.Apply$E@@3
                                                  Sequences._default.Apply$R@@3
                                                  |f#0@@79|
                                                  |run#0@@31|))))
                (let ((a!3 (|Seq#Create| Sequences._default.Apply$R@@3
                                         $Heap@@16
                                         (|Seq#Length| (Lit |run#0@@31|))
                                         (Lit (AtLayer (|lambda#94| a!2)
                                                       ($LS $LZ))))))
                (let ((a!4 (and (forall ((|$l#5#i#0| Int))
                                  (! (let ((a!1 (=> (INTERNAL_lt_boogie
                                                      |$l#5#i#0|
                                                      (|Seq#Length| (Lit |run#0@@31|)))
                                                    true)))
                                       (=> (INTERNAL_le_boogie 0 |$l#5#i#0|)
                                           a!1))
                                     :no-pattern (INTERNAL_lt_boogie
                                                   |$l#5#i#0|
                                                   (|Seq#Length| (Lit |run#0@@31|)))
                                     :no-pattern (INTERNAL_le_boogie
                                                   0
                                                   |$l#5#i#0|)
                                     :skolemid |2292|
                                     :qid |unknown.0:0|))
                                (= (Sequences.__default.Apply
                                     Sequences._default.Apply$E@@3
                                     Sequences._default.Apply$R@@3
                                     (Lit |f#0@@79|)
                                     (Lit |run#0@@31|))
                                   a!3))))
                  (=> (and (= (type Sequences._default.Apply$E@@3) TyType)
                           (= (type Sequences._default.Apply$R@@3) TyType)
                           (= (type $Heap@@16)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@79|) HandleTypeType)
                           (= (type |run#0@@31|) (SeqType BoxType))
                           a!1)
                      a!4))))
                :pattern ((Sequences.__default.Apply
                            Sequences._default.Apply$E@@3
                            Sequences._default.Apply$R@@3
                            (Lit |f#0@@79|)
                            (Lit |run#0@@31|))
                          ($IsGoodHeap $Heap@@16))
                :weight 3
                :skolemid |2293|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@469 T@U)
         (arg1@@207 T@U)
         (arg2@@103 T@U)
         (arg3@@53 T@U)
         (arg4@@32 T@U))
  (! (= (type (Sequences.__default.ApplyOpaque
                arg0@@469
                arg1@@207
                arg2@@103
                arg3@@53
                arg4@@32))
        (SeqType BoxType))
     :pattern ((Sequences.__default.ApplyOpaque
                 arg0@@469
                 arg1@@207
                 arg2@@103
                 arg3@@53
                 arg4@@32))
     :qid |funType:Sequences.__default.ApplyOpaque|)))
(assert (forall ((Sequences._default.ApplyOpaque$E T@U)
         (Sequences._default.ApplyOpaque$R T@U)
         ($ly@@35 T@U)
         (|f#0@@80| T@U)
         (|run#0@@32| T@U))
  (! (=> (and (= (type Sequences._default.ApplyOpaque$E) TyType)
              (= (type Sequences._default.ApplyOpaque$R) TyType)
              (= (type $ly@@35) LayerTypeType)
              (= (type |f#0@@80|) HandleTypeType)
              (= (type |run#0@@32|) (SeqType BoxType)))
         (= (Sequences.__default.ApplyOpaque
              Sequences._default.ApplyOpaque$E
              Sequences._default.ApplyOpaque$R
              ($LS $ly@@35)
              |f#0@@80|
              |run#0@@32|)
            (Sequences.__default.ApplyOpaque
              Sequences._default.ApplyOpaque$E
              Sequences._default.ApplyOpaque$R
              $ly@@35
              |f#0@@80|
              |run#0@@32|)))
     :pattern ((Sequences.__default.ApplyOpaque
                 Sequences._default.ApplyOpaque$E
                 Sequences._default.ApplyOpaque$R
                 ($LS $ly@@35)
                 |f#0@@80|
                 |run#0@@32|))
     :skolemid |2294|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.ApplyOpaque$E@@0 T@U)
         (Sequences._default.ApplyOpaque$R@@0 T@U)
         ($ly@@36 T@U)
         (|f#0@@81| T@U)
         (|run#0@@33| T@U))
  (! (=> (and (= (type Sequences._default.ApplyOpaque$E@@0) TyType)
              (= (type Sequences._default.ApplyOpaque$R@@0) TyType)
              (= (type $ly@@36) LayerTypeType)
              (= (type |f#0@@81|) HandleTypeType)
              (= (type |run#0@@33|) (SeqType BoxType)))
         (= (Sequences.__default.ApplyOpaque
              Sequences._default.ApplyOpaque$E@@0
              Sequences._default.ApplyOpaque$R@@0
              $ly@@36
              |f#0@@81|
              |run#0@@33|)
            (Sequences.__default.ApplyOpaque
              Sequences._default.ApplyOpaque$E@@0
              Sequences._default.ApplyOpaque$R@@0
              $LZ
              |f#0@@81|
              |run#0@@33|)))
     :pattern ((Sequences.__default.ApplyOpaque
                 Sequences._default.ApplyOpaque$E@@0
                 Sequences._default.ApplyOpaque$R@@0
                 (AsFuelBottom $ly@@36)
                 |f#0@@81|
                 |run#0@@33|))
     :skolemid |2295|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.ApplyOpaque$E@@1 T@U)
                    (Sequences._default.ApplyOpaque$R@@1 T@U)
                    ($ly@@37 T@U)
                    ($Heap@@17 T@U)
                    (|f#0@@82| T@U)
                    (|run#0@@34| T@U))
             (! (let ((a!1 (or (|Sequences.__default.ApplyOpaque#canCall|
                                 Sequences._default.ApplyOpaque$E@@1
                                 Sequences._default.ApplyOpaque$R@@1
                                 |f#0@@82|
                                 |run#0@@34|)
                               (and ($IsGoodHeap $Heap@@17)
                                    ($Is |f#0@@82|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.ApplyOpaque$E@@1
                                           Sequences._default.ApplyOpaque$R@@1))
                                    ($Is |run#0@@34|
                                         (TSeq Sequences._default.ApplyOpaque$E@@1))
                                    (forall ((|i#0@@64| Int))
                                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                               0
                                                               |i#0@@64|)
                                                             (INTERNAL_lt_boogie
                                                               |i#0@@64|
                                                               (|Seq#Length| |run#0@@34|)))
                                                        (Requires1 Sequences._default.ApplyOpaque$E@@1
                                                                   Sequences._default.ApplyOpaque$R@@1
                                                                   $Heap@@17
                                                                   |f#0@@82|
                                                                   (|Seq#Index| |run#0@@34|
                                                                                |i#0@@64|)))))
                                           (=> true a!1))
                                         :pattern ((|Seq#Index| |run#0@@34|
                                                                |i#0@@64|))
                                         :skolemid |2296|
                                         :qid |Sequencesidfy.156:21|)))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.ApplyOpaque
                                                   Sequences._default.ApplyOpaque$E@@1
                                                   Sequences._default.ApplyOpaque$R@@1
                                                   $ly@@37
                                                   |f#0@@82|
                                                   |run#0@@34|))
                                   (|Seq#Length| |run#0@@34|))
                                (forall ((|i#1@@10| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#1@@10|)
                                                         (INTERNAL_lt_boogie
                                                           |i#1@@10|
                                                           (|Seq#Length| |run#0@@34|)))
                                                    (= (|Seq#Index| (Sequences.__default.ApplyOpaque
                                                                      Sequences._default.ApplyOpaque$E@@1
                                                                      Sequences._default.ApplyOpaque$R@@1
                                                                      $ly@@37
                                                                      |f#0@@82|
                                                                      |run#0@@34|)
                                                                    |i#1@@10|)
                                                       (Apply1 Sequences._default.ApplyOpaque$E@@1
                                                               Sequences._default.ApplyOpaque$R@@1
                                                               $Heap@@17
                                                               |f#0@@82|
                                                               (|Seq#Index| |run#0@@34|
                                                                            |i#1@@10|))))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| |run#0@@34|
                                                            |i#1@@10|))
                                     :pattern ((|Seq#Index| (Sequences.__default.ApplyOpaque
                                                              Sequences._default.ApplyOpaque$E@@1
                                                              Sequences._default.ApplyOpaque$R@@1
                                                              $ly@@37
                                                              |f#0@@82|
                                                              |run#0@@34|)
                                                            |i#1@@10|))
                                     :skolemid |2297|
                                     :qid |Sequencesidfy.158:20|))
                                ($Is (Sequences.__default.ApplyOpaque
                                       Sequences._default.ApplyOpaque$E@@1
                                       Sequences._default.ApplyOpaque$R@@1
                                       $ly@@37
                                       |f#0@@82|
                                       |run#0@@34|)
                                     (TSeq Sequences._default.ApplyOpaque$R@@1)))))
                  (=> (and (= (type Sequences._default.ApplyOpaque$E@@1) TyType)
                           (= (type Sequences._default.ApplyOpaque$R@@1) TyType)
                           (= (type $ly@@37) LayerTypeType)
                           (= (type $Heap@@17)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@82|) HandleTypeType)
                           (= (type |run#0@@34|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.ApplyOpaque
                            Sequences._default.ApplyOpaque$E@@1
                            Sequences._default.ApplyOpaque$R@@1
                            $ly@@37
                            |f#0@@82|
                            |run#0@@34|)
                          ($IsGoodHeap $Heap@@17))
                :skolemid |2298|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.ApplyOpaque$E@@2 T@U)
         (Sequences._default.ApplyOpaque$R@@2 T@U)
         ($ly@@38 T@U)
         ($Heap@@18 T@U)
         (|f#0@@83| T@U)
         (|run#0@@35| T@U))
  (! (=> (and (= (type Sequences._default.ApplyOpaque$E@@2) TyType)
              (= (type Sequences._default.ApplyOpaque$R@@2) TyType)
              (= (type $ly@@38) LayerTypeType)
              (= (type $Heap@@18) (MapType0Type refType MapType1Type))
              (= (type |f#0@@83|) HandleTypeType)
              (= (type |run#0@@35|) (SeqType BoxType))
              ($IsGoodHeap $Heap@@18)
              ($Is |f#0@@83|
                   (Tclass._System.___hPartialFunc1
                     Sequences._default.ApplyOpaque$E@@2
                     Sequences._default.ApplyOpaque$R@@2))
              ($Is |run#0@@35| (TSeq Sequences._default.ApplyOpaque$E@@2)))
         (= (|Sequences.__default.ApplyOpaque#requires|
              Sequences._default.ApplyOpaque$E@@2
              Sequences._default.ApplyOpaque$R@@2
              $ly@@38
              |f#0@@83|
              |run#0@@35|)
            (forall ((|i#2@@2| Int))
              (! (let ((a!1 (=> (and (INTERNAL_le_boogie 0 |i#2@@2|)
                                     (INTERNAL_lt_boogie
                                       |i#2@@2|
                                       (|Seq#Length| |run#0@@35|)))
                                (Requires1 Sequences._default.ApplyOpaque$E@@2
                                           Sequences._default.ApplyOpaque$R@@2
                                           $Heap@@18
                                           |f#0@@83|
                                           (|Seq#Index| |run#0@@35| |i#2@@2|)))))
                   (=> true a!1))
                 :pattern ((|Seq#Index| |run#0@@35| |i#2@@2|))
                 :skolemid |2299|
                 :qid |Sequencesidfy.156:21|))))
     :pattern ((|Sequences.__default.ApplyOpaque#requires|
                 Sequences._default.ApplyOpaque$E@@2
                 Sequences._default.ApplyOpaque$R@@2
                 $ly@@38
                 |f#0@@83|
                 |run#0@@35|)
               ($IsGoodHeap $Heap@@18))
     :skolemid |2300|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.ApplyOpaque$E@@3 T@U)
                    (Sequences._default.ApplyOpaque$R@@3 T@U)
                    ($ly@@39 T@U)
                    ($Heap@@19 T@U)
                    (|f#0@@84| T@U)
                    (|run#0@@36| T@U))
             (! (let ((a!1 (or (|Sequences.__default.ApplyOpaque#canCall|
                                 Sequences._default.ApplyOpaque$E@@3
                                 Sequences._default.ApplyOpaque$R@@3
                                 |f#0@@84|
                                 |run#0@@36|)
                               (and ($IsGoodHeap $Heap@@19)
                                    ($Is |f#0@@84|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.ApplyOpaque$E@@3
                                           Sequences._default.ApplyOpaque$R@@3))
                                    ($Is |run#0@@36|
                                         (TSeq Sequences._default.ApplyOpaque$E@@3))
                                    (forall ((|i#2@@3| Int))
                                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                               0
                                                               |i#2@@3|)
                                                             (INTERNAL_lt_boogie
                                                               |i#2@@3|
                                                               (|Seq#Length| |run#0@@36|)))
                                                        (Requires1 Sequences._default.ApplyOpaque$E@@3
                                                                   Sequences._default.ApplyOpaque$R@@3
                                                                   $Heap@@19
                                                                   |f#0@@84|
                                                                   (|Seq#Index| |run#0@@36|
                                                                                |i#2@@3|)))))
                                           (=> true a!1))
                                         :pattern ((|Seq#Index| |run#0@@36|
                                                                |i#2@@3|))
                                         :skolemid |2299|
                                         :qid |Sequencesidfy.156:21|)))))
                      (a!2 (and (|Sequences.__default.Apply#canCall|
                                  Sequences._default.ApplyOpaque$E@@3
                                  Sequences._default.ApplyOpaque$R@@3
                                  |f#0@@84|
                                  |run#0@@36|)
                                (= (Sequences.__default.ApplyOpaque
                                     Sequences._default.ApplyOpaque$E@@3
                                     Sequences._default.ApplyOpaque$R@@3
                                     ($LS $ly@@39)
                                     |f#0@@84|
                                     |run#0@@36|)
                                   (Sequences.__default.Apply
                                     Sequences._default.ApplyOpaque$E@@3
                                     Sequences._default.ApplyOpaque$R@@3
                                     |f#0@@84|
                                     |run#0@@36|)))))
                  (=> (and (= (type Sequences._default.ApplyOpaque$E@@3) TyType)
                           (= (type Sequences._default.ApplyOpaque$R@@3) TyType)
                           (= (type $ly@@39) LayerTypeType)
                           (= (type $Heap@@19)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@84|) HandleTypeType)
                           (= (type |run#0@@36|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.ApplyOpaque
                            Sequences._default.ApplyOpaque$E@@3
                            Sequences._default.ApplyOpaque$R@@3
                            ($LS $ly@@39)
                            |f#0@@84|
                            |run#0@@36|)
                          ($IsGoodHeap $Heap@@19))
                :skolemid |2301|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.ApplyOpaque$E@@4 T@U)
                    (Sequences._default.ApplyOpaque$R@@4 T@U)
                    ($ly@@40 T@U)
                    ($Heap@@20 T@U)
                    (|f#0@@85| T@U)
                    (|run#0@@37| T@U))
             (! (let ((a!1 (or (|Sequences.__default.ApplyOpaque#canCall|
                                 Sequences._default.ApplyOpaque$E@@4
                                 Sequences._default.ApplyOpaque$R@@4
                                 |f#0@@85|
                                 (Lit |run#0@@37|))
                               (and ($IsGoodHeap $Heap@@20)
                                    ($Is |f#0@@85|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.ApplyOpaque$E@@4
                                           Sequences._default.ApplyOpaque$R@@4))
                                    ($Is |run#0@@37|
                                         (TSeq Sequences._default.ApplyOpaque$E@@4))
                                    (forall ((|i#3| Int))
                                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                                           0
                                                           |i#3|)
                                                         (INTERNAL_lt_boogie
                                                           |i#3|
                                                           (|Seq#Length| (Lit |run#0@@37|))))))
                                         (let ((a!2 (=> a!1
                                                        (Requires1 Sequences._default.ApplyOpaque$E@@4
                                                                   Sequences._default.ApplyOpaque$R@@4
                                                                   $Heap@@20
                                                                   |f#0@@85|
                                                                   (|Seq#Index| (Lit |run#0@@37|)
                                                                                |i#3|)))))
                                           (=> true a!2)))
                                         :pattern ((|Seq#Index| |run#0@@37|
                                                                |i#3|))
                                         :skolemid |2302|
                                         :qid |Sequencesidfy.156:21|)))))
                      (a!2 (and (|Sequences.__default.Apply#canCall|
                                  Sequences._default.ApplyOpaque$E@@4
                                  Sequences._default.ApplyOpaque$R@@4
                                  |f#0@@85|
                                  (Lit |run#0@@37|))
                                (= (Sequences.__default.ApplyOpaque
                                     Sequences._default.ApplyOpaque$E@@4
                                     Sequences._default.ApplyOpaque$R@@4
                                     ($LS $ly@@40)
                                     |f#0@@85|
                                     (Lit |run#0@@37|))
                                   (Sequences.__default.Apply
                                     Sequences._default.ApplyOpaque$E@@4
                                     Sequences._default.ApplyOpaque$R@@4
                                     |f#0@@85|
                                     (Lit |run#0@@37|))))))
                  (=> (and (= (type Sequences._default.ApplyOpaque$E@@4) TyType)
                           (= (type Sequences._default.ApplyOpaque$R@@4) TyType)
                           (= (type $ly@@40) LayerTypeType)
                           (= (type $Heap@@20)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@85|) HandleTypeType)
                           (= (type |run#0@@37|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.ApplyOpaque
                            Sequences._default.ApplyOpaque$E@@4
                            Sequences._default.ApplyOpaque$R@@4
                            ($LS $ly@@40)
                            |f#0@@85|
                            (Lit |run#0@@37|))
                          ($IsGoodHeap $Heap@@20))
                :weight 3
                :skolemid |2303|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.ApplyOpaque$E@@5 T@U)
                    (Sequences._default.ApplyOpaque$R@@5 T@U)
                    ($ly@@41 T@U)
                    ($Heap@@21 T@U)
                    (|f#0@@86| T@U)
                    (|run#0@@38| T@U))
             (! (let ((a!1 (or (|Sequences.__default.ApplyOpaque#canCall|
                                 Sequences._default.ApplyOpaque$E@@5
                                 Sequences._default.ApplyOpaque$R@@5
                                 (Lit |f#0@@86|)
                                 (Lit |run#0@@38|))
                               (and ($IsGoodHeap $Heap@@21)
                                    ($Is |f#0@@86|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.ApplyOpaque$E@@5
                                           Sequences._default.ApplyOpaque$R@@5))
                                    ($Is |run#0@@38|
                                         (TSeq Sequences._default.ApplyOpaque$E@@5))
                                    (forall ((|i#4@@0| Int))
                                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                                           0
                                                           |i#4@@0|)
                                                         (INTERNAL_lt_boogie
                                                           |i#4@@0|
                                                           (|Seq#Length| (Lit |run#0@@38|))))))
                                         (let ((a!2 (=> a!1
                                                        (Requires1 Sequences._default.ApplyOpaque$E@@5
                                                                   Sequences._default.ApplyOpaque$R@@5
                                                                   $Heap@@21
                                                                   (Lit |f#0@@86|)
                                                                   (|Seq#Index| (Lit |run#0@@38|)
                                                                                |i#4@@0|)))))
                                           (=> true a!2)))
                                         :pattern ((|Seq#Index| |run#0@@38|
                                                                |i#4@@0|))
                                         :skolemid |2304|
                                         :qid |Sequencesidfy.156:21|)))))
                      (a!2 (= (Sequences.__default.ApplyOpaque
                                Sequences._default.ApplyOpaque$E@@5
                                Sequences._default.ApplyOpaque$R@@5
                                ($LS $ly@@41)
                                (Lit |f#0@@86|)
                                (Lit |run#0@@38|))
                              (Lit (Sequences.__default.Apply
                                     Sequences._default.ApplyOpaque$E@@5
                                     Sequences._default.ApplyOpaque$R@@5
                                     (Lit |f#0@@86|)
                                     (Lit |run#0@@38|))))))
                  (=> (and (= (type Sequences._default.ApplyOpaque$E@@5) TyType)
                           (= (type Sequences._default.ApplyOpaque$R@@5) TyType)
                           (= (type $ly@@41) LayerTypeType)
                           (= (type $Heap@@21)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@86|) HandleTypeType)
                           (= (type |run#0@@38|) (SeqType BoxType))
                           a!1)
                      (and (|Sequences.__default.Apply#canCall|
                             Sequences._default.ApplyOpaque$E@@5
                             Sequences._default.ApplyOpaque$R@@5
                             (Lit |f#0@@86|)
                             (Lit |run#0@@38|))
                           a!2)))
                :pattern ((Sequences.__default.ApplyOpaque
                            Sequences._default.ApplyOpaque$E@@5
                            Sequences._default.ApplyOpaque$R@@5
                            ($LS $ly@@41)
                            (Lit |f#0@@86|)
                            (Lit |run#0@@38|))
                          ($IsGoodHeap $Heap@@21))
                :weight 3
                :skolemid |2305|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@470 T@U) (arg1@@208 T@U) (arg2@@104 T@U) (arg3@@54 T@U))
  (! (= (type (Sequences.__default.Filter
                arg0@@470
                arg1@@208
                arg2@@104
                arg3@@54))
        (SeqType BoxType))
     :pattern ((Sequences.__default.Filter
                 arg0@@470
                 arg1@@208
                 arg2@@104
                 arg3@@54))
     :qid |funType:Sequences.__default.Filter|)))
(assert (forall ((Sequences._default.Filter$E T@U)
         ($ly@@42 T@U)
         (|f#0@@87| T@U)
         (|run#0@@39| T@U))
  (! (=> (and (= (type Sequences._default.Filter$E) TyType)
              (= (type $ly@@42) LayerTypeType)
              (= (type |f#0@@87|) HandleTypeType)
              (= (type |run#0@@39|) (SeqType BoxType)))
         (= (Sequences.__default.Filter
              Sequences._default.Filter$E
              ($LS $ly@@42)
              |f#0@@87|
              |run#0@@39|)
            (Sequences.__default.Filter
              Sequences._default.Filter$E
              $ly@@42
              |f#0@@87|
              |run#0@@39|)))
     :pattern ((Sequences.__default.Filter
                 Sequences._default.Filter$E
                 ($LS $ly@@42)
                 |f#0@@87|
                 |run#0@@39|))
     :skolemid |2306|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.Filter$E@@0 T@U)
         ($ly@@43 T@U)
         (|f#0@@88| T@U)
         (|run#0@@40| T@U))
  (! (=> (and (= (type Sequences._default.Filter$E@@0) TyType)
              (= (type $ly@@43) LayerTypeType)
              (= (type |f#0@@88|) HandleTypeType)
              (= (type |run#0@@40|) (SeqType BoxType)))
         (= (Sequences.__default.Filter
              Sequences._default.Filter$E@@0
              $ly@@43
              |f#0@@88|
              |run#0@@40|)
            (Sequences.__default.Filter
              Sequences._default.Filter$E@@0
              $LZ
              |f#0@@88|
              |run#0@@40|)))
     :pattern ((Sequences.__default.Filter
                 Sequences._default.Filter$E@@0
                 (AsFuelBottom $ly@@43)
                 |f#0@@88|
                 |run#0@@40|))
     :skolemid |2307|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Filter$E@@1 T@U)
                    ($ly@@44 T@U)
                    ($Heap@@22 T@U)
                    (|f#0@@89| T@U)
                    (|run#0@@41| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Filter#canCall|
                                 Sequences._default.Filter$E@@1
                                 |f#0@@89|
                                 |run#0@@41|)
                               (and ($IsGoodHeap $Heap@@22)
                                    ($Is |f#0@@89|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Filter$E@@1
                                           TBool))
                                    ($Is |run#0@@41|
                                         (TSeq Sequences._default.Filter$E@@1))
                                    (forall ((|i#0@@65| Int))
                                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                               0
                                                               |i#0@@65|)
                                                             (INTERNAL_lt_boogie
                                                               |i#0@@65|
                                                               (|Seq#Length| |run#0@@41|)))
                                                        (Requires1 Sequences._default.Filter$E@@1
                                                                   TBool
                                                                   $Heap@@22
                                                                   |f#0@@89|
                                                                   (|Seq#Index| |run#0@@41|
                                                                                |i#0@@65|)))))
                                           (=> true a!1))
                                         :pattern ((|Seq#Index| |run#0@@41|
                                                                |i#0@@65|))
                                         :skolemid |2308|
                                         :qid |Sequencesidfy.190:21|)))))
                      (a!2 (forall ((|i#1@@11| Int))
                             (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#1@@11|)
                                                (INTERNAL_lt_boogie
                                                  |i#1@@11|
                                                  (|Seq#Length| (Sequences.__default.Filter
                                                                  Sequences._default.Filter$E@@1
                                                                  $ly@@44
                                                                  |f#0@@89|
                                                                  |run#0@@41|))))))
                                  (=> a!1
                                      (|Seq#Contains| |run#0@@41|
                                                      (|Seq#Index| (Sequences.__default.Filter
                                                                     Sequences._default.Filter$E@@1
                                                                     $ly@@44
                                                                     |f#0@@89|
                                                                     |run#0@@41|)
                                                                   |i#1@@11|))))
                                :pattern ((|Seq#Index| (Sequences.__default.Filter
                                                         Sequences._default.Filter$E@@1
                                                         $ly@@44
                                                         |f#0@@89|
                                                         |run#0@@41|)
                                                       |i#1@@11|))
                                :skolemid |2309|
                                :qid |Sequencesidfy.192:20|)))
                      (a!3 (forall ((|i#3@@0| Int))
                             (! (let ((a!1 (U_2_bool ($Unbox boolType
                                                             (Apply1 Sequences._default.Filter$E@@1
                                                                     TBool
                                                                     $Heap@@22
                                                                     |f#0@@89|
                                                                     (|Seq#Index| |run#0@@41|
                                                                                  |i#3@@0|))))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#3@@0|)
                                           (INTERNAL_lt_boogie
                                             |i#3@@0|
                                             (|Seq#Length| |run#0@@41|))
                                           a!1)
                                      (|Seq#Contains| (Sequences.__default.Filter
                                                        Sequences._default.Filter$E@@1
                                                        $ly@@44
                                                        |f#0@@89|
                                                        |run#0@@41|)
                                                      (|Seq#Index| |run#0@@41|
                                                                   |i#3@@0|))))
                                :pattern ((|Seq#Index| |run#0@@41| |i#3@@0|))
                                :skolemid |2311|
                                :qid |Sequencesidfy.194:20|))))
                (let ((a!4 (and (INTERNAL_le_boogie
                                  (|Seq#Length| (Sequences.__default.Filter
                                                  Sequences._default.Filter$E@@1
                                                  $ly@@44
                                                  |f#0@@89|
                                                  |run#0@@41|))
                                  (|Seq#Length| |run#0@@41|))
                                a!2
                                (forall ((|i#2@@4| Int))
                                  (! (let ((a!1 (and (INTERNAL_le_boogie
                                                       0
                                                       |i#2@@4|)
                                                     (INTERNAL_lt_boogie
                                                       |i#2@@4|
                                                       (|Seq#Length| (Sequences.__default.Filter
                                                                       Sequences._default.Filter$E@@1
                                                                       $ly@@44
                                                                       |f#0@@89|
                                                                       |run#0@@41|)))))
                                           (a!2 ($Unbox boolType
                                                        (Apply1 Sequences._default.Filter$E@@1
                                                                TBool
                                                                $Heap@@22
                                                                |f#0@@89|
                                                                (|Seq#Index| (Sequences.__default.Filter
                                                                               Sequences._default.Filter$E@@1
                                                                               $ly@@44
                                                                               |f#0@@89|
                                                                               |run#0@@41|)
                                                                             |i#2@@4|)))))
                                       (=> a!1 (U_2_bool a!2)))
                                     :pattern ((|Seq#Index| (Sequences.__default.Filter
                                                              Sequences._default.Filter$E@@1
                                                              $ly@@44
                                                              |f#0@@89|
                                                              |run#0@@41|)
                                                            |i#2@@4|))
                                     :skolemid |2310|
                                     :qid |Sequencesidfy.193:20|))
                                a!3
                                ($Is (Sequences.__default.Filter
                                       Sequences._default.Filter$E@@1
                                       $ly@@44
                                       |f#0@@89|
                                       |run#0@@41|)
                                     (TSeq Sequences._default.Filter$E@@1)))))
                  (=> (and (= (type Sequences._default.Filter$E@@1) TyType)
                           (= (type $ly@@44) LayerTypeType)
                           (= (type $Heap@@22)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@89|) HandleTypeType)
                           (= (type |run#0@@41|) (SeqType BoxType))
                           a!1)
                      a!4)))
                :pattern ((Sequences.__default.Filter
                            Sequences._default.Filter$E@@1
                            $ly@@44
                            |f#0@@89|
                            |run#0@@41|)
                          ($IsGoodHeap $Heap@@22))
                :skolemid |2312|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.Filter$E@@2 T@U)
         ($ly@@45 T@U)
         ($Heap@@23 T@U)
         (|f#0@@90| T@U)
         (|run#0@@42| T@U))
  (! (=> (and (= (type Sequences._default.Filter$E@@2) TyType)
              (= (type $ly@@45) LayerTypeType)
              (= (type $Heap@@23) (MapType0Type refType MapType1Type))
              (= (type |f#0@@90|) HandleTypeType)
              (= (type |run#0@@42|) (SeqType BoxType))
              ($IsGoodHeap $Heap@@23)
              ($Is |f#0@@90|
                   (Tclass._System.___hPartialFunc1
                     Sequences._default.Filter$E@@2
                     TBool))
              ($Is |run#0@@42| (TSeq Sequences._default.Filter$E@@2)))
         (= (|Sequences.__default.Filter#requires|
              Sequences._default.Filter$E@@2
              $ly@@45
              |f#0@@90|
              |run#0@@42|)
            (forall ((|i#4@@1| Int))
              (! (let ((a!1 (=> (and (INTERNAL_le_boogie 0 |i#4@@1|)
                                     (INTERNAL_lt_boogie
                                       |i#4@@1|
                                       (|Seq#Length| |run#0@@42|)))
                                (Requires1 Sequences._default.Filter$E@@2
                                           TBool
                                           $Heap@@23
                                           |f#0@@90|
                                           (|Seq#Index| |run#0@@42| |i#4@@1|)))))
                   (=> true a!1))
                 :pattern ((|Seq#Index| |run#0@@42| |i#4@@1|))
                 :skolemid |2313|
                 :qid |Sequencesidfy.190:21|))))
     :pattern ((|Sequences.__default.Filter#requires|
                 Sequences._default.Filter$E@@2
                 $ly@@45
                 |f#0@@90|
                 |run#0@@42|)
               ($IsGoodHeap $Heap@@23))
     :skolemid |2314|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Filter$E@@3 T@U)
                    ($ly@@46 T@U)
                    ($Heap@@24 T@U)
                    (|f#0@@91| T@U)
                    (|run#0@@43| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Filter#canCall|
                                 Sequences._default.Filter$E@@3
                                 |f#0@@91|
                                 |run#0@@43|)
                               (and ($IsGoodHeap $Heap@@24)
                                    ($Is |f#0@@91|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Filter$E@@3
                                           TBool))
                                    ($Is |run#0@@43|
                                         (TSeq Sequences._default.Filter$E@@3))
                                    (forall ((|i#4@@2| Int))
                                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                               0
                                                               |i#4@@2|)
                                                             (INTERNAL_lt_boogie
                                                               |i#4@@2|
                                                               (|Seq#Length| |run#0@@43|)))
                                                        (Requires1 Sequences._default.Filter$E@@3
                                                                   TBool
                                                                   $Heap@@24
                                                                   |f#0@@91|
                                                                   (|Seq#Index| |run#0@@43|
                                                                                |i#4@@2|)))))
                                           (=> true a!1))
                                         :pattern ((|Seq#Index| |run#0@@43|
                                                                |i#4@@2|))
                                         :skolemid |2313|
                                         :qid |Sequencesidfy.190:21|)))))
                      (a!2 (U_2_bool ($Unbox boolType
                                             (Apply1 Sequences._default.Filter$E@@3
                                                     TBool
                                                     $Heap@@24
                                                     |f#0@@91|
                                                     (Sequences.__default.Last
                                                       Sequences._default.Filter$E@@3
                                                       |run#0@@43|)))))
                      (a!3 (and (|Sequences.__default.DropLast#canCall|
                                  Sequences._default.Filter$E@@3
                                  |run#0@@43|)
                                (|Sequences.__default.Filter#canCall|
                                  Sequences._default.Filter$E@@3
                                  |f#0@@91|
                                  (Sequences.__default.DropLast
                                    Sequences._default.Filter$E@@3
                                    |run#0@@43|)))))
                (let ((a!4 (and (|Sequences.__default.Last#canCall|
                                  Sequences._default.Filter$E@@3
                                  |run#0@@43|)
                                (=> a!2
                                    (and a!3
                                         (|Sequences.__default.Last#canCall|
                                           Sequences._default.Filter$E@@3
                                           |run#0@@43|)))
                                (=> (not a!2) a!3)))
                      (a!6 (ite a!2
                                (|Seq#Append| (Sequences.__default.Filter
                                                Sequences._default.Filter$E@@3
                                                $ly@@46
                                                |f#0@@91|
                                                (Sequences.__default.DropLast
                                                  Sequences._default.Filter$E@@3
                                                  |run#0@@43|))
                                              (|Seq#Build| (|Seq#Empty| BoxType)
                                                           (Sequences.__default.Last
                                                             Sequences._default.Filter$E@@3
                                                             |run#0@@43|)))
                                (Sequences.__default.Filter
                                  Sequences._default.Filter$E@@3
                                  $ly@@46
                                  |f#0@@91|
                                  (Sequences.__default.DropLast
                                    Sequences._default.Filter$E@@3
                                    |run#0@@43|)))))
                (let ((a!5 (=> (not (= (|Seq#Length| |run#0@@43|) (LitInt 0)))
                               a!4))
                      (a!7 (= (Sequences.__default.Filter
                                Sequences._default.Filter$E@@3
                                ($LS $ly@@46)
                                |f#0@@91|
                                |run#0@@43|)
                              (ite (= (|Seq#Length| |run#0@@43|) (LitInt 0))
                                   (|Seq#Empty| BoxType)
                                   a!6))))
                  (=> (and (= (type Sequences._default.Filter$E@@3) TyType)
                           (= (type $ly@@46) LayerTypeType)
                           (= (type $Heap@@24)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@91|) HandleTypeType)
                           (= (type |run#0@@43|) (SeqType BoxType))
                           a!1)
                      (and a!5 a!7)))))
                :pattern ((Sequences.__default.Filter
                            Sequences._default.Filter$E@@3
                            ($LS $ly@@46)
                            |f#0@@91|
                            |run#0@@43|)
                          ($IsGoodHeap $Heap@@24))
                :skolemid |2315|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.Filter$E@@4 T@U)
                    ($ly@@47 T@U)
                    ($Heap@@25 T@U)
                    (|f#0@@92| T@U)
                    (|run#0@@44| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Filter#canCall|
                                 Sequences._default.Filter$E@@4
                                 |f#0@@92|
                                 (Lit |run#0@@44|))
                               (and ($IsGoodHeap $Heap@@25)
                                    ($Is |f#0@@92|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Filter$E@@4
                                           TBool))
                                    ($Is |run#0@@44|
                                         (TSeq Sequences._default.Filter$E@@4))
                                    (forall ((|i#5| Int))
                                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                                           0
                                                           |i#5|)
                                                         (INTERNAL_lt_boogie
                                                           |i#5|
                                                           (|Seq#Length| (Lit |run#0@@44|))))))
                                         (let ((a!2 (=> a!1
                                                        (Requires1 Sequences._default.Filter$E@@4
                                                                   TBool
                                                                   $Heap@@25
                                                                   |f#0@@92|
                                                                   (|Seq#Index| (Lit |run#0@@44|)
                                                                                |i#5|)))))
                                           (=> true a!2)))
                                         :pattern ((|Seq#Index| |run#0@@44|
                                                                |i#5|))
                                         :skolemid |2316|
                                         :qid |Sequencesidfy.190:21|)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@44|)) (LitInt 0))))
                      (a!3 (Apply1 Sequences._default.Filter$E@@4
                                   TBool
                                   $Heap@@25
                                   |f#0@@92|
                                   (Lit (Sequences.__default.Last
                                          Sequences._default.Filter$E@@4
                                          (Lit |run#0@@44|)))))
                      (a!4 (|Sequences.__default.Filter#canCall|
                             Sequences._default.Filter$E@@4
                             |f#0@@92|
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.Filter$E@@4
                                    (Lit |run#0@@44|)))))
                      (a!8 (Sequences.__default.Filter
                             Sequences._default.Filter$E@@4
                             ($LS $ly@@47)
                             |f#0@@92|
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.Filter$E@@4
                                    (Lit |run#0@@44|)))))
                      (a!9 (|Seq#Build| (|Seq#Empty| BoxType)
                                        (Lit (Sequences.__default.Last
                                               Sequences._default.Filter$E@@4
                                               (Lit |run#0@@44|))))))
                (let ((a!5 (and (and (|Sequences.__default.DropLast#canCall|
                                       Sequences._default.Filter$E@@4
                                       (Lit |run#0@@44|))
                                     a!4)
                                (|Sequences.__default.Last#canCall|
                                  Sequences._default.Filter$E@@4
                                  (Lit |run#0@@44|))))
                      (a!6 (=> (not (U_2_bool ($Unbox boolType a!3)))
                               (and (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.Filter$E@@4
                                      (Lit |run#0@@44|))
                                    a!4)))
                      (a!10 (ite (= (|Seq#Length| (Lit |run#0@@44|)) (LitInt 0))
                                 (|Seq#Empty| BoxType)
                                 (ite (U_2_bool ($Unbox boolType a!3))
                                      (|Seq#Append| a!8 a!9)
                                      a!8))))
                (let ((a!7 (and (|Sequences.__default.Last#canCall|
                                  Sequences._default.Filter$E@@4
                                  (Lit |run#0@@44|))
                                (=> (U_2_bool ($Unbox boolType a!3)) a!5)
                                a!6)))
                (let ((a!11 (and (=> a!2 a!7)
                                 (= (Sequences.__default.Filter
                                      Sequences._default.Filter$E@@4
                                      ($LS $ly@@47)
                                      |f#0@@92|
                                      (Lit |run#0@@44|))
                                    a!10))))
                  (=> (and (= (type Sequences._default.Filter$E@@4) TyType)
                           (= (type $ly@@47) LayerTypeType)
                           (= (type $Heap@@25)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@92|) HandleTypeType)
                           (= (type |run#0@@44|) (SeqType BoxType))
                           a!1)
                      a!11)))))
                :pattern ((Sequences.__default.Filter
                            Sequences._default.Filter$E@@4
                            ($LS $ly@@47)
                            |f#0@@92|
                            (Lit |run#0@@44|))
                          ($IsGoodHeap $Heap@@25))
                :weight 3
                :skolemid |2317|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.Filter$E@@5 T@U)
                    ($ly@@48 T@U)
                    ($Heap@@26 T@U)
                    (|f#0@@93| T@U)
                    (|run#0@@45| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Filter#canCall|
                                 Sequences._default.Filter$E@@5
                                 (Lit |f#0@@93|)
                                 (Lit |run#0@@45|))
                               (and ($IsGoodHeap $Heap@@26)
                                    ($Is |f#0@@93|
                                         (Tclass._System.___hPartialFunc1
                                           Sequences._default.Filter$E@@5
                                           TBool))
                                    ($Is |run#0@@45|
                                         (TSeq Sequences._default.Filter$E@@5))
                                    (forall ((|i#6@@0| Int))
                                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                                           0
                                                           |i#6@@0|)
                                                         (INTERNAL_lt_boogie
                                                           |i#6@@0|
                                                           (|Seq#Length| (Lit |run#0@@45|))))))
                                         (let ((a!2 (=> a!1
                                                        (Requires1 Sequences._default.Filter$E@@5
                                                                   TBool
                                                                   $Heap@@26
                                                                   (Lit |f#0@@93|)
                                                                   (|Seq#Index| (Lit |run#0@@45|)
                                                                                |i#6@@0|)))))
                                           (=> true a!2)))
                                         :pattern ((|Seq#Index| |run#0@@45|
                                                                |i#6@@0|))
                                         :skolemid |2318|
                                         :qid |Sequencesidfy.190:21|)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@45|)) (LitInt 0))))
                      (a!3 (Apply1 Sequences._default.Filter$E@@5
                                   TBool
                                   $Heap@@26
                                   (Lit |f#0@@93|)
                                   (Lit (Sequences.__default.Last
                                          Sequences._default.Filter$E@@5
                                          (Lit |run#0@@45|)))))
                      (a!4 (|Sequences.__default.Filter#canCall|
                             Sequences._default.Filter$E@@5
                             (Lit |f#0@@93|)
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.Filter$E@@5
                                    (Lit |run#0@@45|)))))
                      (a!8 (Sequences.__default.Filter
                             Sequences._default.Filter$E@@5
                             ($LS $ly@@48)
                             (Lit |f#0@@93|)
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.Filter$E@@5
                                    (Lit |run#0@@45|)))))
                      (a!9 (|Seq#Build| (|Seq#Empty| BoxType)
                                        (Lit (Sequences.__default.Last
                                               Sequences._default.Filter$E@@5
                                               (Lit |run#0@@45|))))))
                (let ((a!5 (and (and (|Sequences.__default.DropLast#canCall|
                                       Sequences._default.Filter$E@@5
                                       (Lit |run#0@@45|))
                                     a!4)
                                (|Sequences.__default.Last#canCall|
                                  Sequences._default.Filter$E@@5
                                  (Lit |run#0@@45|))))
                      (a!6 (=> (not (U_2_bool ($Unbox boolType a!3)))
                               (and (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.Filter$E@@5
                                      (Lit |run#0@@45|))
                                    a!4)))
                      (a!10 (ite (= (|Seq#Length| (Lit |run#0@@45|)) (LitInt 0))
                                 (|Seq#Empty| BoxType)
                                 (ite (U_2_bool ($Unbox boolType a!3))
                                      (|Seq#Append| a!8 a!9)
                                      a!8))))
                (let ((a!7 (and (|Sequences.__default.Last#canCall|
                                  Sequences._default.Filter$E@@5
                                  (Lit |run#0@@45|))
                                (=> (U_2_bool ($Unbox boolType a!3)) a!5)
                                a!6)))
                (let ((a!11 (and (=> a!2 a!7)
                                 (= (Sequences.__default.Filter
                                      Sequences._default.Filter$E@@5
                                      ($LS $ly@@48)
                                      (Lit |f#0@@93|)
                                      (Lit |run#0@@45|))
                                    a!10))))
                  (=> (and (= (type Sequences._default.Filter$E@@5) TyType)
                           (= (type $ly@@48) LayerTypeType)
                           (= (type $Heap@@26)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@93|) HandleTypeType)
                           (= (type |run#0@@45|) (SeqType BoxType))
                           a!1)
                      a!11)))))
                :pattern ((Sequences.__default.Filter
                            Sequences._default.Filter$E@@5
                            ($LS $ly@@48)
                            (Lit |f#0@@93|)
                            (Lit |run#0@@45|))
                          ($IsGoodHeap $Heap@@26))
                :weight 3
                :skolemid |2319|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@471 T@U)
         (arg1@@209 T@U)
         (arg2@@105 T@U)
         (arg3@@55 T@U)
         (arg4@@33 T@U)
         (arg5@@17 T@U))
  (! (= (type (Sequences.__default.FoldLeft
                arg0@@471
                arg1@@209
                arg2@@105
                arg3@@55
                arg4@@33
                arg5@@17))
        BoxType)
     :pattern ((Sequences.__default.FoldLeft
                 arg0@@471
                 arg1@@209
                 arg2@@105
                 arg3@@55
                 arg4@@33
                 arg5@@17))
     :qid |funType:Sequences.__default.FoldLeft|)))
(assert (forall ((Sequences._default.FoldLeft$A T@U)
         (Sequences._default.FoldLeft$E T@U)
         ($ly@@49 T@U)
         (|f#0@@94| T@U)
         (|init#0| T@U)
         (|run#0@@46| T@U))
  (! (=> (and (= (type Sequences._default.FoldLeft$A) TyType)
              (= (type Sequences._default.FoldLeft$E) TyType)
              (= (type $ly@@49) LayerTypeType)
              (= (type |f#0@@94|) HandleTypeType)
              (= (type |init#0|) BoxType)
              (= (type |run#0@@46|) (SeqType BoxType)))
         (= (Sequences.__default.FoldLeft
              Sequences._default.FoldLeft$A
              Sequences._default.FoldLeft$E
              ($LS $ly@@49)
              |f#0@@94|
              |init#0|
              |run#0@@46|)
            (Sequences.__default.FoldLeft
              Sequences._default.FoldLeft$A
              Sequences._default.FoldLeft$E
              $ly@@49
              |f#0@@94|
              |init#0|
              |run#0@@46|)))
     :pattern ((Sequences.__default.FoldLeft
                 Sequences._default.FoldLeft$A
                 Sequences._default.FoldLeft$E
                 ($LS $ly@@49)
                 |f#0@@94|
                 |init#0|
                 |run#0@@46|))
     :skolemid |2320|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.FoldLeft$A@@0 T@U)
         (Sequences._default.FoldLeft$E@@0 T@U)
         ($ly@@50 T@U)
         (|f#0@@95| T@U)
         (|init#0@@0| T@U)
         (|run#0@@47| T@U))
  (! (=> (and (= (type Sequences._default.FoldLeft$A@@0) TyType)
              (= (type Sequences._default.FoldLeft$E@@0) TyType)
              (= (type $ly@@50) LayerTypeType)
              (= (type |f#0@@95|) HandleTypeType)
              (= (type |init#0@@0|) BoxType)
              (= (type |run#0@@47|) (SeqType BoxType)))
         (= (Sequences.__default.FoldLeft
              Sequences._default.FoldLeft$A@@0
              Sequences._default.FoldLeft$E@@0
              $ly@@50
              |f#0@@95|
              |init#0@@0|
              |run#0@@47|)
            (Sequences.__default.FoldLeft
              Sequences._default.FoldLeft$A@@0
              Sequences._default.FoldLeft$E@@0
              $LZ
              |f#0@@95|
              |init#0@@0|
              |run#0@@47|)))
     :pattern ((Sequences.__default.FoldLeft
                 Sequences._default.FoldLeft$A@@0
                 Sequences._default.FoldLeft$E@@0
                 (AsFuelBottom $ly@@50)
                 |f#0@@95|
                 |init#0@@0|
                 |run#0@@47|))
     :skolemid |2321|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FoldLeft$A@@1 T@U)
                    (Sequences._default.FoldLeft$E@@1 T@U)
                    ($ly@@51 T@U)
                    (|f#0@@96| T@U)
                    (|init#0@@1| T@U)
                    (|run#0@@48| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldLeft#canCall|
                                 Sequences._default.FoldLeft$A@@1
                                 Sequences._default.FoldLeft$E@@1
                                 |f#0@@96|
                                 |init#0@@1|
                                 |run#0@@48|)
                               (and ($Is |f#0@@96|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldLeft$A@@1
                                           Sequences._default.FoldLeft$E@@1
                                           Sequences._default.FoldLeft$A@@1))
                                    ($IsBox |init#0@@1|
                                            Sequences._default.FoldLeft$A@@1)
                                    ($Is |run#0@@48|
                                         (TSeq Sequences._default.FoldLeft$E@@1))))))
                  (=> (and (= (type Sequences._default.FoldLeft$A@@1) TyType)
                           (= (type Sequences._default.FoldLeft$E@@1) TyType)
                           (= (type $ly@@51) LayerTypeType)
                           (= (type |f#0@@96|) HandleTypeType)
                           (= (type |init#0@@1|) BoxType)
                           (= (type |run#0@@48|) (SeqType BoxType))
                           a!1)
                      ($IsBox (Sequences.__default.FoldLeft
                                Sequences._default.FoldLeft$A@@1
                                Sequences._default.FoldLeft$E@@1
                                $ly@@51
                                |f#0@@96|
                                |init#0@@1|
                                |run#0@@48|)
                              Sequences._default.FoldLeft$A@@1)))
                :pattern ((Sequences.__default.FoldLeft
                            Sequences._default.FoldLeft$A@@1
                            Sequences._default.FoldLeft$E@@1
                            $ly@@51
                            |f#0@@96|
                            |init#0@@1|
                            |run#0@@48|))
                :skolemid |2322|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.FoldLeft$A@@2 T@U)
         (Sequences._default.FoldLeft$E@@2 T@U)
         ($ly@@52 T@U)
         ($Heap@@27 T@U)
         (|f#0@@97| T@U)
         (|init#0@@2| T@U)
         (|run#0@@49| T@U))
  (! (=> (and (= (type Sequences._default.FoldLeft$A@@2) TyType)
              (= (type Sequences._default.FoldLeft$E@@2) TyType)
              (= (type $ly@@52) LayerTypeType)
              (= (type $Heap@@27) (MapType0Type refType MapType1Type))
              (= (type |f#0@@97|) HandleTypeType)
              (= (type |init#0@@2|) BoxType)
              (= (type |run#0@@49|) (SeqType BoxType))
              ($IsGoodHeap $Heap@@27)
              ($Is |f#0@@97|
                   (Tclass._System.___hTotalFunc2
                     Sequences._default.FoldLeft$A@@2
                     Sequences._default.FoldLeft$E@@2
                     Sequences._default.FoldLeft$A@@2))
              ($IsBox |init#0@@2| Sequences._default.FoldLeft$A@@2)
              ($Is |run#0@@49| (TSeq Sequences._default.FoldLeft$E@@2)))
         (= (|Sequences.__default.FoldLeft#requires|
              Sequences._default.FoldLeft$A@@2
              Sequences._default.FoldLeft$E@@2
              $ly@@52
              |f#0@@97|
              |init#0@@2|
              |run#0@@49|)
            true))
     :pattern ((|Sequences.__default.FoldLeft#requires|
                 Sequences._default.FoldLeft$A@@2
                 Sequences._default.FoldLeft$E@@2
                 $ly@@52
                 |f#0@@97|
                 |init#0@@2|
                 |run#0@@49|)
               ($IsGoodHeap $Heap@@27))
     :skolemid |2323|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FoldLeft$A@@3 T@U)
                    (Sequences._default.FoldLeft$E@@3 T@U)
                    ($ly@@53 T@U)
                    ($Heap@@28 T@U)
                    (|f#0@@98| T@U)
                    (|init#0@@3| T@U)
                    (|run#0@@50| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldLeft#canCall|
                                 Sequences._default.FoldLeft$A@@3
                                 Sequences._default.FoldLeft$E@@3
                                 |f#0@@98|
                                 |init#0@@3|
                                 |run#0@@50|)
                               (and ($IsGoodHeap $Heap@@28)
                                    ($Is |f#0@@98|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldLeft$A@@3
                                           Sequences._default.FoldLeft$E@@3
                                           Sequences._default.FoldLeft$A@@3))
                                    ($IsBox |init#0@@3|
                                            Sequences._default.FoldLeft$A@@3)
                                    ($Is |run#0@@50|
                                         (TSeq Sequences._default.FoldLeft$E@@3)))))
                      (a!2 (Apply2 Sequences._default.FoldLeft$A@@3
                                   Sequences._default.FoldLeft$E@@3
                                   Sequences._default.FoldLeft$A@@3
                                   $Heap@@28
                                   |f#0@@98|
                                   |init#0@@3|
                                   (|Seq#Index| |run#0@@50| (LitInt 0)))))
                (let ((a!3 (=> (not (= (|Seq#Length| |run#0@@50|) (LitInt 0)))
                               (|Sequences.__default.FoldLeft#canCall|
                                 Sequences._default.FoldLeft$A@@3
                                 Sequences._default.FoldLeft$E@@3
                                 |f#0@@98|
                                 a!2
                                 (|Seq#Drop| |run#0@@50| (LitInt 1)))))
                      (a!4 (ite (= (|Seq#Length| |run#0@@50|) (LitInt 0))
                                |init#0@@3|
                                (Sequences.__default.FoldLeft
                                  Sequences._default.FoldLeft$A@@3
                                  Sequences._default.FoldLeft$E@@3
                                  $ly@@53
                                  |f#0@@98|
                                  a!2
                                  (|Seq#Drop| |run#0@@50| (LitInt 1))))))
                (let ((a!5 (and a!3
                                (= (Sequences.__default.FoldLeft
                                     Sequences._default.FoldLeft$A@@3
                                     Sequences._default.FoldLeft$E@@3
                                     ($LS $ly@@53)
                                     |f#0@@98|
                                     |init#0@@3|
                                     |run#0@@50|)
                                   a!4))))
                  (=> (and (= (type Sequences._default.FoldLeft$A@@3) TyType)
                           (= (type Sequences._default.FoldLeft$E@@3) TyType)
                           (= (type $ly@@53) LayerTypeType)
                           (= (type $Heap@@28)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@98|) HandleTypeType)
                           (= (type |init#0@@3|) BoxType)
                           (= (type |run#0@@50|) (SeqType BoxType))
                           a!1)
                      a!5))))
                :pattern ((Sequences.__default.FoldLeft
                            Sequences._default.FoldLeft$A@@3
                            Sequences._default.FoldLeft$E@@3
                            ($LS $ly@@53)
                            |f#0@@98|
                            |init#0@@3|
                            |run#0@@50|)
                          ($IsGoodHeap $Heap@@28))
                :skolemid |2324|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FoldLeft$A@@4 T@U)
                    (Sequences._default.FoldLeft$E@@4 T@U)
                    ($ly@@54 T@U)
                    ($Heap@@29 T@U)
                    (|f#0@@99| T@U)
                    (|init#0@@4| T@U)
                    (|run#0@@51| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldLeft#canCall|
                                 Sequences._default.FoldLeft$A@@4
                                 Sequences._default.FoldLeft$E@@4
                                 |f#0@@99|
                                 |init#0@@4|
                                 (Lit |run#0@@51|))
                               (and ($IsGoodHeap $Heap@@29)
                                    ($Is |f#0@@99|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldLeft$A@@4
                                           Sequences._default.FoldLeft$E@@4
                                           Sequences._default.FoldLeft$A@@4))
                                    ($IsBox |init#0@@4|
                                            Sequences._default.FoldLeft$A@@4)
                                    ($Is |run#0@@51|
                                         (TSeq Sequences._default.FoldLeft$E@@4)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@51|)) (LitInt 0))))
                      (a!3 (Apply2 Sequences._default.FoldLeft$A@@4
                                   Sequences._default.FoldLeft$E@@4
                                   Sequences._default.FoldLeft$A@@4
                                   $Heap@@29
                                   |f#0@@99|
                                   |init#0@@4|
                                   (|Seq#Index| (Lit |run#0@@51|) (LitInt 0)))))
                (let ((a!4 (|Sequences.__default.FoldLeft#canCall|
                             Sequences._default.FoldLeft$A@@4
                             Sequences._default.FoldLeft$E@@4
                             |f#0@@99|
                             a!3
                             (Lit (|Seq#Drop| (Lit |run#0@@51|) (LitInt 1)))))
                      (a!5 (Sequences.__default.FoldLeft
                             Sequences._default.FoldLeft$A@@4
                             Sequences._default.FoldLeft$E@@4
                             ($LS $ly@@54)
                             |f#0@@99|
                             a!3
                             (Lit (|Seq#Drop| (Lit |run#0@@51|) (LitInt 1))))))
                (let ((a!6 (ite (= (|Seq#Length| (Lit |run#0@@51|)) (LitInt 0))
                                |init#0@@4|
                                a!5)))
                (let ((a!7 (and (=> a!2 a!4)
                                (= (Sequences.__default.FoldLeft
                                     Sequences._default.FoldLeft$A@@4
                                     Sequences._default.FoldLeft$E@@4
                                     ($LS $ly@@54)
                                     |f#0@@99|
                                     |init#0@@4|
                                     (Lit |run#0@@51|))
                                   a!6))))
                  (=> (and (= (type Sequences._default.FoldLeft$A@@4) TyType)
                           (= (type Sequences._default.FoldLeft$E@@4) TyType)
                           (= (type $ly@@54) LayerTypeType)
                           (= (type $Heap@@29)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@99|) HandleTypeType)
                           (= (type |init#0@@4|) BoxType)
                           (= (type |run#0@@51|) (SeqType BoxType))
                           a!1)
                      a!7)))))
                :pattern ((Sequences.__default.FoldLeft
                            Sequences._default.FoldLeft$A@@4
                            Sequences._default.FoldLeft$E@@4
                            ($LS $ly@@54)
                            |f#0@@99|
                            |init#0@@4|
                            (Lit |run#0@@51|))
                          ($IsGoodHeap $Heap@@29))
                :weight 3
                :skolemid |2325|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FoldLeft$A@@5 T@U)
                    (Sequences._default.FoldLeft$E@@5 T@U)
                    ($ly@@55 T@U)
                    ($Heap@@30 T@U)
                    (|f#0@@100| T@U)
                    (|init#0@@5| T@U)
                    (|run#0@@52| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldLeft#canCall|
                                 Sequences._default.FoldLeft$A@@5
                                 Sequences._default.FoldLeft$E@@5
                                 (Lit |f#0@@100|)
                                 (Lit |init#0@@5|)
                                 (Lit |run#0@@52|))
                               (and ($IsGoodHeap $Heap@@30)
                                    ($Is |f#0@@100|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldLeft$A@@5
                                           Sequences._default.FoldLeft$E@@5
                                           Sequences._default.FoldLeft$A@@5))
                                    ($IsBox |init#0@@5|
                                            Sequences._default.FoldLeft$A@@5)
                                    ($Is |run#0@@52|
                                         (TSeq Sequences._default.FoldLeft$E@@5)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@52|)) (LitInt 0))))
                      (a!3 (Apply2 Sequences._default.FoldLeft$A@@5
                                   Sequences._default.FoldLeft$E@@5
                                   Sequences._default.FoldLeft$A@@5
                                   $Heap@@30
                                   (Lit |f#0@@100|)
                                   (Lit |init#0@@5|)
                                   (|Seq#Index| (Lit |run#0@@52|) (LitInt 0)))))
                (let ((a!4 (|Sequences.__default.FoldLeft#canCall|
                             Sequences._default.FoldLeft$A@@5
                             Sequences._default.FoldLeft$E@@5
                             (Lit |f#0@@100|)
                             a!3
                             (Lit (|Seq#Drop| (Lit |run#0@@52|) (LitInt 1)))))
                      (a!5 (Sequences.__default.FoldLeft
                             Sequences._default.FoldLeft$A@@5
                             Sequences._default.FoldLeft$E@@5
                             ($LS $ly@@55)
                             (Lit |f#0@@100|)
                             a!3
                             (Lit (|Seq#Drop| (Lit |run#0@@52|) (LitInt 1))))))
                (let ((a!6 (ite (= (|Seq#Length| (Lit |run#0@@52|)) (LitInt 0))
                                |init#0@@5|
                                a!5)))
                (let ((a!7 (and (=> a!2 a!4)
                                (= (Sequences.__default.FoldLeft
                                     Sequences._default.FoldLeft$A@@5
                                     Sequences._default.FoldLeft$E@@5
                                     ($LS $ly@@55)
                                     (Lit |f#0@@100|)
                                     (Lit |init#0@@5|)
                                     (Lit |run#0@@52|))
                                   a!6))))
                  (=> (and (= (type Sequences._default.FoldLeft$A@@5) TyType)
                           (= (type Sequences._default.FoldLeft$E@@5) TyType)
                           (= (type $ly@@55) LayerTypeType)
                           (= (type $Heap@@30)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@100|) HandleTypeType)
                           (= (type |init#0@@5|) BoxType)
                           (= (type |run#0@@52|) (SeqType BoxType))
                           a!1)
                      a!7)))))
                :pattern ((Sequences.__default.FoldLeft
                            Sequences._default.FoldLeft$A@@5
                            Sequences._default.FoldLeft$E@@5
                            ($LS $ly@@55)
                            (Lit |f#0@@100|)
                            (Lit |init#0@@5|)
                            (Lit |run#0@@52|))
                          ($IsGoodHeap $Heap@@30))
                :weight 3
                :skolemid |2326|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@472 T@U)
         (arg1@@210 T@U)
         (arg2@@106 T@U)
         (arg3@@56 T@U)
         (arg4@@34 T@U)
         (arg5@@18 T@U))
  (! (= (type (Sequences.__default.FoldRight
                arg0@@472
                arg1@@210
                arg2@@106
                arg3@@56
                arg4@@34
                arg5@@18))
        BoxType)
     :pattern ((Sequences.__default.FoldRight
                 arg0@@472
                 arg1@@210
                 arg2@@106
                 arg3@@56
                 arg4@@34
                 arg5@@18))
     :qid |funType:Sequences.__default.FoldRight|)))
(assert (forall ((Sequences._default.FoldRight$A T@U)
         (Sequences._default.FoldRight$E T@U)
         ($ly@@56 T@U)
         (|f#0@@101| T@U)
         (|init#0@@6| T@U)
         (|run#0@@53| T@U))
  (! (=> (and (= (type Sequences._default.FoldRight$A) TyType)
              (= (type Sequences._default.FoldRight$E) TyType)
              (= (type $ly@@56) LayerTypeType)
              (= (type |f#0@@101|) HandleTypeType)
              (= (type |init#0@@6|) BoxType)
              (= (type |run#0@@53|) (SeqType BoxType)))
         (= (Sequences.__default.FoldRight
              Sequences._default.FoldRight$A
              Sequences._default.FoldRight$E
              ($LS $ly@@56)
              |f#0@@101|
              |init#0@@6|
              |run#0@@53|)
            (Sequences.__default.FoldRight
              Sequences._default.FoldRight$A
              Sequences._default.FoldRight$E
              $ly@@56
              |f#0@@101|
              |init#0@@6|
              |run#0@@53|)))
     :pattern ((Sequences.__default.FoldRight
                 Sequences._default.FoldRight$A
                 Sequences._default.FoldRight$E
                 ($LS $ly@@56)
                 |f#0@@101|
                 |init#0@@6|
                 |run#0@@53|))
     :skolemid |2327|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.FoldRight$A@@0 T@U)
         (Sequences._default.FoldRight$E@@0 T@U)
         ($ly@@57 T@U)
         (|f#0@@102| T@U)
         (|init#0@@7| T@U)
         (|run#0@@54| T@U))
  (! (=> (and (= (type Sequences._default.FoldRight$A@@0) TyType)
              (= (type Sequences._default.FoldRight$E@@0) TyType)
              (= (type $ly@@57) LayerTypeType)
              (= (type |f#0@@102|) HandleTypeType)
              (= (type |init#0@@7|) BoxType)
              (= (type |run#0@@54|) (SeqType BoxType)))
         (= (Sequences.__default.FoldRight
              Sequences._default.FoldRight$A@@0
              Sequences._default.FoldRight$E@@0
              $ly@@57
              |f#0@@102|
              |init#0@@7|
              |run#0@@54|)
            (Sequences.__default.FoldRight
              Sequences._default.FoldRight$A@@0
              Sequences._default.FoldRight$E@@0
              $LZ
              |f#0@@102|
              |init#0@@7|
              |run#0@@54|)))
     :pattern ((Sequences.__default.FoldRight
                 Sequences._default.FoldRight$A@@0
                 Sequences._default.FoldRight$E@@0
                 (AsFuelBottom $ly@@57)
                 |f#0@@102|
                 |init#0@@7|
                 |run#0@@54|))
     :skolemid |2328|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FoldRight$A@@1 T@U)
                    (Sequences._default.FoldRight$E@@1 T@U)
                    ($ly@@58 T@U)
                    (|f#0@@103| T@U)
                    (|init#0@@8| T@U)
                    (|run#0@@55| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldRight#canCall|
                                 Sequences._default.FoldRight$A@@1
                                 Sequences._default.FoldRight$E@@1
                                 |f#0@@103|
                                 |init#0@@8|
                                 |run#0@@55|)
                               (and ($Is |f#0@@103|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldRight$A@@1
                                           Sequences._default.FoldRight$E@@1
                                           Sequences._default.FoldRight$A@@1))
                                    ($IsBox |init#0@@8|
                                            Sequences._default.FoldRight$A@@1)
                                    ($Is |run#0@@55|
                                         (TSeq Sequences._default.FoldRight$E@@1))))))
                  (=> (and (= (type Sequences._default.FoldRight$A@@1) TyType)
                           (= (type Sequences._default.FoldRight$E@@1) TyType)
                           (= (type $ly@@58) LayerTypeType)
                           (= (type |f#0@@103|) HandleTypeType)
                           (= (type |init#0@@8|) BoxType)
                           (= (type |run#0@@55|) (SeqType BoxType))
                           a!1)
                      ($IsBox (Sequences.__default.FoldRight
                                Sequences._default.FoldRight$A@@1
                                Sequences._default.FoldRight$E@@1
                                $ly@@58
                                |f#0@@103|
                                |init#0@@8|
                                |run#0@@55|)
                              Sequences._default.FoldRight$A@@1)))
                :pattern ((Sequences.__default.FoldRight
                            Sequences._default.FoldRight$A@@1
                            Sequences._default.FoldRight$E@@1
                            $ly@@58
                            |f#0@@103|
                            |init#0@@8|
                            |run#0@@55|))
                :skolemid |2329|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.FoldRight$A@@2 T@U)
         (Sequences._default.FoldRight$E@@2 T@U)
         ($ly@@59 T@U)
         ($Heap@@31 T@U)
         (|f#0@@104| T@U)
         (|init#0@@9| T@U)
         (|run#0@@56| T@U))
  (! (=> (and (= (type Sequences._default.FoldRight$A@@2) TyType)
              (= (type Sequences._default.FoldRight$E@@2) TyType)
              (= (type $ly@@59) LayerTypeType)
              (= (type $Heap@@31) (MapType0Type refType MapType1Type))
              (= (type |f#0@@104|) HandleTypeType)
              (= (type |init#0@@9|) BoxType)
              (= (type |run#0@@56|) (SeqType BoxType))
              ($IsGoodHeap $Heap@@31)
              ($Is |f#0@@104|
                   (Tclass._System.___hTotalFunc2
                     Sequences._default.FoldRight$A@@2
                     Sequences._default.FoldRight$E@@2
                     Sequences._default.FoldRight$A@@2))
              ($IsBox |init#0@@9| Sequences._default.FoldRight$A@@2)
              ($Is |run#0@@56| (TSeq Sequences._default.FoldRight$E@@2)))
         (= (|Sequences.__default.FoldRight#requires|
              Sequences._default.FoldRight$A@@2
              Sequences._default.FoldRight$E@@2
              $ly@@59
              |f#0@@104|
              |init#0@@9|
              |run#0@@56|)
            true))
     :pattern ((|Sequences.__default.FoldRight#requires|
                 Sequences._default.FoldRight$A@@2
                 Sequences._default.FoldRight$E@@2
                 $ly@@59
                 |f#0@@104|
                 |init#0@@9|
                 |run#0@@56|)
               ($IsGoodHeap $Heap@@31))
     :skolemid |2330|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FoldRight$A@@3 T@U)
                    (Sequences._default.FoldRight$E@@3 T@U)
                    ($ly@@60 T@U)
                    ($Heap@@32 T@U)
                    (|f#0@@105| T@U)
                    (|init#0@@10| T@U)
                    (|run#0@@57| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldRight#canCall|
                                 Sequences._default.FoldRight$A@@3
                                 Sequences._default.FoldRight$E@@3
                                 |f#0@@105|
                                 |init#0@@10|
                                 |run#0@@57|)
                               (and ($IsGoodHeap $Heap@@32)
                                    ($Is |f#0@@105|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldRight$A@@3
                                           Sequences._default.FoldRight$E@@3
                                           Sequences._default.FoldRight$A@@3))
                                    ($IsBox |init#0@@10|
                                            Sequences._default.FoldRight$A@@3)
                                    ($Is |run#0@@57|
                                         (TSeq Sequences._default.FoldRight$E@@3)))))
                      (a!2 (=> (not (= (|Seq#Length| |run#0@@57|) (LitInt 0)))
                               (|Sequences.__default.FoldRight#canCall|
                                 Sequences._default.FoldRight$A@@3
                                 Sequences._default.FoldRight$E@@3
                                 |f#0@@105|
                                 |init#0@@10|
                                 (|Seq#Drop| |run#0@@57| (LitInt 1)))))
                      (a!3 (Apply2 Sequences._default.FoldRight$A@@3
                                   Sequences._default.FoldRight$E@@3
                                   Sequences._default.FoldRight$A@@3
                                   $Heap@@32
                                   |f#0@@105|
                                   (Sequences.__default.FoldRight
                                     Sequences._default.FoldRight$A@@3
                                     Sequences._default.FoldRight$E@@3
                                     $ly@@60
                                     |f#0@@105|
                                     |init#0@@10|
                                     (|Seq#Drop| |run#0@@57| (LitInt 1)))
                                   (|Seq#Index| |run#0@@57| (LitInt 0)))))
                (let ((a!4 (= (Sequences.__default.FoldRight
                                Sequences._default.FoldRight$A@@3
                                Sequences._default.FoldRight$E@@3
                                ($LS $ly@@60)
                                |f#0@@105|
                                |init#0@@10|
                                |run#0@@57|)
                              (ite (= (|Seq#Length| |run#0@@57|) (LitInt 0))
                                   |init#0@@10|
                                   a!3))))
                  (=> (and (= (type Sequences._default.FoldRight$A@@3) TyType)
                           (= (type Sequences._default.FoldRight$E@@3) TyType)
                           (= (type $ly@@60) LayerTypeType)
                           (= (type $Heap@@32)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@105|) HandleTypeType)
                           (= (type |init#0@@10|) BoxType)
                           (= (type |run#0@@57|) (SeqType BoxType))
                           a!1)
                      (and a!2 a!4))))
                :pattern ((Sequences.__default.FoldRight
                            Sequences._default.FoldRight$A@@3
                            Sequences._default.FoldRight$E@@3
                            ($LS $ly@@60)
                            |f#0@@105|
                            |init#0@@10|
                            |run#0@@57|)
                          ($IsGoodHeap $Heap@@32))
                :skolemid |2331|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FoldRight$A@@4 T@U)
                    (Sequences._default.FoldRight$E@@4 T@U)
                    ($ly@@61 T@U)
                    ($Heap@@33 T@U)
                    (|f#0@@106| T@U)
                    (|init#0@@11| T@U)
                    (|run#0@@58| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldRight#canCall|
                                 Sequences._default.FoldRight$A@@4
                                 Sequences._default.FoldRight$E@@4
                                 |f#0@@106|
                                 |init#0@@11|
                                 (Lit |run#0@@58|))
                               (and ($IsGoodHeap $Heap@@33)
                                    ($Is |f#0@@106|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldRight$A@@4
                                           Sequences._default.FoldRight$E@@4
                                           Sequences._default.FoldRight$A@@4))
                                    ($IsBox |init#0@@11|
                                            Sequences._default.FoldRight$A@@4)
                                    ($Is |run#0@@58|
                                         (TSeq Sequences._default.FoldRight$E@@4)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@58|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.FoldRight#canCall|
                             Sequences._default.FoldRight$A@@4
                             Sequences._default.FoldRight$E@@4
                             |f#0@@106|
                             |init#0@@11|
                             (Lit (|Seq#Drop| (Lit |run#0@@58|) (LitInt 1)))))
                      (a!4 (Sequences.__default.FoldRight
                             Sequences._default.FoldRight$A@@4
                             Sequences._default.FoldRight$E@@4
                             ($LS $ly@@61)
                             |f#0@@106|
                             |init#0@@11|
                             (Lit (|Seq#Drop| (Lit |run#0@@58|) (LitInt 1))))))
                (let ((a!5 (ite (= (|Seq#Length| (Lit |run#0@@58|)) (LitInt 0))
                                |init#0@@11|
                                (Apply2 Sequences._default.FoldRight$A@@4
                                        Sequences._default.FoldRight$E@@4
                                        Sequences._default.FoldRight$A@@4
                                        $Heap@@33
                                        |f#0@@106|
                                        a!4
                                        (|Seq#Index| (Lit |run#0@@58|)
                                                     (LitInt 0))))))
                (let ((a!6 (and (=> a!2 a!3)
                                (= (Sequences.__default.FoldRight
                                     Sequences._default.FoldRight$A@@4
                                     Sequences._default.FoldRight$E@@4
                                     ($LS $ly@@61)
                                     |f#0@@106|
                                     |init#0@@11|
                                     (Lit |run#0@@58|))
                                   a!5))))
                  (=> (and (= (type Sequences._default.FoldRight$A@@4) TyType)
                           (= (type Sequences._default.FoldRight$E@@4) TyType)
                           (= (type $ly@@61) LayerTypeType)
                           (= (type $Heap@@33)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@106|) HandleTypeType)
                           (= (type |init#0@@11|) BoxType)
                           (= (type |run#0@@58|) (SeqType BoxType))
                           a!1)
                      a!6))))
                :pattern ((Sequences.__default.FoldRight
                            Sequences._default.FoldRight$A@@4
                            Sequences._default.FoldRight$E@@4
                            ($LS $ly@@61)
                            |f#0@@106|
                            |init#0@@11|
                            (Lit |run#0@@58|))
                          ($IsGoodHeap $Heap@@33))
                :weight 3
                :skolemid |2332|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FoldRight$A@@5 T@U)
                    (Sequences._default.FoldRight$E@@5 T@U)
                    ($ly@@62 T@U)
                    ($Heap@@34 T@U)
                    (|f#0@@107| T@U)
                    (|init#0@@12| T@U)
                    (|run#0@@59| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldRight#canCall|
                                 Sequences._default.FoldRight$A@@5
                                 Sequences._default.FoldRight$E@@5
                                 (Lit |f#0@@107|)
                                 (Lit |init#0@@12|)
                                 (Lit |run#0@@59|))
                               (and ($IsGoodHeap $Heap@@34)
                                    ($Is |f#0@@107|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldRight$A@@5
                                           Sequences._default.FoldRight$E@@5
                                           Sequences._default.FoldRight$A@@5))
                                    ($IsBox |init#0@@12|
                                            Sequences._default.FoldRight$A@@5)
                                    ($Is |run#0@@59|
                                         (TSeq Sequences._default.FoldRight$E@@5)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@59|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.FoldRight#canCall|
                             Sequences._default.FoldRight$A@@5
                             Sequences._default.FoldRight$E@@5
                             (Lit |f#0@@107|)
                             (Lit |init#0@@12|)
                             (Lit (|Seq#Drop| (Lit |run#0@@59|) (LitInt 1)))))
                      (a!4 (Sequences.__default.FoldRight
                             Sequences._default.FoldRight$A@@5
                             Sequences._default.FoldRight$E@@5
                             ($LS $ly@@62)
                             (Lit |f#0@@107|)
                             (Lit |init#0@@12|)
                             (Lit (|Seq#Drop| (Lit |run#0@@59|) (LitInt 1))))))
                (let ((a!5 (ite (= (|Seq#Length| (Lit |run#0@@59|)) (LitInt 0))
                                |init#0@@12|
                                (Apply2 Sequences._default.FoldRight$A@@5
                                        Sequences._default.FoldRight$E@@5
                                        Sequences._default.FoldRight$A@@5
                                        $Heap@@34
                                        (Lit |f#0@@107|)
                                        (Lit a!4)
                                        (|Seq#Index| (Lit |run#0@@59|)
                                                     (LitInt 0))))))
                (let ((a!6 (and (=> a!2 a!3)
                                (= (Sequences.__default.FoldRight
                                     Sequences._default.FoldRight$A@@5
                                     Sequences._default.FoldRight$E@@5
                                     ($LS $ly@@62)
                                     (Lit |f#0@@107|)
                                     (Lit |init#0@@12|)
                                     (Lit |run#0@@59|))
                                   a!5))))
                  (=> (and (= (type Sequences._default.FoldRight$A@@5) TyType)
                           (= (type Sequences._default.FoldRight$E@@5) TyType)
                           (= (type $ly@@62) LayerTypeType)
                           (= (type $Heap@@34)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@107|) HandleTypeType)
                           (= (type |init#0@@12|) BoxType)
                           (= (type |run#0@@59|) (SeqType BoxType))
                           a!1)
                      a!6))))
                :pattern ((Sequences.__default.FoldRight
                            Sequences._default.FoldRight$A@@5
                            Sequences._default.FoldRight$E@@5
                            ($LS $ly@@62)
                            (Lit |f#0@@107|)
                            (Lit |init#0@@12|)
                            (Lit |run#0@@59|))
                          ($IsGoodHeap $Heap@@34))
                :weight 3
                :skolemid |2333|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@473 T@U)
         (arg1@@211 T@U)
         (arg2@@107 T@U)
         (arg3@@57 T@U)
         (arg4@@35 T@U)
         (arg5@@19 T@U))
  (! (= (type (Sequences.__default.FoldFromRight
                arg0@@473
                arg1@@211
                arg2@@107
                arg3@@57
                arg4@@35
                arg5@@19))
        BoxType)
     :pattern ((Sequences.__default.FoldFromRight
                 arg0@@473
                 arg1@@211
                 arg2@@107
                 arg3@@57
                 arg4@@35
                 arg5@@19))
     :qid |funType:Sequences.__default.FoldFromRight|)))
(assert (forall ((Sequences._default.FoldFromRight$A T@U)
         (Sequences._default.FoldFromRight$E T@U)
         ($ly@@63 T@U)
         (|f#0@@108| T@U)
         (|init#0@@13| T@U)
         (|run#0@@60| T@U))
  (! (=> (and (= (type Sequences._default.FoldFromRight$A) TyType)
              (= (type Sequences._default.FoldFromRight$E) TyType)
              (= (type $ly@@63) LayerTypeType)
              (= (type |f#0@@108|) HandleTypeType)
              (= (type |init#0@@13|) BoxType)
              (= (type |run#0@@60|) (SeqType BoxType)))
         (= (Sequences.__default.FoldFromRight
              Sequences._default.FoldFromRight$A
              Sequences._default.FoldFromRight$E
              ($LS $ly@@63)
              |f#0@@108|
              |init#0@@13|
              |run#0@@60|)
            (Sequences.__default.FoldFromRight
              Sequences._default.FoldFromRight$A
              Sequences._default.FoldFromRight$E
              $ly@@63
              |f#0@@108|
              |init#0@@13|
              |run#0@@60|)))
     :pattern ((Sequences.__default.FoldFromRight
                 Sequences._default.FoldFromRight$A
                 Sequences._default.FoldFromRight$E
                 ($LS $ly@@63)
                 |f#0@@108|
                 |init#0@@13|
                 |run#0@@60|))
     :skolemid |2334|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.FoldFromRight$A@@0 T@U)
         (Sequences._default.FoldFromRight$E@@0 T@U)
         ($ly@@64 T@U)
         (|f#0@@109| T@U)
         (|init#0@@14| T@U)
         (|run#0@@61| T@U))
  (! (=> (and (= (type Sequences._default.FoldFromRight$A@@0) TyType)
              (= (type Sequences._default.FoldFromRight$E@@0) TyType)
              (= (type $ly@@64) LayerTypeType)
              (= (type |f#0@@109|) HandleTypeType)
              (= (type |init#0@@14|) BoxType)
              (= (type |run#0@@61|) (SeqType BoxType)))
         (= (Sequences.__default.FoldFromRight
              Sequences._default.FoldFromRight$A@@0
              Sequences._default.FoldFromRight$E@@0
              $ly@@64
              |f#0@@109|
              |init#0@@14|
              |run#0@@61|)
            (Sequences.__default.FoldFromRight
              Sequences._default.FoldFromRight$A@@0
              Sequences._default.FoldFromRight$E@@0
              $LZ
              |f#0@@109|
              |init#0@@14|
              |run#0@@61|)))
     :pattern ((Sequences.__default.FoldFromRight
                 Sequences._default.FoldFromRight$A@@0
                 Sequences._default.FoldFromRight$E@@0
                 (AsFuelBottom $ly@@64)
                 |f#0@@109|
                 |init#0@@14|
                 |run#0@@61|))
     :skolemid |2335|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FoldFromRight$A@@1 T@U)
                    (Sequences._default.FoldFromRight$E@@1 T@U)
                    ($ly@@65 T@U)
                    (|f#0@@110| T@U)
                    (|init#0@@15| T@U)
                    (|run#0@@62| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldFromRight#canCall|
                                 Sequences._default.FoldFromRight$A@@1
                                 Sequences._default.FoldFromRight$E@@1
                                 |f#0@@110|
                                 |init#0@@15|
                                 |run#0@@62|)
                               (and ($Is |f#0@@110|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldFromRight$A@@1
                                           Sequences._default.FoldFromRight$E@@1
                                           Sequences._default.FoldFromRight$A@@1))
                                    ($IsBox |init#0@@15|
                                            Sequences._default.FoldFromRight$A@@1)
                                    ($Is |run#0@@62|
                                         (TSeq Sequences._default.FoldFromRight$E@@1))))))
                  (=> (and (= (type Sequences._default.FoldFromRight$A@@1)
                              TyType)
                           (= (type Sequences._default.FoldFromRight$E@@1)
                              TyType)
                           (= (type $ly@@65) LayerTypeType)
                           (= (type |f#0@@110|) HandleTypeType)
                           (= (type |init#0@@15|) BoxType)
                           (= (type |run#0@@62|) (SeqType BoxType))
                           a!1)
                      ($IsBox (Sequences.__default.FoldFromRight
                                Sequences._default.FoldFromRight$A@@1
                                Sequences._default.FoldFromRight$E@@1
                                $ly@@65
                                |f#0@@110|
                                |init#0@@15|
                                |run#0@@62|)
                              Sequences._default.FoldFromRight$A@@1)))
                :pattern ((Sequences.__default.FoldFromRight
                            Sequences._default.FoldFromRight$A@@1
                            Sequences._default.FoldFromRight$E@@1
                            $ly@@65
                            |f#0@@110|
                            |init#0@@15|
                            |run#0@@62|))
                :skolemid |2336|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.FoldFromRight$A@@2 T@U)
         (Sequences._default.FoldFromRight$E@@2 T@U)
         ($ly@@66 T@U)
         ($Heap@@35 T@U)
         (|f#0@@111| T@U)
         (|init#0@@16| T@U)
         (|run#0@@63| T@U))
  (! (=> (and (= (type Sequences._default.FoldFromRight$A@@2) TyType)
              (= (type Sequences._default.FoldFromRight$E@@2) TyType)
              (= (type $ly@@66) LayerTypeType)
              (= (type $Heap@@35) (MapType0Type refType MapType1Type))
              (= (type |f#0@@111|) HandleTypeType)
              (= (type |init#0@@16|) BoxType)
              (= (type |run#0@@63|) (SeqType BoxType))
              ($IsGoodHeap $Heap@@35)
              ($Is |f#0@@111|
                   (Tclass._System.___hTotalFunc2
                     Sequences._default.FoldFromRight$A@@2
                     Sequences._default.FoldFromRight$E@@2
                     Sequences._default.FoldFromRight$A@@2))
              ($IsBox |init#0@@16| Sequences._default.FoldFromRight$A@@2)
              ($Is |run#0@@63| (TSeq Sequences._default.FoldFromRight$E@@2)))
         (= (|Sequences.__default.FoldFromRight#requires|
              Sequences._default.FoldFromRight$A@@2
              Sequences._default.FoldFromRight$E@@2
              $ly@@66
              |f#0@@111|
              |init#0@@16|
              |run#0@@63|)
            true))
     :pattern ((|Sequences.__default.FoldFromRight#requires|
                 Sequences._default.FoldFromRight$A@@2
                 Sequences._default.FoldFromRight$E@@2
                 $ly@@66
                 |f#0@@111|
                 |init#0@@16|
                 |run#0@@63|)
               ($IsGoodHeap $Heap@@35))
     :skolemid |2337|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FoldFromRight$A@@3 T@U)
                    (Sequences._default.FoldFromRight$E@@3 T@U)
                    ($ly@@67 T@U)
                    ($Heap@@36 T@U)
                    (|f#0@@112| T@U)
                    (|init#0@@17| T@U)
                    (|run#0@@64| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldFromRight#canCall|
                                 Sequences._default.FoldFromRight$A@@3
                                 Sequences._default.FoldFromRight$E@@3
                                 |f#0@@112|
                                 |init#0@@17|
                                 |run#0@@64|)
                               (and ($IsGoodHeap $Heap@@36)
                                    ($Is |f#0@@112|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldFromRight$A@@3
                                           Sequences._default.FoldFromRight$E@@3
                                           Sequences._default.FoldFromRight$A@@3))
                                    ($IsBox |init#0@@17|
                                            Sequences._default.FoldFromRight$A@@3)
                                    ($Is |run#0@@64|
                                         (TSeq Sequences._default.FoldFromRight$E@@3)))))
                      (a!2 (=> (not (= (|Seq#Length| |run#0@@64|) (LitInt 0)))
                               (and (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.FoldFromRight$E@@3
                                      |run#0@@64|)
                                    (|Sequences.__default.FoldFromRight#canCall|
                                      Sequences._default.FoldFromRight$A@@3
                                      Sequences._default.FoldFromRight$E@@3
                                      |f#0@@112|
                                      |init#0@@17|
                                      (Sequences.__default.DropLast
                                        Sequences._default.FoldFromRight$E@@3
                                        |run#0@@64|))
                                    (|Sequences.__default.Last#canCall|
                                      Sequences._default.FoldFromRight$E@@3
                                      |run#0@@64|))))
                      (a!3 (ite (= (|Seq#Length| |run#0@@64|) (LitInt 0))
                                |init#0@@17|
                                (Apply2 Sequences._default.FoldFromRight$A@@3
                                        Sequences._default.FoldFromRight$E@@3
                                        Sequences._default.FoldFromRight$A@@3
                                        $Heap@@36
                                        |f#0@@112|
                                        (Sequences.__default.FoldFromRight
                                          Sequences._default.FoldFromRight$A@@3
                                          Sequences._default.FoldFromRight$E@@3
                                          $ly@@67
                                          |f#0@@112|
                                          |init#0@@17|
                                          (Sequences.__default.DropLast
                                            Sequences._default.FoldFromRight$E@@3
                                            |run#0@@64|))
                                        (Sequences.__default.Last
                                          Sequences._default.FoldFromRight$E@@3
                                          |run#0@@64|)))))
                (let ((a!4 (and a!2
                                (= (Sequences.__default.FoldFromRight
                                     Sequences._default.FoldFromRight$A@@3
                                     Sequences._default.FoldFromRight$E@@3
                                     ($LS $ly@@67)
                                     |f#0@@112|
                                     |init#0@@17|
                                     |run#0@@64|)
                                   a!3))))
                  (=> (and (= (type Sequences._default.FoldFromRight$A@@3)
                              TyType)
                           (= (type Sequences._default.FoldFromRight$E@@3)
                              TyType)
                           (= (type $ly@@67) LayerTypeType)
                           (= (type $Heap@@36)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@112|) HandleTypeType)
                           (= (type |init#0@@17|) BoxType)
                           (= (type |run#0@@64|) (SeqType BoxType))
                           a!1)
                      a!4)))
                :pattern ((Sequences.__default.FoldFromRight
                            Sequences._default.FoldFromRight$A@@3
                            Sequences._default.FoldFromRight$E@@3
                            ($LS $ly@@67)
                            |f#0@@112|
                            |init#0@@17|
                            |run#0@@64|)
                          ($IsGoodHeap $Heap@@36))
                :skolemid |2338|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FoldFromRight$A@@4 T@U)
                    (Sequences._default.FoldFromRight$E@@4 T@U)
                    ($ly@@68 T@U)
                    ($Heap@@37 T@U)
                    (|f#0@@113| T@U)
                    (|init#0@@18| T@U)
                    (|run#0@@65| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldFromRight#canCall|
                                 Sequences._default.FoldFromRight$A@@4
                                 Sequences._default.FoldFromRight$E@@4
                                 |f#0@@113|
                                 |init#0@@18|
                                 (Lit |run#0@@65|))
                               (and ($IsGoodHeap $Heap@@37)
                                    ($Is |f#0@@113|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldFromRight$A@@4
                                           Sequences._default.FoldFromRight$E@@4
                                           Sequences._default.FoldFromRight$A@@4))
                                    ($IsBox |init#0@@18|
                                            Sequences._default.FoldFromRight$A@@4)
                                    ($Is |run#0@@65|
                                         (TSeq Sequences._default.FoldFromRight$E@@4)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@65|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.FoldFromRight#canCall|
                             Sequences._default.FoldFromRight$A@@4
                             Sequences._default.FoldFromRight$E@@4
                             |f#0@@113|
                             |init#0@@18|
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.FoldFromRight$E@@4
                                    (Lit |run#0@@65|)))))
                      (a!5 (Sequences.__default.FoldFromRight
                             Sequences._default.FoldFromRight$A@@4
                             Sequences._default.FoldFromRight$E@@4
                             ($LS $ly@@68)
                             |f#0@@113|
                             |init#0@@18|
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.FoldFromRight$E@@4
                                    (Lit |run#0@@65|))))))
                (let ((a!4 (=> a!2
                               (and (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.FoldFromRight$E@@4
                                      (Lit |run#0@@65|))
                                    a!3
                                    (|Sequences.__default.Last#canCall|
                                      Sequences._default.FoldFromRight$E@@4
                                      (Lit |run#0@@65|)))))
                      (a!6 (Apply2 Sequences._default.FoldFromRight$A@@4
                                   Sequences._default.FoldFromRight$E@@4
                                   Sequences._default.FoldFromRight$A@@4
                                   $Heap@@37
                                   |f#0@@113|
                                   a!5
                                   (Lit (Sequences.__default.Last
                                          Sequences._default.FoldFromRight$E@@4
                                          (Lit |run#0@@65|))))))
                (let ((a!7 (ite (= (|Seq#Length| (Lit |run#0@@65|)) (LitInt 0))
                                |init#0@@18|
                                a!6)))
                (let ((a!8 (and a!4
                                (= (Sequences.__default.FoldFromRight
                                     Sequences._default.FoldFromRight$A@@4
                                     Sequences._default.FoldFromRight$E@@4
                                     ($LS $ly@@68)
                                     |f#0@@113|
                                     |init#0@@18|
                                     (Lit |run#0@@65|))
                                   a!7))))
                  (=> (and (= (type Sequences._default.FoldFromRight$A@@4)
                              TyType)
                           (= (type Sequences._default.FoldFromRight$E@@4)
                              TyType)
                           (= (type $ly@@68) LayerTypeType)
                           (= (type $Heap@@37)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@113|) HandleTypeType)
                           (= (type |init#0@@18|) BoxType)
                           (= (type |run#0@@65|) (SeqType BoxType))
                           a!1)
                      a!8)))))
                :pattern ((Sequences.__default.FoldFromRight
                            Sequences._default.FoldFromRight$A@@4
                            Sequences._default.FoldFromRight$E@@4
                            ($LS $ly@@68)
                            |f#0@@113|
                            |init#0@@18|
                            (Lit |run#0@@65|))
                          ($IsGoodHeap $Heap@@37))
                :weight 3
                :skolemid |2339|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FoldFromRight$A@@5 T@U)
                    (Sequences._default.FoldFromRight$E@@5 T@U)
                    ($ly@@69 T@U)
                    ($Heap@@38 T@U)
                    (|f#0@@114| T@U)
                    (|init#0@@19| T@U)
                    (|run#0@@66| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldFromRight#canCall|
                                 Sequences._default.FoldFromRight$A@@5
                                 Sequences._default.FoldFromRight$E@@5
                                 (Lit |f#0@@114|)
                                 (Lit |init#0@@19|)
                                 (Lit |run#0@@66|))
                               (and ($IsGoodHeap $Heap@@38)
                                    ($Is |f#0@@114|
                                         (Tclass._System.___hTotalFunc2
                                           Sequences._default.FoldFromRight$A@@5
                                           Sequences._default.FoldFromRight$E@@5
                                           Sequences._default.FoldFromRight$A@@5))
                                    ($IsBox |init#0@@19|
                                            Sequences._default.FoldFromRight$A@@5)
                                    ($Is |run#0@@66|
                                         (TSeq Sequences._default.FoldFromRight$E@@5)))))
                      (a!2 (not (= (|Seq#Length| (Lit |run#0@@66|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.FoldFromRight#canCall|
                             Sequences._default.FoldFromRight$A@@5
                             Sequences._default.FoldFromRight$E@@5
                             (Lit |f#0@@114|)
                             (Lit |init#0@@19|)
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.FoldFromRight$E@@5
                                    (Lit |run#0@@66|)))))
                      (a!5 (Sequences.__default.FoldFromRight
                             Sequences._default.FoldFromRight$A@@5
                             Sequences._default.FoldFromRight$E@@5
                             ($LS $ly@@69)
                             (Lit |f#0@@114|)
                             (Lit |init#0@@19|)
                             (Lit (Sequences.__default.DropLast
                                    Sequences._default.FoldFromRight$E@@5
                                    (Lit |run#0@@66|))))))
                (let ((a!4 (=> a!2
                               (and (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.FoldFromRight$E@@5
                                      (Lit |run#0@@66|))
                                    a!3
                                    (|Sequences.__default.Last#canCall|
                                      Sequences._default.FoldFromRight$E@@5
                                      (Lit |run#0@@66|)))))
                      (a!6 (Apply2 Sequences._default.FoldFromRight$A@@5
                                   Sequences._default.FoldFromRight$E@@5
                                   Sequences._default.FoldFromRight$A@@5
                                   $Heap@@38
                                   (Lit |f#0@@114|)
                                   (Lit a!5)
                                   (Lit (Sequences.__default.Last
                                          Sequences._default.FoldFromRight$E@@5
                                          (Lit |run#0@@66|))))))
                (let ((a!7 (ite (= (|Seq#Length| (Lit |run#0@@66|)) (LitInt 0))
                                |init#0@@19|
                                a!6)))
                (let ((a!8 (and a!4
                                (= (Sequences.__default.FoldFromRight
                                     Sequences._default.FoldFromRight$A@@5
                                     Sequences._default.FoldFromRight$E@@5
                                     ($LS $ly@@69)
                                     (Lit |f#0@@114|)
                                     (Lit |init#0@@19|)
                                     (Lit |run#0@@66|))
                                   a!7))))
                  (=> (and (= (type Sequences._default.FoldFromRight$A@@5)
                              TyType)
                           (= (type Sequences._default.FoldFromRight$E@@5)
                              TyType)
                           (= (type $ly@@69) LayerTypeType)
                           (= (type $Heap@@38)
                              (MapType0Type refType MapType1Type))
                           (= (type |f#0@@114|) HandleTypeType)
                           (= (type |init#0@@19|) BoxType)
                           (= (type |run#0@@66|) (SeqType BoxType))
                           a!1)
                      a!8)))))
                :pattern ((Sequences.__default.FoldFromRight
                            Sequences._default.FoldFromRight$A@@5
                            Sequences._default.FoldFromRight$E@@5
                            ($LS $ly@@69)
                            (Lit |f#0@@114|)
                            (Lit |init#0@@19|)
                            (Lit |run#0@@66|))
                          ($IsGoodHeap $Heap@@38))
                :weight 3
                :skolemid |2340|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@474 T@U) (arg1@@212 T@U))
  (! (= (type (Sequences.__default.FoldSets arg0@@474 arg1@@212))
        (MapType0Type BoxType boolType))
     :pattern ((Sequences.__default.FoldSets arg0@@474 arg1@@212))
     :qid |funType:Sequences.__default.FoldSets|)))
(assert (let ((a!1 (forall ((Sequences._default.FoldSets$E T@U) (|run#0@@67| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldSets#canCall|
                                 Sequences._default.FoldSets$E
                                 |run#0@@67|)
                               ($Is |run#0@@67|
                                    (TSeq (TSet Sequences._default.FoldSets$E))))))
                  (=> (and (= (type Sequences._default.FoldSets$E) TyType)
                           (= (type |run#0@@67|) (SeqType BoxType))
                           a!1)
                      ($Is (Sequences.__default.FoldSets
                             Sequences._default.FoldSets$E
                             |run#0@@67|)
                           (TSet Sequences._default.FoldSets$E))))
                :pattern ((Sequences.__default.FoldSets
                            Sequences._default.FoldSets$E
                            |run#0@@67|))
                :skolemid |2341|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.FoldSets$E@@0 T@U) (|run#0@@68| T@U))
  (! (let ((a!1 (and (= (type Sequences._default.FoldSets$E@@0) TyType)
                     (= (type |run#0@@68|) (SeqType BoxType))
                     ($Is |run#0@@68|
                          (TSeq (TSet Sequences._default.FoldSets$E@@0))))))
       (=> a!1
           (= (|Sequences.__default.FoldSets#requires|
                Sequences._default.FoldSets$E@@0
                |run#0@@68|)
              true)))
     :pattern ((|Sequences.__default.FoldSets#requires|
                 Sequences._default.FoldSets$E@@0
                 |run#0@@68|))
     :skolemid |2342|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@475 T@U) (arg1@@213 T@U))
             (! (= (type (|lambda#128| arg0@@475 arg1@@213))
                   (MapType3Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 BoxType
                                 boolType))
                :pattern ((|lambda#128| arg0@@475 arg1@@213))
                :qid |funType:lambda#128|)))
      (a!2 (forall ((arg0@@476 T@U))
             (! (= (type (|lambda#130| arg0@@476))
                   (MapType3Type (MapType0Type refType MapType1Type)
                                 BoxType
                                 BoxType
                                 (MapType0Type BoxType boolType)))
                :pattern ((|lambda#130| arg0@@476))
                :qid |funType:lambda#130|))))
  (and (= (type |lambda#127|)
          (MapType3Type (MapType0Type refType MapType1Type)
                        BoxType
                        BoxType
                        BoxType))
       a!1
       a!2)))
(assert (let ((a!1 (forall ((Sequences._default.FoldSets$E@@1 T@U) (|run#0@@69| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldSets#canCall|
                                 Sequences._default.FoldSets$E@@1
                                 |run#0@@69|)
                               ($Is |run#0@@69|
                                    (TSeq (TSet Sequences._default.FoldSets$E@@1)))))
                      (a!2 (Handle2 |lambda#127|
                                    (|lambda#128| (TSet Sequences._default.FoldSets$E@@1)
                                                  (TSet Sequences._default.FoldSets$E@@1))
                                    (|lambda#130| (SetRef_to_SetBox (|lambda#92| false))))))
                (let ((a!3 (|Sequences.__default.FoldRight#canCall|
                             (TSet Sequences._default.FoldSets$E@@1)
                             (TSet Sequences._default.FoldSets$E@@1)
                             (Lit (AtLayer (|lambda#94| a!2) ($LS $LZ)))
                             ($Box (Lit (|Set#Empty| BoxType)))
                             |run#0@@69|))
                      (a!4 (Sequences.__default.FoldRight
                             (TSet Sequences._default.FoldSets$E@@1)
                             (TSet Sequences._default.FoldSets$E@@1)
                             ($LS $LZ)
                             (Lit (AtLayer (|lambda#94| a!2) ($LS $LZ)))
                             ($Box (Lit (|Set#Empty| BoxType)))
                             |run#0@@69|)))
                (let ((a!5 (and a!3
                                (= (Sequences.__default.FoldSets
                                     Sequences._default.FoldSets$E@@1
                                     |run#0@@69|)
                                   ($Unbox (MapType0Type BoxType boolType) a!4)))))
                  (=> (and (= (type Sequences._default.FoldSets$E@@1) TyType)
                           (= (type |run#0@@69|) (SeqType BoxType))
                           a!1)
                      a!5))))
                :pattern ((Sequences.__default.FoldSets
                            Sequences._default.FoldSets$E@@1
                            |run#0@@69|))
                :skolemid |2343|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FoldSets$E@@2 T@U) (|run#0@@70| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FoldSets#canCall|
                                 Sequences._default.FoldSets$E@@2
                                 (Lit |run#0@@70|))
                               ($Is |run#0@@70|
                                    (TSeq (TSet Sequences._default.FoldSets$E@@2)))))
                      (a!2 (Handle2 |lambda#127|
                                    (|lambda#128| (TSet Sequences._default.FoldSets$E@@2)
                                                  (TSet Sequences._default.FoldSets$E@@2))
                                    (|lambda#130| (SetRef_to_SetBox (|lambda#92| false))))))
                (let ((a!3 (|Sequences.__default.FoldRight#canCall|
                             (TSet Sequences._default.FoldSets$E@@2)
                             (TSet Sequences._default.FoldSets$E@@2)
                             (Lit (AtLayer (|lambda#94| a!2) ($LS $LZ)))
                             ($Box (Lit (|Set#Empty| BoxType)))
                             (Lit |run#0@@70|)))
                      (a!4 (Sequences.__default.FoldRight
                             (TSet Sequences._default.FoldSets$E@@2)
                             (TSet Sequences._default.FoldSets$E@@2)
                             ($LS $LZ)
                             (Lit (AtLayer (|lambda#94| a!2) ($LS $LZ)))
                             ($Box (Lit (|Set#Empty| BoxType)))
                             (Lit |run#0@@70|))))
                (let ((a!5 (= (Sequences.__default.FoldSets
                                Sequences._default.FoldSets$E@@2
                                (Lit |run#0@@70|))
                              (Lit ($Unbox (MapType0Type BoxType boolType) a!4)))))
                  (=> (and (= (type Sequences._default.FoldSets$E@@2) TyType)
                           (= (type |run#0@@70|) (SeqType BoxType))
                           a!1)
                      (and a!3 a!5)))))
                :pattern ((Sequences.__default.FoldSets
                            Sequences._default.FoldSets$E@@2
                            (Lit |run#0@@70|)))
                :weight 3
                :skolemid |2344|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@477 T@U) (arg1@@214 T@U) (arg2@@108 T@U) (arg3@@58 Int))
  (! (= (type (Sequences.__default.remove
                arg0@@477
                arg1@@214
                arg2@@108
                arg3@@58))
        (SeqType BoxType))
     :pattern ((Sequences.__default.remove
                 arg0@@477
                 arg1@@214
                 arg2@@108
                 arg3@@58))
     :qid |funType:Sequences.__default.remove|)))
(assert (forall ((Sequences._default.remove$A T@U)
         ($ly@@70 T@U)
         (|s#0@@56| T@U)
         (|pos#0| Int))
  (! (=> (and (= (type Sequences._default.remove$A) TyType)
              (= (type $ly@@70) LayerTypeType)
              (= (type |s#0@@56|) (SeqType BoxType)))
         (= (Sequences.__default.remove
              Sequences._default.remove$A
              ($LS $ly@@70)
              |s#0@@56|
              |pos#0|)
            (Sequences.__default.remove
              Sequences._default.remove$A
              $ly@@70
              |s#0@@56|
              |pos#0|)))
     :pattern ((Sequences.__default.remove
                 Sequences._default.remove$A
                 ($LS $ly@@70)
                 |s#0@@56|
                 |pos#0|))
     :skolemid |2345|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.remove$A@@0 T@U)
         ($ly@@71 T@U)
         (|s#0@@57| T@U)
         (|pos#0@@0| Int))
  (! (=> (and (= (type Sequences._default.remove$A@@0) TyType)
              (= (type $ly@@71) LayerTypeType)
              (= (type |s#0@@57|) (SeqType BoxType)))
         (= (Sequences.__default.remove
              Sequences._default.remove$A@@0
              $ly@@71
              |s#0@@57|
              |pos#0@@0|)
            (Sequences.__default.remove
              Sequences._default.remove$A@@0
              $LZ
              |s#0@@57|
              |pos#0@@0|)))
     :pattern ((Sequences.__default.remove
                 Sequences._default.remove$A@@0
                 (AsFuelBottom $ly@@71)
                 |s#0@@57|
                 |pos#0@@0|))
     :skolemid |2346|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.remove$A@@1 T@U)
                    ($ly@@72 T@U)
                    (|s#0@@58| T@U)
                    (|pos#0@@1| Int))
             (! (let ((a!1 (or (|Sequences.__default.remove#canCall|
                                 Sequences._default.remove$A@@1
                                 |s#0@@58|
                                 |pos#0@@1|)
                               (and ($Is |s#0@@58|
                                         (TSeq Sequences._default.remove$A@@1))
                                    (INTERNAL_le_boogie 0 |pos#0@@1|)
                                    (INTERNAL_lt_boogie
                                      |pos#0@@1|
                                      (|Seq#Length| |s#0@@58|)))))
                      (a!2 (forall ((|i#0@@66| Int))
                             (! (=> (and (INTERNAL_le_boogie 0 |i#0@@66|)
                                         (INTERNAL_lt_boogie
                                           |i#0@@66|
                                           |pos#0@@1|))
                                    (= (|Seq#Index| (Sequences.__default.remove
                                                      Sequences._default.remove$A@@1
                                                      $ly@@72
                                                      |s#0@@58|
                                                      |pos#0@@1|)
                                                    |i#0@@66|)
                                       (|Seq#Index| |s#0@@58| |i#0@@66|)))
                                :pattern ((|Seq#Index| |s#0@@58| |i#0@@66|))
                                :pattern ((|Seq#Index| (Sequences.__default.remove
                                                         Sequences._default.remove$A@@1
                                                         $ly@@72
                                                         |s#0@@58|
                                                         |pos#0@@1|)
                                                       |i#0@@66|))
                                :skolemid |2347|
                                :qid |Sequencesidfy.369:18|)))
                      (a!3 (forall ((|i#1@@12| Int))
                             (! (let ((a!1 (and (INTERNAL_le_boogie
                                                  |pos#0@@1|
                                                  |i#1@@12|)
                                                (INTERNAL_lt_boogie
                                                  |i#1@@12|
                                                  (INTERNAL_sub_boogie
                                                    (|Seq#Length| |s#0@@58|)
                                                    1)))))
                                  (=> a!1
                                      (= (|Seq#Index| (Sequences.__default.remove
                                                        Sequences._default.remove$A@@1
                                                        $ly@@72
                                                        |s#0@@58|
                                                        |pos#0@@1|)
                                                      |i#1@@12|)
                                         (|Seq#Index| |s#0@@58|
                                                      (INTERNAL_add_boogie
                                                        |i#1@@12|
                                                        1)))))
                                :pattern ((|Seq#Index| |s#0@@58|
                                                       (INTERNAL_add_boogie
                                                         |i#1@@12|
                                                         1)))
                                :pattern ((|Seq#Index| (Sequences.__default.remove
                                                         Sequences._default.remove$A@@1
                                                         $ly@@72
                                                         |s#0@@58|
                                                         |pos#0@@1|)
                                                       |i#1@@12|))
                                :skolemid |2348|
                                :qid |Sequencesidfy.370:18|))))
                (let ((a!4 (and (= (|Seq#Length| (Sequences.__default.remove
                                                   Sequences._default.remove$A@@1
                                                   $ly@@72
                                                   |s#0@@58|
                                                   |pos#0@@1|))
                                   (INTERNAL_sub_boogie
                                     (|Seq#Length| |s#0@@58|)
                                     1))
                                a!2
                                a!3
                                ($Is (Sequences.__default.remove
                                       Sequences._default.remove$A@@1
                                       $ly@@72
                                       |s#0@@58|
                                       |pos#0@@1|)
                                     (TSeq Sequences._default.remove$A@@1)))))
                  (=> (and (= (type Sequences._default.remove$A@@1) TyType)
                           (= (type $ly@@72) LayerTypeType)
                           (= (type |s#0@@58|) (SeqType BoxType))
                           a!1)
                      a!4)))
                :pattern ((Sequences.__default.remove
                            Sequences._default.remove$A@@1
                            $ly@@72
                            |s#0@@58|
                            |pos#0@@1|))
                :skolemid |2349|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.remove$A@@2 T@U)
         ($ly@@73 T@U)
         (|s#0@@59| T@U)
         (|pos#0@@2| Int))
  (! (let ((a!1 (= (|Sequences.__default.remove#requires|
                     Sequences._default.remove$A@@2
                     $ly@@73
                     |s#0@@59|
                     |pos#0@@2|)
                   (and (INTERNAL_le_boogie 0 |pos#0@@2|)
                        (INTERNAL_lt_boogie |pos#0@@2| (|Seq#Length| |s#0@@59|))))))
       (=> (and (= (type Sequences._default.remove$A@@2) TyType)
                (= (type $ly@@73) LayerTypeType)
                (= (type |s#0@@59|) (SeqType BoxType))
                ($Is |s#0@@59| (TSeq Sequences._default.remove$A@@2)))
           a!1))
     :pattern ((|Sequences.__default.remove#requires|
                 Sequences._default.remove$A@@2
                 $ly@@73
                 |s#0@@59|
                 |pos#0@@2|))
     :skolemid |2350|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.remove$A@@3 T@U)
                    ($ly@@74 T@U)
                    (|s#0@@60| T@U)
                    (|pos#0@@3| Int))
             (! (let ((a!1 (or (|Sequences.__default.remove#canCall|
                                 Sequences._default.remove$A@@3
                                 |s#0@@60|
                                 |pos#0@@3|)
                               (and ($Is |s#0@@60|
                                         (TSeq Sequences._default.remove$A@@3))
                                    (INTERNAL_le_boogie 0 |pos#0@@3|)
                                    (INTERNAL_lt_boogie
                                      |pos#0@@3|
                                      (|Seq#Length| |s#0@@60|)))))
                      (a!2 (= (Sequences.__default.remove
                                Sequences._default.remove$A@@3
                                ($LS $ly@@74)
                                |s#0@@60|
                                |pos#0@@3|)
                              (|Seq#Append| (|Seq#Take| |s#0@@60| |pos#0@@3|)
                                            (|Seq#Drop| |s#0@@60|
                                                        (INTERNAL_add_boogie
                                                          |pos#0@@3|
                                                          1))))))
                  (=> (and (= (type Sequences._default.remove$A@@3) TyType)
                           (= (type $ly@@74) LayerTypeType)
                           (= (type |s#0@@60|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.remove
                            Sequences._default.remove$A@@3
                            ($LS $ly@@74)
                            |s#0@@60|
                            |pos#0@@3|))
                :skolemid |2351|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.remove$A@@4 T@U)
                    ($ly@@75 T@U)
                    (|s#0@@61| T@U)
                    (|pos#0@@4| Int))
             (! (let ((a!1 (and ($Is |s#0@@61|
                                     (TSeq Sequences._default.remove$A@@4))
                                (INTERNAL_le_boogie 0 |pos#0@@4|)
                                (INTERNAL_lt_boogie
                                  |pos#0@@4|
                                  (|Seq#Length| (Lit |s#0@@61|)))))
                      (a!3 (|Seq#Append| (|Seq#Take| (Lit |s#0@@61|)
                                                     (LitInt |pos#0@@4|))
                                         (|Seq#Drop| (Lit |s#0@@61|)
                                                     (LitInt (INTERNAL_add_boogie
                                                               |pos#0@@4|
                                                               1))))))
                (let ((a!2 (and (= (type Sequences._default.remove$A@@4) TyType)
                                (= (type $ly@@75) LayerTypeType)
                                (= (type |s#0@@61|) (SeqType BoxType))
                                (or (|Sequences.__default.remove#canCall|
                                      Sequences._default.remove$A@@4
                                      (Lit |s#0@@61|)
                                      (LitInt |pos#0@@4|))
                                    a!1))))
                  (=> a!2
                      (= (Sequences.__default.remove
                           Sequences._default.remove$A@@4
                           ($LS $ly@@75)
                           (Lit |s#0@@61|)
                           (LitInt |pos#0@@4|))
                         a!3))))
                :pattern ((Sequences.__default.remove
                            Sequences._default.remove$A@@4
                            ($LS $ly@@75)
                            (Lit |s#0@@61|)
                            (LitInt |pos#0@@4|)))
                :weight 3
                :skolemid |2352|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@478 T@U) (arg1@@215 T@U) (arg2@@109 T@U) (arg3@@59 T@U))
  (! (= (type (Sequences.__default.RemoveOneValue
                arg0@@478
                arg1@@215
                arg2@@109
                arg3@@59))
        (SeqType BoxType))
     :pattern ((Sequences.__default.RemoveOneValue
                 arg0@@478
                 arg1@@215
                 arg2@@109
                 arg3@@59))
     :qid |funType:Sequences.__default.RemoveOneValue|)))
(assert (forall ((Sequences._default.RemoveOneValue$V T@U)
         ($ly@@76 T@U)
         (|s#0@@62| T@U)
         (|v#0@@17| T@U))
  (! (=> (and (= (type Sequences._default.RemoveOneValue$V) TyType)
              (= (type $ly@@76) LayerTypeType)
              (= (type |s#0@@62|) (SeqType BoxType))
              (= (type |v#0@@17|) BoxType))
         (= (Sequences.__default.RemoveOneValue
              Sequences._default.RemoveOneValue$V
              ($LS $ly@@76)
              |s#0@@62|
              |v#0@@17|)
            (Sequences.__default.RemoveOneValue
              Sequences._default.RemoveOneValue$V
              $ly@@76
              |s#0@@62|
              |v#0@@17|)))
     :pattern ((Sequences.__default.RemoveOneValue
                 Sequences._default.RemoveOneValue$V
                 ($LS $ly@@76)
                 |s#0@@62|
                 |v#0@@17|))
     :skolemid |2353|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.RemoveOneValue$V@@0 T@U)
         ($ly@@77 T@U)
         (|s#0@@63| T@U)
         (|v#0@@18| T@U))
  (! (=> (and (= (type Sequences._default.RemoveOneValue$V@@0) TyType)
              (= (type $ly@@77) LayerTypeType)
              (= (type |s#0@@63|) (SeqType BoxType))
              (= (type |v#0@@18|) BoxType))
         (= (Sequences.__default.RemoveOneValue
              Sequences._default.RemoveOneValue$V@@0
              $ly@@77
              |s#0@@63|
              |v#0@@18|)
            (Sequences.__default.RemoveOneValue
              Sequences._default.RemoveOneValue$V@@0
              $LZ
              |s#0@@63|
              |v#0@@18|)))
     :pattern ((Sequences.__default.RemoveOneValue
                 Sequences._default.RemoveOneValue$V@@0
                 (AsFuelBottom $ly@@77)
                 |s#0@@63|
                 |v#0@@18|))
     :skolemid |2354|
     :qid |unknown.0:0|)))
(assert (= (type StartFuel_Sequences._default.NoDupes) LayerTypeType))
(assert (let ((a!1 (forall ((Sequences._default.RemoveOneValue$V@@1 T@U)
                    ($ly@@78 T@U)
                    (|s#0@@64| T@U)
                    (|v#0@@19| T@U))
             (! (let ((a!1 (or (|Sequences.__default.RemoveOneValue#canCall|
                                 Sequences._default.RemoveOneValue$V@@1
                                 |s#0@@64|
                                 |v#0@@19|)
                               (and ($Is |s#0@@64|
                                         (TSeq Sequences._default.RemoveOneValue$V@@1))
                                    ($IsBox |v#0@@19|
                                            Sequences._default.RemoveOneValue$V@@1))))
                      (a!2 (|Set#Equal| (Sequences.__default.Set
                                          Sequences._default.RemoveOneValue$V@@1
                                          (Sequences.__default.RemoveOneValue
                                            Sequences._default.RemoveOneValue$V@@1
                                            $ly@@78
                                            |s#0@@64|
                                            |v#0@@19|))
                                        (|Set#Difference| (Sequences.__default.Set
                                                            Sequences._default.RemoveOneValue$V@@1
                                                            |s#0@@64|)
                                                          (|Set#UnionOne| (|Set#Empty| BoxType)
                                                                          |v#0@@19|)))))
                (let ((a!3 (=> (Sequences.__default.NoDupes
                                 Sequences._default.RemoveOneValue$V@@1
                                 StartFuel_Sequences._default.NoDupes
                                 |s#0@@64|)
                               (and (Sequences.__default.NoDupes
                                      Sequences._default.RemoveOneValue$V@@1
                                      StartFuel_Sequences._default.NoDupes
                                      (Sequences.__default.RemoveOneValue
                                        Sequences._default.RemoveOneValue$V@@1
                                        $ly@@78
                                        |s#0@@64|
                                        |v#0@@19|))
                                    a!2))))
                  (=> (and (= (type Sequences._default.RemoveOneValue$V@@1)
                              TyType)
                           (= (type $ly@@78) LayerTypeType)
                           (= (type |s#0@@64|) (SeqType BoxType))
                           (= (type |v#0@@19|) BoxType)
                           a!1)
                      (and a!3
                           ($Is (Sequences.__default.RemoveOneValue
                                  Sequences._default.RemoveOneValue$V@@1
                                  $ly@@78
                                  |s#0@@64|
                                  |v#0@@19|)
                                (TSeq Sequences._default.RemoveOneValue$V@@1))))))
                :pattern ((Sequences.__default.RemoveOneValue
                            Sequences._default.RemoveOneValue$V@@1
                            $ly@@78
                            |s#0@@64|
                            |v#0@@19|))
                :skolemid |2355|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.RemoveOneValue$V@@2 T@U)
         ($ly@@79 T@U)
         ($Heap@@39 T@U)
         (|s#0@@65| T@U)
         (|v#0@@20| T@U))
  (! (=> (and (= (type Sequences._default.RemoveOneValue$V@@2) TyType)
              (= (type $ly@@79) LayerTypeType)
              (= (type $Heap@@39) (MapType0Type refType MapType1Type))
              (= (type |s#0@@65|) (SeqType BoxType))
              (= (type |v#0@@20|) BoxType)
              ($IsGoodHeap $Heap@@39)
              ($Is |s#0@@65| (TSeq Sequences._default.RemoveOneValue$V@@2))
              ($IsBox |v#0@@20| Sequences._default.RemoveOneValue$V@@2))
         (= (|Sequences.__default.RemoveOneValue#requires|
              Sequences._default.RemoveOneValue$V@@2
              $ly@@79
              |s#0@@65|
              |v#0@@20|)
            true))
     :pattern ((|Sequences.__default.RemoveOneValue#requires|
                 Sequences._default.RemoveOneValue$V@@2
                 $ly@@79
                 |s#0@@65|
                 |v#0@@20|)
               ($IsGoodHeap $Heap@@39))
     :skolemid |2356|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.RemoveOneValue$V@@3 T@U) (s@@50 T@U) (v@@52 T@U))
  (! (let ((a!1 (and (INTERNAL_le_boogie
                       0
                       (|$let#4_i| Sequences._default.RemoveOneValue$V@@3
                                   s@@50
                                   v@@52))
                     (INTERNAL_lt_boogie
                       (|$let#4_i| Sequences._default.RemoveOneValue$V@@3
                                   s@@50
                                   v@@52)
                       (|Seq#Length| s@@50))
                     (= (|Seq#Index| s@@50
                                     (|$let#4_i| Sequences._default.RemoveOneValue$V@@3
                                                 s@@50
                                                 v@@52))
                        v@@52))))
       (=> (and (= (type Sequences._default.RemoveOneValue$V@@3) TyType)
                (= (type s@@50) (SeqType BoxType))
                (= (type v@@52) BoxType)
                (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@3
                                  s@@50
                                  v@@52))
           a!1))
     :pattern ((|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52))
     :skolemid |2357|
     :qid |Sequencesidfy.380:5|)))
(assert (and (= (type MoreFuel_Sequences._default.NoDupes0) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.NoDupes) LayerTypeType)))
(assert (let ((a!1 (forall ((Sequences._default.RemoveOneValue$V@@4 T@U)
                    ($ly@@80 T@U)
                    ($Heap@@40 T@U)
                    (|s#0@@66| T@U)
                    (|v#0@@21| T@U))
             (! (let ((a!1 (or (|Sequences.__default.RemoveOneValue#canCall|
                                 Sequences._default.RemoveOneValue$V@@4
                                 |s#0@@66|
                                 |v#0@@21|)
                               (and ($IsGoodHeap $Heap@@40)
                                    ($Is |s#0@@66|
                                         (TSeq Sequences._default.RemoveOneValue$V@@4))
                                    ($IsBox |v#0@@21|
                                            Sequences._default.RemoveOneValue$V@@4))))
                      (a!2 (|Seq#Append| (|Seq#Take| |s#0@@66|
                                                     (|$let#4_i| Sequences._default.RemoveOneValue$V@@4
                                                                 |s#0@@66|
                                                                 |v#0@@21|))
                                         (|Seq#Drop| |s#0@@66|
                                                     (INTERNAL_add_boogie
                                                       (|$let#4_i| Sequences._default.RemoveOneValue$V@@4
                                                                   |s#0@@66|
                                                                   |v#0@@21|)
                                                       1)))))
                (let ((a!3 (= (Sequences.__default.RemoveOneValue
                                Sequences._default.RemoveOneValue$V@@4
                                ($LS $ly@@80)
                                |s#0@@66|
                                |v#0@@21|)
                              (ite (not (|Seq#Contains| |s#0@@66| |v#0@@21|))
                                   |s#0@@66|
                                   a!2))))
                (let ((a!4 (and (=> (|Seq#Contains| |s#0@@66| |v#0@@21|)
                                    (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@4
                                                      |s#0@@66|
                                                      |v#0@@21|))
                                (= StartFuel_Sequences._default.NoDupes
                                   ($LS MoreFuel_Sequences._default.NoDupes0))
                                (= StartFuelAssert_Sequences._default.NoDupes
                                   ($LS ($LS MoreFuel_Sequences._default.NoDupes0)))
                                (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes0)
                                   MoreFuel_Sequences._default.NoDupes0)
                                a!3)))
                  (=> (and (= (type Sequences._default.RemoveOneValue$V@@4)
                              TyType)
                           (= (type $ly@@80) LayerTypeType)
                           (= (type $Heap@@40)
                              (MapType0Type refType MapType1Type))
                           (= (type |s#0@@66|) (SeqType BoxType))
                           (= (type |v#0@@21|) BoxType)
                           a!1)
                      a!4))))
                :pattern ((Sequences.__default.RemoveOneValue
                            Sequences._default.RemoveOneValue$V@@4
                            ($LS $ly@@80)
                            |s#0@@66|
                            |v#0@@21|)
                          ($IsGoodHeap $Heap@@40))
                :skolemid |2358|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type MoreFuel_Sequences._default.NoDupes1) LayerTypeType))
(assert (let ((a!1 (forall ((Sequences._default.RemoveOneValue$V@@5 T@U)
                    ($ly@@81 T@U)
                    ($Heap@@41 T@U)
                    (|s#0@@67| T@U)
                    (|v#0@@22| T@U))
             (! (let ((a!1 (or (|Sequences.__default.RemoveOneValue#canCall|
                                 Sequences._default.RemoveOneValue$V@@5
                                 (Lit |s#0@@67|)
                                 |v#0@@22|)
                               (and ($IsGoodHeap $Heap@@41)
                                    ($Is |s#0@@67|
                                         (TSeq Sequences._default.RemoveOneValue$V@@5))
                                    ($IsBox |v#0@@22|
                                            Sequences._default.RemoveOneValue$V@@5))))
                      (a!2 (|Seq#Drop| (Lit |s#0@@67|)
                                       (INTERNAL_add_boogie
                                         (|$let#4_i| Sequences._default.RemoveOneValue$V@@5
                                                     (Lit |s#0@@67|)
                                                     |v#0@@22|)
                                         1))))
                (let ((a!3 (|Seq#Append| (|Seq#Take| (Lit |s#0@@67|)
                                                     (|$let#4_i| Sequences._default.RemoveOneValue$V@@5
                                                                 (Lit |s#0@@67|)
                                                                 |v#0@@22|))
                                         a!2)))
                (let ((a!4 (= (Sequences.__default.RemoveOneValue
                                Sequences._default.RemoveOneValue$V@@5
                                ($LS $ly@@81)
                                (Lit |s#0@@67|)
                                |v#0@@22|)
                              (ite (not (|Seq#Contains| |s#0@@67| |v#0@@22|))
                                   |s#0@@67|
                                   a!3))))
                (let ((a!5 (and (=> (|Seq#Contains| |s#0@@67| |v#0@@22|)
                                    (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@5
                                                      (Lit |s#0@@67|)
                                                      |v#0@@22|))
                                (= StartFuel_Sequences._default.NoDupes
                                   ($LS MoreFuel_Sequences._default.NoDupes1))
                                (= StartFuelAssert_Sequences._default.NoDupes
                                   ($LS ($LS MoreFuel_Sequences._default.NoDupes1)))
                                (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes1)
                                   MoreFuel_Sequences._default.NoDupes1)
                                a!4)))
                  (=> (and (= (type Sequences._default.RemoveOneValue$V@@5)
                              TyType)
                           (= (type $ly@@81) LayerTypeType)
                           (= (type $Heap@@41)
                              (MapType0Type refType MapType1Type))
                           (= (type |s#0@@67|) (SeqType BoxType))
                           (= (type |v#0@@22|) BoxType)
                           a!1)
                      a!5)))))
                :pattern ((Sequences.__default.RemoveOneValue
                            Sequences._default.RemoveOneValue$V@@5
                            ($LS $ly@@81)
                            (Lit |s#0@@67|)
                            |v#0@@22|)
                          ($IsGoodHeap $Heap@@41))
                :weight 3
                :skolemid |2359|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type MoreFuel_Sequences._default.NoDupes2) LayerTypeType))
(assert (let ((a!1 (forall ((Sequences._default.RemoveOneValue$V@@6 T@U)
                    ($ly@@82 T@U)
                    ($Heap@@42 T@U)
                    (|s#0@@68| T@U)
                    (|v#0@@23| T@U))
             (! (let ((a!1 (or (|Sequences.__default.RemoveOneValue#canCall|
                                 Sequences._default.RemoveOneValue$V@@6
                                 (Lit |s#0@@68|)
                                 (Lit |v#0@@23|))
                               (and ($IsGoodHeap $Heap@@42)
                                    ($Is |s#0@@68|
                                         (TSeq Sequences._default.RemoveOneValue$V@@6))
                                    ($IsBox |v#0@@23|
                                            Sequences._default.RemoveOneValue$V@@6))))
                      (a!2 (|Seq#Drop| (Lit |s#0@@68|)
                                       (INTERNAL_add_boogie
                                         (|$let#4_i| Sequences._default.RemoveOneValue$V@@6
                                                     (Lit |s#0@@68|)
                                                     (Lit |v#0@@23|))
                                         1))))
                (let ((a!3 (|Seq#Append| (|Seq#Take| (Lit |s#0@@68|)
                                                     (|$let#4_i| Sequences._default.RemoveOneValue$V@@6
                                                                 (Lit |s#0@@68|)
                                                                 (Lit |v#0@@23|)))
                                         a!2)))
                (let ((a!4 (= (Sequences.__default.RemoveOneValue
                                Sequences._default.RemoveOneValue$V@@6
                                ($LS $ly@@82)
                                (Lit |s#0@@68|)
                                (Lit |v#0@@23|))
                              (ite (not (|Seq#Contains| |s#0@@68| |v#0@@23|))
                                   |s#0@@68|
                                   a!3))))
                (let ((a!5 (and (=> (|Seq#Contains| |s#0@@68| |v#0@@23|)
                                    (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@6
                                                      (Lit |s#0@@68|)
                                                      (Lit |v#0@@23|)))
                                (= StartFuel_Sequences._default.NoDupes
                                   ($LS MoreFuel_Sequences._default.NoDupes2))
                                (= StartFuelAssert_Sequences._default.NoDupes
                                   ($LS ($LS MoreFuel_Sequences._default.NoDupes2)))
                                (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes2)
                                   MoreFuel_Sequences._default.NoDupes2)
                                a!4)))
                  (=> (and (= (type Sequences._default.RemoveOneValue$V@@6)
                              TyType)
                           (= (type $ly@@82) LayerTypeType)
                           (= (type $Heap@@42)
                              (MapType0Type refType MapType1Type))
                           (= (type |s#0@@68|) (SeqType BoxType))
                           (= (type |v#0@@23|) BoxType)
                           a!1)
                      a!5)))))
                :pattern ((Sequences.__default.RemoveOneValue
                            Sequences._default.RemoveOneValue$V@@6
                            ($LS $ly@@82)
                            (Lit |s#0@@68|)
                            (Lit |v#0@@23|))
                          ($IsGoodHeap $Heap@@42))
                :weight 3
                :skolemid |2360|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@479 T@U)
         (arg1@@216 T@U)
         (arg2@@110 T@U)
         (arg3@@60 T@U)
         (arg4@@36 Int))
  (! (= (type (Sequences.__default.insert
                arg0@@479
                arg1@@216
                arg2@@110
                arg3@@60
                arg4@@36))
        (SeqType BoxType))
     :pattern ((Sequences.__default.insert
                 arg0@@479
                 arg1@@216
                 arg2@@110
                 arg3@@60
                 arg4@@36))
     :qid |funType:Sequences.__default.insert|)))
(assert (forall ((Sequences._default.insert$A T@U)
         ($ly@@83 T@U)
         (|s#0@@69| T@U)
         (|a#0@@27| T@U)
         (|pos#0@@5| Int))
  (! (=> (and (= (type Sequences._default.insert$A) TyType)
              (= (type $ly@@83) LayerTypeType)
              (= (type |s#0@@69|) (SeqType BoxType))
              (= (type |a#0@@27|) BoxType))
         (= (Sequences.__default.insert
              Sequences._default.insert$A
              ($LS $ly@@83)
              |s#0@@69|
              |a#0@@27|
              |pos#0@@5|)
            (Sequences.__default.insert
              Sequences._default.insert$A
              $ly@@83
              |s#0@@69|
              |a#0@@27|
              |pos#0@@5|)))
     :pattern ((Sequences.__default.insert
                 Sequences._default.insert$A
                 ($LS $ly@@83)
                 |s#0@@69|
                 |a#0@@27|
                 |pos#0@@5|))
     :skolemid |2361|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.insert$A@@0 T@U)
         ($ly@@84 T@U)
         (|s#0@@70| T@U)
         (|a#0@@28| T@U)
         (|pos#0@@6| Int))
  (! (=> (and (= (type Sequences._default.insert$A@@0) TyType)
              (= (type $ly@@84) LayerTypeType)
              (= (type |s#0@@70|) (SeqType BoxType))
              (= (type |a#0@@28|) BoxType))
         (= (Sequences.__default.insert
              Sequences._default.insert$A@@0
              $ly@@84
              |s#0@@70|
              |a#0@@28|
              |pos#0@@6|)
            (Sequences.__default.insert
              Sequences._default.insert$A@@0
              $LZ
              |s#0@@70|
              |a#0@@28|
              |pos#0@@6|)))
     :pattern ((Sequences.__default.insert
                 Sequences._default.insert$A@@0
                 (AsFuelBottom $ly@@84)
                 |s#0@@70|
                 |a#0@@28|
                 |pos#0@@6|))
     :skolemid |2362|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.insert$A@@1 T@U)
                    ($ly@@85 T@U)
                    (|s#0@@71| T@U)
                    (|a#0@@29| T@U)
                    (|pos#0@@7| Int))
             (! (let ((a!1 (or (|Sequences.__default.insert#canCall|
                                 Sequences._default.insert$A@@1
                                 |s#0@@71|
                                 |a#0@@29|
                                 |pos#0@@7|)
                               (and ($Is |s#0@@71|
                                         (TSeq Sequences._default.insert$A@@1))
                                    ($IsBox |a#0@@29|
                                            Sequences._default.insert$A@@1)
                                    (INTERNAL_le_boogie 0 |pos#0@@7|)
                                    (INTERNAL_le_boogie
                                      |pos#0@@7|
                                      (|Seq#Length| |s#0@@71|)))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.insert
                                                   Sequences._default.insert$A@@1
                                                   $ly@@85
                                                   |s#0@@71|
                                                   |a#0@@29|
                                                   |pos#0@@7|))
                                   (INTERNAL_add_boogie
                                     (|Seq#Length| |s#0@@71|)
                                     1))
                                (forall ((|i#0@@68| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#0@@68|)
                                                         (INTERNAL_lt_boogie
                                                           |i#0@@68|
                                                           |pos#0@@7|))
                                                    (= (|Seq#Index| (Sequences.__default.insert
                                                                      Sequences._default.insert$A@@1
                                                                      $ly@@85
                                                                      |s#0@@71|
                                                                      |a#0@@29|
                                                                      |pos#0@@7|)
                                                                    |i#0@@68|)
                                                       (|Seq#Index| |s#0@@71|
                                                                    |i#0@@68|)))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| |s#0@@71| |i#0@@68|))
                                     :pattern ((|Seq#Index| (Sequences.__default.insert
                                                              Sequences._default.insert$A@@1
                                                              $ly@@85
                                                              |s#0@@71|
                                                              |a#0@@29|
                                                              |pos#0@@7|)
                                                            |i#0@@68|))
                                     :skolemid |2363|
                                     :qid |Sequencesidfy.387:18|))
                                (forall ((|i#1@@14| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           |pos#0@@7|
                                                           |i#1@@14|)
                                                         (INTERNAL_lt_boogie
                                                           |i#1@@14|
                                                           (|Seq#Length| |s#0@@71|)))
                                                    (= (|Seq#Index| (Sequences.__default.insert
                                                                      Sequences._default.insert$A@@1
                                                                      $ly@@85
                                                                      |s#0@@71|
                                                                      |a#0@@29|
                                                                      |pos#0@@7|)
                                                                    (INTERNAL_add_boogie
                                                                      |i#1@@14|
                                                                      1))
                                                       (|Seq#Index| |s#0@@71|
                                                                    |i#1@@14|)))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| |s#0@@71| |i#1@@14|))
                                     :pattern ((|Seq#Index| (Sequences.__default.insert
                                                              Sequences._default.insert$A@@1
                                                              $ly@@85
                                                              |s#0@@71|
                                                              |a#0@@29|
                                                              |pos#0@@7|)
                                                            (INTERNAL_add_boogie
                                                              |i#1@@14|
                                                              1)))
                                     :skolemid |2364|
                                     :qid |Sequencesidfy.388:18|))
                                (= (|Seq#Index| (Sequences.__default.insert
                                                  Sequences._default.insert$A@@1
                                                  $ly@@85
                                                  |s#0@@71|
                                                  |a#0@@29|
                                                  |pos#0@@7|)
                                                |pos#0@@7|)
                                   |a#0@@29|)
                                ($Is (Sequences.__default.insert
                                       Sequences._default.insert$A@@1
                                       $ly@@85
                                       |s#0@@71|
                                       |a#0@@29|
                                       |pos#0@@7|)
                                     (TSeq Sequences._default.insert$A@@1)))))
                  (=> (and (= (type Sequences._default.insert$A@@1) TyType)
                           (= (type $ly@@85) LayerTypeType)
                           (= (type |s#0@@71|) (SeqType BoxType))
                           (= (type |a#0@@29|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.insert
                            Sequences._default.insert$A@@1
                            $ly@@85
                            |s#0@@71|
                            |a#0@@29|
                            |pos#0@@7|))
                :skolemid |2365|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.insert$A@@2 T@U)
         ($ly@@86 T@U)
         (|s#0@@72| T@U)
         (|a#0@@30| T@U)
         (|pos#0@@8| Int))
  (! (let ((a!1 (= (|Sequences.__default.insert#requires|
                     Sequences._default.insert$A@@2
                     $ly@@86
                     |s#0@@72|
                     |a#0@@30|
                     |pos#0@@8|)
                   (and (INTERNAL_le_boogie 0 |pos#0@@8|)
                        (INTERNAL_le_boogie |pos#0@@8| (|Seq#Length| |s#0@@72|))))))
       (=> (and (= (type Sequences._default.insert$A@@2) TyType)
                (= (type $ly@@86) LayerTypeType)
                (= (type |s#0@@72|) (SeqType BoxType))
                (= (type |a#0@@30|) BoxType)
                ($Is |s#0@@72| (TSeq Sequences._default.insert$A@@2))
                ($IsBox |a#0@@30| Sequences._default.insert$A@@2))
           a!1))
     :pattern ((|Sequences.__default.insert#requires|
                 Sequences._default.insert$A@@2
                 $ly@@86
                 |s#0@@72|
                 |a#0@@30|
                 |pos#0@@8|))
     :skolemid |2366|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.insert$A@@3 T@U)
                    ($ly@@87 T@U)
                    (|s#0@@73| T@U)
                    (|a#0@@31| T@U)
                    (|pos#0@@9| Int))
             (! (let ((a!1 (or (|Sequences.__default.insert#canCall|
                                 Sequences._default.insert$A@@3
                                 |s#0@@73|
                                 |a#0@@31|
                                 |pos#0@@9|)
                               (and ($Is |s#0@@73|
                                         (TSeq Sequences._default.insert$A@@3))
                                    ($IsBox |a#0@@31|
                                            Sequences._default.insert$A@@3)
                                    (INTERNAL_le_boogie 0 |pos#0@@9|)
                                    (INTERNAL_le_boogie
                                      |pos#0@@9|
                                      (|Seq#Length| |s#0@@73|)))))
                      (a!2 (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@73|
                                                                   |pos#0@@9|)
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |a#0@@31|))
                                         (|Seq#Drop| |s#0@@73| |pos#0@@9|))))
                  (=> (and (= (type Sequences._default.insert$A@@3) TyType)
                           (= (type $ly@@87) LayerTypeType)
                           (= (type |s#0@@73|) (SeqType BoxType))
                           (= (type |a#0@@31|) BoxType)
                           a!1)
                      (= (Sequences.__default.insert
                           Sequences._default.insert$A@@3
                           ($LS $ly@@87)
                           |s#0@@73|
                           |a#0@@31|
                           |pos#0@@9|)
                         a!2)))
                :pattern ((Sequences.__default.insert
                            Sequences._default.insert$A@@3
                            ($LS $ly@@87)
                            |s#0@@73|
                            |a#0@@31|
                            |pos#0@@9|))
                :skolemid |2367|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.insert$A@@4 T@U)
                    ($ly@@88 T@U)
                    (|s#0@@74| T@U)
                    (|a#0@@32| T@U)
                    (|pos#0@@10| Int))
             (! (let ((a!1 (and ($Is |s#0@@74|
                                     (TSeq Sequences._default.insert$A@@4))
                                ($IsBox |a#0@@32|
                                        Sequences._default.insert$A@@4)
                                (INTERNAL_le_boogie 0 |pos#0@@10|)
                                (INTERNAL_le_boogie
                                  |pos#0@@10|
                                  (|Seq#Length| (Lit |s#0@@74|)))))
                      (a!3 (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@74|)
                                                                   (LitInt |pos#0@@10|))
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |a#0@@32|))
                                         (|Seq#Drop| (Lit |s#0@@74|)
                                                     (LitInt |pos#0@@10|)))))
                (let ((a!2 (and (= (type Sequences._default.insert$A@@4) TyType)
                                (= (type $ly@@88) LayerTypeType)
                                (= (type |s#0@@74|) (SeqType BoxType))
                                (= (type |a#0@@32|) BoxType)
                                (or (|Sequences.__default.insert#canCall|
                                      Sequences._default.insert$A@@4
                                      (Lit |s#0@@74|)
                                      |a#0@@32|
                                      (LitInt |pos#0@@10|))
                                    a!1))))
                  (=> a!2
                      (= (Sequences.__default.insert
                           Sequences._default.insert$A@@4
                           ($LS $ly@@88)
                           (Lit |s#0@@74|)
                           |a#0@@32|
                           (LitInt |pos#0@@10|))
                         a!3))))
                :pattern ((Sequences.__default.insert
                            Sequences._default.insert$A@@4
                            ($LS $ly@@88)
                            (Lit |s#0@@74|)
                            |a#0@@32|
                            (LitInt |pos#0@@10|)))
                :weight 3
                :skolemid |2368|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.insert$A@@5 T@U)
                    ($ly@@89 T@U)
                    (|s#0@@75| T@U)
                    (|a#0@@33| T@U)
                    (|pos#0@@11| Int))
             (! (let ((a!1 (and ($Is |s#0@@75|
                                     (TSeq Sequences._default.insert$A@@5))
                                ($IsBox |a#0@@33|
                                        Sequences._default.insert$A@@5)
                                (INTERNAL_le_boogie 0 |pos#0@@11|)
                                (INTERNAL_le_boogie
                                  |pos#0@@11|
                                  (|Seq#Length| (Lit |s#0@@75|)))))
                      (a!3 (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@75|)
                                                                   (LitInt |pos#0@@11|))
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    (Lit |a#0@@33|)))
                                         (|Seq#Drop| (Lit |s#0@@75|)
                                                     (LitInt |pos#0@@11|)))))
                (let ((a!2 (and (= (type Sequences._default.insert$A@@5) TyType)
                                (= (type $ly@@89) LayerTypeType)
                                (= (type |s#0@@75|) (SeqType BoxType))
                                (= (type |a#0@@33|) BoxType)
                                (or (|Sequences.__default.insert#canCall|
                                      Sequences._default.insert$A@@5
                                      (Lit |s#0@@75|)
                                      (Lit |a#0@@33|)
                                      (LitInt |pos#0@@11|))
                                    a!1))))
                  (=> a!2
                      (= (Sequences.__default.insert
                           Sequences._default.insert$A@@5
                           ($LS $ly@@89)
                           (Lit |s#0@@75|)
                           (Lit |a#0@@33|)
                           (LitInt |pos#0@@11|))
                         a!3))))
                :pattern ((Sequences.__default.insert
                            Sequences._default.insert$A@@5
                            ($LS $ly@@89)
                            (Lit |s#0@@75|)
                            (Lit |a#0@@33|)
                            (LitInt |pos#0@@11|)))
                :weight 3
                :skolemid |2369|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@480 T@U)
         (arg1@@217 T@U)
         (arg2@@111 T@U)
         (arg3@@61 T@U)
         (arg4@@37 T@U)
         (arg5@@20 Int))
  (! (= (type (Sequences.__default.replace1with2
                arg0@@480
                arg1@@217
                arg2@@111
                arg3@@61
                arg4@@37
                arg5@@20))
        (SeqType BoxType))
     :pattern ((Sequences.__default.replace1with2
                 arg0@@480
                 arg1@@217
                 arg2@@111
                 arg3@@61
                 arg4@@37
                 arg5@@20))
     :qid |funType:Sequences.__default.replace1with2|)))
(assert (forall ((Sequences._default.replace1with2$A T@U)
         ($ly@@90 T@U)
         (|s#0@@76| T@U)
         (|a#0@@34| T@U)
         (|b#0@@9| T@U)
         (|pos#0@@12| Int))
  (! (=> (and (= (type Sequences._default.replace1with2$A) TyType)
              (= (type $ly@@90) LayerTypeType)
              (= (type |s#0@@76|) (SeqType BoxType))
              (= (type |a#0@@34|) BoxType)
              (= (type |b#0@@9|) BoxType))
         (= (Sequences.__default.replace1with2
              Sequences._default.replace1with2$A
              ($LS $ly@@90)
              |s#0@@76|
              |a#0@@34|
              |b#0@@9|
              |pos#0@@12|)
            (Sequences.__default.replace1with2
              Sequences._default.replace1with2$A
              $ly@@90
              |s#0@@76|
              |a#0@@34|
              |b#0@@9|
              |pos#0@@12|)))
     :pattern ((Sequences.__default.replace1with2
                 Sequences._default.replace1with2$A
                 ($LS $ly@@90)
                 |s#0@@76|
                 |a#0@@34|
                 |b#0@@9|
                 |pos#0@@12|))
     :skolemid |2370|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.replace1with2$A@@0 T@U)
         ($ly@@91 T@U)
         (|s#0@@77| T@U)
         (|a#0@@35| T@U)
         (|b#0@@10| T@U)
         (|pos#0@@13| Int))
  (! (=> (and (= (type Sequences._default.replace1with2$A@@0) TyType)
              (= (type $ly@@91) LayerTypeType)
              (= (type |s#0@@77|) (SeqType BoxType))
              (= (type |a#0@@35|) BoxType)
              (= (type |b#0@@10|) BoxType))
         (= (Sequences.__default.replace1with2
              Sequences._default.replace1with2$A@@0
              $ly@@91
              |s#0@@77|
              |a#0@@35|
              |b#0@@10|
              |pos#0@@13|)
            (Sequences.__default.replace1with2
              Sequences._default.replace1with2$A@@0
              $LZ
              |s#0@@77|
              |a#0@@35|
              |b#0@@10|
              |pos#0@@13|)))
     :pattern ((Sequences.__default.replace1with2
                 Sequences._default.replace1with2$A@@0
                 (AsFuelBottom $ly@@91)
                 |s#0@@77|
                 |a#0@@35|
                 |b#0@@10|
                 |pos#0@@13|))
     :skolemid |2371|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.replace1with2$A@@1 T@U)
                    ($ly@@92 T@U)
                    (|s#0@@78| T@U)
                    (|a#0@@36| T@U)
                    (|b#0@@11| T@U)
                    (|pos#0@@14| Int))
             (! (let ((a!1 (or (|Sequences.__default.replace1with2#canCall|
                                 Sequences._default.replace1with2$A@@1
                                 |s#0@@78|
                                 |a#0@@36|
                                 |b#0@@11|
                                 |pos#0@@14|)
                               (and ($Is |s#0@@78|
                                         (TSeq Sequences._default.replace1with2$A@@1))
                                    ($IsBox |a#0@@36|
                                            Sequences._default.replace1with2$A@@1)
                                    ($IsBox |b#0@@11|
                                            Sequences._default.replace1with2$A@@1)
                                    (INTERNAL_le_boogie 0 |pos#0@@14|)
                                    (INTERNAL_lt_boogie
                                      |pos#0@@14|
                                      (|Seq#Length| |s#0@@78|)))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.replace1with2
                                                   Sequences._default.replace1with2$A@@1
                                                   $ly@@92
                                                   |s#0@@78|
                                                   |a#0@@36|
                                                   |b#0@@11|
                                                   |pos#0@@14|))
                                   (INTERNAL_add_boogie
                                     (|Seq#Length| |s#0@@78|)
                                     1))
                                (forall ((|i#0@@69| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#0@@69|)
                                                         (INTERNAL_lt_boogie
                                                           |i#0@@69|
                                                           |pos#0@@14|))
                                                    (= (|Seq#Index| (Sequences.__default.replace1with2
                                                                      Sequences._default.replace1with2$A@@1
                                                                      $ly@@92
                                                                      |s#0@@78|
                                                                      |a#0@@36|
                                                                      |b#0@@11|
                                                                      |pos#0@@14|)
                                                                    |i#0@@69|)
                                                       (|Seq#Index| |s#0@@78|
                                                                    |i#0@@69|)))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| |s#0@@78| |i#0@@69|))
                                     :pattern ((|Seq#Index| (Sequences.__default.replace1with2
                                                              Sequences._default.replace1with2$A@@1
                                                              $ly@@92
                                                              |s#0@@78|
                                                              |a#0@@36|
                                                              |b#0@@11|
                                                              |pos#0@@14|)
                                                            |i#0@@69|))
                                     :skolemid |2372|
                                     :qid |Sequencesidfy.412:18|))
                                (forall ((|i#1@@15| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_lt_boogie
                                                           |pos#0@@14|
                                                           |i#1@@15|)
                                                         (INTERNAL_lt_boogie
                                                           |i#1@@15|
                                                           (|Seq#Length| |s#0@@78|)))
                                                    (= (|Seq#Index| (Sequences.__default.replace1with2
                                                                      Sequences._default.replace1with2$A@@1
                                                                      $ly@@92
                                                                      |s#0@@78|
                                                                      |a#0@@36|
                                                                      |b#0@@11|
                                                                      |pos#0@@14|)
                                                                    (INTERNAL_add_boogie
                                                                      |i#1@@15|
                                                                      1))
                                                       (|Seq#Index| |s#0@@78|
                                                                    |i#1@@15|)))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| |s#0@@78| |i#1@@15|))
                                     :pattern ((|Seq#Index| (Sequences.__default.replace1with2
                                                              Sequences._default.replace1with2$A@@1
                                                              $ly@@92
                                                              |s#0@@78|
                                                              |a#0@@36|
                                                              |b#0@@11|
                                                              |pos#0@@14|)
                                                            (INTERNAL_add_boogie
                                                              |i#1@@15|
                                                              1)))
                                     :skolemid |2373|
                                     :qid |Sequencesidfy.413:18|))
                                (= (|Seq#Index| (Sequences.__default.replace1with2
                                                  Sequences._default.replace1with2$A@@1
                                                  $ly@@92
                                                  |s#0@@78|
                                                  |a#0@@36|
                                                  |b#0@@11|
                                                  |pos#0@@14|)
                                                |pos#0@@14|)
                                   |a#0@@36|)
                                (= (|Seq#Index| (Sequences.__default.replace1with2
                                                  Sequences._default.replace1with2$A@@1
                                                  $ly@@92
                                                  |s#0@@78|
                                                  |a#0@@36|
                                                  |b#0@@11|
                                                  |pos#0@@14|)
                                                (INTERNAL_add_boogie
                                                  |pos#0@@14|
                                                  1))
                                   |b#0@@11|)
                                ($Is (Sequences.__default.replace1with2
                                       Sequences._default.replace1with2$A@@1
                                       $ly@@92
                                       |s#0@@78|
                                       |a#0@@36|
                                       |b#0@@11|
                                       |pos#0@@14|)
                                     (TSeq Sequences._default.replace1with2$A@@1)))))
                  (=> (and (= (type Sequences._default.replace1with2$A@@1)
                              TyType)
                           (= (type $ly@@92) LayerTypeType)
                           (= (type |s#0@@78|) (SeqType BoxType))
                           (= (type |a#0@@36|) BoxType)
                           (= (type |b#0@@11|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.replace1with2
                            Sequences._default.replace1with2$A@@1
                            $ly@@92
                            |s#0@@78|
                            |a#0@@36|
                            |b#0@@11|
                            |pos#0@@14|))
                :skolemid |2374|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.replace1with2$A@@2 T@U)
         ($ly@@93 T@U)
         (|s#0@@79| T@U)
         (|a#0@@37| T@U)
         (|b#0@@12| T@U)
         (|pos#0@@15| Int))
  (! (let ((a!1 (= (|Sequences.__default.replace1with2#requires|
                     Sequences._default.replace1with2$A@@2
                     $ly@@93
                     |s#0@@79|
                     |a#0@@37|
                     |b#0@@12|
                     |pos#0@@15|)
                   (and (INTERNAL_le_boogie 0 |pos#0@@15|)
                        (INTERNAL_lt_boogie
                          |pos#0@@15|
                          (|Seq#Length| |s#0@@79|))))))
       (=> (and (= (type Sequences._default.replace1with2$A@@2) TyType)
                (= (type $ly@@93) LayerTypeType)
                (= (type |s#0@@79|) (SeqType BoxType))
                (= (type |a#0@@37|) BoxType)
                (= (type |b#0@@12|) BoxType)
                ($Is |s#0@@79| (TSeq Sequences._default.replace1with2$A@@2))
                ($IsBox |a#0@@37| Sequences._default.replace1with2$A@@2)
                ($IsBox |b#0@@12| Sequences._default.replace1with2$A@@2))
           a!1))
     :pattern ((|Sequences.__default.replace1with2#requires|
                 Sequences._default.replace1with2$A@@2
                 $ly@@93
                 |s#0@@79|
                 |a#0@@37|
                 |b#0@@12|
                 |pos#0@@15|))
     :skolemid |2375|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.replace1with2$A@@3 T@U)
                    ($ly@@94 T@U)
                    (|s#0@@80| T@U)
                    (|a#0@@38| T@U)
                    (|b#0@@13| T@U)
                    (|pos#0@@16| Int))
             (! (let ((a!1 (or (|Sequences.__default.replace1with2#canCall|
                                 Sequences._default.replace1with2$A@@3
                                 |s#0@@80|
                                 |a#0@@38|
                                 |b#0@@13|
                                 |pos#0@@16|)
                               (and ($Is |s#0@@80|
                                         (TSeq Sequences._default.replace1with2$A@@3))
                                    ($IsBox |a#0@@38|
                                            Sequences._default.replace1with2$A@@3)
                                    ($IsBox |b#0@@13|
                                            Sequences._default.replace1with2$A@@3)
                                    (INTERNAL_le_boogie 0 |pos#0@@16|)
                                    (INTERNAL_lt_boogie
                                      |pos#0@@16|
                                      (|Seq#Length| |s#0@@80|)))))
                      (a!2 (|Seq#Append| (|Seq#Take| |s#0@@80| |pos#0@@16|)
                                         (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType)
                                                                   |a#0@@38|)
                                                      |b#0@@13|))))
                (let ((a!3 (= (Sequences.__default.replace1with2
                                Sequences._default.replace1with2$A@@3
                                ($LS $ly@@94)
                                |s#0@@80|
                                |a#0@@38|
                                |b#0@@13|
                                |pos#0@@16|)
                              (|Seq#Append| a!2
                                            (|Seq#Drop| |s#0@@80|
                                                        (INTERNAL_add_boogie
                                                          |pos#0@@16|
                                                          1))))))
                  (=> (and (= (type Sequences._default.replace1with2$A@@3)
                              TyType)
                           (= (type $ly@@94) LayerTypeType)
                           (= (type |s#0@@80|) (SeqType BoxType))
                           (= (type |a#0@@38|) BoxType)
                           (= (type |b#0@@13|) BoxType)
                           a!1)
                      a!3)))
                :pattern ((Sequences.__default.replace1with2
                            Sequences._default.replace1with2$A@@3
                            ($LS $ly@@94)
                            |s#0@@80|
                            |a#0@@38|
                            |b#0@@13|
                            |pos#0@@16|))
                :skolemid |2376|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.replace1with2$A@@4 T@U)
                    ($ly@@95 T@U)
                    (|s#0@@81| T@U)
                    (|a#0@@39| T@U)
                    (|b#0@@14| T@U)
                    (|pos#0@@17| Int))
             (! (let ((a!1 (and ($Is |s#0@@81|
                                     (TSeq Sequences._default.replace1with2$A@@4))
                                ($IsBox |a#0@@39|
                                        Sequences._default.replace1with2$A@@4)
                                ($IsBox |b#0@@14|
                                        Sequences._default.replace1with2$A@@4)
                                (INTERNAL_le_boogie 0 |pos#0@@17|)
                                (INTERNAL_lt_boogie
                                  |pos#0@@17|
                                  (|Seq#Length| (Lit |s#0@@81|)))))
                      (a!3 (|Seq#Append| (|Seq#Take| (Lit |s#0@@81|)
                                                     (LitInt |pos#0@@17|))
                                         (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType)
                                                                   |a#0@@39|)
                                                      |b#0@@14|))))
                (let ((a!2 (and (= (type Sequences._default.replace1with2$A@@4)
                                   TyType)
                                (= (type $ly@@95) LayerTypeType)
                                (= (type |s#0@@81|) (SeqType BoxType))
                                (= (type |a#0@@39|) BoxType)
                                (= (type |b#0@@14|) BoxType)
                                (or (|Sequences.__default.replace1with2#canCall|
                                      Sequences._default.replace1with2$A@@4
                                      (Lit |s#0@@81|)
                                      |a#0@@39|
                                      |b#0@@14|
                                      (LitInt |pos#0@@17|))
                                    a!1)))
                      (a!4 (|Seq#Append| a!3
                                         (|Seq#Drop| (Lit |s#0@@81|)
                                                     (LitInt (INTERNAL_add_boogie
                                                               |pos#0@@17|
                                                               1))))))
                  (=> a!2
                      (= (Sequences.__default.replace1with2
                           Sequences._default.replace1with2$A@@4
                           ($LS $ly@@95)
                           (Lit |s#0@@81|)
                           |a#0@@39|
                           |b#0@@14|
                           (LitInt |pos#0@@17|))
                         a!4))))
                :pattern ((Sequences.__default.replace1with2
                            Sequences._default.replace1with2$A@@4
                            ($LS $ly@@95)
                            (Lit |s#0@@81|)
                            |a#0@@39|
                            |b#0@@14|
                            (LitInt |pos#0@@17|)))
                :weight 3
                :skolemid |2377|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.replace1with2$A@@5 T@U)
                    ($ly@@96 T@U)
                    (|s#0@@82| T@U)
                    (|a#0@@40| T@U)
                    (|b#0@@15| T@U)
                    (|pos#0@@18| Int))
             (! (let ((a!1 (and ($Is |s#0@@82|
                                     (TSeq Sequences._default.replace1with2$A@@5))
                                ($IsBox |a#0@@40|
                                        Sequences._default.replace1with2$A@@5)
                                ($IsBox |b#0@@15|
                                        Sequences._default.replace1with2$A@@5)
                                (INTERNAL_le_boogie 0 |pos#0@@18|)
                                (INTERNAL_lt_boogie
                                  |pos#0@@18|
                                  (|Seq#Length| (Lit |s#0@@82|)))))
                      (a!3 (|Seq#Append| (|Seq#Take| (Lit |s#0@@82|)
                                                     (LitInt |pos#0@@18|))
                                         (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType)
                                                                   (Lit |a#0@@40|))
                                                      (Lit |b#0@@15|)))))
                (let ((a!2 (and (= (type Sequences._default.replace1with2$A@@5)
                                   TyType)
                                (= (type $ly@@96) LayerTypeType)
                                (= (type |s#0@@82|) (SeqType BoxType))
                                (= (type |a#0@@40|) BoxType)
                                (= (type |b#0@@15|) BoxType)
                                (or (|Sequences.__default.replace1with2#canCall|
                                      Sequences._default.replace1with2$A@@5
                                      (Lit |s#0@@82|)
                                      (Lit |a#0@@40|)
                                      (Lit |b#0@@15|)
                                      (LitInt |pos#0@@18|))
                                    a!1)))
                      (a!4 (|Seq#Append| a!3
                                         (|Seq#Drop| (Lit |s#0@@82|)
                                                     (LitInt (INTERNAL_add_boogie
                                                               |pos#0@@18|
                                                               1))))))
                  (=> a!2
                      (= (Sequences.__default.replace1with2
                           Sequences._default.replace1with2$A@@5
                           ($LS $ly@@96)
                           (Lit |s#0@@82|)
                           (Lit |a#0@@40|)
                           (Lit |b#0@@15|)
                           (LitInt |pos#0@@18|))
                         a!4))))
                :pattern ((Sequences.__default.replace1with2
                            Sequences._default.replace1with2$A@@5
                            ($LS $ly@@96)
                            (Lit |s#0@@82|)
                            (Lit |a#0@@40|)
                            (Lit |b#0@@15|)
                            (LitInt |pos#0@@18|)))
                :weight 3
                :skolemid |2378|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@481 T@U)
         (arg1@@218 T@U)
         (arg2@@112 T@U)
         (arg3@@62 T@U)
         (arg4@@38 Int))
  (! (= (type (Sequences.__default.replace2with1
                arg0@@481
                arg1@@218
                arg2@@112
                arg3@@62
                arg4@@38))
        (SeqType BoxType))
     :pattern ((Sequences.__default.replace2with1
                 arg0@@481
                 arg1@@218
                 arg2@@112
                 arg3@@62
                 arg4@@38))
     :qid |funType:Sequences.__default.replace2with1|)))
(assert (forall ((Sequences._default.replace2with1$A T@U)
         ($ly@@97 T@U)
         (|s#0@@83| T@U)
         (|a#0@@41| T@U)
         (|pos#0@@19| Int))
  (! (=> (and (= (type Sequences._default.replace2with1$A) TyType)
              (= (type $ly@@97) LayerTypeType)
              (= (type |s#0@@83|) (SeqType BoxType))
              (= (type |a#0@@41|) BoxType))
         (= (Sequences.__default.replace2with1
              Sequences._default.replace2with1$A
              ($LS $ly@@97)
              |s#0@@83|
              |a#0@@41|
              |pos#0@@19|)
            (Sequences.__default.replace2with1
              Sequences._default.replace2with1$A
              $ly@@97
              |s#0@@83|
              |a#0@@41|
              |pos#0@@19|)))
     :pattern ((Sequences.__default.replace2with1
                 Sequences._default.replace2with1$A
                 ($LS $ly@@97)
                 |s#0@@83|
                 |a#0@@41|
                 |pos#0@@19|))
     :skolemid |2379|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.replace2with1$A@@0 T@U)
         ($ly@@98 T@U)
         (|s#0@@84| T@U)
         (|a#0@@42| T@U)
         (|pos#0@@20| Int))
  (! (=> (and (= (type Sequences._default.replace2with1$A@@0) TyType)
              (= (type $ly@@98) LayerTypeType)
              (= (type |s#0@@84|) (SeqType BoxType))
              (= (type |a#0@@42|) BoxType))
         (= (Sequences.__default.replace2with1
              Sequences._default.replace2with1$A@@0
              $ly@@98
              |s#0@@84|
              |a#0@@42|
              |pos#0@@20|)
            (Sequences.__default.replace2with1
              Sequences._default.replace2with1$A@@0
              $LZ
              |s#0@@84|
              |a#0@@42|
              |pos#0@@20|)))
     :pattern ((Sequences.__default.replace2with1
                 Sequences._default.replace2with1$A@@0
                 (AsFuelBottom $ly@@98)
                 |s#0@@84|
                 |a#0@@42|
                 |pos#0@@20|))
     :skolemid |2380|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.replace2with1$A@@1 T@U)
                    ($ly@@99 T@U)
                    (|s#0@@85| T@U)
                    (|a#0@@43| T@U)
                    (|pos#0@@21| Int))
             (! (let ((a!1 (and ($Is |s#0@@85|
                                     (TSeq Sequences._default.replace2with1$A@@1))
                                ($IsBox |a#0@@43|
                                        Sequences._default.replace2with1$A@@1)
                                (INTERNAL_le_boogie 0 |pos#0@@21|)
                                (INTERNAL_lt_boogie
                                  |pos#0@@21|
                                  (INTERNAL_sub_boogie
                                    (|Seq#Length| |s#0@@85|)
                                    1))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.replace2with1
                                                   Sequences._default.replace2with1$A@@1
                                                   $ly@@99
                                                   |s#0@@85|
                                                   |a#0@@43|
                                                   |pos#0@@21|))
                                   (INTERNAL_sub_boogie
                                     (|Seq#Length| |s#0@@85|)
                                     1))
                                (forall ((|i#0@@70| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#0@@70|)
                                                         (INTERNAL_lt_boogie
                                                           |i#0@@70|
                                                           |pos#0@@21|))
                                                    (= (|Seq#Index| (Sequences.__default.replace2with1
                                                                      Sequences._default.replace2with1$A@@1
                                                                      $ly@@99
                                                                      |s#0@@85|
                                                                      |a#0@@43|
                                                                      |pos#0@@21|)
                                                                    |i#0@@70|)
                                                       (|Seq#Index| |s#0@@85|
                                                                    |i#0@@70|)))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| |s#0@@85| |i#0@@70|))
                                     :pattern ((|Seq#Index| (Sequences.__default.replace2with1
                                                              Sequences._default.replace2with1$A@@1
                                                              $ly@@99
                                                              |s#0@@85|
                                                              |a#0@@43|
                                                              |pos#0@@21|)
                                                            |i#0@@70|))
                                     :skolemid |2381|
                                     :qid |Sequencesidfy.431:18|))
                                (forall ((|i#1@@16| Int))
                                  (! (let ((a!1 (and (INTERNAL_lt_boogie
                                                       |pos#0@@21|
                                                       |i#1@@16|)
                                                     (INTERNAL_lt_boogie
                                                       |i#1@@16|
                                                       (INTERNAL_sub_boogie
                                                         (|Seq#Length| |s#0@@85|)
                                                         1)))))
                                     (let ((a!2 (=> a!1
                                                    (= (|Seq#Index| (Sequences.__default.replace2with1
                                                                      Sequences._default.replace2with1$A@@1
                                                                      $ly@@99
                                                                      |s#0@@85|
                                                                      |a#0@@43|
                                                                      |pos#0@@21|)
                                                                    |i#1@@16|)
                                                       (|Seq#Index| |s#0@@85|
                                                                    (INTERNAL_add_boogie
                                                                      |i#1@@16|
                                                                      1))))))
                                       (=> true a!2)))
                                     :pattern ((|Seq#Index| |s#0@@85|
                                                            (INTERNAL_add_boogie
                                                              |i#1@@16|
                                                              1)))
                                     :pattern ((|Seq#Index| (Sequences.__default.replace2with1
                                                              Sequences._default.replace2with1$A@@1
                                                              $ly@@99
                                                              |s#0@@85|
                                                              |a#0@@43|
                                                              |pos#0@@21|)
                                                            |i#1@@16|))
                                     :skolemid |2382|
                                     :qid |Sequencesidfy.432:18|))
                                (= (|Seq#Index| (Sequences.__default.replace2with1
                                                  Sequences._default.replace2with1$A@@1
                                                  $ly@@99
                                                  |s#0@@85|
                                                  |a#0@@43|
                                                  |pos#0@@21|)
                                                |pos#0@@21|)
                                   |a#0@@43|)
                                ($Is (Sequences.__default.replace2with1
                                       Sequences._default.replace2with1$A@@1
                                       $ly@@99
                                       |s#0@@85|
                                       |a#0@@43|
                                       |pos#0@@21|)
                                     (TSeq Sequences._default.replace2with1$A@@1)))))
                  (=> (and (= (type Sequences._default.replace2with1$A@@1)
                              TyType)
                           (= (type $ly@@99) LayerTypeType)
                           (= (type |s#0@@85|) (SeqType BoxType))
                           (= (type |a#0@@43|) BoxType)
                           (or (|Sequences.__default.replace2with1#canCall|
                                 Sequences._default.replace2with1$A@@1
                                 |s#0@@85|
                                 |a#0@@43|
                                 |pos#0@@21|)
                               a!1))
                      a!2))
                :pattern ((Sequences.__default.replace2with1
                            Sequences._default.replace2with1$A@@1
                            $ly@@99
                            |s#0@@85|
                            |a#0@@43|
                            |pos#0@@21|))
                :skolemid |2383|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.replace2with1$A@@2 T@U)
         ($ly@@100 T@U)
         (|s#0@@86| T@U)
         (|a#0@@44| T@U)
         (|pos#0@@22| Int))
  (! (let ((a!1 (and (INTERNAL_le_boogie 0 |pos#0@@22|)
                     (INTERNAL_lt_boogie
                       |pos#0@@22|
                       (INTERNAL_sub_boogie (|Seq#Length| |s#0@@86|) 1)))))
       (=> (and (= (type Sequences._default.replace2with1$A@@2) TyType)
                (= (type $ly@@100) LayerTypeType)
                (= (type |s#0@@86|) (SeqType BoxType))
                (= (type |a#0@@44|) BoxType)
                ($Is |s#0@@86| (TSeq Sequences._default.replace2with1$A@@2))
                ($IsBox |a#0@@44| Sequences._default.replace2with1$A@@2))
           (= (|Sequences.__default.replace2with1#requires|
                Sequences._default.replace2with1$A@@2
                $ly@@100
                |s#0@@86|
                |a#0@@44|
                |pos#0@@22|)
              a!1)))
     :pattern ((|Sequences.__default.replace2with1#requires|
                 Sequences._default.replace2with1$A@@2
                 $ly@@100
                 |s#0@@86|
                 |a#0@@44|
                 |pos#0@@22|))
     :skolemid |2384|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.replace2with1$A@@3 T@U)
                    ($ly@@101 T@U)
                    (|s#0@@87| T@U)
                    (|a#0@@45| T@U)
                    (|pos#0@@23| Int))
             (! (let ((a!1 (and ($Is |s#0@@87|
                                     (TSeq Sequences._default.replace2with1$A@@3))
                                ($IsBox |a#0@@45|
                                        Sequences._default.replace2with1$A@@3)
                                (INTERNAL_le_boogie 0 |pos#0@@23|)
                                (INTERNAL_lt_boogie
                                  |pos#0@@23|
                                  (INTERNAL_sub_boogie
                                    (|Seq#Length| |s#0@@87|)
                                    1))))
                      (a!2 (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@87|
                                                                   |pos#0@@23|)
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |a#0@@45|))
                                         (|Seq#Drop| |s#0@@87|
                                                     (INTERNAL_add_boogie
                                                       |pos#0@@23|
                                                       2)))))
                  (=> (and (= (type Sequences._default.replace2with1$A@@3)
                              TyType)
                           (= (type $ly@@101) LayerTypeType)
                           (= (type |s#0@@87|) (SeqType BoxType))
                           (= (type |a#0@@45|) BoxType)
                           (or (|Sequences.__default.replace2with1#canCall|
                                 Sequences._default.replace2with1$A@@3
                                 |s#0@@87|
                                 |a#0@@45|
                                 |pos#0@@23|)
                               a!1))
                      (= (Sequences.__default.replace2with1
                           Sequences._default.replace2with1$A@@3
                           ($LS $ly@@101)
                           |s#0@@87|
                           |a#0@@45|
                           |pos#0@@23|)
                         a!2)))
                :pattern ((Sequences.__default.replace2with1
                            Sequences._default.replace2with1$A@@3
                            ($LS $ly@@101)
                            |s#0@@87|
                            |a#0@@45|
                            |pos#0@@23|))
                :skolemid |2385|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.replace2with1$A@@4 T@U)
                    ($ly@@102 T@U)
                    (|s#0@@88| T@U)
                    (|a#0@@46| T@U)
                    (|pos#0@@24| Int))
             (! (let ((a!1 (INTERNAL_lt_boogie
                             |pos#0@@24|
                             (INTERNAL_sub_boogie
                               (|Seq#Length| (Lit |s#0@@88|))
                               1)))
                      (a!3 (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@88|)
                                                                   (LitInt |pos#0@@24|))
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |a#0@@46|))
                                         (|Seq#Drop| (Lit |s#0@@88|)
                                                     (LitInt (INTERNAL_add_boogie
                                                               |pos#0@@24|
                                                               2))))))
                (let ((a!2 (or (|Sequences.__default.replace2with1#canCall|
                                 Sequences._default.replace2with1$A@@4
                                 (Lit |s#0@@88|)
                                 |a#0@@46|
                                 (LitInt |pos#0@@24|))
                               (and ($Is |s#0@@88|
                                         (TSeq Sequences._default.replace2with1$A@@4))
                                    ($IsBox |a#0@@46|
                                            Sequences._default.replace2with1$A@@4)
                                    (INTERNAL_le_boogie 0 |pos#0@@24|)
                                    a!1))))
                  (=> (and (= (type Sequences._default.replace2with1$A@@4)
                              TyType)
                           (= (type $ly@@102) LayerTypeType)
                           (= (type |s#0@@88|) (SeqType BoxType))
                           (= (type |a#0@@46|) BoxType)
                           a!2)
                      (= (Sequences.__default.replace2with1
                           Sequences._default.replace2with1$A@@4
                           ($LS $ly@@102)
                           (Lit |s#0@@88|)
                           |a#0@@46|
                           (LitInt |pos#0@@24|))
                         a!3))))
                :pattern ((Sequences.__default.replace2with1
                            Sequences._default.replace2with1$A@@4
                            ($LS $ly@@102)
                            (Lit |s#0@@88|)
                            |a#0@@46|
                            (LitInt |pos#0@@24|)))
                :weight 3
                :skolemid |2386|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.replace2with1$A@@5 T@U)
                    ($ly@@103 T@U)
                    (|s#0@@89| T@U)
                    (|a#0@@47| T@U)
                    (|pos#0@@25| Int))
             (! (let ((a!1 (INTERNAL_lt_boogie
                             |pos#0@@25|
                             (INTERNAL_sub_boogie
                               (|Seq#Length| (Lit |s#0@@89|))
                               1)))
                      (a!3 (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@89|)
                                                                   (LitInt |pos#0@@25|))
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    (Lit |a#0@@47|)))
                                         (|Seq#Drop| (Lit |s#0@@89|)
                                                     (LitInt (INTERNAL_add_boogie
                                                               |pos#0@@25|
                                                               2))))))
                (let ((a!2 (or (|Sequences.__default.replace2with1#canCall|
                                 Sequences._default.replace2with1$A@@5
                                 (Lit |s#0@@89|)
                                 (Lit |a#0@@47|)
                                 (LitInt |pos#0@@25|))
                               (and ($Is |s#0@@89|
                                         (TSeq Sequences._default.replace2with1$A@@5))
                                    ($IsBox |a#0@@47|
                                            Sequences._default.replace2with1$A@@5)
                                    (INTERNAL_le_boogie 0 |pos#0@@25|)
                                    a!1))))
                  (=> (and (= (type Sequences._default.replace2with1$A@@5)
                              TyType)
                           (= (type $ly@@103) LayerTypeType)
                           (= (type |s#0@@89|) (SeqType BoxType))
                           (= (type |a#0@@47|) BoxType)
                           a!2)
                      (= (Sequences.__default.replace2with1
                           Sequences._default.replace2with1$A@@5
                           ($LS $ly@@103)
                           (Lit |s#0@@89|)
                           (Lit |a#0@@47|)
                           (LitInt |pos#0@@25|))
                         a!3))))
                :pattern ((Sequences.__default.replace2with1
                            Sequences._default.replace2with1$A@@5
                            ($LS $ly@@103)
                            (Lit |s#0@@89|)
                            (Lit |a#0@@47|)
                            (LitInt |pos#0@@25|)))
                :weight 3
                :skolemid |2387|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@482 T@U) (arg1@@219 T@U) (arg2@@113 T@U) (arg3@@63 T@U))
  (! (= (type (Sequences.__default.concat
                arg0@@482
                arg1@@219
                arg2@@113
                arg3@@63))
        (SeqType BoxType))
     :pattern ((Sequences.__default.concat
                 arg0@@482
                 arg1@@219
                 arg2@@113
                 arg3@@63))
     :qid |funType:Sequences.__default.concat|)))
(assert (forall ((Sequences._default.concat$A T@U)
         ($ly@@104 T@U)
         (|a#0@@48| T@U)
         (|b#0@@16| T@U))
  (! (=> (and (= (type Sequences._default.concat$A) TyType)
              (= (type $ly@@104) LayerTypeType)
              (= (type |a#0@@48|) (SeqType BoxType))
              (= (type |b#0@@16|) (SeqType BoxType)))
         (= (Sequences.__default.concat
              Sequences._default.concat$A
              ($LS $ly@@104)
              |a#0@@48|
              |b#0@@16|)
            (Sequences.__default.concat
              Sequences._default.concat$A
              $ly@@104
              |a#0@@48|
              |b#0@@16|)))
     :pattern ((Sequences.__default.concat
                 Sequences._default.concat$A
                 ($LS $ly@@104)
                 |a#0@@48|
                 |b#0@@16|))
     :skolemid |2388|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.concat$A@@0 T@U)
         ($ly@@105 T@U)
         (|a#0@@49| T@U)
         (|b#0@@17| T@U))
  (! (=> (and (= (type Sequences._default.concat$A@@0) TyType)
              (= (type $ly@@105) LayerTypeType)
              (= (type |a#0@@49|) (SeqType BoxType))
              (= (type |b#0@@17|) (SeqType BoxType)))
         (= (Sequences.__default.concat
              Sequences._default.concat$A@@0
              $ly@@105
              |a#0@@49|
              |b#0@@17|)
            (Sequences.__default.concat
              Sequences._default.concat$A@@0
              $LZ
              |a#0@@49|
              |b#0@@17|)))
     :pattern ((Sequences.__default.concat
                 Sequences._default.concat$A@@0
                 (AsFuelBottom $ly@@105)
                 |a#0@@49|
                 |b#0@@17|))
     :skolemid |2389|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.concat$A@@1 T@U)
                    ($ly@@106 T@U)
                    (|a#0@@50| T@U)
                    (|b#0@@18| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concat#canCall|
                                 Sequences._default.concat$A@@1
                                 |a#0@@50|
                                 |b#0@@18|)
                               (and ($Is |a#0@@50|
                                         (TSeq Sequences._default.concat$A@@1))
                                    ($Is |b#0@@18|
                                         (TSeq Sequences._default.concat$A@@1)))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.concat
                                                   Sequences._default.concat$A@@1
                                                   $ly@@106
                                                   |a#0@@50|
                                                   |b#0@@18|))
                                   (INTERNAL_add_boogie
                                     (|Seq#Length| |a#0@@50|)
                                     (|Seq#Length| |b#0@@18|)))
                                (forall ((|i#0@@71| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#0@@71|)
                                                         (INTERNAL_lt_boogie
                                                           |i#0@@71|
                                                           (|Seq#Length| |a#0@@50|)))
                                                    (= (|Seq#Index| |a#0@@50|
                                                                    |i#0@@71|)
                                                       (|Seq#Index| (Sequences.__default.concat
                                                                      Sequences._default.concat$A@@1
                                                                      $ly@@106
                                                                      |a#0@@50|
                                                                      |b#0@@18|)
                                                                    |i#0@@71|)))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| (Sequences.__default.concat
                                                              Sequences._default.concat$A@@1
                                                              $ly@@106
                                                              |a#0@@50|
                                                              |b#0@@18|)
                                                            |i#0@@71|))
                                     :pattern ((|Seq#Index| |a#0@@50| |i#0@@71|))
                                     :skolemid |2390|
                                     :qid |Sequencesidfy.440:18|))
                                (forall ((|i#1@@17| Int))
                                  (! (let ((a!1 (= (|Seq#Index| |b#0@@18|
                                                                |i#1@@17|)
                                                   (|Seq#Index| (Sequences.__default.concat
                                                                  Sequences._default.concat$A@@1
                                                                  $ly@@106
                                                                  |a#0@@50|
                                                                  |b#0@@18|)
                                                                (INTERNAL_add_boogie
                                                                  (|Seq#Length| |a#0@@50|)
                                                                  |i#1@@17|)))))
                                     (let ((a!2 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#1@@17|)
                                                         (INTERNAL_lt_boogie
                                                           |i#1@@17|
                                                           (|Seq#Length| |b#0@@18|)))
                                                    a!1)))
                                       (=> true a!2)))
                                     :pattern ((|Seq#Index| (Sequences.__default.concat
                                                              Sequences._default.concat$A@@1
                                                              $ly@@106
                                                              |a#0@@50|
                                                              |b#0@@18|)
                                                            (INTERNAL_add_boogie
                                                              (|Seq#Length| |a#0@@50|)
                                                              |i#1@@17|)))
                                     :pattern ((|Seq#Index| |b#0@@18| |i#1@@17|))
                                     :skolemid |2391|
                                     :qid |Sequencesidfy.441:18|))
                                ($Is (Sequences.__default.concat
                                       Sequences._default.concat$A@@1
                                       $ly@@106
                                       |a#0@@50|
                                       |b#0@@18|)
                                     (TSeq Sequences._default.concat$A@@1)))))
                  (=> (and (= (type Sequences._default.concat$A@@1) TyType)
                           (= (type $ly@@106) LayerTypeType)
                           (= (type |a#0@@50|) (SeqType BoxType))
                           (= (type |b#0@@18|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.concat
                            Sequences._default.concat$A@@1
                            $ly@@106
                            |a#0@@50|
                            |b#0@@18|))
                :skolemid |2392|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.concat$A@@2 T@U)
         ($ly@@107 T@U)
         (|a#0@@51| T@U)
         (|b#0@@19| T@U))
  (! (=> (and (= (type Sequences._default.concat$A@@2) TyType)
              (= (type $ly@@107) LayerTypeType)
              (= (type |a#0@@51|) (SeqType BoxType))
              (= (type |b#0@@19|) (SeqType BoxType))
              ($Is |a#0@@51| (TSeq Sequences._default.concat$A@@2))
              ($Is |b#0@@19| (TSeq Sequences._default.concat$A@@2)))
         (= (|Sequences.__default.concat#requires|
              Sequences._default.concat$A@@2
              $ly@@107
              |a#0@@51|
              |b#0@@19|)
            true))
     :pattern ((|Sequences.__default.concat#requires|
                 Sequences._default.concat$A@@2
                 $ly@@107
                 |a#0@@51|
                 |b#0@@19|))
     :skolemid |2393|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.concat$A@@3 T@U)
                    ($ly@@108 T@U)
                    (|a#0@@52| T@U)
                    (|b#0@@20| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concat#canCall|
                                 Sequences._default.concat$A@@3
                                 |a#0@@52|
                                 |b#0@@20|)
                               (and ($Is |a#0@@52|
                                         (TSeq Sequences._default.concat$A@@3))
                                    ($Is |b#0@@20|
                                         (TSeq Sequences._default.concat$A@@3))))))
                  (=> (and (= (type Sequences._default.concat$A@@3) TyType)
                           (= (type $ly@@108) LayerTypeType)
                           (= (type |a#0@@52|) (SeqType BoxType))
                           (= (type |b#0@@20|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.concat
                           Sequences._default.concat$A@@3
                           ($LS $ly@@108)
                           |a#0@@52|
                           |b#0@@20|)
                         (|Seq#Append| |a#0@@52| |b#0@@20|))))
                :pattern ((Sequences.__default.concat
                            Sequences._default.concat$A@@3
                            ($LS $ly@@108)
                            |a#0@@52|
                            |b#0@@20|))
                :skolemid |2394|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.concat$A@@4 T@U)
                    ($ly@@109 T@U)
                    (|a#0@@53| T@U)
                    (|b#0@@21| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concat#canCall|
                                 Sequences._default.concat$A@@4
                                 (Lit |a#0@@53|)
                                 (Lit |b#0@@21|))
                               (and ($Is |a#0@@53|
                                         (TSeq Sequences._default.concat$A@@4))
                                    ($Is |b#0@@21|
                                         (TSeq Sequences._default.concat$A@@4))))))
                  (=> (and (= (type Sequences._default.concat$A@@4) TyType)
                           (= (type $ly@@109) LayerTypeType)
                           (= (type |a#0@@53|) (SeqType BoxType))
                           (= (type |b#0@@21|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.concat
                           Sequences._default.concat$A@@4
                           ($LS $ly@@109)
                           (Lit |a#0@@53|)
                           (Lit |b#0@@21|))
                         (|Seq#Append| |a#0@@53| |b#0@@21|))))
                :pattern ((Sequences.__default.concat
                            Sequences._default.concat$A@@4
                            ($LS $ly@@109)
                            (Lit |a#0@@53|)
                            (Lit |b#0@@21|)))
                :weight 3
                :skolemid |2395|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@483 T@U)
         (arg1@@220 T@U)
         (arg2@@114 T@U)
         (arg3@@64 T@U)
         (arg4@@39 T@U))
  (! (= (type (Sequences.__default.concat3
                arg0@@483
                arg1@@220
                arg2@@114
                arg3@@64
                arg4@@39))
        (SeqType BoxType))
     :pattern ((Sequences.__default.concat3
                 arg0@@483
                 arg1@@220
                 arg2@@114
                 arg3@@64
                 arg4@@39))
     :qid |funType:Sequences.__default.concat3|)))
(assert (forall ((Sequences._default.concat3$A T@U)
         ($ly@@110 T@U)
         (|a#0@@54| T@U)
         (|b#0@@22| T@U)
         (|c#0@@3| T@U))
  (! (=> (and (= (type Sequences._default.concat3$A) TyType)
              (= (type $ly@@110) LayerTypeType)
              (= (type |a#0@@54|) (SeqType BoxType))
              (= (type |b#0@@22|) BoxType)
              (= (type |c#0@@3|) (SeqType BoxType)))
         (= (Sequences.__default.concat3
              Sequences._default.concat3$A
              ($LS $ly@@110)
              |a#0@@54|
              |b#0@@22|
              |c#0@@3|)
            (Sequences.__default.concat3
              Sequences._default.concat3$A
              $ly@@110
              |a#0@@54|
              |b#0@@22|
              |c#0@@3|)))
     :pattern ((Sequences.__default.concat3
                 Sequences._default.concat3$A
                 ($LS $ly@@110)
                 |a#0@@54|
                 |b#0@@22|
                 |c#0@@3|))
     :skolemid |2396|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.concat3$A@@0 T@U)
         ($ly@@111 T@U)
         (|a#0@@55| T@U)
         (|b#0@@23| T@U)
         (|c#0@@4| T@U))
  (! (=> (and (= (type Sequences._default.concat3$A@@0) TyType)
              (= (type $ly@@111) LayerTypeType)
              (= (type |a#0@@55|) (SeqType BoxType))
              (= (type |b#0@@23|) BoxType)
              (= (type |c#0@@4|) (SeqType BoxType)))
         (= (Sequences.__default.concat3
              Sequences._default.concat3$A@@0
              $ly@@111
              |a#0@@55|
              |b#0@@23|
              |c#0@@4|)
            (Sequences.__default.concat3
              Sequences._default.concat3$A@@0
              $LZ
              |a#0@@55|
              |b#0@@23|
              |c#0@@4|)))
     :pattern ((Sequences.__default.concat3
                 Sequences._default.concat3$A@@0
                 (AsFuelBottom $ly@@111)
                 |a#0@@55|
                 |b#0@@23|
                 |c#0@@4|))
     :skolemid |2397|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.concat3$A@@1 T@U)
                    ($ly@@112 T@U)
                    (|a#0@@56| T@U)
                    (|b#0@@24| T@U)
                    (|c#0@@5| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concat3#canCall|
                                 Sequences._default.concat3$A@@1
                                 |a#0@@56|
                                 |b#0@@24|
                                 |c#0@@5|)
                               (and ($Is |a#0@@56|
                                         (TSeq Sequences._default.concat3$A@@1))
                                    ($IsBox |b#0@@24|
                                            Sequences._default.concat3$A@@1)
                                    ($Is |c#0@@5|
                                         (TSeq Sequences._default.concat3$A@@1)))))
                      (a!2 (= (|Seq#Length| (Sequences.__default.concat3
                                              Sequences._default.concat3$A@@1
                                              $ly@@112
                                              |a#0@@56|
                                              |b#0@@24|
                                              |c#0@@5|))
                              (INTERNAL_add_boogie
                                (INTERNAL_add_boogie
                                  (|Seq#Length| |a#0@@56|)
                                  (|Seq#Length| |c#0@@5|))
                                1))))
                (let ((a!3 (and a!2
                                (forall ((|i#0@@72| Int))
                                  (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#0@@72|)
                                                         (INTERNAL_lt_boogie
                                                           |i#0@@72|
                                                           (|Seq#Length| |a#0@@56|)))
                                                    (= (|Seq#Index| |a#0@@56|
                                                                    |i#0@@72|)
                                                       (|Seq#Index| (Sequences.__default.concat3
                                                                      Sequences._default.concat3$A@@1
                                                                      $ly@@112
                                                                      |a#0@@56|
                                                                      |b#0@@24|
                                                                      |c#0@@5|)
                                                                    |i#0@@72|)))))
                                       (=> true a!1))
                                     :pattern ((|Seq#Index| (Sequences.__default.concat3
                                                              Sequences._default.concat3$A@@1
                                                              $ly@@112
                                                              |a#0@@56|
                                                              |b#0@@24|
                                                              |c#0@@5|)
                                                            |i#0@@72|))
                                     :pattern ((|Seq#Index| |a#0@@56| |i#0@@72|))
                                     :skolemid |2398|
                                     :qid |Sequencesidfy.448:18|))
                                (= (|Seq#Index| (Sequences.__default.concat3
                                                  Sequences._default.concat3$A@@1
                                                  $ly@@112
                                                  |a#0@@56|
                                                  |b#0@@24|
                                                  |c#0@@5|)
                                                (|Seq#Length| |a#0@@56|))
                                   |b#0@@24|)
                                (forall ((|i#1@@18| Int))
                                  (! (let ((a!1 (|Seq#Index| (Sequences.__default.concat3
                                                               Sequences._default.concat3$A@@1
                                                               $ly@@112
                                                               |a#0@@56|
                                                               |b#0@@24|
                                                               |c#0@@5|)
                                                             (INTERNAL_add_boogie
                                                               (INTERNAL_add_boogie
                                                                 (|Seq#Length| |a#0@@56|)
                                                                 1)
                                                               |i#1@@18|))))
                                     (let ((a!2 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#1@@18|)
                                                         (INTERNAL_lt_boogie
                                                           |i#1@@18|
                                                           (|Seq#Length| |c#0@@5|)))
                                                    (= (|Seq#Index| |c#0@@5|
                                                                    |i#1@@18|)
                                                       a!1))))
                                       (=> true a!2)))
                                     :pattern ((|Seq#Index| (Sequences.__default.concat3
                                                              Sequences._default.concat3$A@@1
                                                              $ly@@112
                                                              |a#0@@56|
                                                              |b#0@@24|
                                                              |c#0@@5|)
                                                            (INTERNAL_add_boogie
                                                              (INTERNAL_add_boogie
                                                                (|Seq#Length| |a#0@@56|)
                                                                1)
                                                              |i#1@@18|)))
                                     :pattern ((|Seq#Index| |c#0@@5| |i#1@@18|))
                                     :skolemid |2399|
                                     :qid |Sequencesidfy.450:18|))
                                ($Is (Sequences.__default.concat3
                                       Sequences._default.concat3$A@@1
                                       $ly@@112
                                       |a#0@@56|
                                       |b#0@@24|
                                       |c#0@@5|)
                                     (TSeq Sequences._default.concat3$A@@1)))))
                  (=> (and (= (type Sequences._default.concat3$A@@1) TyType)
                           (= (type $ly@@112) LayerTypeType)
                           (= (type |a#0@@56|) (SeqType BoxType))
                           (= (type |b#0@@24|) BoxType)
                           (= (type |c#0@@5|) (SeqType BoxType))
                           a!1)
                      a!3)))
                :pattern ((Sequences.__default.concat3
                            Sequences._default.concat3$A@@1
                            $ly@@112
                            |a#0@@56|
                            |b#0@@24|
                            |c#0@@5|))
                :skolemid |2400|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.concat3$A@@2 T@U)
         ($ly@@113 T@U)
         (|a#0@@57| T@U)
         (|b#0@@25| T@U)
         (|c#0@@6| T@U))
  (! (=> (and (= (type Sequences._default.concat3$A@@2) TyType)
              (= (type $ly@@113) LayerTypeType)
              (= (type |a#0@@57|) (SeqType BoxType))
              (= (type |b#0@@25|) BoxType)
              (= (type |c#0@@6|) (SeqType BoxType))
              ($Is |a#0@@57| (TSeq Sequences._default.concat3$A@@2))
              ($IsBox |b#0@@25| Sequences._default.concat3$A@@2)
              ($Is |c#0@@6| (TSeq Sequences._default.concat3$A@@2)))
         (= (|Sequences.__default.concat3#requires|
              Sequences._default.concat3$A@@2
              $ly@@113
              |a#0@@57|
              |b#0@@25|
              |c#0@@6|)
            true))
     :pattern ((|Sequences.__default.concat3#requires|
                 Sequences._default.concat3$A@@2
                 $ly@@113
                 |a#0@@57|
                 |b#0@@25|
                 |c#0@@6|))
     :skolemid |2401|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.concat3$A@@3 T@U)
                    ($ly@@114 T@U)
                    (|a#0@@58| T@U)
                    (|b#0@@26| T@U)
                    (|c#0@@7| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concat3#canCall|
                                 Sequences._default.concat3$A@@3
                                 |a#0@@58|
                                 |b#0@@26|
                                 |c#0@@7|)
                               (and ($Is |a#0@@58|
                                         (TSeq Sequences._default.concat3$A@@3))
                                    ($IsBox |b#0@@26|
                                            Sequences._default.concat3$A@@3)
                                    ($Is |c#0@@7|
                                         (TSeq Sequences._default.concat3$A@@3)))))
                      (a!2 (|Seq#Append| (|Seq#Append| |a#0@@58|
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |b#0@@26|))
                                         |c#0@@7|)))
                  (=> (and (= (type Sequences._default.concat3$A@@3) TyType)
                           (= (type $ly@@114) LayerTypeType)
                           (= (type |a#0@@58|) (SeqType BoxType))
                           (= (type |b#0@@26|) BoxType)
                           (= (type |c#0@@7|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.concat3
                           Sequences._default.concat3$A@@3
                           ($LS $ly@@114)
                           |a#0@@58|
                           |b#0@@26|
                           |c#0@@7|)
                         a!2)))
                :pattern ((Sequences.__default.concat3
                            Sequences._default.concat3$A@@3
                            ($LS $ly@@114)
                            |a#0@@58|
                            |b#0@@26|
                            |c#0@@7|))
                :skolemid |2402|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.concat3$A@@4 T@U)
                    ($ly@@115 T@U)
                    (|a#0@@59| T@U)
                    (|b#0@@27| T@U)
                    (|c#0@@8| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concat3#canCall|
                                 Sequences._default.concat3$A@@4
                                 (Lit |a#0@@59|)
                                 |b#0@@27|
                                 (Lit |c#0@@8|))
                               (and ($Is |a#0@@59|
                                         (TSeq Sequences._default.concat3$A@@4))
                                    ($IsBox |b#0@@27|
                                            Sequences._default.concat3$A@@4)
                                    ($Is |c#0@@8|
                                         (TSeq Sequences._default.concat3$A@@4)))))
                      (a!2 (|Seq#Append| (|Seq#Append| |a#0@@59|
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |b#0@@27|))
                                         |c#0@@8|)))
                  (=> (and (= (type Sequences._default.concat3$A@@4) TyType)
                           (= (type $ly@@115) LayerTypeType)
                           (= (type |a#0@@59|) (SeqType BoxType))
                           (= (type |b#0@@27|) BoxType)
                           (= (type |c#0@@8|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.concat3
                           Sequences._default.concat3$A@@4
                           ($LS $ly@@115)
                           (Lit |a#0@@59|)
                           |b#0@@27|
                           (Lit |c#0@@8|))
                         a!2)))
                :pattern ((Sequences.__default.concat3
                            Sequences._default.concat3$A@@4
                            ($LS $ly@@115)
                            (Lit |a#0@@59|)
                            |b#0@@27|
                            (Lit |c#0@@8|)))
                :weight 3
                :skolemid |2403|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.concat3$A@@5 T@U)
                    ($ly@@116 T@U)
                    (|a#0@@60| T@U)
                    (|b#0@@28| T@U)
                    (|c#0@@9| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concat3#canCall|
                                 Sequences._default.concat3$A@@5
                                 (Lit |a#0@@60|)
                                 (Lit |b#0@@28|)
                                 (Lit |c#0@@9|))
                               (and ($Is |a#0@@60|
                                         (TSeq Sequences._default.concat3$A@@5))
                                    ($IsBox |b#0@@28|
                                            Sequences._default.concat3$A@@5)
                                    ($Is |c#0@@9|
                                         (TSeq Sequences._default.concat3$A@@5)))))
                      (a!2 (|Seq#Append| (|Seq#Append| |a#0@@60|
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    (Lit |b#0@@28|)))
                                         |c#0@@9|)))
                  (=> (and (= (type Sequences._default.concat3$A@@5) TyType)
                           (= (type $ly@@116) LayerTypeType)
                           (= (type |a#0@@60|) (SeqType BoxType))
                           (= (type |b#0@@28|) BoxType)
                           (= (type |c#0@@9|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.concat3
                           Sequences._default.concat3$A@@5
                           ($LS $ly@@116)
                           (Lit |a#0@@60|)
                           (Lit |b#0@@28|)
                           (Lit |c#0@@9|))
                         a!2)))
                :pattern ((Sequences.__default.concat3
                            Sequences._default.concat3$A@@5
                            ($LS $ly@@116)
                            (Lit |a#0@@60|)
                            (Lit |b#0@@28|)
                            (Lit |c#0@@9|)))
                :weight 3
                :skolemid |2404|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@484 T@U) (arg1@@221 T@U) (arg2@@115 T@U))
  (! (= (type (Sequences.__default.concatSeq arg0@@484 arg1@@221 arg2@@115))
        (SeqType BoxType))
     :pattern ((Sequences.__default.concatSeq arg0@@484 arg1@@221 arg2@@115))
     :qid |funType:Sequences.__default.concatSeq|)))
(assert (forall ((Sequences._default.concatSeq$A T@U) ($ly@@117 T@U) (|a#0@@61| T@U))
  (! (=> (and (= (type Sequences._default.concatSeq$A) TyType)
              (= (type $ly@@117) LayerTypeType)
              (= (type |a#0@@61|) (SeqType BoxType)))
         (= (Sequences.__default.concatSeq
              Sequences._default.concatSeq$A
              ($LS $ly@@117)
              |a#0@@61|)
            (Sequences.__default.concatSeq
              Sequences._default.concatSeq$A
              $ly@@117
              |a#0@@61|)))
     :pattern ((Sequences.__default.concatSeq
                 Sequences._default.concatSeq$A
                 ($LS $ly@@117)
                 |a#0@@61|))
     :skolemid |2405|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.concatSeq$A@@0 T@U) ($ly@@118 T@U) (|a#0@@62| T@U))
  (! (=> (and (= (type Sequences._default.concatSeq$A@@0) TyType)
              (= (type $ly@@118) LayerTypeType)
              (= (type |a#0@@62|) (SeqType BoxType)))
         (= (Sequences.__default.concatSeq
              Sequences._default.concatSeq$A@@0
              $ly@@118
              |a#0@@62|)
            (Sequences.__default.concatSeq
              Sequences._default.concatSeq$A@@0
              $LZ
              |a#0@@62|)))
     :pattern ((Sequences.__default.concatSeq
                 Sequences._default.concatSeq$A@@0
                 (AsFuelBottom $ly@@118)
                 |a#0@@62|))
     :skolemid |2406|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.concatSeq$A@@1 T@U)
                    ($ly@@119 T@U)
                    (|a#0@@63| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concatSeq#canCall|
                                 Sequences._default.concatSeq$A@@1
                                 |a#0@@63|)
                               ($Is |a#0@@63|
                                    (TSeq (TSeq Sequences._default.concatSeq$A@@1))))))
                  (=> (and (= (type Sequences._default.concatSeq$A@@1) TyType)
                           (= (type $ly@@119) LayerTypeType)
                           (= (type |a#0@@63|) (SeqType BoxType))
                           a!1)
                      ($Is (Sequences.__default.concatSeq
                             Sequences._default.concatSeq$A@@1
                             $ly@@119
                             |a#0@@63|)
                           (TSeq Sequences._default.concatSeq$A@@1))))
                :pattern ((Sequences.__default.concatSeq
                            Sequences._default.concatSeq$A@@1
                            $ly@@119
                            |a#0@@63|))
                :skolemid |2407|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.concatSeq$A@@2 T@U) ($ly@@120 T@U) (|a#0@@64| T@U))
  (! (let ((a!1 (and (= (type Sequences._default.concatSeq$A@@2) TyType)
                     (= (type $ly@@120) LayerTypeType)
                     (= (type |a#0@@64|) (SeqType BoxType))
                     ($Is |a#0@@64|
                          (TSeq (TSeq Sequences._default.concatSeq$A@@2))))))
       (=> a!1
           (= (|Sequences.__default.concatSeq#requires|
                Sequences._default.concatSeq$A@@2
                $ly@@120
                |a#0@@64|)
              true)))
     :pattern ((|Sequences.__default.concatSeq#requires|
                 Sequences._default.concatSeq$A@@2
                 $ly@@120
                 |a#0@@64|))
     :skolemid |2408|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.concatSeq$A@@3 T@U)
                    ($ly@@121 T@U)
                    (|a#0@@65| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concatSeq#canCall|
                                 Sequences._default.concatSeq$A@@3
                                 |a#0@@65|)
                               ($Is |a#0@@65|
                                    (TSeq (TSeq Sequences._default.concatSeq$A@@3)))))
                      (a!2 (and (|Sequences.__default.DropLast#canCall|
                                  (TSeq Sequences._default.concatSeq$A@@3)
                                  |a#0@@65|)
                                (|Sequences.__default.concatSeq#canCall|
                                  Sequences._default.concatSeq$A@@3
                                  (Sequences.__default.DropLast
                                    (TSeq Sequences._default.concatSeq$A@@3)
                                    |a#0@@65|))
                                (|Sequences.__default.Last#canCall|
                                  (TSeq Sequences._default.concatSeq$A@@3)
                                  |a#0@@65|)))
                      (a!4 (|Seq#Append| (Sequences.__default.concatSeq
                                           Sequences._default.concatSeq$A@@3
                                           $ly@@121
                                           (Sequences.__default.DropLast
                                             (TSeq Sequences._default.concatSeq$A@@3)
                                             |a#0@@65|))
                                         ($Unbox (SeqType BoxType)
                                                 (Sequences.__default.Last
                                                   (TSeq Sequences._default.concatSeq$A@@3)
                                                   |a#0@@65|)))))
                (let ((a!3 (=> (not (= (|Seq#Length| |a#0@@65|) (LitInt 0)))
                               a!2))
                      (a!5 (= (Sequences.__default.concatSeq
                                Sequences._default.concatSeq$A@@3
                                ($LS $ly@@121)
                                |a#0@@65|)
                              (ite (= (|Seq#Length| |a#0@@65|) (LitInt 0))
                                   (|Seq#Empty| BoxType)
                                   a!4))))
                  (=> (and (= (type Sequences._default.concatSeq$A@@3) TyType)
                           (= (type $ly@@121) LayerTypeType)
                           (= (type |a#0@@65|) (SeqType BoxType))
                           a!1)
                      (and a!3 a!5))))
                :pattern ((Sequences.__default.concatSeq
                            Sequences._default.concatSeq$A@@3
                            ($LS $ly@@121)
                            |a#0@@65|))
                :skolemid |2409|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.concatSeq$A@@4 T@U)
                    ($ly@@122 T@U)
                    (|a#0@@66| T@U))
             (! (let ((a!1 (or (|Sequences.__default.concatSeq#canCall|
                                 Sequences._default.concatSeq$A@@4
                                 (Lit |a#0@@66|))
                               ($Is |a#0@@66|
                                    (TSeq (TSeq Sequences._default.concatSeq$A@@4)))))
                      (a!2 (not (= (|Seq#Length| (Lit |a#0@@66|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.concatSeq#canCall|
                             Sequences._default.concatSeq$A@@4
                             (Lit (Sequences.__default.DropLast
                                    (TSeq Sequences._default.concatSeq$A@@4)
                                    (Lit |a#0@@66|)))))
                      (a!5 (Sequences.__default.concatSeq
                             Sequences._default.concatSeq$A@@4
                             ($LS $ly@@122)
                             (Lit (Sequences.__default.DropLast
                                    (TSeq Sequences._default.concatSeq$A@@4)
                                    (Lit |a#0@@66|))))))
                (let ((a!4 (=> a!2
                               (and (|Sequences.__default.DropLast#canCall|
                                      (TSeq Sequences._default.concatSeq$A@@4)
                                      (Lit |a#0@@66|))
                                    a!3
                                    (|Sequences.__default.Last#canCall|
                                      (TSeq Sequences._default.concatSeq$A@@4)
                                      (Lit |a#0@@66|)))))
                      (a!6 (|Seq#Append| a!5
                                         ($Unbox (SeqType BoxType)
                                                 (Sequences.__default.Last
                                                   (TSeq Sequences._default.concatSeq$A@@4)
                                                   (Lit |a#0@@66|))))))
                (let ((a!7 (ite (= (|Seq#Length| (Lit |a#0@@66|)) (LitInt 0))
                                (|Seq#Empty| BoxType)
                                a!6)))
                (let ((a!8 (and a!4
                                (= (Sequences.__default.concatSeq
                                     Sequences._default.concatSeq$A@@4
                                     ($LS $ly@@122)
                                     (Lit |a#0@@66|))
                                   a!7))))
                  (=> (and (= (type Sequences._default.concatSeq$A@@4) TyType)
                           (= (type $ly@@122) LayerTypeType)
                           (= (type |a#0@@66|) (SeqType BoxType))
                           a!1)
                      a!8)))))
                :pattern ((Sequences.__default.concatSeq
                            Sequences._default.concatSeq$A@@4
                            ($LS $ly@@122)
                            (Lit |a#0@@66|)))
                :weight 3
                :skolemid |2410|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.IsPrefix$A T@U)
         ($ly@@123 T@U)
         (|a#0@@67| T@U)
         (|b#0@@29| T@U))
  (! (=> (and (= (type Sequences._default.IsPrefix$A) TyType)
              (= (type $ly@@123) LayerTypeType)
              (= (type |a#0@@67|) (SeqType BoxType))
              (= (type |b#0@@29|) (SeqType BoxType)))
         (= (Sequences.__default.IsPrefix
              Sequences._default.IsPrefix$A
              ($LS $ly@@123)
              |a#0@@67|
              |b#0@@29|)
            (Sequences.__default.IsPrefix
              Sequences._default.IsPrefix$A
              $ly@@123
              |a#0@@67|
              |b#0@@29|)))
     :pattern ((Sequences.__default.IsPrefix
                 Sequences._default.IsPrefix$A
                 ($LS $ly@@123)
                 |a#0@@67|
                 |b#0@@29|))
     :skolemid |2411|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.IsPrefix$A@@0 T@U)
         ($ly@@124 T@U)
         (|a#0@@68| T@U)
         (|b#0@@30| T@U))
  (! (=> (and (= (type Sequences._default.IsPrefix$A@@0) TyType)
              (= (type $ly@@124) LayerTypeType)
              (= (type |a#0@@68|) (SeqType BoxType))
              (= (type |b#0@@30|) (SeqType BoxType)))
         (= (Sequences.__default.IsPrefix
              Sequences._default.IsPrefix$A@@0
              $ly@@124
              |a#0@@68|
              |b#0@@30|)
            (Sequences.__default.IsPrefix
              Sequences._default.IsPrefix$A@@0
              $LZ
              |a#0@@68|
              |b#0@@30|)))
     :pattern ((Sequences.__default.IsPrefix
                 Sequences._default.IsPrefix$A@@0
                 (AsFuelBottom $ly@@124)
                 |a#0@@68|
                 |b#0@@30|))
     :skolemid |2412|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.IsPrefix$A@@1 T@U)
                    ($ly@@125 T@U)
                    (|a#0@@69| T@U)
                    (|b#0@@31| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IsPrefix#canCall|
                                 Sequences._default.IsPrefix$A@@1
                                 |a#0@@69|
                                 |b#0@@31|)
                               (and ($Is |a#0@@69|
                                         (TSeq Sequences._default.IsPrefix$A@@1))
                                    ($Is |b#0@@31|
                                         (TSeq Sequences._default.IsPrefix$A@@1))))))
                  (=> (and (= (type Sequences._default.IsPrefix$A@@1) TyType)
                           (= (type $ly@@125) LayerTypeType)
                           (= (type |a#0@@69|) (SeqType BoxType))
                           (= (type |b#0@@31|) (SeqType BoxType))
                           a!1
                           (Sequences.__default.IsPrefix
                             Sequences._default.IsPrefix$A@@1
                             $ly@@125
                             |a#0@@69|
                             |b#0@@31|))
                      (INTERNAL_le_boogie
                        (|Seq#Length| |a#0@@69|)
                        (|Seq#Length| |b#0@@31|))))
                :pattern ((Sequences.__default.IsPrefix
                            Sequences._default.IsPrefix$A@@1
                            $ly@@125
                            |a#0@@69|
                            |b#0@@31|))
                :skolemid |2413|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.IsPrefix$A@@2 T@U)
         ($ly@@126 T@U)
         (|a#0@@70| T@U)
         (|b#0@@32| T@U))
  (! (=> (and (= (type Sequences._default.IsPrefix$A@@2) TyType)
              (= (type $ly@@126) LayerTypeType)
              (= (type |a#0@@70|) (SeqType BoxType))
              (= (type |b#0@@32|) (SeqType BoxType))
              ($Is |a#0@@70| (TSeq Sequences._default.IsPrefix$A@@2))
              ($Is |b#0@@32| (TSeq Sequences._default.IsPrefix$A@@2)))
         (= (|Sequences.__default.IsPrefix#requires|
              Sequences._default.IsPrefix$A@@2
              $ly@@126
              |a#0@@70|
              |b#0@@32|)
            true))
     :pattern ((|Sequences.__default.IsPrefix#requires|
                 Sequences._default.IsPrefix$A@@2
                 $ly@@126
                 |a#0@@70|
                 |b#0@@32|))
     :skolemid |2414|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.IsPrefix$A@@3 T@U)
                    ($ly@@127 T@U)
                    (|a#0@@71| T@U)
                    (|b#0@@33| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IsPrefix#canCall|
                                 Sequences._default.IsPrefix$A@@3
                                 |a#0@@71|
                                 |b#0@@33|)
                               (and ($Is |a#0@@71|
                                         (TSeq Sequences._default.IsPrefix$A@@3))
                                    ($Is |b#0@@33|
                                         (TSeq Sequences._default.IsPrefix$A@@3)))))
                      (a!2 (and (INTERNAL_le_boogie
                                  (|Seq#Length| |a#0@@71|)
                                  (|Seq#Length| |b#0@@33|))
                                (|Seq#Equal| |a#0@@71|
                                             (|Seq#Take| |b#0@@33|
                                                         (|Seq#Length| |a#0@@71|))))))
                  (=> (and (= (type Sequences._default.IsPrefix$A@@3) TyType)
                           (= (type $ly@@127) LayerTypeType)
                           (= (type |a#0@@71|) (SeqType BoxType))
                           (= (type |b#0@@33|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.IsPrefix
                           Sequences._default.IsPrefix$A@@3
                           ($LS $ly@@127)
                           |a#0@@71|
                           |b#0@@33|)
                         a!2)))
                :pattern ((Sequences.__default.IsPrefix
                            Sequences._default.IsPrefix$A@@3
                            ($LS $ly@@127)
                            |a#0@@71|
                            |b#0@@33|))
                :skolemid |2415|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.IsPrefix$A@@4 T@U)
                    ($ly@@128 T@U)
                    (|a#0@@72| T@U)
                    (|b#0@@34| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IsPrefix#canCall|
                                 Sequences._default.IsPrefix$A@@4
                                 (Lit |a#0@@72|)
                                 (Lit |b#0@@34|))
                               (and ($Is |a#0@@72|
                                         (TSeq Sequences._default.IsPrefix$A@@4))
                                    ($Is |b#0@@34|
                                         (TSeq Sequences._default.IsPrefix$A@@4)))))
                      (a!2 (|Seq#Equal| |a#0@@72|
                                        (|Seq#Take| (Lit |b#0@@34|)
                                                    (|Seq#Length| (Lit |a#0@@72|))))))
                (let ((a!3 (and (INTERNAL_le_boogie
                                  (|Seq#Length| (Lit |a#0@@72|))
                                  (|Seq#Length| (Lit |b#0@@34|)))
                                a!2)))
                  (=> (and (= (type Sequences._default.IsPrefix$A@@4) TyType)
                           (= (type $ly@@128) LayerTypeType)
                           (= (type |a#0@@72|) (SeqType BoxType))
                           (= (type |b#0@@34|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.IsPrefix
                           Sequences._default.IsPrefix$A@@4
                           ($LS $ly@@128)
                           (Lit |a#0@@72|)
                           (Lit |b#0@@34|))
                         a!3))))
                :pattern ((Sequences.__default.IsPrefix
                            Sequences._default.IsPrefix$A@@4
                            ($LS $ly@@128)
                            (Lit |a#0@@72|)
                            (Lit |b#0@@34|)))
                :weight 3
                :skolemid |2416|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.IsSuffix$A T@U)
         ($ly@@129 T@U)
         (|a#0@@73| T@U)
         (|b#0@@35| T@U))
  (! (=> (and (= (type Sequences._default.IsSuffix$A) TyType)
              (= (type $ly@@129) LayerTypeType)
              (= (type |a#0@@73|) (SeqType BoxType))
              (= (type |b#0@@35|) (SeqType BoxType)))
         (= (Sequences.__default.IsSuffix
              Sequences._default.IsSuffix$A
              ($LS $ly@@129)
              |a#0@@73|
              |b#0@@35|)
            (Sequences.__default.IsSuffix
              Sequences._default.IsSuffix$A
              $ly@@129
              |a#0@@73|
              |b#0@@35|)))
     :pattern ((Sequences.__default.IsSuffix
                 Sequences._default.IsSuffix$A
                 ($LS $ly@@129)
                 |a#0@@73|
                 |b#0@@35|))
     :skolemid |2417|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.IsSuffix$A@@0 T@U)
         ($ly@@130 T@U)
         (|a#0@@74| T@U)
         (|b#0@@36| T@U))
  (! (=> (and (= (type Sequences._default.IsSuffix$A@@0) TyType)
              (= (type $ly@@130) LayerTypeType)
              (= (type |a#0@@74|) (SeqType BoxType))
              (= (type |b#0@@36|) (SeqType BoxType)))
         (= (Sequences.__default.IsSuffix
              Sequences._default.IsSuffix$A@@0
              $ly@@130
              |a#0@@74|
              |b#0@@36|)
            (Sequences.__default.IsSuffix
              Sequences._default.IsSuffix$A@@0
              $LZ
              |a#0@@74|
              |b#0@@36|)))
     :pattern ((Sequences.__default.IsSuffix
                 Sequences._default.IsSuffix$A@@0
                 (AsFuelBottom $ly@@130)
                 |a#0@@74|
                 |b#0@@36|))
     :skolemid |2418|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.IsSuffix$A@@1 T@U)
                    ($ly@@131 T@U)
                    (|a#0@@75| T@U)
                    (|b#0@@37| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IsSuffix#canCall|
                                 Sequences._default.IsSuffix$A@@1
                                 |a#0@@75|
                                 |b#0@@37|)
                               (and ($Is |a#0@@75|
                                         (TSeq Sequences._default.IsSuffix$A@@1))
                                    ($Is |b#0@@37|
                                         (TSeq Sequences._default.IsSuffix$A@@1))))))
                  (=> (and (= (type Sequences._default.IsSuffix$A@@1) TyType)
                           (= (type $ly@@131) LayerTypeType)
                           (= (type |a#0@@75|) (SeqType BoxType))
                           (= (type |b#0@@37|) (SeqType BoxType))
                           a!1)
                      true))
                :pattern ((Sequences.__default.IsSuffix
                            Sequences._default.IsSuffix$A@@1
                            $ly@@131
                            |a#0@@75|
                            |b#0@@37|))
                :skolemid |2419|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.IsSuffix$A@@2 T@U)
         ($ly@@132 T@U)
         (|a#0@@76| T@U)
         (|b#0@@38| T@U))
  (! (=> (and (= (type Sequences._default.IsSuffix$A@@2) TyType)
              (= (type $ly@@132) LayerTypeType)
              (= (type |a#0@@76|) (SeqType BoxType))
              (= (type |b#0@@38|) (SeqType BoxType))
              ($Is |a#0@@76| (TSeq Sequences._default.IsSuffix$A@@2))
              ($Is |b#0@@38| (TSeq Sequences._default.IsSuffix$A@@2)))
         (= (|Sequences.__default.IsSuffix#requires|
              Sequences._default.IsSuffix$A@@2
              $ly@@132
              |a#0@@76|
              |b#0@@38|)
            true))
     :pattern ((|Sequences.__default.IsSuffix#requires|
                 Sequences._default.IsSuffix$A@@2
                 $ly@@132
                 |a#0@@76|
                 |b#0@@38|))
     :skolemid |2420|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.IsSuffix$A@@3 T@U)
                    ($ly@@133 T@U)
                    (|a#0@@77| T@U)
                    (|b#0@@39| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IsSuffix#canCall|
                                 Sequences._default.IsSuffix$A@@3
                                 |a#0@@77|
                                 |b#0@@39|)
                               (and ($Is |a#0@@77|
                                         (TSeq Sequences._default.IsSuffix$A@@3))
                                    ($Is |b#0@@39|
                                         (TSeq Sequences._default.IsSuffix$A@@3)))))
                      (a!2 (|Seq#Equal| |a#0@@77|
                                        (|Seq#Drop| |b#0@@39|
                                                    (INTERNAL_sub_boogie
                                                      (|Seq#Length| |b#0@@39|)
                                                      (|Seq#Length| |a#0@@77|))))))
                (let ((a!3 (= (Sequences.__default.IsSuffix
                                Sequences._default.IsSuffix$A@@3
                                ($LS $ly@@133)
                                |a#0@@77|
                                |b#0@@39|)
                              (and (INTERNAL_le_boogie
                                     (|Seq#Length| |a#0@@77|)
                                     (|Seq#Length| |b#0@@39|))
                                   a!2))))
                  (=> (and (= (type Sequences._default.IsSuffix$A@@3) TyType)
                           (= (type $ly@@133) LayerTypeType)
                           (= (type |a#0@@77|) (SeqType BoxType))
                           (= (type |b#0@@39|) (SeqType BoxType))
                           a!1)
                      a!3)))
                :pattern ((Sequences.__default.IsSuffix
                            Sequences._default.IsSuffix$A@@3
                            ($LS $ly@@133)
                            |a#0@@77|
                            |b#0@@39|))
                :skolemid |2421|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.IsSuffix$A@@4 T@U)
                    ($ly@@134 T@U)
                    (|a#0@@78| T@U)
                    (|b#0@@40| T@U))
             (! (let ((a!1 (or (|Sequences.__default.IsSuffix#canCall|
                                 Sequences._default.IsSuffix$A@@4
                                 (Lit |a#0@@78|)
                                 (Lit |b#0@@40|))
                               (and ($Is |a#0@@78|
                                         (TSeq Sequences._default.IsSuffix$A@@4))
                                    ($Is |b#0@@40|
                                         (TSeq Sequences._default.IsSuffix$A@@4)))))
                      (a!2 (|Seq#Drop| (Lit |b#0@@40|)
                                       (INTERNAL_sub_boogie
                                         (|Seq#Length| (Lit |b#0@@40|))
                                         (|Seq#Length| (Lit |a#0@@78|))))))
                (let ((a!3 (and (INTERNAL_le_boogie
                                  (|Seq#Length| (Lit |a#0@@78|))
                                  (|Seq#Length| (Lit |b#0@@40|)))
                                (|Seq#Equal| |a#0@@78| a!2))))
                  (=> (and (= (type Sequences._default.IsSuffix$A@@4) TyType)
                           (= (type $ly@@134) LayerTypeType)
                           (= (type |a#0@@78|) (SeqType BoxType))
                           (= (type |b#0@@40|) (SeqType BoxType))
                           a!1)
                      (= (Sequences.__default.IsSuffix
                           Sequences._default.IsSuffix$A@@4
                           ($LS $ly@@134)
                           (Lit |a#0@@78|)
                           (Lit |b#0@@40|))
                         a!3))))
                :pattern ((Sequences.__default.IsSuffix
                            Sequences._default.IsSuffix$A@@4
                            ($LS $ly@@134)
                            (Lit |a#0@@78|)
                            (Lit |b#0@@40|)))
                :weight 3
                :skolemid |2422|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@485 T@U)
         (arg1@@222 T@U)
         (arg2@@116 T@U)
         (arg3@@65 T@U)
         (arg4@@40 Int))
  (! (= (type (Sequences.__default.SeqIndexIterate
                arg0@@485
                arg1@@222
                arg2@@116
                arg3@@65
                arg4@@40))
        DatatypeTypeType)
     :pattern ((Sequences.__default.SeqIndexIterate
                 arg0@@485
                 arg1@@222
                 arg2@@116
                 arg3@@65
                 arg4@@40))
     :qid |funType:Sequences.__default.SeqIndexIterate|)))
(assert (forall ((Sequences._default.SeqIndexIterate$A T@U)
         ($ly@@135 T@U)
         (|run#0@@71| T@U)
         (|needle#0| T@U)
         (|i#0@@73| Int))
  (! (=> (and (= (type Sequences._default.SeqIndexIterate$A) TyType)
              (= (type $ly@@135) LayerTypeType)
              (= (type |run#0@@71|) (SeqType BoxType))
              (= (type |needle#0|) BoxType))
         (= (Sequences.__default.SeqIndexIterate
              Sequences._default.SeqIndexIterate$A
              ($LS $ly@@135)
              |run#0@@71|
              |needle#0|
              |i#0@@73|)
            (Sequences.__default.SeqIndexIterate
              Sequences._default.SeqIndexIterate$A
              $ly@@135
              |run#0@@71|
              |needle#0|
              |i#0@@73|)))
     :pattern ((Sequences.__default.SeqIndexIterate
                 Sequences._default.SeqIndexIterate$A
                 ($LS $ly@@135)
                 |run#0@@71|
                 |needle#0|
                 |i#0@@73|))
     :skolemid |2423|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.SeqIndexIterate$A@@0 T@U)
         ($ly@@136 T@U)
         (|run#0@@72| T@U)
         (|needle#0@@0| T@U)
         (|i#0@@74| Int))
  (! (=> (and (= (type Sequences._default.SeqIndexIterate$A@@0) TyType)
              (= (type $ly@@136) LayerTypeType)
              (= (type |run#0@@72|) (SeqType BoxType))
              (= (type |needle#0@@0|) BoxType))
         (= (Sequences.__default.SeqIndexIterate
              Sequences._default.SeqIndexIterate$A@@0
              $ly@@136
              |run#0@@72|
              |needle#0@@0|
              |i#0@@74|)
            (Sequences.__default.SeqIndexIterate
              Sequences._default.SeqIndexIterate$A@@0
              $LZ
              |run#0@@72|
              |needle#0@@0|
              |i#0@@74|)))
     :pattern ((Sequences.__default.SeqIndexIterate
                 Sequences._default.SeqIndexIterate$A@@0
                 (AsFuelBottom $ly@@136)
                 |run#0@@72|
                 |needle#0@@0|
                 |i#0@@74|))
     :skolemid |2424|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndexIterate$A@@1 T@U)
                    ($ly@@137 T@U)
                    (|run#0@@73| T@U)
                    (|needle#0@@1| T@U)
                    (|i#0@@75| Int))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndexIterate#canCall|
                                 Sequences._default.SeqIndexIterate$A@@1
                                 |run#0@@73|
                                 |needle#0@@1|
                                 |i#0@@75|)
                               (and ($Is |run#0@@73|
                                         (TSeq Sequences._default.SeqIndexIterate$A@@1))
                                    ($IsBox |needle#0@@1|
                                            Sequences._default.SeqIndexIterate$A@@1)
                                    (INTERNAL_le_boogie 0 |i#0@@75|)
                                    (INTERNAL_le_boogie
                                      |i#0@@75|
                                      (|Seq#Length| |run#0@@73|)))))
                      (a!2 (U_2_int ($Unbox intType
                                            (Options.Option.value
                                              (Sequences.__default.SeqIndexIterate
                                                Sequences._default.SeqIndexIterate$A@@1
                                                $ly@@137
                                                |run#0@@73|
                                                |needle#0@@1|
                                                |i#0@@75|)))))
                      (a!4 (forall ((|j#0@@1| Int))
                             (! (=> (and (INTERNAL_le_boogie |i#0@@75| |j#0@@1|)
                                         (INTERNAL_lt_boogie
                                           |j#0@@1|
                                           (|Seq#Length| |run#0@@73|)))
                                    (not (= (|Seq#Index| |run#0@@73| |j#0@@1|)
                                            |needle#0@@1|)))
                                :pattern ((|Seq#Index| |run#0@@73| |j#0@@1|))
                                :skolemid |2425|
                                :qid |Sequencesidfy.530:32|))))
                (let ((a!3 (=> (Options.Option.Some_q
                                 (Sequences.__default.SeqIndexIterate
                                   Sequences._default.SeqIndexIterate$A@@1
                                   $ly@@137
                                   |run#0@@73|
                                   |needle#0@@1|
                                   |i#0@@75|))
                               (and (INTERNAL_le_boogie 0 a!2)
                                    (INTERNAL_lt_boogie
                                      a!2
                                      (|Seq#Length| |run#0@@73|))
                                    (= (|Seq#Index| |run#0@@73| a!2)
                                       |needle#0@@1|)))))
                (let ((a!5 (and a!3
                                (=> (Options.Option.None_q
                                      (Sequences.__default.SeqIndexIterate
                                        Sequences._default.SeqIndexIterate$A@@1
                                        $ly@@137
                                        |run#0@@73|
                                        |needle#0@@1|
                                        |i#0@@75|))
                                    a!4)
                                ($Is (Sequences.__default.SeqIndexIterate
                                       Sequences._default.SeqIndexIterate$A@@1
                                       $ly@@137
                                       |run#0@@73|
                                       |needle#0@@1|
                                       |i#0@@75|)
                                     (Tclass.Options.Option TInt)))))
                  (=> (and (= (type Sequences._default.SeqIndexIterate$A@@1)
                              TyType)
                           (= (type $ly@@137) LayerTypeType)
                           (= (type |run#0@@73|) (SeqType BoxType))
                           (= (type |needle#0@@1|) BoxType)
                           a!1)
                      a!5))))
                :pattern ((Sequences.__default.SeqIndexIterate
                            Sequences._default.SeqIndexIterate$A@@1
                            $ly@@137
                            |run#0@@73|
                            |needle#0@@1|
                            |i#0@@75|))
                :skolemid |2426|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.SeqIndexIterate$A@@2 T@U)
         ($ly@@138 T@U)
         (|run#0@@74| T@U)
         (|needle#0@@2| T@U)
         (|i#0@@76| Int))
  (! (let ((a!1 (= (|Sequences.__default.SeqIndexIterate#requires|
                     Sequences._default.SeqIndexIterate$A@@2
                     $ly@@138
                     |run#0@@74|
                     |needle#0@@2|
                     |i#0@@76|)
                   (and (INTERNAL_le_boogie 0 |i#0@@76|)
                        (INTERNAL_le_boogie
                          |i#0@@76|
                          (|Seq#Length| |run#0@@74|))))))
       (=> (and (= (type Sequences._default.SeqIndexIterate$A@@2) TyType)
                (= (type $ly@@138) LayerTypeType)
                (= (type |run#0@@74|) (SeqType BoxType))
                (= (type |needle#0@@2|) BoxType)
                ($Is |run#0@@74| (TSeq Sequences._default.SeqIndexIterate$A@@2))
                ($IsBox |needle#0@@2| Sequences._default.SeqIndexIterate$A@@2))
           a!1))
     :pattern ((|Sequences.__default.SeqIndexIterate#requires|
                 Sequences._default.SeqIndexIterate$A@@2
                 $ly@@138
                 |run#0@@74|
                 |needle#0@@2|
                 |i#0@@76|))
     :skolemid |2427|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndexIterate$A@@3 T@U)
                    ($ly@@139 T@U)
                    (|run#0@@75| T@U)
                    (|needle#0@@3| T@U)
                    (|i#0@@77| Int))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndexIterate#canCall|
                                 Sequences._default.SeqIndexIterate$A@@3
                                 |run#0@@75|
                                 |needle#0@@3|
                                 |i#0@@77|)
                               (and ($Is |run#0@@75|
                                         (TSeq Sequences._default.SeqIndexIterate$A@@3))
                                    ($IsBox |needle#0@@3|
                                            Sequences._default.SeqIndexIterate$A@@3)
                                    (INTERNAL_le_boogie 0 |i#0@@77|)
                                    (INTERNAL_le_boogie
                                      |i#0@@77|
                                      (|Seq#Length| |run#0@@75|)))))
                      (a!2 (=> (not (= (|Seq#Index| |run#0@@75| |i#0@@77|)
                                       |needle#0@@3|))
                               (|Sequences.__default.SeqIndexIterate#canCall|
                                 Sequences._default.SeqIndexIterate$A@@3
                                 |run#0@@75|
                                 |needle#0@@3|
                                 (INTERNAL_add_boogie |i#0@@77| 1))))
                      (a!4 (ite (= (|Seq#Index| |run#0@@75| |i#0@@77|)
                                   |needle#0@@3|)
                                (|#Options.Option.Some|
                                  ($Box (int_2_U |i#0@@77|)))
                                (Sequences.__default.SeqIndexIterate
                                  Sequences._default.SeqIndexIterate$A@@3
                                  $ly@@139
                                  |run#0@@75|
                                  |needle#0@@3|
                                  (INTERNAL_add_boogie |i#0@@77| 1)))))
                (let ((a!3 (=> (not (= |i#0@@77| (|Seq#Length| |run#0@@75|)))
                               a!2))
                      (a!5 (= (Sequences.__default.SeqIndexIterate
                                Sequences._default.SeqIndexIterate$A@@3
                                ($LS $ly@@139)
                                |run#0@@75|
                                |needle#0@@3|
                                |i#0@@77|)
                              (ite (= |i#0@@77| (|Seq#Length| |run#0@@75|))
                                   |#Options.Option.None|
                                   a!4))))
                  (=> (and (= (type Sequences._default.SeqIndexIterate$A@@3)
                              TyType)
                           (= (type $ly@@139) LayerTypeType)
                           (= (type |run#0@@75|) (SeqType BoxType))
                           (= (type |needle#0@@3|) BoxType)
                           a!1)
                      (and a!3 a!5))))
                :pattern ((Sequences.__default.SeqIndexIterate
                            Sequences._default.SeqIndexIterate$A@@3
                            ($LS $ly@@139)
                            |run#0@@75|
                            |needle#0@@3|
                            |i#0@@77|))
                :skolemid |2428|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((Sequences._default.SeqIndexIterate$A@@4 T@U)
             ($ly@@140 T@U)
             (|run#0@@76| T@U)
             (|needle#0@@4| T@U)
             (|i#0@@78| Int))
      (! (let ((a!1 (and ($Is |run#0@@76|
                              (TSeq Sequences._default.SeqIndexIterate$A@@4))
                         ($IsBox |needle#0@@4|
                                 Sequences._default.SeqIndexIterate$A@@4)
                         (INTERNAL_le_boogie 0 |i#0@@78|)
                         (INTERNAL_le_boogie
                           |i#0@@78|
                           (|Seq#Length| (Lit |run#0@@76|)))))
               (a!3 (not (= (LitInt |i#0@@78|) (|Seq#Length| (Lit |run#0@@76|)))))
               (a!4 (not (= (|Seq#Index| (Lit |run#0@@76|) (LitInt |i#0@@78|))
                            |needle#0@@4|)))
               (a!6 (|#Options.Option.Some| ($Box (int_2_U (LitInt |i#0@@78|))))))
         (let ((a!2 (and (= (type Sequences._default.SeqIndexIterate$A@@4)
                            TyType)
                         (= (type $ly@@140) LayerTypeType)
                         (= (type |run#0@@76|) (SeqType BoxType))
                         (= (type |needle#0@@4|) BoxType)
                         (or (|Sequences.__default.SeqIndexIterate#canCall|
                               Sequences._default.SeqIndexIterate$A@@4
                               (Lit |run#0@@76|)
                               |needle#0@@4|
                               (LitInt |i#0@@78|))
                             a!1)))
               (a!5 (=> a!4
                        (|Sequences.__default.SeqIndexIterate#canCall|
                          Sequences._default.SeqIndexIterate$A@@4
                          (Lit |run#0@@76|)
                          |needle#0@@4|
                          (LitInt (INTERNAL_add_boogie |i#0@@78| 1)))))
               (a!7 (ite (= (|Seq#Index| (Lit |run#0@@76|) (LitInt |i#0@@78|))
                            |needle#0@@4|)
                         a!6
                         (Sequences.__default.SeqIndexIterate
                           Sequences._default.SeqIndexIterate$A@@4
                           ($LS $ly@@140)
                           (Lit |run#0@@76|)
                           |needle#0@@4|
                           (LitInt (INTERNAL_add_boogie |i#0@@78| 1))))))
         (let ((a!8 (ite (= (LitInt |i#0@@78|) (|Seq#Length| (Lit |run#0@@76|)))
                         |#Options.Option.None|
                         a!7)))
         (let ((a!9 (and (=> a!3 a!5)
                         (= (Sequences.__default.SeqIndexIterate
                              Sequences._default.SeqIndexIterate$A@@4
                              ($LS $ly@@140)
                              (Lit |run#0@@76|)
                              |needle#0@@4|
                              (LitInt |i#0@@78|))
                            a!8))))
           (=> a!2 a!9)))))
         :pattern ((Sequences.__default.SeqIndexIterate
                     Sequences._default.SeqIndexIterate$A@@4
                     ($LS $ly@@140)
                     (Lit |run#0@@76|)
                     |needle#0@@4|
                     (LitInt |i#0@@78|)))
         :weight 3
         :skolemid |2429|
         :qid |unknown.0:0|))))
(assert (=> true
    (forall ((Sequences._default.SeqIndexIterate$A@@5 T@U)
             ($ly@@141 T@U)
             (|run#0@@77| T@U)
             (|needle#0@@5| T@U)
             (|i#0@@79| Int))
      (! (let ((a!1 (and ($Is |run#0@@77|
                              (TSeq Sequences._default.SeqIndexIterate$A@@5))
                         ($IsBox |needle#0@@5|
                                 Sequences._default.SeqIndexIterate$A@@5)
                         (INTERNAL_le_boogie 0 |i#0@@79|)
                         (INTERNAL_le_boogie
                           |i#0@@79|
                           (|Seq#Length| (Lit |run#0@@77|)))))
               (a!3 (not (= (LitInt |i#0@@79|) (|Seq#Length| (Lit |run#0@@77|)))))
               (a!4 (not (= (|Seq#Index| (Lit |run#0@@77|) (LitInt |i#0@@79|))
                            (Lit |needle#0@@5|))))
               (a!6 (|#Options.Option.Some| ($Box (int_2_U (LitInt |i#0@@79|))))))
         (let ((a!2 (and (= (type Sequences._default.SeqIndexIterate$A@@5)
                            TyType)
                         (= (type $ly@@141) LayerTypeType)
                         (= (type |run#0@@77|) (SeqType BoxType))
                         (= (type |needle#0@@5|) BoxType)
                         (or (|Sequences.__default.SeqIndexIterate#canCall|
                               Sequences._default.SeqIndexIterate$A@@5
                               (Lit |run#0@@77|)
                               (Lit |needle#0@@5|)
                               (LitInt |i#0@@79|))
                             a!1)))
               (a!5 (=> a!4
                        (|Sequences.__default.SeqIndexIterate#canCall|
                          Sequences._default.SeqIndexIterate$A@@5
                          (Lit |run#0@@77|)
                          (Lit |needle#0@@5|)
                          (LitInt (INTERNAL_add_boogie |i#0@@79| 1)))))
               (a!7 (ite (= (|Seq#Index| (Lit |run#0@@77|) (LitInt |i#0@@79|))
                            (Lit |needle#0@@5|))
                         a!6
                         (Sequences.__default.SeqIndexIterate
                           Sequences._default.SeqIndexIterate$A@@5
                           ($LS $ly@@141)
                           (Lit |run#0@@77|)
                           (Lit |needle#0@@5|)
                           (LitInt (INTERNAL_add_boogie |i#0@@79| 1))))))
         (let ((a!8 (ite (= (LitInt |i#0@@79|) (|Seq#Length| (Lit |run#0@@77|)))
                         |#Options.Option.None|
                         a!7)))
         (let ((a!9 (and (=> a!3 a!5)
                         (= (Sequences.__default.SeqIndexIterate
                              Sequences._default.SeqIndexIterate$A@@5
                              ($LS $ly@@141)
                              (Lit |run#0@@77|)
                              (Lit |needle#0@@5|)
                              (LitInt |i#0@@79|))
                            a!8))))
           (=> a!2 a!9)))))
         :pattern ((Sequences.__default.SeqIndexIterate
                     Sequences._default.SeqIndexIterate$A@@5
                     ($LS $ly@@141)
                     (Lit |run#0@@77|)
                     (Lit |needle#0@@5|)
                     (LitInt |i#0@@79|)))
         :weight 3
         :skolemid |2430|
         :qid |unknown.0:0|))))
(assert (forall ((arg0@@486 T@U) (arg1@@223 T@U) (arg2@@117 T@U) (arg3@@66 T@U))
  (! (= (type (Sequences.__default.SeqIndex
                arg0@@486
                arg1@@223
                arg2@@117
                arg3@@66))
        DatatypeTypeType)
     :pattern ((Sequences.__default.SeqIndex
                 arg0@@486
                 arg1@@223
                 arg2@@117
                 arg3@@66))
     :qid |funType:Sequences.__default.SeqIndex|)))
(assert (forall ((Sequences._default.SeqIndex$A T@U)
         ($ly@@142 T@U)
         (|run#0@@78| T@U)
         (|needle#0@@6| T@U))
  (! (=> (and (= (type Sequences._default.SeqIndex$A) TyType)
              (= (type $ly@@142) LayerTypeType)
              (= (type |run#0@@78|) (SeqType BoxType))
              (= (type |needle#0@@6|) BoxType))
         (= (Sequences.__default.SeqIndex
              Sequences._default.SeqIndex$A
              ($LS $ly@@142)
              |run#0@@78|
              |needle#0@@6|)
            (Sequences.__default.SeqIndex
              Sequences._default.SeqIndex$A
              $ly@@142
              |run#0@@78|
              |needle#0@@6|)))
     :pattern ((Sequences.__default.SeqIndex
                 Sequences._default.SeqIndex$A
                 ($LS $ly@@142)
                 |run#0@@78|
                 |needle#0@@6|))
     :skolemid |2431|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.SeqIndex$A@@0 T@U)
         ($ly@@143 T@U)
         (|run#0@@79| T@U)
         (|needle#0@@7| T@U))
  (! (=> (and (= (type Sequences._default.SeqIndex$A@@0) TyType)
              (= (type $ly@@143) LayerTypeType)
              (= (type |run#0@@79|) (SeqType BoxType))
              (= (type |needle#0@@7|) BoxType))
         (= (Sequences.__default.SeqIndex
              Sequences._default.SeqIndex$A@@0
              $ly@@143
              |run#0@@79|
              |needle#0@@7|)
            (Sequences.__default.SeqIndex
              Sequences._default.SeqIndex$A@@0
              $LZ
              |run#0@@79|
              |needle#0@@7|)))
     :pattern ((Sequences.__default.SeqIndex
                 Sequences._default.SeqIndex$A@@0
                 (AsFuelBottom $ly@@143)
                 |run#0@@79|
                 |needle#0@@7|))
     :skolemid |2432|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndex$A@@1 T@U)
                    ($ly@@144 T@U)
                    (|run#0@@80| T@U)
                    (|needle#0@@8| T@U))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndex#canCall|
                                 Sequences._default.SeqIndex$A@@1
                                 |run#0@@80|
                                 |needle#0@@8|)
                               (and ($Is |run#0@@80|
                                         (TSeq Sequences._default.SeqIndex$A@@1))
                                    ($IsBox |needle#0@@8|
                                            Sequences._default.SeqIndex$A@@1))))
                      (a!2 (U_2_int ($Unbox intType
                                            (Options.Option.value
                                              (Sequences.__default.SeqIndex
                                                Sequences._default.SeqIndex$A@@1
                                                $ly@@144
                                                |run#0@@80|
                                                |needle#0@@8|)))))
                      (a!4 (forall ((|i#0@@80| Int))
                             (! (=> (and (INTERNAL_le_boogie 0 |i#0@@80|)
                                         (INTERNAL_lt_boogie
                                           |i#0@@80|
                                           (|Seq#Length| |run#0@@80|)))
                                    (not (= (|Seq#Index| |run#0@@80| |i#0@@80|)
                                            |needle#0@@8|)))
                                :pattern ((|Seq#Index| |run#0@@80| |i#0@@80|))
                                :skolemid |2433|
                                :qid |Sequencesidfy.540:32|))))
                (let ((a!3 (=> (Options.Option.Some_q
                                 (Sequences.__default.SeqIndex
                                   Sequences._default.SeqIndex$A@@1
                                   $ly@@144
                                   |run#0@@80|
                                   |needle#0@@8|))
                               (and (INTERNAL_le_boogie 0 a!2)
                                    (INTERNAL_lt_boogie
                                      a!2
                                      (|Seq#Length| |run#0@@80|))
                                    (= (|Seq#Index| |run#0@@80| a!2)
                                       |needle#0@@8|)))))
                (let ((a!5 (and a!3
                                (=> (Options.Option.None_q
                                      (Sequences.__default.SeqIndex
                                        Sequences._default.SeqIndex$A@@1
                                        $ly@@144
                                        |run#0@@80|
                                        |needle#0@@8|))
                                    a!4)
                                ($Is (Sequences.__default.SeqIndex
                                       Sequences._default.SeqIndex$A@@1
                                       $ly@@144
                                       |run#0@@80|
                                       |needle#0@@8|)
                                     (Tclass.Options.Option TInt)))))
                  (=> (and (= (type Sequences._default.SeqIndex$A@@1) TyType)
                           (= (type $ly@@144) LayerTypeType)
                           (= (type |run#0@@80|) (SeqType BoxType))
                           (= (type |needle#0@@8|) BoxType)
                           a!1)
                      a!5))))
                :pattern ((Sequences.__default.SeqIndex
                            Sequences._default.SeqIndex$A@@1
                            $ly@@144
                            |run#0@@80|
                            |needle#0@@8|))
                :skolemid |2434|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.SeqIndex$A@@2 T@U)
         ($ly@@145 T@U)
         (|run#0@@81| T@U)
         (|needle#0@@9| T@U))
  (! (=> (and (= (type Sequences._default.SeqIndex$A@@2) TyType)
              (= (type $ly@@145) LayerTypeType)
              (= (type |run#0@@81|) (SeqType BoxType))
              (= (type |needle#0@@9|) BoxType)
              ($Is |run#0@@81| (TSeq Sequences._default.SeqIndex$A@@2))
              ($IsBox |needle#0@@9| Sequences._default.SeqIndex$A@@2))
         (= (|Sequences.__default.SeqIndex#requires|
              Sequences._default.SeqIndex$A@@2
              $ly@@145
              |run#0@@81|
              |needle#0@@9|)
            true))
     :pattern ((|Sequences.__default.SeqIndex#requires|
                 Sequences._default.SeqIndex$A@@2
                 $ly@@145
                 |run#0@@81|
                 |needle#0@@9|))
     :skolemid |2435|
     :qid |unknown.0:0|)))
(assert (= (type StartFuel_Sequences._default.SeqIndexIterate) LayerTypeType))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndex$A@@3 T@U)
                    ($ly@@146 T@U)
                    (|run#0@@82| T@U)
                    (|needle#0@@10| T@U))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndex#canCall|
                                 Sequences._default.SeqIndex$A@@3
                                 |run#0@@82|
                                 |needle#0@@10|)
                               (and ($Is |run#0@@82|
                                         (TSeq Sequences._default.SeqIndex$A@@3))
                                    ($IsBox |needle#0@@10|
                                            Sequences._default.SeqIndex$A@@3))))
                      (a!2 (and (|Sequences.__default.SeqIndexIterate#canCall|
                                  Sequences._default.SeqIndex$A@@3
                                  |run#0@@82|
                                  |needle#0@@10|
                                  (LitInt 0))
                                (= (Sequences.__default.SeqIndex
                                     Sequences._default.SeqIndex$A@@3
                                     ($LS $ly@@146)
                                     |run#0@@82|
                                     |needle#0@@10|)
                                   (Sequences.__default.SeqIndexIterate
                                     Sequences._default.SeqIndex$A@@3
                                     StartFuel_Sequences._default.SeqIndexIterate
                                     |run#0@@82|
                                     |needle#0@@10|
                                     (LitInt 0))))))
                  (=> (and (= (type Sequences._default.SeqIndex$A@@3) TyType)
                           (= (type $ly@@146) LayerTypeType)
                           (= (type |run#0@@82|) (SeqType BoxType))
                           (= (type |needle#0@@10|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.SeqIndex
                            Sequences._default.SeqIndex$A@@3
                            ($LS $ly@@146)
                            |run#0@@82|
                            |needle#0@@10|))
                :skolemid |2436|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndex$A@@4 T@U)
                    ($ly@@147 T@U)
                    (|run#0@@83| T@U)
                    (|needle#0@@11| T@U))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndex#canCall|
                                 Sequences._default.SeqIndex$A@@4
                                 (Lit |run#0@@83|)
                                 |needle#0@@11|)
                               (and ($Is |run#0@@83|
                                         (TSeq Sequences._default.SeqIndex$A@@4))
                                    ($IsBox |needle#0@@11|
                                            Sequences._default.SeqIndex$A@@4))))
                      (a!2 (and (|Sequences.__default.SeqIndexIterate#canCall|
                                  Sequences._default.SeqIndex$A@@4
                                  (Lit |run#0@@83|)
                                  |needle#0@@11|
                                  (LitInt 0))
                                (= (Sequences.__default.SeqIndex
                                     Sequences._default.SeqIndex$A@@4
                                     ($LS $ly@@147)
                                     (Lit |run#0@@83|)
                                     |needle#0@@11|)
                                   (Sequences.__default.SeqIndexIterate
                                     Sequences._default.SeqIndex$A@@4
                                     StartFuel_Sequences._default.SeqIndexIterate
                                     (Lit |run#0@@83|)
                                     |needle#0@@11|
                                     (LitInt 0))))))
                  (=> (and (= (type Sequences._default.SeqIndex$A@@4) TyType)
                           (= (type $ly@@147) LayerTypeType)
                           (= (type |run#0@@83|) (SeqType BoxType))
                           (= (type |needle#0@@11|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.SeqIndex
                            Sequences._default.SeqIndex$A@@4
                            ($LS $ly@@147)
                            (Lit |run#0@@83|)
                            |needle#0@@11|))
                :weight 3
                :skolemid |2437|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndex$A@@5 T@U)
                    ($ly@@148 T@U)
                    (|run#0@@84| T@U)
                    (|needle#0@@12| T@U))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndex#canCall|
                                 Sequences._default.SeqIndex$A@@5
                                 (Lit |run#0@@84|)
                                 (Lit |needle#0@@12|))
                               (and ($Is |run#0@@84|
                                         (TSeq Sequences._default.SeqIndex$A@@5))
                                    ($IsBox |needle#0@@12|
                                            Sequences._default.SeqIndex$A@@5))))
                      (a!2 (and (|Sequences.__default.SeqIndexIterate#canCall|
                                  Sequences._default.SeqIndex$A@@5
                                  (Lit |run#0@@84|)
                                  (Lit |needle#0@@12|)
                                  (LitInt 0))
                                (= (Sequences.__default.SeqIndex
                                     Sequences._default.SeqIndex$A@@5
                                     ($LS $ly@@148)
                                     (Lit |run#0@@84|)
                                     (Lit |needle#0@@12|))
                                   (Sequences.__default.SeqIndexIterate
                                     Sequences._default.SeqIndex$A@@5
                                     StartFuel_Sequences._default.SeqIndexIterate
                                     (Lit |run#0@@84|)
                                     (Lit |needle#0@@12|)
                                     (LitInt 0))))))
                  (=> (and (= (type Sequences._default.SeqIndex$A@@5) TyType)
                           (= (type $ly@@148) LayerTypeType)
                           (= (type |run#0@@84|) (SeqType BoxType))
                           (= (type |needle#0@@12|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.SeqIndex
                            Sequences._default.SeqIndex$A@@5
                            ($LS $ly@@148)
                            (Lit |run#0@@84|)
                            (Lit |needle#0@@12|)))
                :weight 3
                :skolemid |2438|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@487 T@U) (arg1@@224 T@U) (arg2@@118 Int) (arg3@@67 T@U))
  (! (= (type (Sequences.__default.SeqOfLength
                arg0@@487
                arg1@@224
                arg2@@118
                arg3@@67))
        (SeqType BoxType))
     :pattern ((Sequences.__default.SeqOfLength
                 arg0@@487
                 arg1@@224
                 arg2@@118
                 arg3@@67))
     :qid |funType:Sequences.__default.SeqOfLength|)))
(assert (forall ((Sequences._default.SeqOfLength$V T@U)
         ($ly@@149 T@U)
         (|length#0@@5| Int)
         (|v#0@@24| T@U))
  (! (=> (and (= (type Sequences._default.SeqOfLength$V) TyType)
              (= (type $ly@@149) LayerTypeType)
              (= (type |v#0@@24|) BoxType))
         (= (Sequences.__default.SeqOfLength
              Sequences._default.SeqOfLength$V
              ($LS $ly@@149)
              |length#0@@5|
              |v#0@@24|)
            (Sequences.__default.SeqOfLength
              Sequences._default.SeqOfLength$V
              $ly@@149
              |length#0@@5|
              |v#0@@24|)))
     :pattern ((Sequences.__default.SeqOfLength
                 Sequences._default.SeqOfLength$V
                 ($LS $ly@@149)
                 |length#0@@5|
                 |v#0@@24|))
     :skolemid |2439|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.SeqOfLength$V@@0 T@U)
         ($ly@@150 T@U)
         (|length#0@@6| Int)
         (|v#0@@25| T@U))
  (! (=> (and (= (type Sequences._default.SeqOfLength$V@@0) TyType)
              (= (type $ly@@150) LayerTypeType)
              (= (type |v#0@@25|) BoxType))
         (= (Sequences.__default.SeqOfLength
              Sequences._default.SeqOfLength$V@@0
              $ly@@150
              |length#0@@6|
              |v#0@@25|)
            (Sequences.__default.SeqOfLength
              Sequences._default.SeqOfLength$V@@0
              $LZ
              |length#0@@6|
              |v#0@@25|)))
     :pattern ((Sequences.__default.SeqOfLength
                 Sequences._default.SeqOfLength$V@@0
                 (AsFuelBottom $ly@@150)
                 |length#0@@6|
                 |v#0@@25|))
     :skolemid |2440|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((Sequences._default.SeqOfLength$V@@1 T@U)
             ($ly@@151 T@U)
             (|length#0@@7| Int)
             (|v#0@@26| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.SeqOfLength$V@@1) TyType)
                         (= (type $ly@@151) LayerTypeType)
                         (= (type |v#0@@26|) BoxType)
                         (or (|Sequences.__default.SeqOfLength#canCall|
                               Sequences._default.SeqOfLength$V@@1
                               |length#0@@7|
                               |v#0@@26|)
                             (and (INTERNAL_le_boogie 0 |length#0@@7|)
                                  ($IsBox |v#0@@26|
                                          Sequences._default.SeqOfLength$V@@1)))))
               (a!2 (forall ((|i#0@@81| Int))
                      (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#0@@81|)
                                         (INTERNAL_lt_boogie
                                           |i#0@@81|
                                           (|Seq#Length| (Sequences.__default.SeqOfLength
                                                           Sequences._default.SeqOfLength$V@@1
                                                           $ly@@151
                                                           |length#0@@7|
                                                           |v#0@@26|))))))
                           (=> a!1
                               (= (|Seq#Index| (Sequences.__default.SeqOfLength
                                                 Sequences._default.SeqOfLength$V@@1
                                                 $ly@@151
                                                 |length#0@@7|
                                                 |v#0@@26|)
                                               |i#0@@81|)
                                  |v#0@@26|)))
                         :pattern ((|Seq#Index| (Sequences.__default.SeqOfLength
                                                  Sequences._default.SeqOfLength$V@@1
                                                  $ly@@151
                                                  |length#0@@7|
                                                  |v#0@@26|)
                                                |i#0@@81|))
                         :skolemid |2441|
                         :qid |Sequencesidfy.547:18|))))
         (let ((a!3 (and (= (|Seq#Length| (Sequences.__default.SeqOfLength
                                            Sequences._default.SeqOfLength$V@@1
                                            $ly@@151
                                            |length#0@@7|
                                            |v#0@@26|))
                            |length#0@@7|)
                         a!2
                         ($Is (Sequences.__default.SeqOfLength
                                Sequences._default.SeqOfLength$V@@1
                                $ly@@151
                                |length#0@@7|
                                |v#0@@26|)
                              (TSeq Sequences._default.SeqOfLength$V@@1)))))
           (=> a!1 a!3)))
         :pattern ((Sequences.__default.SeqOfLength
                     Sequences._default.SeqOfLength$V@@1
                     $ly@@151
                     |length#0@@7|
                     |v#0@@26|))
         :skolemid |2442|
         :qid |unknown.0:0|))))
(assert (forall ((Sequences._default.SeqOfLength$V@@2 T@U)
         ($ly@@152 T@U)
         (|length#0@@8| Int)
         (|v#0@@27| T@U))
  (! (=> (and (= (type Sequences._default.SeqOfLength$V@@2) TyType)
              (= (type $ly@@152) LayerTypeType)
              (= (type |v#0@@27|) BoxType)
              (INTERNAL_le_boogie 0 |length#0@@8|)
              ($IsBox |v#0@@27| Sequences._default.SeqOfLength$V@@2))
         (= (|Sequences.__default.SeqOfLength#requires|
              Sequences._default.SeqOfLength$V@@2
              $ly@@152
              |length#0@@8|
              |v#0@@27|)
            true))
     :pattern ((|Sequences.__default.SeqOfLength#requires|
                 Sequences._default.SeqOfLength$V@@2
                 $ly@@152
                 |length#0@@8|
                 |v#0@@27|))
     :skolemid |2443|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((Sequences._default.SeqOfLength$V@@3 T@U)
             ($ly@@153 T@U)
             (|length#0@@9| Int)
             (|v#0@@28| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.SeqOfLength$V@@3) TyType)
                         (= (type $ly@@153) LayerTypeType)
                         (= (type |v#0@@28|) BoxType)
                         (or (|Sequences.__default.SeqOfLength#canCall|
                               Sequences._default.SeqOfLength$V@@3
                               |length#0@@9|
                               |v#0@@28|)
                             (and (INTERNAL_le_boogie 0 |length#0@@9|)
                                  ($IsBox |v#0@@28|
                                          Sequences._default.SeqOfLength$V@@3)))))
               (a!2 (=> (not (= |length#0@@9| (LitInt 0)))
                        (|Sequences.__default.SeqOfLength#canCall|
                          Sequences._default.SeqOfLength$V@@3
                          (INTERNAL_sub_boogie |length#0@@9| 1)
                          |v#0@@28|)))
               (a!3 (ite (= |length#0@@9| (LitInt 0))
                         (|Seq#Empty| BoxType)
                         (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType)
                                                    |v#0@@28|)
                                       (Sequences.__default.SeqOfLength
                                         Sequences._default.SeqOfLength$V@@3
                                         $ly@@153
                                         (INTERNAL_sub_boogie |length#0@@9| 1)
                                         |v#0@@28|)))))
         (let ((a!4 (and a!2
                         (= (Sequences.__default.SeqOfLength
                              Sequences._default.SeqOfLength$V@@3
                              ($LS $ly@@153)
                              |length#0@@9|
                              |v#0@@28|)
                            a!3))))
           (=> a!1 a!4)))
         :pattern ((Sequences.__default.SeqOfLength
                     Sequences._default.SeqOfLength$V@@3
                     ($LS $ly@@153)
                     |length#0@@9|
                     |v#0@@28|))
         :skolemid |2444|
         :qid |unknown.0:0|))))
(assert (=> true
    (forall ((Sequences._default.SeqOfLength$V@@4 T@U)
             ($ly@@154 T@U)
             (|length#0@@10| Int)
             (|v#0@@29| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.SeqOfLength$V@@4) TyType)
                         (= (type $ly@@154) LayerTypeType)
                         (= (type |v#0@@29|) BoxType)
                         (or (|Sequences.__default.SeqOfLength#canCall|
                               Sequences._default.SeqOfLength$V@@4
                               (LitInt |length#0@@10|)
                               |v#0@@29|)
                             (and (INTERNAL_le_boogie 0 |length#0@@10|)
                                  ($IsBox |v#0@@29|
                                          Sequences._default.SeqOfLength$V@@4)))))
               (a!2 (=> (not (= (LitInt |length#0@@10|) (LitInt 0)))
                        (|Sequences.__default.SeqOfLength#canCall|
                          Sequences._default.SeqOfLength$V@@4
                          (LitInt (INTERNAL_sub_boogie |length#0@@10| 1))
                          |v#0@@29|)))
               (a!3 (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) |v#0@@29|)
                                  (Sequences.__default.SeqOfLength
                                    Sequences._default.SeqOfLength$V@@4
                                    ($LS $ly@@154)
                                    (LitInt (INTERNAL_sub_boogie
                                              |length#0@@10|
                                              1))
                                    |v#0@@29|))))
         (let ((a!4 (= (Sequences.__default.SeqOfLength
                         Sequences._default.SeqOfLength$V@@4
                         ($LS $ly@@154)
                         (LitInt |length#0@@10|)
                         |v#0@@29|)
                       (ite (= (LitInt |length#0@@10|) (LitInt 0))
                            (|Seq#Empty| BoxType)
                            a!3))))
           (=> a!1 (and a!2 a!4))))
         :pattern ((Sequences.__default.SeqOfLength
                     Sequences._default.SeqOfLength$V@@4
                     ($LS $ly@@154)
                     (LitInt |length#0@@10|)
                     |v#0@@29|))
         :weight 3
         :skolemid |2445|
         :qid |unknown.0:0|))))
(assert (=> true
    (forall ((Sequences._default.SeqOfLength$V@@5 T@U)
             ($ly@@155 T@U)
             (|length#0@@11| Int)
             (|v#0@@30| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.SeqOfLength$V@@5) TyType)
                         (= (type $ly@@155) LayerTypeType)
                         (= (type |v#0@@30|) BoxType)
                         (or (|Sequences.__default.SeqOfLength#canCall|
                               Sequences._default.SeqOfLength$V@@5
                               (LitInt |length#0@@11|)
                               (Lit |v#0@@30|))
                             (and (INTERNAL_le_boogie 0 |length#0@@11|)
                                  ($IsBox |v#0@@30|
                                          Sequences._default.SeqOfLength$V@@5)))))
               (a!2 (=> (not (= (LitInt |length#0@@11|) (LitInt 0)))
                        (|Sequences.__default.SeqOfLength#canCall|
                          Sequences._default.SeqOfLength$V@@5
                          (LitInt (INTERNAL_sub_boogie |length#0@@11| 1))
                          (Lit |v#0@@30|))))
               (a!3 (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType)
                                               (Lit |v#0@@30|))
                                  (Sequences.__default.SeqOfLength
                                    Sequences._default.SeqOfLength$V@@5
                                    ($LS $ly@@155)
                                    (LitInt (INTERNAL_sub_boogie
                                              |length#0@@11|
                                              1))
                                    (Lit |v#0@@30|)))))
         (let ((a!4 (= (Sequences.__default.SeqOfLength
                         Sequences._default.SeqOfLength$V@@5
                         ($LS $ly@@155)
                         (LitInt |length#0@@11|)
                         (Lit |v#0@@30|))
                       (ite (= (LitInt |length#0@@11|) (LitInt 0))
                            (|Seq#Empty| BoxType)
                            a!3))))
           (=> a!1 (and a!2 a!4))))
         :pattern ((Sequences.__default.SeqOfLength
                     Sequences._default.SeqOfLength$V@@5
                     ($LS $ly@@155)
                     (LitInt |length#0@@11|)
                     (Lit |v#0@@30|)))
         :weight 3
         :skolemid |2446|
         :qid |unknown.0:0|))))
(assert (forall ((arg0@@488 T@U)
         (arg1@@225 T@U)
         (arg2@@119 T@U)
         (arg3@@68 Int)
         (arg4@@41 T@U))
  (! (= (type (Sequences.__default.SeqIndexUpdate
                arg0@@488
                arg1@@225
                arg2@@119
                arg3@@68
                arg4@@41))
        (SeqType BoxType))
     :pattern ((Sequences.__default.SeqIndexUpdate
                 arg0@@488
                 arg1@@225
                 arg2@@119
                 arg3@@68
                 arg4@@41))
     :qid |funType:Sequences.__default.SeqIndexUpdate|)))
(assert (forall ((Sequences._default.SeqIndexUpdate$T T@U)
         ($ly@@156 T@U)
         (|s#0@@90| T@U)
         (|i#0@@82| Int)
         (|t#0| T@U))
  (! (=> (and (= (type Sequences._default.SeqIndexUpdate$T) TyType)
              (= (type $ly@@156) LayerTypeType)
              (= (type |s#0@@90|) (SeqType BoxType))
              (= (type |t#0|) BoxType))
         (= (Sequences.__default.SeqIndexUpdate
              Sequences._default.SeqIndexUpdate$T
              ($LS $ly@@156)
              |s#0@@90|
              |i#0@@82|
              |t#0|)
            (Sequences.__default.SeqIndexUpdate
              Sequences._default.SeqIndexUpdate$T
              $ly@@156
              |s#0@@90|
              |i#0@@82|
              |t#0|)))
     :pattern ((Sequences.__default.SeqIndexUpdate
                 Sequences._default.SeqIndexUpdate$T
                 ($LS $ly@@156)
                 |s#0@@90|
                 |i#0@@82|
                 |t#0|))
     :skolemid |2447|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.SeqIndexUpdate$T@@0 T@U)
         ($ly@@157 T@U)
         (|s#0@@91| T@U)
         (|i#0@@83| Int)
         (|t#0@@0| T@U))
  (! (=> (and (= (type Sequences._default.SeqIndexUpdate$T@@0) TyType)
              (= (type $ly@@157) LayerTypeType)
              (= (type |s#0@@91|) (SeqType BoxType))
              (= (type |t#0@@0|) BoxType))
         (= (Sequences.__default.SeqIndexUpdate
              Sequences._default.SeqIndexUpdate$T@@0
              $ly@@157
              |s#0@@91|
              |i#0@@83|
              |t#0@@0|)
            (Sequences.__default.SeqIndexUpdate
              Sequences._default.SeqIndexUpdate$T@@0
              $LZ
              |s#0@@91|
              |i#0@@83|
              |t#0@@0|)))
     :pattern ((Sequences.__default.SeqIndexUpdate
                 Sequences._default.SeqIndexUpdate$T@@0
                 (AsFuelBottom $ly@@157)
                 |s#0@@91|
                 |i#0@@83|
                 |t#0@@0|))
     :skolemid |2448|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndexUpdate$T@@1 T@U)
                    ($ly@@158 T@U)
                    (|s#0@@92| T@U)
                    (|i#0@@84| Int)
                    (|t#0@@1| T@U))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndexUpdate#canCall|
                                 Sequences._default.SeqIndexUpdate$T@@1
                                 |s#0@@92|
                                 |i#0@@84|
                                 |t#0@@1|)
                               (and ($Is |s#0@@92|
                                         (TSeq Sequences._default.SeqIndexUpdate$T@@1))
                                    (INTERNAL_le_boogie 0 |i#0@@84|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@84|
                                      18446744073709551616)
                                    ($IsBox |t#0@@1|
                                            Sequences._default.SeqIndexUpdate$T@@1)
                                    (INTERNAL_lt_boogie
                                      (INTERNAL_add_boogie |i#0@@84| 1)
                                      18446744073709551616)
                                    (INTERNAL_le_boogie 0 |i#0@@84|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@84|
                                      (|Seq#Length| |s#0@@92|))))))
                  (=> (and (= (type Sequences._default.SeqIndexUpdate$T@@1)
                              TyType)
                           (= (type $ly@@158) LayerTypeType)
                           (= (type |s#0@@92|) (SeqType BoxType))
                           (= (type |t#0@@1|) BoxType)
                           a!1)
                      (and (|Seq#Equal| (Sequences.__default.SeqIndexUpdate
                                          Sequences._default.SeqIndexUpdate$T@@1
                                          $ly@@158
                                          |s#0@@92|
                                          |i#0@@84|
                                          |t#0@@1|)
                                        (|Seq#Update| |s#0@@92|
                                                      |i#0@@84|
                                                      |t#0@@1|))
                           ($Is (Sequences.__default.SeqIndexUpdate
                                  Sequences._default.SeqIndexUpdate$T@@1
                                  $ly@@158
                                  |s#0@@92|
                                  |i#0@@84|
                                  |t#0@@1|)
                                (TSeq Sequences._default.SeqIndexUpdate$T@@1)))))
                :pattern ((Sequences.__default.SeqIndexUpdate
                            Sequences._default.SeqIndexUpdate$T@@1
                            $ly@@158
                            |s#0@@92|
                            |i#0@@84|
                            |t#0@@1|))
                :skolemid |2449|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.SeqIndexUpdate$T@@2 T@U)
         ($ly@@159 T@U)
         (|s#0@@93| T@U)
         (|i#0@@85| Int)
         (|t#0@@2| T@U))
  (! (let ((a!1 (= (|Sequences.__default.SeqIndexUpdate#requires|
                     Sequences._default.SeqIndexUpdate$T@@2
                     $ly@@159
                     |s#0@@93|
                     |i#0@@85|
                     |t#0@@2|)
                   (and (INTERNAL_lt_boogie
                          (INTERNAL_add_boogie |i#0@@85| 1)
                          18446744073709551616)
                        (INTERNAL_le_boogie 0 |i#0@@85|)
                        (INTERNAL_lt_boogie |i#0@@85| (|Seq#Length| |s#0@@93|))))))
       (=> (and (= (type Sequences._default.SeqIndexUpdate$T@@2) TyType)
                (= (type $ly@@159) LayerTypeType)
                (= (type |s#0@@93|) (SeqType BoxType))
                (= (type |t#0@@2|) BoxType)
                ($Is |s#0@@93| (TSeq Sequences._default.SeqIndexUpdate$T@@2))
                (INTERNAL_le_boogie 0 |i#0@@85|)
                (INTERNAL_lt_boogie |i#0@@85| 18446744073709551616)
                ($IsBox |t#0@@2| Sequences._default.SeqIndexUpdate$T@@2))
           a!1))
     :pattern ((|Sequences.__default.SeqIndexUpdate#requires|
                 Sequences._default.SeqIndexUpdate$T@@2
                 $ly@@159
                 |s#0@@93|
                 |i#0@@85|
                 |t#0@@2|))
     :skolemid |2450|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndexUpdate$T@@3 T@U)
                    ($ly@@160 T@U)
                    (|s#0@@94| T@U)
                    (|i#0@@86| Int)
                    (|t#0@@3| T@U))
             (! (let ((a!1 (or (|Sequences.__default.SeqIndexUpdate#canCall|
                                 Sequences._default.SeqIndexUpdate$T@@3
                                 |s#0@@94|
                                 |i#0@@86|
                                 |t#0@@3|)
                               (and ($Is |s#0@@94|
                                         (TSeq Sequences._default.SeqIndexUpdate$T@@3))
                                    (INTERNAL_le_boogie 0 |i#0@@86|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@86|
                                      18446744073709551616)
                                    ($IsBox |t#0@@3|
                                            Sequences._default.SeqIndexUpdate$T@@3)
                                    (INTERNAL_lt_boogie
                                      (INTERNAL_add_boogie |i#0@@86| 1)
                                      18446744073709551616)
                                    (INTERNAL_le_boogie 0 |i#0@@86|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@86|
                                      (|Seq#Length| |s#0@@94|)))))
                      (a!2 (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@94|
                                                                   |i#0@@86|)
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |t#0@@3|))
                                         (|Seq#Drop| |s#0@@94|
                                                     (INTERNAL_add_boogie
                                                       |i#0@@86|
                                                       1)))))
                  (=> (and (= (type Sequences._default.SeqIndexUpdate$T@@3)
                              TyType)
                           (= (type $ly@@160) LayerTypeType)
                           (= (type |s#0@@94|) (SeqType BoxType))
                           (= (type |t#0@@3|) BoxType)
                           a!1)
                      (= (Sequences.__default.SeqIndexUpdate
                           Sequences._default.SeqIndexUpdate$T@@3
                           ($LS $ly@@160)
                           |s#0@@94|
                           |i#0@@86|
                           |t#0@@3|)
                         a!2)))
                :pattern ((Sequences.__default.SeqIndexUpdate
                            Sequences._default.SeqIndexUpdate$T@@3
                            ($LS $ly@@160)
                            |s#0@@94|
                            |i#0@@86|
                            |t#0@@3|))
                :skolemid |2451|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndexUpdate$T@@4 T@U)
                    ($ly@@161 T@U)
                    (|s#0@@95| T@U)
                    (|i#0@@87| Int)
                    (|t#0@@4| T@U))
             (! (let ((a!1 (Lit (bool_2_U (INTERNAL_lt_boogie
                                            (INTERNAL_add_boogie |i#0@@87| 1)
                                            18446744073709551616))))
                      (a!4 (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@95|)
                                                                   (LitInt |i#0@@87|))
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    |t#0@@4|))
                                         (|Seq#Drop| (Lit |s#0@@95|)
                                                     (LitInt (INTERNAL_add_boogie
                                                               |i#0@@87|
                                                               1))))))
                (let ((a!2 (and ($Is |s#0@@95|
                                     (TSeq Sequences._default.SeqIndexUpdate$T@@4))
                                (INTERNAL_le_boogie 0 |i#0@@87|)
                                (INTERNAL_lt_boogie
                                  |i#0@@87|
                                  18446744073709551616)
                                ($IsBox |t#0@@4|
                                        Sequences._default.SeqIndexUpdate$T@@4)
                                (U_2_bool a!1)
                                (INTERNAL_le_boogie 0 |i#0@@87|)
                                (INTERNAL_lt_boogie
                                  |i#0@@87|
                                  (|Seq#Length| (Lit |s#0@@95|))))))
                (let ((a!3 (and (= (type Sequences._default.SeqIndexUpdate$T@@4)
                                   TyType)
                                (= (type $ly@@161) LayerTypeType)
                                (= (type |s#0@@95|) (SeqType BoxType))
                                (= (type |t#0@@4|) BoxType)
                                (or (|Sequences.__default.SeqIndexUpdate#canCall|
                                      Sequences._default.SeqIndexUpdate$T@@4
                                      (Lit |s#0@@95|)
                                      (LitInt |i#0@@87|)
                                      |t#0@@4|)
                                    a!2))))
                  (=> a!3
                      (= (Sequences.__default.SeqIndexUpdate
                           Sequences._default.SeqIndexUpdate$T@@4
                           ($LS $ly@@161)
                           (Lit |s#0@@95|)
                           (LitInt |i#0@@87|)
                           |t#0@@4|)
                         a!4)))))
                :pattern ((Sequences.__default.SeqIndexUpdate
                            Sequences._default.SeqIndexUpdate$T@@4
                            ($LS $ly@@161)
                            (Lit |s#0@@95|)
                            (LitInt |i#0@@87|)
                            |t#0@@4|))
                :weight 3
                :skolemid |2452|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.SeqIndexUpdate$T@@5 T@U)
                    ($ly@@162 T@U)
                    (|s#0@@96| T@U)
                    (|i#0@@88| Int)
                    (|t#0@@5| T@U))
             (! (let ((a!1 (Lit (bool_2_U (INTERNAL_lt_boogie
                                            (INTERNAL_add_boogie |i#0@@88| 1)
                                            18446744073709551616))))
                      (a!4 (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@96|)
                                                                   (LitInt |i#0@@88|))
                                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                                    (Lit |t#0@@5|)))
                                         (|Seq#Drop| (Lit |s#0@@96|)
                                                     (LitInt (INTERNAL_add_boogie
                                                               |i#0@@88|
                                                               1))))))
                (let ((a!2 (and ($Is |s#0@@96|
                                     (TSeq Sequences._default.SeqIndexUpdate$T@@5))
                                (INTERNAL_le_boogie 0 |i#0@@88|)
                                (INTERNAL_lt_boogie
                                  |i#0@@88|
                                  18446744073709551616)
                                ($IsBox |t#0@@5|
                                        Sequences._default.SeqIndexUpdate$T@@5)
                                (U_2_bool a!1)
                                (INTERNAL_le_boogie 0 |i#0@@88|)
                                (INTERNAL_lt_boogie
                                  |i#0@@88|
                                  (|Seq#Length| (Lit |s#0@@96|))))))
                (let ((a!3 (and (= (type Sequences._default.SeqIndexUpdate$T@@5)
                                   TyType)
                                (= (type $ly@@162) LayerTypeType)
                                (= (type |s#0@@96|) (SeqType BoxType))
                                (= (type |t#0@@5|) BoxType)
                                (or (|Sequences.__default.SeqIndexUpdate#canCall|
                                      Sequences._default.SeqIndexUpdate$T@@5
                                      (Lit |s#0@@96|)
                                      (LitInt |i#0@@88|)
                                      (Lit |t#0@@5|))
                                    a!2))))
                  (=> a!3
                      (= (Sequences.__default.SeqIndexUpdate
                           Sequences._default.SeqIndexUpdate$T@@5
                           ($LS $ly@@162)
                           (Lit |s#0@@96|)
                           (LitInt |i#0@@88|)
                           (Lit |t#0@@5|))
                         a!4)))))
                :pattern ((Sequences.__default.SeqIndexUpdate
                            Sequences._default.SeqIndexUpdate$T@@5
                            ($LS $ly@@162)
                            (Lit |s#0@@96|)
                            (LitInt |i#0@@88|)
                            (Lit |t#0@@5|)))
                :weight 3
                :skolemid |2453|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@489 T@U)
         (arg1@@226 T@U)
         (arg2@@120 T@U)
         (arg3@@69 T@U)
         (arg4@@42 T@U))
  (! (= (type (Sequences.__default.Zip
                arg0@@489
                arg1@@226
                arg2@@120
                arg3@@69
                arg4@@42))
        (SeqType BoxType))
     :pattern ((Sequences.__default.Zip
                 arg0@@489
                 arg1@@226
                 arg2@@120
                 arg3@@69
                 arg4@@42))
     :qid |funType:Sequences.__default.Zip|)))
(assert (forall ((Sequences._default.Zip$A T@U)
         (Sequences._default.Zip$B T@U)
         ($ly@@163 T@U)
         (|a#0@@79| T@U)
         (|b#0@@41| T@U))
  (! (=> (and (= (type Sequences._default.Zip$A) TyType)
              (= (type Sequences._default.Zip$B) TyType)
              (= (type $ly@@163) LayerTypeType)
              (= (type |a#0@@79|) (SeqType BoxType))
              (= (type |b#0@@41|) (SeqType BoxType)))
         (= (Sequences.__default.Zip
              Sequences._default.Zip$A
              Sequences._default.Zip$B
              ($LS $ly@@163)
              |a#0@@79|
              |b#0@@41|)
            (Sequences.__default.Zip
              Sequences._default.Zip$A
              Sequences._default.Zip$B
              $ly@@163
              |a#0@@79|
              |b#0@@41|)))
     :pattern ((Sequences.__default.Zip
                 Sequences._default.Zip$A
                 Sequences._default.Zip$B
                 ($LS $ly@@163)
                 |a#0@@79|
                 |b#0@@41|))
     :skolemid |2454|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.Zip$A@@0 T@U)
         (Sequences._default.Zip$B@@0 T@U)
         ($ly@@164 T@U)
         (|a#0@@80| T@U)
         (|b#0@@42| T@U))
  (! (=> (and (= (type Sequences._default.Zip$A@@0) TyType)
              (= (type Sequences._default.Zip$B@@0) TyType)
              (= (type $ly@@164) LayerTypeType)
              (= (type |a#0@@80|) (SeqType BoxType))
              (= (type |b#0@@42|) (SeqType BoxType)))
         (= (Sequences.__default.Zip
              Sequences._default.Zip$A@@0
              Sequences._default.Zip$B@@0
              $ly@@164
              |a#0@@80|
              |b#0@@42|)
            (Sequences.__default.Zip
              Sequences._default.Zip$A@@0
              Sequences._default.Zip$B@@0
              $LZ
              |a#0@@80|
              |b#0@@42|)))
     :pattern ((Sequences.__default.Zip
                 Sequences._default.Zip$A@@0
                 Sequences._default.Zip$B@@0
                 (AsFuelBottom $ly@@164)
                 |a#0@@80|
                 |b#0@@42|))
     :skolemid |2455|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Zip$A@@1 T@U)
                    (Sequences._default.Zip$B@@1 T@U)
                    ($ly@@165 T@U)
                    (|a#0@@81| T@U)
                    (|b#0@@43| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Zip#canCall|
                                 Sequences._default.Zip$A@@1
                                 Sequences._default.Zip$B@@1
                                 |a#0@@81|
                                 |b#0@@43|)
                               (and ($Is |a#0@@81|
                                         (TSeq Sequences._default.Zip$A@@1))
                                    ($Is |b#0@@43|
                                         (TSeq Sequences._default.Zip$B@@1))
                                    (= (|Seq#Length| |a#0@@81|)
                                       (|Seq#Length| |b#0@@43|)))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.Zip
                                                   Sequences._default.Zip$A@@1
                                                   Sequences._default.Zip$B@@1
                                                   $ly@@165
                                                   |a#0@@81|
                                                   |b#0@@43|))
                                   (|Seq#Length| |a#0@@81|))
                                (forall ((|i#0@@89| Int))
                                  (! (let ((a!1 (and (INTERNAL_le_boogie
                                                       0
                                                       |i#0@@89|)
                                                     (INTERNAL_lt_boogie
                                                       |i#0@@89|
                                                       (|Seq#Length| (Sequences.__default.Zip
                                                                       Sequences._default.Zip$A@@1
                                                                       Sequences._default.Zip$B@@1
                                                                       $ly@@165
                                                                       |a#0@@81|
                                                                       |b#0@@43|)))))
                                           (a!2 (|_System.Tuple2#Equal|
                                                  ($Unbox DatatypeTypeType
                                                          (|Seq#Index| (Sequences.__default.Zip
                                                                         Sequences._default.Zip$A@@1
                                                                         Sequences._default.Zip$B@@1
                                                                         $ly@@165
                                                                         |a#0@@81|
                                                                         |b#0@@43|)
                                                                       |i#0@@89|))
                                                  (|#_System._tuple#2._#Make2|
                                                    (|Seq#Index| |a#0@@81|
                                                                 |i#0@@89|)
                                                    (|Seq#Index| |b#0@@43|
                                                                 |i#0@@89|)))))
                                       (=> true (=> a!1 a!2)))
                                     :pattern ((|Seq#Index| |b#0@@43| |i#0@@89|))
                                     :pattern ((|Seq#Index| |a#0@@81| |i#0@@89|))
                                     :pattern (($Unbox DatatypeTypeType
                                                       (|Seq#Index| (Sequences.__default.Zip
                                                                      Sequences._default.Zip$A@@1
                                                                      Sequences._default.Zip$B@@1
                                                                      $ly@@165
                                                                      |a#0@@81|
                                                                      |b#0@@43|)
                                                                    |i#0@@89|)))
                                     :skolemid |2456|
                                     :qid |Sequencesidfy.568:20|))
                                ($Is (Sequences.__default.Zip
                                       Sequences._default.Zip$A@@1
                                       Sequences._default.Zip$B@@1
                                       $ly@@165
                                       |a#0@@81|
                                       |b#0@@43|)
                                     (TSeq (Tclass._System.Tuple2
                                             Sequences._default.Zip$A@@1
                                             Sequences._default.Zip$B@@1))))))
                  (=> (and (= (type Sequences._default.Zip$A@@1) TyType)
                           (= (type Sequences._default.Zip$B@@1) TyType)
                           (= (type $ly@@165) LayerTypeType)
                           (= (type |a#0@@81|) (SeqType BoxType))
                           (= (type |b#0@@43|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.Zip
                            Sequences._default.Zip$A@@1
                            Sequences._default.Zip$B@@1
                            $ly@@165
                            |a#0@@81|
                            |b#0@@43|))
                :skolemid |2457|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.Zip$A@@2 T@U)
         (Sequences._default.Zip$B@@2 T@U)
         ($ly@@166 T@U)
         (|a#0@@82| T@U)
         (|b#0@@44| T@U))
  (! (=> (and (= (type Sequences._default.Zip$A@@2) TyType)
              (= (type Sequences._default.Zip$B@@2) TyType)
              (= (type $ly@@166) LayerTypeType)
              (= (type |a#0@@82|) (SeqType BoxType))
              (= (type |b#0@@44|) (SeqType BoxType))
              ($Is |a#0@@82| (TSeq Sequences._default.Zip$A@@2))
              ($Is |b#0@@44| (TSeq Sequences._default.Zip$B@@2)))
         (= (|Sequences.__default.Zip#requires|
              Sequences._default.Zip$A@@2
              Sequences._default.Zip$B@@2
              $ly@@166
              |a#0@@82|
              |b#0@@44|)
            (= (|Seq#Length| |a#0@@82|) (|Seq#Length| |b#0@@44|))))
     :pattern ((|Sequences.__default.Zip#requires|
                 Sequences._default.Zip$A@@2
                 Sequences._default.Zip$B@@2
                 $ly@@166
                 |a#0@@82|
                 |b#0@@44|))
     :skolemid |2458|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Zip$A@@3 T@U)
                    (Sequences._default.Zip$B@@3 T@U)
                    ($ly@@167 T@U)
                    (|a#0@@83| T@U)
                    (|b#0@@45| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Zip#canCall|
                                 Sequences._default.Zip$A@@3
                                 Sequences._default.Zip$B@@3
                                 |a#0@@83|
                                 |b#0@@45|)
                               (and ($Is |a#0@@83|
                                         (TSeq Sequences._default.Zip$A@@3))
                                    ($Is |b#0@@45|
                                         (TSeq Sequences._default.Zip$B@@3))
                                    (= (|Seq#Length| |a#0@@83|)
                                       (|Seq#Length| |b#0@@45|)))))
                      (a!2 (=> (not (= (|Seq#Length| |a#0@@83|) (LitInt 0)))
                               (and (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.Zip$A@@3
                                      |a#0@@83|)
                                    (|Sequences.__default.DropLast#canCall|
                                      Sequences._default.Zip$B@@3
                                      |b#0@@45|)
                                    (|Sequences.__default.Zip#canCall|
                                      Sequences._default.Zip$A@@3
                                      Sequences._default.Zip$B@@3
                                      (Sequences.__default.DropLast
                                        Sequences._default.Zip$A@@3
                                        |a#0@@83|)
                                      (Sequences.__default.DropLast
                                        Sequences._default.Zip$B@@3
                                        |b#0@@45|))
                                    (|Sequences.__default.Last#canCall|
                                      Sequences._default.Zip$A@@3
                                      |a#0@@83|)
                                    (|Sequences.__default.Last#canCall|
                                      Sequences._default.Zip$B@@3
                                      |b#0@@45|))))
                      (a!3 (|Seq#Build| (|Seq#Empty| BoxType)
                                        ($Box (|#_System._tuple#2._#Make2|
                                                (Sequences.__default.Last
                                                  Sequences._default.Zip$A@@3
                                                  |a#0@@83|)
                                                (Sequences.__default.Last
                                                  Sequences._default.Zip$B@@3
                                                  |b#0@@45|))))))
                (let ((a!4 (ite (= (|Seq#Length| |a#0@@83|) (LitInt 0))
                                (|Seq#Empty| BoxType)
                                (|Seq#Append| (Sequences.__default.Zip
                                                Sequences._default.Zip$A@@3
                                                Sequences._default.Zip$B@@3
                                                $ly@@167
                                                (Sequences.__default.DropLast
                                                  Sequences._default.Zip$A@@3
                                                  |a#0@@83|)
                                                (Sequences.__default.DropLast
                                                  Sequences._default.Zip$B@@3
                                                  |b#0@@45|))
                                              a!3))))
                (let ((a!5 (and a!2
                                (= (Sequences.__default.Zip
                                     Sequences._default.Zip$A@@3
                                     Sequences._default.Zip$B@@3
                                     ($LS $ly@@167)
                                     |a#0@@83|
                                     |b#0@@45|)
                                   a!4))))
                  (=> (and (= (type Sequences._default.Zip$A@@3) TyType)
                           (= (type Sequences._default.Zip$B@@3) TyType)
                           (= (type $ly@@167) LayerTypeType)
                           (= (type |a#0@@83|) (SeqType BoxType))
                           (= (type |b#0@@45|) (SeqType BoxType))
                           a!1)
                      a!5))))
                :pattern ((Sequences.__default.Zip
                            Sequences._default.Zip$A@@3
                            Sequences._default.Zip$B@@3
                            ($LS $ly@@167)
                            |a#0@@83|
                            |b#0@@45|))
                :skolemid |2459|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((Sequences._default.Zip$A@@4 T@U)
             (Sequences._default.Zip$B@@4 T@U)
             ($ly@@168 T@U)
             (|a#0@@84| T@U)
             (|b#0@@46| T@U))
      (! (let ((a!1 (and ($Is |a#0@@84| (TSeq Sequences._default.Zip$A@@4))
                         ($Is |b#0@@46| (TSeq Sequences._default.Zip$B@@4))
                         (= (|Seq#Length| (Lit |a#0@@84|))
                            (|Seq#Length| (Lit |b#0@@46|)))))
               (a!3 (not (= (|Seq#Length| (Lit |a#0@@84|)) (LitInt 0))))
               (a!4 (|Sequences.__default.Zip#canCall|
                      Sequences._default.Zip$A@@4
                      Sequences._default.Zip$B@@4
                      (Lit (Sequences.__default.DropLast
                             Sequences._default.Zip$A@@4
                             (Lit |a#0@@84|)))
                      (Lit (Sequences.__default.DropLast
                             Sequences._default.Zip$B@@4
                             (Lit |b#0@@46|)))))
               (a!6 (Sequences.__default.Zip
                      Sequences._default.Zip$A@@4
                      Sequences._default.Zip$B@@4
                      ($LS $ly@@168)
                      (Lit (Sequences.__default.DropLast
                             Sequences._default.Zip$A@@4
                             (Lit |a#0@@84|)))
                      (Lit (Sequences.__default.DropLast
                             Sequences._default.Zip$B@@4
                             (Lit |b#0@@46|)))))
               (a!7 (|#_System._tuple#2._#Make2|
                      (Lit (Sequences.__default.Last
                             Sequences._default.Zip$A@@4
                             (Lit |a#0@@84|)))
                      (Lit (Sequences.__default.Last
                             Sequences._default.Zip$B@@4
                             (Lit |b#0@@46|))))))
         (let ((a!2 (and (= (type Sequences._default.Zip$A@@4) TyType)
                         (= (type Sequences._default.Zip$B@@4) TyType)
                         (= (type $ly@@168) LayerTypeType)
                         (= (type |a#0@@84|) (SeqType BoxType))
                         (= (type |b#0@@46|) (SeqType BoxType))
                         (or (|Sequences.__default.Zip#canCall|
                               Sequences._default.Zip$A@@4
                               Sequences._default.Zip$B@@4
                               (Lit |a#0@@84|)
                               (Lit |b#0@@46|))
                             a!1)))
               (a!5 (=> a!3
                        (and (|Sequences.__default.DropLast#canCall|
                               Sequences._default.Zip$A@@4
                               (Lit |a#0@@84|))
                             (|Sequences.__default.DropLast#canCall|
                               Sequences._default.Zip$B@@4
                               (Lit |b#0@@46|))
                             a!4
                             (|Sequences.__default.Last#canCall|
                               Sequences._default.Zip$A@@4
                               (Lit |a#0@@84|))
                             (|Sequences.__default.Last#canCall|
                               Sequences._default.Zip$B@@4
                               (Lit |b#0@@46|)))))
               (a!8 (|Seq#Append| a!6
                                  (|Seq#Build| (|Seq#Empty| BoxType)
                                               ($Box (Lit a!7))))))
         (let ((a!9 (ite (= (|Seq#Length| (Lit |a#0@@84|)) (LitInt 0))
                         (|Seq#Empty| BoxType)
                         a!8)))
         (let ((a!10 (and a!5
                          (= (Sequences.__default.Zip
                               Sequences._default.Zip$A@@4
                               Sequences._default.Zip$B@@4
                               ($LS $ly@@168)
                               (Lit |a#0@@84|)
                               (Lit |b#0@@46|))
                             a!9))))
           (=> a!2 a!10)))))
         :pattern ((Sequences.__default.Zip
                     Sequences._default.Zip$A@@4
                     Sequences._default.Zip$B@@4
                     ($LS $ly@@168)
                     (Lit |a#0@@84|)
                     (Lit |b#0@@46|)))
         :weight 3
         :skolemid |2460|
         :qid |unknown.0:0|))))
(assert (forall ((arg0@@490 T@U) (arg1@@227 T@U) (arg2@@121 T@U) (arg3@@70 T@U))
  (! (= (type (Sequences.__default.Unzip arg0@@490 arg1@@227 arg2@@121 arg3@@70))
        DatatypeTypeType)
     :pattern ((Sequences.__default.Unzip
                 arg0@@490
                 arg1@@227
                 arg2@@121
                 arg3@@70))
     :qid |funType:Sequences.__default.Unzip|)))
(assert (forall ((Sequences._default.Unzip$A T@U)
         (Sequences._default.Unzip$B T@U)
         ($ly@@169 T@U)
         (|z#0| T@U))
  (! (=> (and (= (type Sequences._default.Unzip$A) TyType)
              (= (type Sequences._default.Unzip$B) TyType)
              (= (type $ly@@169) LayerTypeType)
              (= (type |z#0|) (SeqType BoxType)))
         (= (Sequences.__default.Unzip
              Sequences._default.Unzip$A
              Sequences._default.Unzip$B
              ($LS $ly@@169)
              |z#0|)
            (Sequences.__default.Unzip
              Sequences._default.Unzip$A
              Sequences._default.Unzip$B
              $ly@@169
              |z#0|)))
     :pattern ((Sequences.__default.Unzip
                 Sequences._default.Unzip$A
                 Sequences._default.Unzip$B
                 ($LS $ly@@169)
                 |z#0|))
     :skolemid |2461|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.Unzip$A@@0 T@U)
         (Sequences._default.Unzip$B@@0 T@U)
         ($ly@@170 T@U)
         (|z#0@@0| T@U))
  (! (=> (and (= (type Sequences._default.Unzip$A@@0) TyType)
              (= (type Sequences._default.Unzip$B@@0) TyType)
              (= (type $ly@@170) LayerTypeType)
              (= (type |z#0@@0|) (SeqType BoxType)))
         (= (Sequences.__default.Unzip
              Sequences._default.Unzip$A@@0
              Sequences._default.Unzip$B@@0
              $ly@@170
              |z#0@@0|)
            (Sequences.__default.Unzip
              Sequences._default.Unzip$A@@0
              Sequences._default.Unzip$B@@0
              $LZ
              |z#0@@0|)))
     :pattern ((Sequences.__default.Unzip
                 Sequences._default.Unzip$A@@0
                 Sequences._default.Unzip$B@@0
                 (AsFuelBottom $ly@@170)
                 |z#0@@0|))
     :skolemid |2462|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Unzip$A@@1 T@U)
                    (Sequences._default.Unzip$B@@1 T@U)
                    ($ly@@171 T@U)
                    (|z#0@@1| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Unzip#canCall|
                                 Sequences._default.Unzip$A@@1
                                 Sequences._default.Unzip$B@@1
                                 |z#0@@1|)
                               ($Is |z#0@@1|
                                    (TSeq (Tclass._System.Tuple2
                                            Sequences._default.Unzip$A@@1
                                            Sequences._default.Unzip$B@@1)))))
                      (a!2 (|Seq#Length| ($Unbox (SeqType BoxType)
                                                 (_System.Tuple2._0
                                                   (Sequences.__default.Unzip
                                                     Sequences._default.Unzip$A@@1
                                                     Sequences._default.Unzip$B@@1
                                                     $ly@@171
                                                     |z#0@@1|)))))
                      (a!3 (|Seq#Length| ($Unbox (SeqType BoxType)
                                                 (_System.Tuple2._1
                                                   (Sequences.__default.Unzip
                                                     Sequences._default.Unzip$A@@1
                                                     Sequences._default.Unzip$B@@1
                                                     $ly@@171
                                                     |z#0@@1|))))))
                (let ((a!4 (and (= a!2 a!3)
                                (= a!3 (|Seq#Length| |z#0@@1|))
                                (forall ((|i#0@@90| Int))
                                  (! (let ((a!1 (|Seq#Index| ($Unbox (SeqType BoxType)
                                                                     (_System.Tuple2._0
                                                                       (Sequences.__default.Unzip
                                                                         Sequences._default.Unzip$A@@1
                                                                         Sequences._default.Unzip$B@@1
                                                                         $ly@@171
                                                                         |z#0@@1|)))
                                                             |i#0@@90|))
                                           (a!2 (|Seq#Index| ($Unbox (SeqType BoxType)
                                                                     (_System.Tuple2._1
                                                                       (Sequences.__default.Unzip
                                                                         Sequences._default.Unzip$A@@1
                                                                         Sequences._default.Unzip$B@@1
                                                                         $ly@@171
                                                                         |z#0@@1|)))
                                                             |i#0@@90|)))
                                     (let ((a!3 (=> (and (INTERNAL_le_boogie
                                                           0
                                                           |i#0@@90|)
                                                         (INTERNAL_lt_boogie
                                                           |i#0@@90|
                                                           (|Seq#Length| |z#0@@1|)))
                                                    (|_System.Tuple2#Equal|
                                                      (|#_System._tuple#2._#Make2|
                                                        a!1
                                                        a!2)
                                                      ($Unbox DatatypeTypeType
                                                              (|Seq#Index| |z#0@@1|
                                                                           |i#0@@90|))))))
                                       (=> true a!3)))
                                     :pattern (($Unbox DatatypeTypeType
                                                       (|Seq#Index| |z#0@@1|
                                                                    |i#0@@90|)))
                                     :pattern ((|Seq#Index| ($Unbox (SeqType BoxType)
                                                                    (_System.Tuple2._1
                                                                      (Sequences.__default.Unzip
                                                                        Sequences._default.Unzip$A@@1
                                                                        Sequences._default.Unzip$B@@1
                                                                        $ly@@171
                                                                        |z#0@@1|)))
                                                            |i#0@@90|))
                                     :pattern ((|Seq#Index| ($Unbox (SeqType BoxType)
                                                                    (_System.Tuple2._0
                                                                      (Sequences.__default.Unzip
                                                                        Sequences._default.Unzip$A@@1
                                                                        Sequences._default.Unzip$B@@1
                                                                        $ly@@171
                                                                        |z#0@@1|)))
                                                            |i#0@@90|))
                                     :skolemid |2463|
                                     :qid |Sequencesidfy.576:20|))
                                ($Is (Sequences.__default.Unzip
                                       Sequences._default.Unzip$A@@1
                                       Sequences._default.Unzip$B@@1
                                       $ly@@171
                                       |z#0@@1|)
                                     (Tclass._System.Tuple2
                                       (TSeq Sequences._default.Unzip$A@@1)
                                       (TSeq Sequences._default.Unzip$B@@1))))))
                  (=> (and (= (type Sequences._default.Unzip$A@@1) TyType)
                           (= (type Sequences._default.Unzip$B@@1) TyType)
                           (= (type $ly@@171) LayerTypeType)
                           (= (type |z#0@@1|) (SeqType BoxType))
                           a!1)
                      a!4)))
                :pattern ((Sequences.__default.Unzip
                            Sequences._default.Unzip$A@@1
                            Sequences._default.Unzip$B@@1
                            $ly@@171
                            |z#0@@1|))
                :skolemid |2464|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.Unzip$A@@2 T@U)
         (Sequences._default.Unzip$B@@2 T@U)
         ($ly@@172 T@U)
         (|z#0@@2| T@U))
  (! (let ((a!1 (and (= (type Sequences._default.Unzip$A@@2) TyType)
                     (= (type Sequences._default.Unzip$B@@2) TyType)
                     (= (type $ly@@172) LayerTypeType)
                     (= (type |z#0@@2|) (SeqType BoxType))
                     ($Is |z#0@@2|
                          (TSeq (Tclass._System.Tuple2
                                  Sequences._default.Unzip$A@@2
                                  Sequences._default.Unzip$B@@2))))))
       (=> a!1
           (= (|Sequences.__default.Unzip#requires|
                Sequences._default.Unzip$A@@2
                Sequences._default.Unzip$B@@2
                $ly@@172
                |z#0@@2|)
              true)))
     :pattern ((|Sequences.__default.Unzip#requires|
                 Sequences._default.Unzip$A@@2
                 Sequences._default.Unzip$B@@2
                 $ly@@172
                 |z#0@@2|))
     :skolemid |2465|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.Unzip$A@@3 T@U)
                    (Sequences._default.Unzip$B@@3 T@U)
                    ($ly@@173 T@U)
                    (|z#0@@3| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Unzip#canCall|
                                 Sequences._default.Unzip$A@@3
                                 Sequences._default.Unzip$B@@3
                                 |z#0@@3|)
                               ($Is |z#0@@3|
                                    (TSeq (Tclass._System.Tuple2
                                            Sequences._default.Unzip$A@@3
                                            Sequences._default.Unzip$B@@3)))))
                      (a!2 (_System.Tuple2.___hMake2_q
                             ($Unbox DatatypeTypeType
                                     (Sequences.__default.Last
                                       (Tclass._System.Tuple2
                                         Sequences._default.Unzip$A@@3
                                         Sequences._default.Unzip$B@@3)
                                       |z#0@@3|))))
                      (a!5 (|#_System._tuple#2._#Make2|
                             ($Box (Lit (|Seq#Empty| BoxType)))
                             ($Box (Lit (|Seq#Empty| BoxType)))))
                      (a!6 (_System.Tuple2._0
                             (Sequences.__default.Unzip
                               Sequences._default.Unzip$A@@3
                               Sequences._default.Unzip$B@@3
                               $ly@@173
                               (Sequences.__default.DropLast
                                 (Tclass._System.Tuple2
                                   Sequences._default.Unzip$A@@3
                                   Sequences._default.Unzip$B@@3)
                                 |z#0@@3|))))
                      (a!7 (_System.Tuple2._0
                             ($Unbox DatatypeTypeType
                                     (Sequences.__default.Last
                                       (Tclass._System.Tuple2
                                         Sequences._default.Unzip$A@@3
                                         Sequences._default.Unzip$B@@3)
                                       |z#0@@3|))))
                      (a!9 (_System.Tuple2._1
                             (Sequences.__default.Unzip
                               Sequences._default.Unzip$A@@3
                               Sequences._default.Unzip$B@@3
                               $ly@@173
                               (Sequences.__default.DropLast
                                 (Tclass._System.Tuple2
                                   Sequences._default.Unzip$A@@3
                                   Sequences._default.Unzip$B@@3)
                                 |z#0@@3|))))
                      (a!10 (_System.Tuple2._1
                              ($Unbox DatatypeTypeType
                                      (Sequences.__default.Last
                                        (Tclass._System.Tuple2
                                          Sequences._default.Unzip$A@@3
                                          Sequences._default.Unzip$B@@3)
                                        |z#0@@3|)))))
                (let ((a!3 (and (|Sequences.__default.DropLast#canCall|
                                  (Tclass._System.Tuple2
                                    Sequences._default.Unzip$A@@3
                                    Sequences._default.Unzip$B@@3)
                                  |z#0@@3|)
                                (|Sequences.__default.Unzip#canCall|
                                  Sequences._default.Unzip$A@@3
                                  Sequences._default.Unzip$B@@3
                                  (Sequences.__default.DropLast
                                    (Tclass._System.Tuple2
                                      Sequences._default.Unzip$A@@3
                                      Sequences._default.Unzip$B@@3)
                                    |z#0@@3|))
                                (and (|Sequences.__default.Last#canCall|
                                       (Tclass._System.Tuple2
                                         Sequences._default.Unzip$A@@3
                                         Sequences._default.Unzip$B@@3)
                                       |z#0@@3|)
                                     a!2)
                                (and (|Sequences.__default.Last#canCall|
                                       (Tclass._System.Tuple2
                                         Sequences._default.Unzip$A@@3
                                         Sequences._default.Unzip$B@@3)
                                       |z#0@@3|)
                                     a!2)))
                      (a!8 ($Box (|Seq#Append| ($Unbox (SeqType BoxType) a!6)
                                               (|Seq#Build| (|Seq#Empty| BoxType)
                                                            a!7))))
                      (a!11 ($Box (|Seq#Append| ($Unbox (SeqType BoxType) a!9)
                                                (|Seq#Build| (|Seq#Empty| BoxType)
                                                             a!10)))))
                (let ((a!4 (=> (not (= (|Seq#Length| |z#0@@3|) (LitInt 0))) a!3))
                      (a!12 (= (Sequences.__default.Unzip
                                 Sequences._default.Unzip$A@@3
                                 Sequences._default.Unzip$B@@3
                                 ($LS $ly@@173)
                                 |z#0@@3|)
                               (ite (= (|Seq#Length| |z#0@@3|) (LitInt 0))
                                    a!5
                                    (|#_System._tuple#2._#Make2| a!8 a!11)))))
                  (=> (and (= (type Sequences._default.Unzip$A@@3) TyType)
                           (= (type Sequences._default.Unzip$B@@3) TyType)
                           (= (type $ly@@173) LayerTypeType)
                           (= (type |z#0@@3|) (SeqType BoxType))
                           a!1)
                      (and a!4 a!12)))))
                :pattern ((Sequences.__default.Unzip
                            Sequences._default.Unzip$A@@3
                            Sequences._default.Unzip$B@@3
                            ($LS $ly@@173)
                            |z#0@@3|))
                :skolemid |2466|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.Unzip$A@@4 T@U)
                    (Sequences._default.Unzip$B@@4 T@U)
                    ($ly@@174 T@U)
                    (|z#0@@4| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Unzip#canCall|
                                 Sequences._default.Unzip$A@@4
                                 Sequences._default.Unzip$B@@4
                                 (Lit |z#0@@4|))
                               ($Is |z#0@@4|
                                    (TSeq (Tclass._System.Tuple2
                                            Sequences._default.Unzip$A@@4
                                            Sequences._default.Unzip$B@@4)))))
                      (a!2 (not (= (|Seq#Length| (Lit |z#0@@4|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.Unzip#canCall|
                             Sequences._default.Unzip$A@@4
                             Sequences._default.Unzip$B@@4
                             (Lit (Sequences.__default.DropLast
                                    (Tclass._System.Tuple2
                                      Sequences._default.Unzip$A@@4
                                      Sequences._default.Unzip$B@@4)
                                    (Lit |z#0@@4|)))))
                      (a!4 (Lit ($Unbox DatatypeTypeType
                                        (Sequences.__default.Last
                                          (Tclass._System.Tuple2
                                            Sequences._default.Unzip$A@@4
                                            Sequences._default.Unzip$B@@4)
                                          (Lit |z#0@@4|)))))
                      (a!6 (|#_System._tuple#2._#Make2|
                             ($Box (Lit (|Seq#Empty| BoxType)))
                             ($Box (Lit (|Seq#Empty| BoxType)))))
                      (a!7 (Sequences.__default.Unzip
                             Sequences._default.Unzip$A@@4
                             Sequences._default.Unzip$B@@4
                             ($LS $ly@@174)
                             (Lit (Sequences.__default.DropLast
                                    (Tclass._System.Tuple2
                                      Sequences._default.Unzip$A@@4
                                      Sequences._default.Unzip$B@@4)
                                    (Lit |z#0@@4|))))))
                (let ((a!5 (and (|Sequences.__default.DropLast#canCall|
                                  (Tclass._System.Tuple2
                                    Sequences._default.Unzip$A@@4
                                    Sequences._default.Unzip$B@@4)
                                  (Lit |z#0@@4|))
                                a!3
                                (and (|Sequences.__default.Last#canCall|
                                       (Tclass._System.Tuple2
                                         Sequences._default.Unzip$A@@4
                                         Sequences._default.Unzip$B@@4)
                                       (Lit |z#0@@4|))
                                     (_System.Tuple2.___hMake2_q a!4))
                                (and (|Sequences.__default.Last#canCall|
                                       (Tclass._System.Tuple2
                                         Sequences._default.Unzip$A@@4
                                         Sequences._default.Unzip$B@@4)
                                       (Lit |z#0@@4|))
                                     (_System.Tuple2.___hMake2_q a!4))))
                      (a!8 (|Seq#Append| ($Unbox (SeqType BoxType)
                                                 (_System.Tuple2._0 a!7))
                                         (|Seq#Build| (|Seq#Empty| BoxType)
                                                      (Lit (_System.Tuple2._0
                                                             a!4)))))
                      (a!9 (|Seq#Append| ($Unbox (SeqType BoxType)
                                                 (_System.Tuple2._1 a!7))
                                         (|Seq#Build| (|Seq#Empty| BoxType)
                                                      (Lit (_System.Tuple2._1
                                                             a!4))))))
                (let ((a!10 (ite (= (|Seq#Length| (Lit |z#0@@4|)) (LitInt 0))
                                 a!6
                                 (|#_System._tuple#2._#Make2|
                                   ($Box a!8)
                                   ($Box a!9)))))
                (let ((a!11 (and (=> a!2 a!5)
                                 (= (Sequences.__default.Unzip
                                      Sequences._default.Unzip$A@@4
                                      Sequences._default.Unzip$B@@4
                                      ($LS $ly@@174)
                                      (Lit |z#0@@4|))
                                    a!10))))
                  (=> (and (= (type Sequences._default.Unzip$A@@4) TyType)
                           (= (type Sequences._default.Unzip$B@@4) TyType)
                           (= (type $ly@@174) LayerTypeType)
                           (= (type |z#0@@4|) (SeqType BoxType))
                           a!1)
                      a!11)))))
                :pattern ((Sequences.__default.Unzip
                            Sequences._default.Unzip$A@@4
                            Sequences._default.Unzip$B@@4
                            ($LS $ly@@174)
                            (Lit |z#0@@4|)))
                :weight 3
                :skolemid |2467|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@491 T@U) (arg1@@228 T@U) (arg2@@122 T@U))
  (! (= (type (Sequences.__default.FlattenShape arg0@@491 arg1@@228 arg2@@122))
        (SeqType BoxType))
     :pattern ((Sequences.__default.FlattenShape arg0@@491 arg1@@228 arg2@@122))
     :qid |funType:Sequences.__default.FlattenShape|)))
(assert (forall ((Sequences._default.FlattenShape$A T@U) ($ly@@175 T@U) (|seqs#0| T@U))
  (! (=> (and (= (type Sequences._default.FlattenShape$A) TyType)
              (= (type $ly@@175) LayerTypeType)
              (= (type |seqs#0|) (SeqType BoxType)))
         (= (Sequences.__default.FlattenShape
              Sequences._default.FlattenShape$A
              ($LS $ly@@175)
              |seqs#0|)
            (Sequences.__default.FlattenShape
              Sequences._default.FlattenShape$A
              $ly@@175
              |seqs#0|)))
     :pattern ((Sequences.__default.FlattenShape
                 Sequences._default.FlattenShape$A
                 ($LS $ly@@175)
                 |seqs#0|))
     :skolemid |2468|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.FlattenShape$A@@0 T@U)
         ($ly@@176 T@U)
         (|seqs#0@@0| T@U))
  (! (=> (and (= (type Sequences._default.FlattenShape$A@@0) TyType)
              (= (type $ly@@176) LayerTypeType)
              (= (type |seqs#0@@0|) (SeqType BoxType)))
         (= (Sequences.__default.FlattenShape
              Sequences._default.FlattenShape$A@@0
              $ly@@176
              |seqs#0@@0|)
            (Sequences.__default.FlattenShape
              Sequences._default.FlattenShape$A@@0
              $LZ
              |seqs#0@@0|)))
     :pattern ((Sequences.__default.FlattenShape
                 Sequences._default.FlattenShape$A@@0
                 (AsFuelBottom $ly@@176)
                 |seqs#0@@0|))
     :skolemid |2469|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FlattenShape$A@@1 T@U)
                    ($ly@@177 T@U)
                    (|seqs#0@@1| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FlattenShape#canCall|
                                 Sequences._default.FlattenShape$A@@1
                                 |seqs#0@@1|)
                               ($Is |seqs#0@@1|
                                    (TSeq (TSeq Sequences._default.FlattenShape$A@@1)))))
                      (a!2 (and (= (|Seq#Length| (Sequences.__default.FlattenShape
                                                   Sequences._default.FlattenShape$A@@1
                                                   $ly@@177
                                                   |seqs#0@@1|))
                                   (|Seq#Length| |seqs#0@@1|))
                                (forall ((|i#0@@91| Int))
                                  (! (let ((a!1 (and (INTERNAL_le_boogie
                                                       0
                                                       |i#0@@91|)
                                                     (INTERNAL_lt_boogie
                                                       |i#0@@91|
                                                       (|Seq#Length| (Sequences.__default.FlattenShape
                                                                       Sequences._default.FlattenShape$A@@1
                                                                       $ly@@177
                                                                       |seqs#0@@1|)))))
                                           (a!2 (U_2_int ($Unbox intType
                                                                 (|Seq#Index| (Sequences.__default.FlattenShape
                                                                                Sequences._default.FlattenShape$A@@1
                                                                                $ly@@177
                                                                                |seqs#0@@1|)
                                                                              |i#0@@91|)))))
                                     (let ((a!3 (= a!2
                                                   (|Seq#Length| ($Unbox (SeqType BoxType)
                                                                         (|Seq#Index| |seqs#0@@1|
                                                                                      |i#0@@91|))))))
                                       (=> true (=> a!1 a!3))))
                                     :pattern (($Unbox (SeqType BoxType)
                                                       (|Seq#Index| |seqs#0@@1|
                                                                    |i#0@@91|)))
                                     :pattern (($Unbox intType
                                                       (|Seq#Index| (Sequences.__default.FlattenShape
                                                                      Sequences._default.FlattenShape$A@@1
                                                                      $ly@@177
                                                                      |seqs#0@@1|)
                                                                    |i#0@@91|)))
                                     :skolemid |2470|
                                     :qid |Sequencesidfy.598:20|))
                                ($Is (Sequences.__default.FlattenShape
                                       Sequences._default.FlattenShape$A@@1
                                       $ly@@177
                                       |seqs#0@@1|)
                                     (TSeq Tclass._System.nat)))))
                  (=> (and (= (type Sequences._default.FlattenShape$A@@1)
                              TyType)
                           (= (type $ly@@177) LayerTypeType)
                           (= (type |seqs#0@@1|) (SeqType BoxType))
                           a!1)
                      a!2))
                :pattern ((Sequences.__default.FlattenShape
                            Sequences._default.FlattenShape$A@@1
                            $ly@@177
                            |seqs#0@@1|))
                :skolemid |2471|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.FlattenShape$A@@2 T@U)
         ($ly@@178 T@U)
         (|seqs#0@@2| T@U))
  (! (let ((a!1 (and (= (type Sequences._default.FlattenShape$A@@2) TyType)
                     (= (type $ly@@178) LayerTypeType)
                     (= (type |seqs#0@@2|) (SeqType BoxType))
                     ($Is |seqs#0@@2|
                          (TSeq (TSeq Sequences._default.FlattenShape$A@@2))))))
       (=> a!1
           (= (|Sequences.__default.FlattenShape#requires|
                Sequences._default.FlattenShape$A@@2
                $ly@@178
                |seqs#0@@2|)
              true)))
     :pattern ((|Sequences.__default.FlattenShape#requires|
                 Sequences._default.FlattenShape$A@@2
                 $ly@@178
                 |seqs#0@@2|))
     :skolemid |2472|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.FlattenShape$A@@3 T@U)
                    ($ly@@179 T@U)
                    (|seqs#0@@3| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FlattenShape#canCall|
                                 Sequences._default.FlattenShape$A@@3
                                 |seqs#0@@3|)
                               ($Is |seqs#0@@3|
                                    (TSeq (TSeq Sequences._default.FlattenShape$A@@3)))))
                      (a!2 (and (|Sequences.__default.DropLast#canCall|
                                  (TSeq Sequences._default.FlattenShape$A@@3)
                                  |seqs#0@@3|)
                                (|Sequences.__default.FlattenShape#canCall|
                                  Sequences._default.FlattenShape$A@@3
                                  (Sequences.__default.DropLast
                                    (TSeq Sequences._default.FlattenShape$A@@3)
                                    |seqs#0@@3|))
                                (|Sequences.__default.Last#canCall|
                                  (TSeq Sequences._default.FlattenShape$A@@3)
                                  |seqs#0@@3|)))
                      (a!4 (|Seq#Length| ($Unbox (SeqType BoxType)
                                                 (Sequences.__default.Last
                                                   (TSeq Sequences._default.FlattenShape$A@@3)
                                                   |seqs#0@@3|)))))
                (let ((a!3 (=> (not (= (|Seq#Length| |seqs#0@@3|) (LitInt 0)))
                               a!2))
                      (a!5 (|Seq#Append| (Sequences.__default.FlattenShape
                                           Sequences._default.FlattenShape$A@@3
                                           $ly@@179
                                           (Sequences.__default.DropLast
                                             (TSeq Sequences._default.FlattenShape$A@@3)
                                             |seqs#0@@3|))
                                         (|Seq#Build| (|Seq#Empty| BoxType)
                                                      ($Box (int_2_U a!4))))))
                (let ((a!6 (= (Sequences.__default.FlattenShape
                                Sequences._default.FlattenShape$A@@3
                                ($LS $ly@@179)
                                |seqs#0@@3|)
                              (ite (= (|Seq#Length| |seqs#0@@3|) (LitInt 0))
                                   (|Seq#Empty| BoxType)
                                   a!5))))
                  (=> (and (= (type Sequences._default.FlattenShape$A@@3)
                              TyType)
                           (= (type $ly@@179) LayerTypeType)
                           (= (type |seqs#0@@3|) (SeqType BoxType))
                           a!1)
                      (and a!3 a!6)))))
                :pattern ((Sequences.__default.FlattenShape
                            Sequences._default.FlattenShape$A@@3
                            ($LS $ly@@179)
                            |seqs#0@@3|))
                :skolemid |2473|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Sequences._default.FlattenShape$A@@4 T@U)
                    ($ly@@180 T@U)
                    (|seqs#0@@4| T@U))
             (! (let ((a!1 (or (|Sequences.__default.FlattenShape#canCall|
                                 Sequences._default.FlattenShape$A@@4
                                 (Lit |seqs#0@@4|))
                               ($Is |seqs#0@@4|
                                    (TSeq (TSeq Sequences._default.FlattenShape$A@@4)))))
                      (a!2 (not (= (|Seq#Length| (Lit |seqs#0@@4|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.FlattenShape#canCall|
                             Sequences._default.FlattenShape$A@@4
                             (Lit (Sequences.__default.DropLast
                                    (TSeq Sequences._default.FlattenShape$A@@4)
                                    (Lit |seqs#0@@4|)))))
                      (a!5 (Sequences.__default.FlattenShape
                             Sequences._default.FlattenShape$A@@4
                             ($LS $ly@@180)
                             (Lit (Sequences.__default.DropLast
                                    (TSeq Sequences._default.FlattenShape$A@@4)
                                    (Lit |seqs#0@@4|)))))
                      (a!6 (Lit ($Unbox (SeqType BoxType)
                                        (Sequences.__default.Last
                                          (TSeq Sequences._default.FlattenShape$A@@4)
                                          (Lit |seqs#0@@4|))))))
                (let ((a!4 (=> a!2
                               (and (|Sequences.__default.DropLast#canCall|
                                      (TSeq Sequences._default.FlattenShape$A@@4)
                                      (Lit |seqs#0@@4|))
                                    a!3
                                    (|Sequences.__default.Last#canCall|
                                      (TSeq Sequences._default.FlattenShape$A@@4)
                                      (Lit |seqs#0@@4|)))))
                      (a!7 (|Seq#Build| (|Seq#Empty| BoxType)
                                        ($Box (int_2_U (|Seq#Length| a!6))))))
                (let ((a!8 (ite (= (|Seq#Length| (Lit |seqs#0@@4|)) (LitInt 0))
                                (|Seq#Empty| BoxType)
                                (|Seq#Append| a!5 a!7))))
                (let ((a!9 (and a!4
                                (= (Sequences.__default.FlattenShape
                                     Sequences._default.FlattenShape$A@@4
                                     ($LS $ly@@180)
                                     (Lit |seqs#0@@4|))
                                   a!8))))
                  (=> (and (= (type Sequences._default.FlattenShape$A@@4)
                              TyType)
                           (= (type $ly@@180) LayerTypeType)
                           (= (type |seqs#0@@4|) (SeqType BoxType))
                           a!1)
                      a!9)))))
                :pattern ((Sequences.__default.FlattenShape
                            Sequences._default.FlattenShape$A@@4
                            ($LS $ly@@180)
                            (Lit |seqs#0@@4|)))
                :weight 3
                :skolemid |2474|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall (($ly@@181 T@U) (|shape#0| T@U))
  (! (=> (and (= (type $ly@@181) LayerTypeType)
              (= (type |shape#0|) (SeqType BoxType)))
         (= (Sequences.__default.FlattenLength ($LS $ly@@181) |shape#0|)
            (Sequences.__default.FlattenLength $ly@@181 |shape#0|)))
     :pattern ((Sequences.__default.FlattenLength ($LS $ly@@181) |shape#0|))
     :skolemid |2475|
     :qid |Sequencesidfy.609:22|)))
(assert (forall (($ly@@182 T@U) (|shape#0@@0| T@U))
  (! (=> (and (= (type $ly@@182) LayerTypeType)
              (= (type |shape#0@@0|) (SeqType BoxType)))
         (= (Sequences.__default.FlattenLength $ly@@182 |shape#0@@0|)
            (Sequences.__default.FlattenLength $LZ |shape#0@@0|)))
     :pattern ((Sequences.__default.FlattenLength
                 (AsFuelBottom $ly@@182)
                 |shape#0@@0|))
     :skolemid |2476|
     :qid |Sequencesidfy.609:22|)))
(assert (=> true
    (forall (($ly@@183 T@U) (|shape#0@@1| T@U))
      (! (let ((a!1 (and (= (type $ly@@183) LayerTypeType)
                         (= (type |shape#0@@1|) (SeqType BoxType))
                         (or (|Sequences.__default.FlattenLength#canCall|
                               |shape#0@@1|)
                             ($Is |shape#0@@1| (TSeq Tclass._System.nat)))))
               (a!2 (and (=> (= (|Seq#Length| |shape#0@@1|) (LitInt 0))
                             (= (Sequences.__default.FlattenLength
                                  $ly@@183
                                  |shape#0@@1|)
                                (LitInt 0)))
                         (INTERNAL_le_boogie
                           0
                           (Sequences.__default.FlattenLength
                             $ly@@183
                             |shape#0@@1|)))))
           (=> a!1 a!2))
         :pattern ((Sequences.__default.FlattenLength $ly@@183 |shape#0@@1|))
         :skolemid |2477|
         :qid |Sequencesidfy.609:22|))))
(assert (forall (($ly@@184 T@U) (|shape#0@@2| T@U))
  (! (=> (and (= (type $ly@@184) LayerTypeType)
              (= (type |shape#0@@2|) (SeqType BoxType))
              ($Is |shape#0@@2| (TSeq Tclass._System.nat)))
         (= (|Sequences.__default.FlattenLength#requires| $ly@@184 |shape#0@@2|)
            true))
     :pattern ((|Sequences.__default.FlattenLength#requires|
                 $ly@@184
                 |shape#0@@2|))
     :skolemid |2478|
     :qid |Sequencesidfy.609:22|)))
(assert (=> true
    (forall (($ly@@185 T@U) (|shape#0@@3| T@U))
      (! (let ((a!1 (and (= (type $ly@@185) LayerTypeType)
                         (= (type |shape#0@@3|) (SeqType BoxType))
                         (or (|Sequences.__default.FlattenLength#canCall|
                               |shape#0@@3|)
                             ($Is |shape#0@@3| (TSeq Tclass._System.nat)))))
               (a!2 (=> (not (= (|Seq#Length| |shape#0@@3|) (LitInt 0)))
                        (and (|Sequences.__default.DropLast#canCall|
                               Tclass._System.nat
                               |shape#0@@3|)
                             (|Sequences.__default.FlattenLength#canCall|
                               (Sequences.__default.DropLast
                                 Tclass._System.nat
                                 |shape#0@@3|))
                             (|Sequences.__default.Last#canCall|
                               Tclass._System.nat
                               |shape#0@@3|))))
               (a!3 (INTERNAL_add_boogie
                      (Sequences.__default.FlattenLength
                        $ly@@185
                        (Sequences.__default.DropLast
                          Tclass._System.nat
                          |shape#0@@3|))
                      (U_2_int ($Unbox intType
                                       (Sequences.__default.Last
                                         Tclass._System.nat
                                         |shape#0@@3|))))))
         (let ((a!4 (= (Sequences.__default.FlattenLength
                         ($LS $ly@@185)
                         |shape#0@@3|)
                       (ite (= (|Seq#Length| |shape#0@@3|) (LitInt 0)) 0 a!3))))
           (=> a!1 (and a!2 a!4))))
         :pattern ((Sequences.__default.FlattenLength
                     ($LS $ly@@185)
                     |shape#0@@3|))
         :skolemid |2479|
         :qid |Sequencesidfy.609:22|))))
(assert (=> true
    (forall (($ly@@186 T@U) (|shape#0@@4| T@U))
      (! (let ((a!1 (and (= (type $ly@@186) LayerTypeType)
                         (= (type |shape#0@@4|) (SeqType BoxType))
                         (or (|Sequences.__default.FlattenLength#canCall|
                               (Lit |shape#0@@4|))
                             ($Is |shape#0@@4| (TSeq Tclass._System.nat)))))
               (a!2 (not (= (|Seq#Length| (Lit |shape#0@@4|)) (LitInt 0))))
               (a!3 (|Sequences.__default.FlattenLength#canCall|
                      (Lit (Sequences.__default.DropLast
                             Tclass._System.nat
                             (Lit |shape#0@@4|)))))
               (a!5 (Sequences.__default.FlattenLength
                      ($LS $ly@@186)
                      (Lit (Sequences.__default.DropLast
                             Tclass._System.nat
                             (Lit |shape#0@@4|)))))
               (a!6 (U_2_int ($Unbox intType
                                     (Sequences.__default.Last
                                       Tclass._System.nat
                                       (Lit |shape#0@@4|))))))
         (let ((a!4 (=> a!2
                        (and (|Sequences.__default.DropLast#canCall|
                               Tclass._System.nat
                               (Lit |shape#0@@4|))
                             a!3
                             (|Sequences.__default.Last#canCall|
                               Tclass._System.nat
                               (Lit |shape#0@@4|)))))
               (a!7 (ite (= (|Seq#Length| (Lit |shape#0@@4|)) (LitInt 0))
                         0
                         (INTERNAL_add_boogie a!5 a!6))))
         (let ((a!8 (and a!4
                         (= (Sequences.__default.FlattenLength
                              ($LS $ly@@186)
                              (Lit |shape#0@@4|))
                            a!7))))
           (=> a!1 a!8))))
         :pattern ((Sequences.__default.FlattenLength
                     ($LS $ly@@186)
                     (Lit |shape#0@@4|)))
         :weight 3
         :skolemid |2480|
         :qid |Sequencesidfy.609:22|))))
(assert (forall ((arg0@@492 T@U) (arg1@@229 T@U) (arg2@@123 T@U))
  (! (= (type (Sequences.__default.Flatten arg0@@492 arg1@@229 arg2@@123))
        (SeqType BoxType))
     :pattern ((Sequences.__default.Flatten arg0@@492 arg1@@229 arg2@@123))
     :qid |funType:Sequences.__default.Flatten|)))
(assert (forall ((Sequences._default.Flatten$A T@U) ($ly@@187 T@U) (|seqs#0@@5| T@U))
  (! (=> (and (= (type Sequences._default.Flatten$A) TyType)
              (= (type $ly@@187) LayerTypeType)
              (= (type |seqs#0@@5|) (SeqType BoxType)))
         (= (Sequences.__default.Flatten
              Sequences._default.Flatten$A
              ($LS $ly@@187)
              |seqs#0@@5|)
            (Sequences.__default.Flatten
              Sequences._default.Flatten$A
              $ly@@187
              |seqs#0@@5|)))
     :pattern ((Sequences.__default.Flatten
                 Sequences._default.Flatten$A
                 ($LS $ly@@187)
                 |seqs#0@@5|))
     :skolemid |2481|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.Flatten$A@@0 T@U) ($ly@@188 T@U) (|seqs#0@@6| T@U))
  (! (=> (and (= (type Sequences._default.Flatten$A@@0) TyType)
              (= (type $ly@@188) LayerTypeType)
              (= (type |seqs#0@@6|) (SeqType BoxType)))
         (= (Sequences.__default.Flatten
              Sequences._default.Flatten$A@@0
              $ly@@188
              |seqs#0@@6|)
            (Sequences.__default.Flatten
              Sequences._default.Flatten$A@@0
              $LZ
              |seqs#0@@6|)))
     :pattern ((Sequences.__default.Flatten
                 Sequences._default.Flatten$A@@0
                 (AsFuelBottom $ly@@188)
                 |seqs#0@@6|))
     :skolemid |2482|
     :qid |unknown.0:0|)))
(assert (and (= (type StartFuel_Sequences._default.FlattenLength) LayerTypeType)
     (= (type StartFuel_Sequences._default.FlattenShape) LayerTypeType)))
(assert (let ((a!1 (forall ((Sequences._default.Flatten$A@@1 T@U)
                    ($ly@@189 T@U)
                    (|seqs#0@@7| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Flatten#canCall|
                                 Sequences._default.Flatten$A@@1
                                 |seqs#0@@7|)
                               ($Is |seqs#0@@7|
                                    (TSeq (TSeq Sequences._default.Flatten$A@@1)))))
                      (a!2 (=> (= (|Seq#Length| |seqs#0@@7|) (LitInt 0))
                               (= (|Seq#Length| (Sequences.__default.Flatten
                                                  Sequences._default.Flatten$A@@1
                                                  $ly@@189
                                                  |seqs#0@@7|))
                                  (LitInt 0)))))
                (let ((a!3 (and (= (|Seq#Length| (Sequences.__default.Flatten
                                                   Sequences._default.Flatten$A@@1
                                                   $ly@@189
                                                   |seqs#0@@7|))
                                   (Sequences.__default.FlattenLength
                                     StartFuel_Sequences._default.FlattenLength
                                     (Sequences.__default.FlattenShape
                                       Sequences._default.Flatten$A@@1
                                       StartFuel_Sequences._default.FlattenShape
                                       |seqs#0@@7|)))
                                a!2
                                ($Is (Sequences.__default.Flatten
                                       Sequences._default.Flatten$A@@1
                                       $ly@@189
                                       |seqs#0@@7|)
                                     (TSeq Sequences._default.Flatten$A@@1)))))
                  (=> (and (= (type Sequences._default.Flatten$A@@1) TyType)
                           (= (type $ly@@189) LayerTypeType)
                           (= (type |seqs#0@@7|) (SeqType BoxType))
                           a!1)
                      a!3)))
                :pattern ((Sequences.__default.Flatten
                            Sequences._default.Flatten$A@@1
                            $ly@@189
                            |seqs#0@@7|))
                :skolemid |2483|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Sequences._default.Flatten$A@@2 T@U) ($ly@@190 T@U) (|seqs#0@@8| T@U))
  (! (let ((a!1 (and (= (type Sequences._default.Flatten$A@@2) TyType)
                     (= (type $ly@@190) LayerTypeType)
                     (= (type |seqs#0@@8|) (SeqType BoxType))
                     ($Is |seqs#0@@8|
                          (TSeq (TSeq Sequences._default.Flatten$A@@2))))))
       (=> a!1
           (= (|Sequences.__default.Flatten#requires|
                Sequences._default.Flatten$A@@2
                $ly@@190
                |seqs#0@@8|)
              true)))
     :pattern ((|Sequences.__default.Flatten#requires|
                 Sequences._default.Flatten$A@@2
                 $ly@@190
                 |seqs#0@@8|))
     :skolemid |2484|
     :qid |unknown.0:0|)))
(assert (and (= (type MoreFuel_Sequences._default.FlattenShape0) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.FlattenShape) LayerTypeType)))
(assert (let ((a!1 (forall ((Sequences._default.Flatten$A@@3 T@U)
                    ($ly@@191 T@U)
                    (|seqs#0@@9| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Flatten#canCall|
                                 Sequences._default.Flatten$A@@3
                                 |seqs#0@@9|)
                               ($Is |seqs#0@@9|
                                    (TSeq (TSeq Sequences._default.Flatten$A@@3)))))
                      (a!2 (and (|Sequences.__default.DropLast#canCall|
                                  (TSeq Sequences._default.Flatten$A@@3)
                                  |seqs#0@@9|)
                                (|Sequences.__default.Flatten#canCall|
                                  Sequences._default.Flatten$A@@3
                                  (Sequences.__default.DropLast
                                    (TSeq Sequences._default.Flatten$A@@3)
                                    |seqs#0@@9|))
                                (|Sequences.__default.Last#canCall|
                                  (TSeq Sequences._default.Flatten$A@@3)
                                  |seqs#0@@9|)))
                      (a!4 (|Seq#Append| (Sequences.__default.Flatten
                                           Sequences._default.Flatten$A@@3
                                           $ly@@191
                                           (Sequences.__default.DropLast
                                             (TSeq Sequences._default.Flatten$A@@3)
                                             |seqs#0@@9|))
                                         ($Unbox (SeqType BoxType)
                                                 (Sequences.__default.Last
                                                   (TSeq Sequences._default.Flatten$A@@3)
                                                   |seqs#0@@9|)))))
                (let ((a!3 (=> (not (= (|Seq#Length| |seqs#0@@9|) (LitInt 0)))
                               a!2))
                      (a!5 (= (Sequences.__default.Flatten
                                Sequences._default.Flatten$A@@3
                                ($LS $ly@@191)
                                |seqs#0@@9|)
                              (ite (= (|Seq#Length| |seqs#0@@9|) (LitInt 0))
                                   (|Seq#Empty| BoxType)
                                   a!4))))
                (let ((a!6 (and a!3
                                (= StartFuel_Sequences._default.FlattenShape
                                   ($LS MoreFuel_Sequences._default.FlattenShape0))
                                (= StartFuelAssert_Sequences._default.FlattenShape
                                   ($LS ($LS MoreFuel_Sequences._default.FlattenShape0)))
                                (= (AsFuelBottom MoreFuel_Sequences._default.FlattenShape0)
                                   MoreFuel_Sequences._default.FlattenShape0)
                                a!5)))
                  (=> (and (= (type Sequences._default.Flatten$A@@3) TyType)
                           (= (type $ly@@191) LayerTypeType)
                           (= (type |seqs#0@@9|) (SeqType BoxType))
                           a!1)
                      a!6))))
                :pattern ((Sequences.__default.Flatten
                            Sequences._default.Flatten$A@@3
                            ($LS $ly@@191)
                            |seqs#0@@9|))
                :skolemid |2485|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type MoreFuel_Sequences._default.FlattenShape1) LayerTypeType))
(assert (let ((a!1 (forall ((Sequences._default.Flatten$A@@4 T@U)
                    ($ly@@192 T@U)
                    (|seqs#0@@10| T@U))
             (! (let ((a!1 (or (|Sequences.__default.Flatten#canCall|
                                 Sequences._default.Flatten$A@@4
                                 (Lit |seqs#0@@10|))
                               ($Is |seqs#0@@10|
                                    (TSeq (TSeq Sequences._default.Flatten$A@@4)))))
                      (a!2 (not (= (|Seq#Length| (Lit |seqs#0@@10|)) (LitInt 0))))
                      (a!3 (|Sequences.__default.Flatten#canCall|
                             Sequences._default.Flatten$A@@4
                             (Lit (Sequences.__default.DropLast
                                    (TSeq Sequences._default.Flatten$A@@4)
                                    (Lit |seqs#0@@10|)))))
                      (a!5 (Sequences.__default.Flatten
                             Sequences._default.Flatten$A@@4
                             ($LS $ly@@192)
                             (Lit (Sequences.__default.DropLast
                                    (TSeq Sequences._default.Flatten$A@@4)
                                    (Lit |seqs#0@@10|))))))
                (let ((a!4 (=> a!2
                               (and (|Sequences.__default.DropLast#canCall|
                                      (TSeq Sequences._default.Flatten$A@@4)
                                      (Lit |seqs#0@@10|))
                                    a!3
                                    (|Sequences.__default.Last#canCall|
                                      (TSeq Sequences._default.Flatten$A@@4)
                                      (Lit |seqs#0@@10|)))))
                      (a!6 (|Seq#Append| a!5
                                         ($Unbox (SeqType BoxType)
                                                 (Sequences.__default.Last
                                                   (TSeq Sequences._default.Flatten$A@@4)
                                                   (Lit |seqs#0@@10|))))))
                (let ((a!7 (ite (= (|Seq#Length| (Lit |seqs#0@@10|)) (LitInt 0))
                                (|Seq#Empty| BoxType)
                                a!6)))
                (let ((a!8 (and a!4
                                (= StartFuel_Sequences._default.FlattenShape
                                   ($LS MoreFuel_Sequences._default.FlattenShape1))
                                (= StartFuelAssert_Sequences._default.FlattenShape
                                   ($LS ($LS MoreFuel_Sequences._default.FlattenShape1)))
                                (= (AsFuelBottom MoreFuel_Sequences._default.FlattenShape1)
                                   MoreFuel_Sequences._default.FlattenShape1)
                                (= (Sequences.__default.Flatten
                                     Sequences._default.Flatten$A@@4
                                     ($LS $ly@@192)
                                     (Lit |seqs#0@@10|))
                                   a!7))))
                  (=> (and (= (type Sequences._default.Flatten$A@@4) TyType)
                           (= (type $ly@@192) LayerTypeType)
                           (= (type |seqs#0@@10|) (SeqType BoxType))
                           a!1)
                      a!8)))))
                :pattern ((Sequences.__default.Flatten
                            Sequences._default.Flatten$A@@4
                            ($LS $ly@@192)
                            (Lit |seqs#0@@10|)))
                :weight 3
                :skolemid |2486|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|shape#0@@5| T@U) (|i#0@@92| Int) (|j#0@@2| Int))
             (! (let ((a!1 (INTERNAL_lt_boogie
                             |j#0@@2|
                             (U_2_int ($Unbox intType
                                              (|Seq#Index| |shape#0@@5|
                                                           |i#0@@92|))))))
                (let ((a!2 (or (|Sequences.__default.FlattenIndex#canCall|
                                 |shape#0@@5|
                                 |i#0@@92|
                                 |j#0@@2|)
                               (and ($Is |shape#0@@5| (TSeq Tclass._System.nat))
                                    (INTERNAL_le_boogie 0 |i#0@@92|)
                                    (INTERNAL_le_boogie 0 |j#0@@2|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@92|
                                      (|Seq#Length| |shape#0@@5|))
                                    a!1))))
                  (=> (and (= (type |shape#0@@5|) (SeqType BoxType)) a!2)
                      (INTERNAL_le_boogie
                        0
                        (Sequences.__default.FlattenIndex
                          |shape#0@@5|
                          |i#0@@92|
                          |j#0@@2|)))))
                :pattern ((Sequences.__default.FlattenIndex
                            |shape#0@@5|
                            |i#0@@92|
                            |j#0@@2|))
                :skolemid |2487|
                :qid |Sequencesidfy.678:25|))))
  (=> true a!1)))
(assert (forall ((|shape#0@@6| T@U) (|i#0@@93| Int) (|j#0@@3| Int))
  (! (let ((a!1 (INTERNAL_lt_boogie
                  |j#0@@3|
                  (U_2_int ($Unbox intType (|Seq#Index| |shape#0@@6| |i#0@@93|))))))
     (let ((a!2 (= (|Sequences.__default.FlattenIndex#requires|
                     |shape#0@@6|
                     |i#0@@93|
                     |j#0@@3|)
                   (and (INTERNAL_lt_boogie
                          |i#0@@93|
                          (|Seq#Length| |shape#0@@6|))
                        a!1))))
     (let ((a!3 (=> (and ($Is |shape#0@@6| (TSeq Tclass._System.nat))
                         (INTERNAL_le_boogie 0 |i#0@@93|)
                         (INTERNAL_le_boogie 0 |j#0@@3|))
                    a!2)))
       (=> (= (type |shape#0@@6|) (SeqType BoxType)) a!3))))
     :pattern ((|Sequences.__default.FlattenIndex#requires|
                 |shape#0@@6|
                 |i#0@@93|
                 |j#0@@3|))
     :skolemid |2488|
     :qid |Sequencesidfy.678:25|)))
(assert (let ((a!1 (forall ((|shape#0@@7| T@U) (|i#0@@94| Int) (|j#0@@4| Int))
             (! (let ((a!1 (INTERNAL_lt_boogie
                             |j#0@@4|
                             (U_2_int ($Unbox intType
                                              (|Seq#Index| |shape#0@@7|
                                                           |i#0@@94|)))))
                      (a!3 (= (Sequences.__default.FlattenIndex
                                |shape#0@@7|
                                |i#0@@94|
                                |j#0@@4|)
                              (INTERNAL_add_boogie
                                (Sequences.__default.FlattenLength
                                  StartFuel_Sequences._default.FlattenLength
                                  (|Seq#Take| |shape#0@@7| |i#0@@94|))
                                |j#0@@4|))))
                (let ((a!2 (or (|Sequences.__default.FlattenIndex#canCall|
                                 |shape#0@@7|
                                 |i#0@@94|
                                 |j#0@@4|)
                               (and ($Is |shape#0@@7| (TSeq Tclass._System.nat))
                                    (INTERNAL_le_boogie 0 |i#0@@94|)
                                    (INTERNAL_le_boogie 0 |j#0@@4|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@94|
                                      (|Seq#Length| |shape#0@@7|))
                                    a!1))))
                  (=> (and (= (type |shape#0@@7|) (SeqType BoxType)) a!2)
                      (and (|Sequences.__default.FlattenLength#canCall|
                             (|Seq#Take| |shape#0@@7| |i#0@@94|))
                           a!3))))
                :pattern ((Sequences.__default.FlattenIndex
                            |shape#0@@7|
                            |i#0@@94|
                            |j#0@@4|))
                :skolemid |2489|
                :qid |Sequencesidfy.678:25|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|shape#0@@8| T@U) (|i#0@@95| Int) (|j#0@@5| Int))
      (! (let ((a!1 (U_2_int ($Unbox intType
                                     (|Seq#Index| (Lit |shape#0@@8|)
                                                  (LitInt |i#0@@95|)))))
               (a!4 (|Sequences.__default.FlattenLength#canCall|
                      (Lit (|Seq#Take| (Lit |shape#0@@8|) (LitInt |i#0@@95|)))))
               (a!5 (Sequences.__default.FlattenLength
                      StartFuel_Sequences._default.FlattenLength
                      (Lit (|Seq#Take| (Lit |shape#0@@8|) (LitInt |i#0@@95|))))))
         (let ((a!2 (and ($Is |shape#0@@8| (TSeq Tclass._System.nat))
                         (INTERNAL_le_boogie 0 |i#0@@95|)
                         (INTERNAL_le_boogie 0 |j#0@@5|)
                         (INTERNAL_lt_boogie
                           |i#0@@95|
                           (|Seq#Length| (Lit |shape#0@@8|)))
                         (INTERNAL_lt_boogie |j#0@@5| a!1)))
               (a!6 (and a!4
                         (= (Sequences.__default.FlattenIndex
                              (Lit |shape#0@@8|)
                              (LitInt |i#0@@95|)
                              (LitInt |j#0@@5|))
                            (INTERNAL_add_boogie a!5 |j#0@@5|)))))
         (let ((a!3 (and (= (type |shape#0@@8|) (SeqType BoxType))
                         (or (|Sequences.__default.FlattenIndex#canCall|
                               (Lit |shape#0@@8|)
                               (LitInt |i#0@@95|)
                               (LitInt |j#0@@5|))
                             a!2))))
           (=> a!3 a!6))))
         :pattern ((Sequences.__default.FlattenIndex
                     (Lit |shape#0@@8|)
                     (LitInt |i#0@@95|)
                     (LitInt |j#0@@5|)))
         :weight 3
         :skolemid |2490|
         :qid |Sequencesidfy.678:25|))))
(assert (forall ((arg0@@493 T@U) (arg1@@230 T@U) (arg2@@124 Int))
  (! (= (type (Sequences.__default.UnflattenIndex arg0@@493 arg1@@230 arg2@@124))
        DatatypeTypeType)
     :pattern ((Sequences.__default.UnflattenIndex
                 arg0@@493
                 arg1@@230
                 arg2@@124))
     :qid |funType:Sequences.__default.UnflattenIndex|)))
(assert (forall (($ly@@193 T@U) (|shape#0@@9| T@U) (|i#0@@96| Int))
  (! (=> (and (= (type $ly@@193) LayerTypeType)
              (= (type |shape#0@@9|) (SeqType BoxType)))
         (= (Sequences.__default.UnflattenIndex
              ($LS $ly@@193)
              |shape#0@@9|
              |i#0@@96|)
            (Sequences.__default.UnflattenIndex $ly@@193 |shape#0@@9| |i#0@@96|)))
     :pattern ((Sequences.__default.UnflattenIndex
                 ($LS $ly@@193)
                 |shape#0@@9|
                 |i#0@@96|))
     :skolemid |2491|
     :qid |Sequencesidfy.685:12|)))
(assert (forall (($ly@@194 T@U) (|shape#0@@10| T@U) (|i#0@@97| Int))
  (! (=> (and (= (type $ly@@194) LayerTypeType)
              (= (type |shape#0@@10|) (SeqType BoxType)))
         (= (Sequences.__default.UnflattenIndex
              $ly@@194
              |shape#0@@10|
              |i#0@@97|)
            (Sequences.__default.UnflattenIndex $LZ |shape#0@@10| |i#0@@97|)))
     :pattern ((Sequences.__default.UnflattenIndex
                 (AsFuelBottom $ly@@194)
                 |shape#0@@10|
                 |i#0@@97|))
     :skolemid |2492|
     :qid |Sequencesidfy.685:12|)))
(assert (let ((a!1 (forall (($ly@@195 T@U) (|shape#0@@11| T@U) (|i#0@@98| Int))
             (! (let ((a!1 (or (|Sequences.__default.UnflattenIndex#canCall|
                                 |shape#0@@11|
                                 |i#0@@98|)
                               (and ($Is |shape#0@@11|
                                         (TSeq Tclass._System.nat))
                                    (INTERNAL_le_boogie 0 |i#0@@98|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@98|
                                      (Sequences.__default.FlattenLength
                                        StartFuel_Sequences._default.FlattenLength
                                        |shape#0@@11|))))))
                  (=> (and (= (type $ly@@195) LayerTypeType)
                           (= (type |shape#0@@11|) (SeqType BoxType))
                           a!1)
                      ($Is (Sequences.__default.UnflattenIndex
                             $ly@@195
                             |shape#0@@11|
                             |i#0@@98|)
                           (Tclass._System.Tuple2
                             Tclass._System.nat
                             Tclass._System.nat))))
                :pattern ((Sequences.__default.UnflattenIndex
                            $ly@@195
                            |shape#0@@11|
                            |i#0@@98|))
                :skolemid |2493|
                :qid |Sequencesidfy.685:12|))))
  (=> true a!1)))
(assert (forall (($ly@@196 T@U) (|shape#0@@12| T@U) (|i#0@@99| Int))
  (! (=> (and (= (type $ly@@196) LayerTypeType)
              (= (type |shape#0@@12|) (SeqType BoxType))
              ($Is |shape#0@@12| (TSeq Tclass._System.nat))
              (INTERNAL_le_boogie 0 |i#0@@99|))
         (= (|Sequences.__default.UnflattenIndex#requires|
              $ly@@196
              |shape#0@@12|
              |i#0@@99|)
            (INTERNAL_lt_boogie
              |i#0@@99|
              (Sequences.__default.FlattenLength
                StartFuel_Sequences._default.FlattenLength
                |shape#0@@12|))))
     :pattern ((|Sequences.__default.UnflattenIndex#requires|
                 $ly@@196
                 |shape#0@@12|
                 |i#0@@99|))
     :skolemid |2494|
     :qid |Sequencesidfy.685:12|)))
(assert (and (= (type MoreFuel_Sequences._default.FlattenLength0) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.FlattenLength) LayerTypeType)))
(assert (let ((a!1 (forall (($ly@@197 T@U) (|shape#0@@13| T@U) (|i#0@@100| Int))
             (! (let ((a!1 (or (|Sequences.__default.UnflattenIndex#canCall|
                                 |shape#0@@13|
                                 |i#0@@100|)
                               (and ($Is |shape#0@@13|
                                         (TSeq Tclass._System.nat))
                                    (INTERNAL_le_boogie 0 |i#0@@100|)
                                    (INTERNAL_lt_boogie
                                      |i#0@@100|
                                      (Sequences.__default.FlattenLength
                                        StartFuel_Sequences._default.FlattenLength
                                        |shape#0@@13|)))))
                      (a!2 (=> (INTERNAL_lt_boogie
                                 |i#0@@100|
                                 (Sequences.__default.FlattenLength
                                   StartFuel_Sequences._default.FlattenLength
                                   (Sequences.__default.DropLast
                                     Tclass._System.nat
                                     |shape#0@@13|)))
                               (and (|Sequences.__default.DropLast#canCall|
                                      Tclass._System.nat
                                      |shape#0@@13|)
                                    (|Sequences.__default.UnflattenIndex#canCall|
                                      (Sequences.__default.DropLast
                                        Tclass._System.nat
                                        |shape#0@@13|)
                                      |i#0@@100|))))
                      (a!3 (not (INTERNAL_lt_boogie
                                  |i#0@@100|
                                  (Sequences.__default.FlattenLength
                                    StartFuel_Sequences._default.FlattenLength
                                    (Sequences.__default.DropLast
                                      Tclass._System.nat
                                      |shape#0@@13|)))))
                      (a!5 ($Box (int_2_U (INTERNAL_sub_boogie
                                            (|Seq#Length| |shape#0@@13|)
                                            1))))
                      (a!6 (int_2_U (INTERNAL_sub_boogie
                                      |i#0@@100|
                                      (Sequences.__default.FlattenLength
                                        StartFuel_Sequences._default.FlattenLength
                                        (Sequences.__default.DropLast
                                          Tclass._System.nat
                                          |shape#0@@13|))))))
                (let ((a!4 (=> a!3
                               (and (|Sequences.__default.DropLast#canCall|
                                      Tclass._System.nat
                                      |shape#0@@13|)
                                    (|Sequences.__default.FlattenLength#canCall|
                                      (Sequences.__default.DropLast
                                        Tclass._System.nat
                                        |shape#0@@13|)))))
                      (a!7 (ite (INTERNAL_lt_boogie
                                  |i#0@@100|
                                  (Sequences.__default.FlattenLength
                                    StartFuel_Sequences._default.FlattenLength
                                    (Sequences.__default.DropLast
                                      Tclass._System.nat
                                      |shape#0@@13|)))
                                (Sequences.__default.UnflattenIndex
                                  $ly@@197
                                  (Sequences.__default.DropLast
                                    Tclass._System.nat
                                    |shape#0@@13|)
                                  |i#0@@100|)
                                (|#_System._tuple#2._#Make2| a!5 ($Box a!6)))))
                (let ((a!8 (and (and (|Sequences.__default.DropLast#canCall|
                                       Tclass._System.nat
                                       |shape#0@@13|)
                                     (|Sequences.__default.FlattenLength#canCall|
                                       (Sequences.__default.DropLast
                                         Tclass._System.nat
                                         |shape#0@@13|)))
                                a!2
                                a!4
                                (= StartFuel_Sequences._default.FlattenLength
                                   ($LS MoreFuel_Sequences._default.FlattenLength0))
                                (= StartFuelAssert_Sequences._default.FlattenLength
                                   ($LS ($LS MoreFuel_Sequences._default.FlattenLength0)))
                                (= (AsFuelBottom MoreFuel_Sequences._default.FlattenLength0)
                                   MoreFuel_Sequences._default.FlattenLength0)
                                (= (Sequences.__default.UnflattenIndex
                                     ($LS $ly@@197)
                                     |shape#0@@13|
                                     |i#0@@100|)
                                   a!7))))
                  (=> (and (= (type $ly@@197) LayerTypeType)
                           (= (type |shape#0@@13|) (SeqType BoxType))
                           a!1)
                      a!8))))
                :pattern ((Sequences.__default.UnflattenIndex
                            ($LS $ly@@197)
                            |shape#0@@13|
                            |i#0@@100|))
                :skolemid |2495|
                :qid |Sequencesidfy.685:12|))))
  (=> true a!1)))
(assert (= (type MoreFuel_Sequences._default.FlattenLength1) LayerTypeType))
(assert (=> true
    (forall (($ly@@198 T@U) (|shape#0@@14| T@U) (|i#0@@101| Int))
      (! (let ((a!1 (and ($Is |shape#0@@14| (TSeq Tclass._System.nat))
                         (INTERNAL_le_boogie 0 |i#0@@101|)
                         (INTERNAL_lt_boogie
                           |i#0@@101|
                           (Sequences.__default.FlattenLength
                             StartFuel_Sequences._default.FlattenLength
                             (Lit |shape#0@@14|)))))
               (a!3 (|Sequences.__default.FlattenLength#canCall|
                      (Lit (Sequences.__default.DropLast
                             Tclass._System.nat
                             (Lit |shape#0@@14|)))))
               (a!4 (Sequences.__default.FlattenLength
                      StartFuel_Sequences._default.FlattenLength
                      (Lit (Sequences.__default.DropLast
                             Tclass._System.nat
                             (Lit |shape#0@@14|)))))
               (a!5 (|Sequences.__default.UnflattenIndex#canCall|
                      (Lit (Sequences.__default.DropLast
                             Tclass._System.nat
                             (Lit |shape#0@@14|)))
                      (LitInt |i#0@@101|)))
               (a!8 (Sequences.__default.UnflattenIndex
                      ($LS $ly@@198)
                      (Lit (Sequences.__default.DropLast
                             Tclass._System.nat
                             (Lit |shape#0@@14|)))
                      (LitInt |i#0@@101|)))
               (a!9 (int_2_U (INTERNAL_sub_boogie
                               (|Seq#Length| (Lit |shape#0@@14|))
                               1))))
         (let ((a!2 (and (= (type $ly@@198) LayerTypeType)
                         (= (type |shape#0@@14|) (SeqType BoxType))
                         (or (|Sequences.__default.UnflattenIndex#canCall|
                               (Lit |shape#0@@14|)
                               (LitInt |i#0@@101|))
                             a!1)))
               (a!6 (=> (INTERNAL_lt_boogie |i#0@@101| a!4)
                        (and (|Sequences.__default.DropLast#canCall|
                               Tclass._System.nat
                               (Lit |shape#0@@14|))
                             a!5)))
               (a!7 (=> (not (INTERNAL_lt_boogie |i#0@@101| a!4))
                        (and (|Sequences.__default.DropLast#canCall|
                               Tclass._System.nat
                               (Lit |shape#0@@14|))
                             a!3)))
               (a!10 (|#_System._tuple#2._#Make2|
                       ($Box a!9)
                       ($Box (int_2_U (INTERNAL_sub_boogie |i#0@@101| a!4))))))
         (let ((a!11 (and (and (|Sequences.__default.DropLast#canCall|
                                 Tclass._System.nat
                                 (Lit |shape#0@@14|))
                               a!3)
                          a!6
                          a!7
                          (= StartFuel_Sequences._default.FlattenLength
                             ($LS MoreFuel_Sequences._default.FlattenLength1))
                          (= StartFuelAssert_Sequences._default.FlattenLength
                             ($LS ($LS MoreFuel_Sequences._default.FlattenLength1)))
                          (= (AsFuelBottom MoreFuel_Sequences._default.FlattenLength1)
                             MoreFuel_Sequences._default.FlattenLength1)
                          (= (Sequences.__default.UnflattenIndex
                               ($LS $ly@@198)
                               (Lit |shape#0@@14|)
                               (LitInt |i#0@@101|))
                             (ite (INTERNAL_lt_boogie |i#0@@101| a!4) a!8 a!10)))))
           (=> a!2 a!11))))
         :pattern ((Sequences.__default.UnflattenIndex
                     ($LS $ly@@198)
                     (Lit |shape#0@@14|)
                     (LitInt |i#0@@101|)))
         :weight 3
         :skolemid |2496|
         :qid |Sequencesidfy.685:12|))))
(assert (forall (($ly@@199 T@U) (|s#0@@97| T@U))
  (! (=> (and (= (type $ly@@199) LayerTypeType)
              (= (type |s#0@@97|) (SeqType BoxType)))
         (= (Sequences.__default.seqMax ($LS $ly@@199) |s#0@@97|)
            (Sequences.__default.seqMax $ly@@199 |s#0@@97|)))
     :pattern ((Sequences.__default.seqMax ($LS $ly@@199) |s#0@@97|))
     :skolemid |2497|
     :qid |Sequencesidfy.795:22|)))
(assert (forall (($ly@@200 T@U) (|s#0@@98| T@U))
  (! (=> (and (= (type $ly@@200) LayerTypeType)
              (= (type |s#0@@98|) (SeqType BoxType)))
         (= (Sequences.__default.seqMax $ly@@200 |s#0@@98|)
            (Sequences.__default.seqMax $LZ |s#0@@98|)))
     :pattern ((Sequences.__default.seqMax (AsFuelBottom $ly@@200) |s#0@@98|))
     :skolemid |2498|
     :qid |Sequencesidfy.795:22|)))
(assert (let ((a!1 (forall (($ly@@201 T@U) (|s#0@@99| T@U))
             (! (let ((a!1 (or (|Sequences.__default.seqMax#canCall| |s#0@@99|)
                               (and ($Is |s#0@@99| (TSeq TInt))
                                    (INTERNAL_lt_boogie
                                      0
                                      (|Seq#Length| |s#0@@99|)))))
                      (a!2 (forall ((|k#0@@15| T@U))
                             (! (=> (and (= (type |k#0@@15|) intType)
                                         true
                                         (|Seq#Contains| |s#0@@99|
                                                         ($Box |k#0@@15|)))
                                    (INTERNAL_ge_boogie
                                      (Sequences.__default.seqMax
                                        $ly@@201
                                        |s#0@@99|)
                                      (U_2_int |k#0@@15|)))
                                :pattern ((|Seq#Contains| |s#0@@99|
                                                          ($Box |k#0@@15|)))
                                :skolemid |2499|
                                :qid |Sequencesidfy.797:20|)))
                      (a!3 (|Seq#Contains| |s#0@@99|
                                           ($Box (int_2_U (Sequences.__default.seqMax
                                                            $ly@@201
                                                            |s#0@@99|))))))
                  (=> (and (= (type $ly@@201) LayerTypeType)
                           (= (type |s#0@@99|) (SeqType BoxType))
                           a!1)
                      (and a!2 a!3)))
                :pattern ((Sequences.__default.seqMax $ly@@201 |s#0@@99|))
                :skolemid |2500|
                :qid |Sequencesidfy.795:22|))))
  (=> true a!1)))
(assert (forall (($ly@@202 T@U) (|s#0@@100| T@U))
  (! (=> (and (= (type $ly@@202) LayerTypeType)
              (= (type |s#0@@100|) (SeqType BoxType))
              ($Is |s#0@@100| (TSeq TInt)))
         (= (|Sequences.__default.seqMax#requires| $ly@@202 |s#0@@100|)
            (INTERNAL_lt_boogie 0 (|Seq#Length| |s#0@@100|))))
     :pattern ((|Sequences.__default.seqMax#requires| $ly@@202 |s#0@@100|))
     :skolemid |2501|
     :qid |Sequencesidfy.795:22|)))
(assert (let ((a!1 (forall (($ly@@203 T@U) (|s#0@@101| T@U))
             (! (let ((a!1 (or (|Sequences.__default.seqMax#canCall| |s#0@@101|)
                               (and ($Is |s#0@@101| (TSeq TInt))
                                    (INTERNAL_lt_boogie
                                      0
                                      (|Seq#Length| |s#0@@101|)))))
                      (a!2 (|Mathematics.__default.max#canCall|
                             (Sequences.__default.seqMax
                               $ly@@203
                               (Sequences.__default.DropLast TInt |s#0@@101|))
                             (U_2_int ($Unbox intType
                                              (Sequences.__default.Last
                                                TInt
                                                |s#0@@101|)))))
                      (a!4 (U_2_int ($Unbox intType
                                            (|Seq#Index| |s#0@@101| (LitInt 0)))))
                      (a!5 (Mathematics.__default.max
                             (Sequences.__default.seqMax
                               $ly@@203
                               (Sequences.__default.DropLast TInt |s#0@@101|))
                             (U_2_int ($Unbox intType
                                              (Sequences.__default.Last
                                                TInt
                                                |s#0@@101|))))))
                (let ((a!3 (=> (not (= (|Seq#Length| |s#0@@101|) (LitInt 1)))
                               (and (|Sequences.__default.DropLast#canCall|
                                      TInt
                                      |s#0@@101|)
                                    (|Sequences.__default.seqMax#canCall|
                                      (Sequences.__default.DropLast
                                        TInt
                                        |s#0@@101|))
                                    (|Sequences.__default.Last#canCall|
                                      TInt
                                      |s#0@@101|)
                                    a!2)))
                      (a!6 (= (Sequences.__default.seqMax
                                ($LS $ly@@203)
                                |s#0@@101|)
                              (ite (= (|Seq#Length| |s#0@@101|) (LitInt 1))
                                   a!4
                                   a!5))))
                  (=> (and (= (type $ly@@203) LayerTypeType)
                           (= (type |s#0@@101|) (SeqType BoxType))
                           a!1)
                      (and a!3 a!6))))
                :pattern ((Sequences.__default.seqMax ($LS $ly@@203) |s#0@@101|))
                :skolemid |2502|
                :qid |Sequencesidfy.795:22|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@204 T@U) (|s#0@@102| T@U))
      (! (let ((a!1 (and ($Is |s#0@@102| (TSeq TInt))
                         (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit |s#0@@102|)))))
               (a!3 (not (= (|Seq#Length| (Lit |s#0@@102|)) (LitInt 1))))
               (a!4 (|Sequences.__default.seqMax#canCall|
                      (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|)))))
               (a!5 (Sequences.__default.seqMax
                      ($LS $ly@@204)
                      (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|)))))
               (a!6 (U_2_int ($Unbox intType
                                     (Sequences.__default.Last
                                       TInt
                                       (Lit |s#0@@102|)))))
               (a!8 (U_2_int ($Unbox intType
                                     (|Seq#Index| (Lit |s#0@@102|) (LitInt 0))))))
         (let ((a!2 (and (= (type $ly@@204) LayerTypeType)
                         (= (type |s#0@@102|) (SeqType BoxType))
                         (or (|Sequences.__default.seqMax#canCall|
                               (Lit |s#0@@102|))
                             a!1)))
               (a!7 (=> a!3
                        (and (|Sequences.__default.DropLast#canCall|
                               TInt
                               (Lit |s#0@@102|))
                             a!4
                             (|Sequences.__default.Last#canCall|
                               TInt
                               (Lit |s#0@@102|))
                             (|Mathematics.__default.max#canCall|
                               a!5
                               (LitInt a!6)))))
               (a!9 (ite (= (|Seq#Length| (Lit |s#0@@102|)) (LitInt 1))
                         a!8
                         (Mathematics.__default.max a!5 (LitInt a!6)))))
         (let ((a!10 (and a!7
                          (= (Sequences.__default.seqMax
                               ($LS $ly@@204)
                               (Lit |s#0@@102|))
                             a!9))))
           (=> a!2 a!10))))
         :pattern ((Sequences.__default.seqMax ($LS $ly@@204) (Lit |s#0@@102|)))
         :weight 3
         :skolemid |2503|
         :qid |Sequencesidfy.795:22|))))
(assert (forall ((arg0@@494 T@U) (arg1@@231 T@U) (arg2@@125 Int) (arg3@@71 T@U))
  (! (= (type (Sequences.__default.fill arg0@@494 arg1@@231 arg2@@125 arg3@@71))
        (SeqType BoxType))
     :pattern ((Sequences.__default.fill arg0@@494 arg1@@231 arg2@@125 arg3@@71))
     :qid |funType:Sequences.__default.fill|)))
(assert (forall ((Sequences._default.fill$T T@U)
         ($ly@@205 T@U)
         (|n#0@@5| Int)
         (|t#0@@6| T@U))
  (! (=> (and (= (type Sequences._default.fill$T) TyType)
              (= (type $ly@@205) LayerTypeType)
              (= (type |t#0@@6|) BoxType))
         (= (Sequences.__default.fill
              Sequences._default.fill$T
              ($LS $ly@@205)
              |n#0@@5|
              |t#0@@6|)
            (Sequences.__default.fill
              Sequences._default.fill$T
              $ly@@205
              |n#0@@5|
              |t#0@@6|)))
     :pattern ((Sequences.__default.fill
                 Sequences._default.fill$T
                 ($LS $ly@@205)
                 |n#0@@5|
                 |t#0@@6|))
     :skolemid |2504|
     :qid |unknown.0:0|)))
(assert (forall ((Sequences._default.fill$T@@0 T@U)
         ($ly@@206 T@U)
         (|n#0@@6| Int)
         (|t#0@@7| T@U))
  (! (=> (and (= (type Sequences._default.fill$T@@0) TyType)
              (= (type $ly@@206) LayerTypeType)
              (= (type |t#0@@7|) BoxType))
         (= (Sequences.__default.fill
              Sequences._default.fill$T@@0
              $ly@@206
              |n#0@@6|
              |t#0@@7|)
            (Sequences.__default.fill
              Sequences._default.fill$T@@0
              $LZ
              |n#0@@6|
              |t#0@@7|)))
     :pattern ((Sequences.__default.fill
                 Sequences._default.fill$T@@0
                 (AsFuelBottom $ly@@206)
                 |n#0@@6|
                 |t#0@@7|))
     :skolemid |2505|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((Sequences._default.fill$T@@1 T@U)
             ($ly@@207 T@U)
             (|n#0@@7| Int)
             (|t#0@@8| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.fill$T@@1) TyType)
                         (= (type $ly@@207) LayerTypeType)
                         (= (type |t#0@@8|) BoxType)
                         (or (|Sequences.__default.fill#canCall|
                               Sequences._default.fill$T@@1
                               |n#0@@7|
                               |t#0@@8|)
                             (and ($IsBox |t#0@@8| Sequences._default.fill$T@@1)
                                  (INTERNAL_ge_boogie |n#0@@7| 0)))))
               (a!2 (forall ((|i#0@@102| Int))
                      (! (=> (and (INTERNAL_le_boogie 0 |i#0@@102|)
                                  (INTERNAL_lt_boogie |i#0@@102| |n#0@@7|))
                             (= (|Seq#Index| (Sequences.__default.fill
                                               Sequences._default.fill$T@@1
                                               $ly@@207
                                               |n#0@@7|
                                               |t#0@@8|)
                                             |i#0@@102|)
                                |t#0@@8|))
                         :pattern ((|Seq#Index| (Sequences.__default.fill
                                                  Sequences._default.fill$T@@1
                                                  $ly@@207
                                                  |n#0@@7|
                                                  |t#0@@8|)
                                                |i#0@@102|))
                         :skolemid |2506|
                         :qid |Sequencesidfy.884:18|))))
         (let ((a!3 (and (= (|Seq#Length| (Sequences.__default.fill
                                            Sequences._default.fill$T@@1
                                            $ly@@207
                                            |n#0@@7|
                                            |t#0@@8|))
                            |n#0@@7|)
                         a!2
                         ($Is (Sequences.__default.fill
                                Sequences._default.fill$T@@1
                                $ly@@207
                                |n#0@@7|
                                |t#0@@8|)
                              (TSeq Sequences._default.fill$T@@1)))))
           (=> a!1 a!3)))
         :pattern ((Sequences.__default.fill
                     Sequences._default.fill$T@@1
                     $ly@@207
                     |n#0@@7|
                     |t#0@@8|))
         :skolemid |2507|
         :qid |unknown.0:0|))))
(assert (forall ((Sequences._default.fill$T@@2 T@U)
         ($ly@@208 T@U)
         (|n#0@@8| Int)
         (|t#0@@9| T@U))
  (! (=> (and (= (type Sequences._default.fill$T@@2) TyType)
              (= (type $ly@@208) LayerTypeType)
              (= (type |t#0@@9|) BoxType)
              ($IsBox |t#0@@9| Sequences._default.fill$T@@2))
         (= (|Sequences.__default.fill#requires|
              Sequences._default.fill$T@@2
              $ly@@208
              |n#0@@8|
              |t#0@@9|)
            (INTERNAL_ge_boogie |n#0@@8| 0)))
     :pattern ((|Sequences.__default.fill#requires|
                 Sequences._default.fill$T@@2
                 $ly@@208
                 |n#0@@8|
                 |t#0@@9|))
     :skolemid |2508|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((Sequences._default.fill$T@@3 T@U)
             ($ly@@209 T@U)
             (|n#0@@9| Int)
             (|t#0@@10| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.fill$T@@3) TyType)
                         (= (type $ly@@209) LayerTypeType)
                         (= (type |t#0@@10|) BoxType)
                         (or (|Sequences.__default.fill#canCall|
                               Sequences._default.fill$T@@3
                               |n#0@@9|
                               |t#0@@10|)
                             (and ($IsBox |t#0@@10|
                                          Sequences._default.fill$T@@3)
                                  (INTERNAL_ge_boogie |n#0@@9| 0)))))
               (a!2 (=> (not (= |n#0@@9| (LitInt 0)))
                        (|Sequences.__default.fill#canCall|
                          Sequences._default.fill$T@@3
                          (INTERNAL_sub_boogie |n#0@@9| 1)
                          |t#0@@10|)))
               (a!3 (ite (= |n#0@@9| (LitInt 0))
                         (|Seq#Empty| BoxType)
                         (|Seq#Append| (Sequences.__default.fill
                                         Sequences._default.fill$T@@3
                                         $ly@@209
                                         (INTERNAL_sub_boogie |n#0@@9| 1)
                                         |t#0@@10|)
                                       (|Seq#Build| (|Seq#Empty| BoxType)
                                                    |t#0@@10|)))))
         (let ((a!4 (and a!2
                         (= (Sequences.__default.fill
                              Sequences._default.fill$T@@3
                              ($LS $ly@@209)
                              |n#0@@9|
                              |t#0@@10|)
                            a!3))))
           (=> a!1 a!4)))
         :pattern ((Sequences.__default.fill
                     Sequences._default.fill$T@@3
                     ($LS $ly@@209)
                     |n#0@@9|
                     |t#0@@10|))
         :skolemid |2509|
         :qid |unknown.0:0|))))
(assert (=> true
    (forall ((Sequences._default.fill$T@@4 T@U)
             ($ly@@210 T@U)
             (|n#0@@10| Int)
             (|t#0@@11| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.fill$T@@4) TyType)
                         (= (type $ly@@210) LayerTypeType)
                         (= (type |t#0@@11|) BoxType)
                         (or (|Sequences.__default.fill#canCall|
                               Sequences._default.fill$T@@4
                               (LitInt |n#0@@10|)
                               |t#0@@11|)
                             (and ($IsBox |t#0@@11|
                                          Sequences._default.fill$T@@4)
                                  (INTERNAL_ge_boogie |n#0@@10| 0)))))
               (a!2 (=> (not (= (LitInt |n#0@@10|) (LitInt 0)))
                        (|Sequences.__default.fill#canCall|
                          Sequences._default.fill$T@@4
                          (LitInt (INTERNAL_sub_boogie |n#0@@10| 1))
                          |t#0@@11|)))
               (a!3 (|Seq#Append| (Sequences.__default.fill
                                    Sequences._default.fill$T@@4
                                    ($LS $ly@@210)
                                    (LitInt (INTERNAL_sub_boogie |n#0@@10| 1))
                                    |t#0@@11|)
                                  (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@11|))))
         (let ((a!4 (= (Sequences.__default.fill
                         Sequences._default.fill$T@@4
                         ($LS $ly@@210)
                         (LitInt |n#0@@10|)
                         |t#0@@11|)
                       (ite (= (LitInt |n#0@@10|) (LitInt 0))
                            (|Seq#Empty| BoxType)
                            a!3))))
           (=> a!1 (and a!2 a!4))))
         :pattern ((Sequences.__default.fill
                     Sequences._default.fill$T@@4
                     ($LS $ly@@210)
                     (LitInt |n#0@@10|)
                     |t#0@@11|))
         :weight 3
         :skolemid |2510|
         :qid |unknown.0:0|))))
(assert (=> true
    (forall ((Sequences._default.fill$T@@5 T@U)
             ($ly@@211 T@U)
             (|n#0@@11| Int)
             (|t#0@@12| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.fill$T@@5) TyType)
                         (= (type $ly@@211) LayerTypeType)
                         (= (type |t#0@@12|) BoxType)
                         (or (|Sequences.__default.fill#canCall|
                               Sequences._default.fill$T@@5
                               (LitInt |n#0@@11|)
                               (Lit |t#0@@12|))
                             (and ($IsBox |t#0@@12|
                                          Sequences._default.fill$T@@5)
                                  (INTERNAL_ge_boogie |n#0@@11| 0)))))
               (a!2 (=> (not (= (LitInt |n#0@@11|) (LitInt 0)))
                        (|Sequences.__default.fill#canCall|
                          Sequences._default.fill$T@@5
                          (LitInt (INTERNAL_sub_boogie |n#0@@11| 1))
                          (Lit |t#0@@12|))))
               (a!3 (|Seq#Append| (Sequences.__default.fill
                                    Sequences._default.fill$T@@5
                                    ($LS $ly@@211)
                                    (LitInt (INTERNAL_sub_boogie |n#0@@11| 1))
                                    (Lit |t#0@@12|))
                                  (|Seq#Build| (|Seq#Empty| BoxType)
                                               (Lit |t#0@@12|)))))
         (let ((a!4 (= (Sequences.__default.fill
                         Sequences._default.fill$T@@5
                         ($LS $ly@@211)
                         (LitInt |n#0@@11|)
                         (Lit |t#0@@12|))
                       (ite (= (LitInt |n#0@@11|) (LitInt 0))
                            (|Seq#Empty| BoxType)
                            a!3))))
           (=> a!1 (and a!2 a!4))))
         :pattern ((Sequences.__default.fill
                     Sequences._default.fill$T@@5
                     ($LS $ly@@211)
                     (LitInt |n#0@@11|)
                     (Lit |t#0@@12|)))
         :weight 3
         :skolemid |2511|
         :qid |unknown.0:0|))))
(assert (=> true
    (forall ((Sequences._default.SeqHasUniqueElems$T T@U) (|s#0@@103| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.SeqHasUniqueElems$T)
                            TyType)
                         (= (type |s#0@@103|) (SeqType BoxType))
                         (or (|Sequences.__default.SeqHasUniqueElems#canCall|
                               Sequences._default.SeqHasUniqueElems$T
                               |s#0@@103|)
                             ($Is |s#0@@103|
                                  (TSeq Sequences._default.SeqHasUniqueElems$T))))))
           (=> a!1 true))
         :pattern ((Sequences.__default.SeqHasUniqueElems
                     Sequences._default.SeqHasUniqueElems$T
                     |s#0@@103|))
         :skolemid |2512|
         :qid |unknown.0:0|))))
(assert (forall ((Sequences._default.SeqHasUniqueElems$T@@0 T@U) (|s#0@@104| T@U))
  (! (=> (and (= (type Sequences._default.SeqHasUniqueElems$T@@0) TyType)
              (= (type |s#0@@104|) (SeqType BoxType))
              ($Is |s#0@@104| (TSeq Sequences._default.SeqHasUniqueElems$T@@0)))
         (= (|Sequences.__default.SeqHasUniqueElems#requires|
              Sequences._default.SeqHasUniqueElems$T@@0
              |s#0@@104|)
            true))
     :pattern ((|Sequences.__default.SeqHasUniqueElems#requires|
                 Sequences._default.SeqHasUniqueElems$T@@0
                 |s#0@@104|))
     :skolemid |2513|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Sequences._default.SeqHasUniqueElems$T@@1 T@U)
                    (|s#0@@105| T@U))
             (! (let ((a!1 (and (= (type Sequences._default.SeqHasUniqueElems$T@@1)
                                   TyType)
                                (= (type |s#0@@105|) (SeqType BoxType))
                                (or (|Sequences.__default.SeqHasUniqueElems#canCall|
                                      Sequences._default.SeqHasUniqueElems$T@@1
                                      |s#0@@105|)
                                    ($Is |s#0@@105|
                                         (TSeq Sequences._default.SeqHasUniqueElems$T@@1)))))
                      (a!2 (forall ((|i#0@@103| Int) (|j#0@@6| Int))
                             (! (=> (and (INTERNAL_le_boogie 0 |i#0@@103|)
                                         (INTERNAL_lt_boogie
                                           |i#0@@103|
                                           (|Seq#Length| |s#0@@105|))
                                         (INTERNAL_le_boogie 0 |j#0@@6|)
                                         (INTERNAL_lt_boogie
                                           |j#0@@6|
                                           (|Seq#Length| |s#0@@105|))
                                         (= (|Seq#Index| |s#0@@105| |i#0@@103|)
                                            (|Seq#Index| |s#0@@105| |j#0@@6|)))
                                    (= |i#0@@103| |j#0@@6|))
                                :pattern ((|Seq#Index| |s#0@@105| |j#0@@6|)
                                          (|Seq#Index| |s#0@@105| |i#0@@103|))
                                :skolemid |2514|
                                :qid |Sequencesidfy.896:12|))))
                  (=> a!1
                      (= (Sequences.__default.SeqHasUniqueElems
                           Sequences._default.SeqHasUniqueElems$T@@1
                           |s#0@@105|)
                         a!2)))
                :pattern ((Sequences.__default.SeqHasUniqueElems
                            Sequences._default.SeqHasUniqueElems$T@@1
                            |s#0@@105|))
                :skolemid |2515|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((Sequences._default.SeqHasUniqueElems$T@@2 T@U) (|s#0@@106| T@U))
      (! (let ((a!1 (and (= (type Sequences._default.SeqHasUniqueElems$T@@2)
                            TyType)
                         (= (type |s#0@@106|) (SeqType BoxType))
                         (or (|Sequences.__default.SeqHasUniqueElems#canCall|
                               Sequences._default.SeqHasUniqueElems$T@@2
                               (Lit |s#0@@106|))
                             ($Is |s#0@@106|
                                  (TSeq Sequences._default.SeqHasUniqueElems$T@@2)))))
               (a!2 (= (Sequences.__default.SeqHasUniqueElems
                         Sequences._default.SeqHasUniqueElems$T@@2
                         (Lit |s#0@@106|))
                       (forall ((|i#1@@19| Int) (|j#1@@0| Int))
                         (! (let ((a!1 (and (INTERNAL_le_boogie 0 |i#1@@19|)
                                            (INTERNAL_lt_boogie
                                              |i#1@@19|
                                              (|Seq#Length| (Lit |s#0@@106|)))
                                            (INTERNAL_le_boogie 0 |j#1@@0|)
                                            (INTERNAL_lt_boogie
                                              |j#1@@0|
                                              (|Seq#Length| (Lit |s#0@@106|)))
                                            (= (|Seq#Index| (Lit |s#0@@106|)
                                                            |i#1@@19|)
                                               (|Seq#Index| (Lit |s#0@@106|)
                                                            |j#1@@0|)))))
                              (=> a!1 (= |i#1@@19| |j#1@@0|)))
                            :pattern ((|Seq#Index| |s#0@@106| |j#1@@0|)
                                      (|Seq#Index| |s#0@@106| |i#1@@19|))
                            :skolemid |2516|
                            :qid |Sequencesidfy.896:12|)))))
           (=> a!1 a!2))
         :pattern ((Sequences.__default.SeqHasUniqueElems
                     Sequences._default.SeqHasUniqueElems$T@@2
                     (Lit |s#0@@106|)))
         :weight 3
         :skolemid |2517|
         :qid |unknown.0:0|))))
(assert (= (type Tclass.MapRemove_s.__default) TyType))
(assert (= (Tag Tclass.MapRemove_s.__default) Tagclass.MapRemove_s.__default))
(assert (= (TagFamily Tclass.MapRemove_s.__default) tytagFamily$_default))
(assert (forall ((bx@@154 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@154)) bx@@154)
                     ($Is ($Unbox refType bx@@154) Tclass.MapRemove_s.__default))))
       (=> (and (= (type bx@@154) BoxType)
                ($IsBox bx@@154 Tclass.MapRemove_s.__default))
           a!1))
     :pattern (($IsBox bx@@154 Tclass.MapRemove_s.__default))
     :skolemid |2518|
     :qid |unknown.0:0|)))
(assert (forall (($o@@41 T@U))
  (! (let ((a!1 (= ($Is $o@@41 Tclass.MapRemove_s.__default)
                   (or (= $o@@41 null)
                       (= (dtype $o@@41) Tclass.MapRemove_s.__default)))))
       (=> (= (type $o@@41) refType) a!1))
     :pattern (($Is $o@@41 Tclass.MapRemove_s.__default))
     :skolemid |2519|
     :qid |unknown.0:0|)))
(assert (forall (($o@@42 T@U) ($h@@91 T@U))
  (! (let ((a!1 (or (= $o@@42 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@91 $o@@42)
                                              alloc)))))
       (=> (and (= (type $o@@42) refType)
                (= (type $h@@91) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@42 Tclass.MapRemove_s.__default $h@@91) a!1)))
     :pattern (($IsAlloc $o@@42 Tclass.MapRemove_s.__default $h@@91))
     :skolemid |2520|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@495 T@U)
         (arg1@@232 T@U)
         (arg2@@126 T@U)
         (arg3@@72 T@U)
         (arg4@@43 T@U))
  (! (= (type (MapRemove_s.__default.MapRemove1
                arg0@@495
                arg1@@232
                arg2@@126
                arg3@@72
                arg4@@43))
        (MapType BoxType BoxType))
     :pattern ((MapRemove_s.__default.MapRemove1
                 arg0@@495
                 arg1@@232
                 arg2@@126
                 arg3@@72
                 arg4@@43))
     :qid |funType:MapRemove_s.__default.MapRemove1|)))
(assert (forall ((MapRemove_s._default.MapRemove1$K T@U)
         (MapRemove_s._default.MapRemove1$V T@U)
         ($ly@@212 T@U)
         (|m#0@@13| T@U)
         (|k#0@@16| T@U))
  (! (=> (and (= (type MapRemove_s._default.MapRemove1$K) TyType)
              (= (type MapRemove_s._default.MapRemove1$V) TyType)
              (= (type $ly@@212) LayerTypeType)
              (= (type |m#0@@13|) (MapType BoxType BoxType))
              (= (type |k#0@@16|) BoxType))
         (= (MapRemove_s.__default.MapRemove1
              MapRemove_s._default.MapRemove1$K
              MapRemove_s._default.MapRemove1$V
              ($LS $ly@@212)
              |m#0@@13|
              |k#0@@16|)
            (MapRemove_s.__default.MapRemove1
              MapRemove_s._default.MapRemove1$K
              MapRemove_s._default.MapRemove1$V
              $ly@@212
              |m#0@@13|
              |k#0@@16|)))
     :pattern ((MapRemove_s.__default.MapRemove1
                 MapRemove_s._default.MapRemove1$K
                 MapRemove_s._default.MapRemove1$V
                 ($LS $ly@@212)
                 |m#0@@13|
                 |k#0@@16|))
     :skolemid |2521|
     :qid |unknown.0:0|)))
(assert (forall ((MapRemove_s._default.MapRemove1$K@@0 T@U)
         (MapRemove_s._default.MapRemove1$V@@0 T@U)
         ($ly@@213 T@U)
         (|m#0@@14| T@U)
         (|k#0@@17| T@U))
  (! (=> (and (= (type MapRemove_s._default.MapRemove1$K@@0) TyType)
              (= (type MapRemove_s._default.MapRemove1$V@@0) TyType)
              (= (type $ly@@213) LayerTypeType)
              (= (type |m#0@@14|) (MapType BoxType BoxType))
              (= (type |k#0@@17|) BoxType))
         (= (MapRemove_s.__default.MapRemove1
              MapRemove_s._default.MapRemove1$K@@0
              MapRemove_s._default.MapRemove1$V@@0
              $ly@@213
              |m#0@@14|
              |k#0@@17|)
            (MapRemove_s.__default.MapRemove1
              MapRemove_s._default.MapRemove1$K@@0
              MapRemove_s._default.MapRemove1$V@@0
              $LZ
              |m#0@@14|
              |k#0@@17|)))
     :pattern ((MapRemove_s.__default.MapRemove1
                 MapRemove_s._default.MapRemove1$K@@0
                 MapRemove_s._default.MapRemove1$V@@0
                 (AsFuelBottom $ly@@213)
                 |m#0@@14|
                 |k#0@@17|))
     :skolemid |2522|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((MapRemove_s._default.MapRemove1$K@@1 T@U)
                    (MapRemove_s._default.MapRemove1$V@@1 T@U)
                    ($ly@@214 T@U)
                    (|m#0@@15| T@U)
                    (|k#0@@18| T@U))
             (! (let ((a!1 (or (|MapRemove_s.__default.MapRemove1#canCall|
                                 MapRemove_s._default.MapRemove1$K@@1
                                 MapRemove_s._default.MapRemove1$V@@1
                                 |m#0@@15|
                                 |k#0@@18|)
                               (and ($Is |m#0@@15|
                                         (TMap MapRemove_s._default.MapRemove1$K@@1
                                               MapRemove_s._default.MapRemove1$V@@1))
                                    ($IsBox |k#0@@18|
                                            MapRemove_s._default.MapRemove1$K@@1))))
                      (a!2 (forall ((|j#1@@1| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1
                                                                                     MapRemove_s._default.MapRemove1$K@@1
                                                                                     MapRemove_s._default.MapRemove1$V@@1
                                                                                     $ly@@214
                                                                                     |m#0@@15|
                                                                                     |k#0@@18|))
                                                                     |j#1@@1|))))
                                (let ((a!2 (=> a!1
                                               (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|)
                                                                         |j#1@@1|)))))
                                (let ((a!3 (and a!2
                                                (=> a!1
                                                    (not (= |j#1@@1| |k#0@@18|))))))
                                  (=> (and (= (type |j#1@@1|) BoxType)
                                           ($IsBox |j#1@@1|
                                                   MapRemove_s._default.MapRemove1$K@@1))
                                      a!3))))
                                :pattern ((MapType0Select (|Map#Domain| |m#0@@15|)
                                                          |j#1@@1|))
                                :pattern ((MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1
                                                                          MapRemove_s._default.MapRemove1$K@@1
                                                                          MapRemove_s._default.MapRemove1$V@@1
                                                                          $ly@@214
                                                                          |m#0@@15|
                                                                          |k#0@@18|))
                                                          |j#1@@1|))
                                :skolemid |2524|
                                :qid |MapRemovesdfy.16:20|)))
                      (a!3 (INTERNAL_le_boogie
                             (|Set#Card| (|Map#Domain| (MapRemove_s.__default.MapRemove1
                                                         MapRemove_s._default.MapRemove1$K@@1
                                                         MapRemove_s._default.MapRemove1$V@@1
                                                         $ly@@214
                                                         |m#0@@15|
                                                         |k#0@@18|)))
                             (|Set#Card| (|Map#Domain| |m#0@@15|))))
                      (a!4 (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|)
                                                         |k#0@@18|))
                               (= (|Map#Card| (MapRemove_s.__default.MapRemove1
                                                MapRemove_s._default.MapRemove1$K@@1
                                                MapRemove_s._default.MapRemove1$V@@1
                                                $ly@@214
                                                |m#0@@15|
                                                |k#0@@18|))
                                  (INTERNAL_sub_boogie (|Map#Card| |m#0@@15|) 1))))
                      (a!5 (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|)
                                                          |k#0@@18|)))))
                (let ((a!6 (=> a!5
                               (= (|Map#Card| (MapRemove_s.__default.MapRemove1
                                                MapRemove_s._default.MapRemove1$K@@1
                                                MapRemove_s._default.MapRemove1$V@@1
                                                $ly@@214
                                                |m#0@@15|
                                                |k#0@@18|))
                                  (|Map#Card| |m#0@@15|)))))
                  (=> (and (= (type MapRemove_s._default.MapRemove1$K@@1)
                              TyType)
                           (= (type MapRemove_s._default.MapRemove1$V@@1)
                              TyType)
                           (= (type $ly@@214) LayerTypeType)
                           (= (type |m#0@@15|) (MapType BoxType BoxType))
                           (= (type |k#0@@18|) BoxType)
                           a!1)
                      (and (forall ((|j#0@@7| T@U))
                             (! (let ((a!1 (and (and (= (type |j#0@@7|) BoxType)
                                                     ($IsBox |j#0@@7|
                                                             MapRemove_s._default.MapRemove1$K@@1))
                                                (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|)
                                                                          |j#0@@7|))
                                                (not (= |j#0@@7| |k#0@@18|))))
                                      (a!2 (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1
                                                                                     MapRemove_s._default.MapRemove1$K@@1
                                                                                     MapRemove_s._default.MapRemove1$V@@1
                                                                                     $ly@@214
                                                                                     |m#0@@15|
                                                                                     |k#0@@18|))
                                                                     |j#0@@7|))))
                                  (=> a!1 a!2))
                                :pattern ((MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1
                                                                          MapRemove_s._default.MapRemove1$K@@1
                                                                          MapRemove_s._default.MapRemove1$V@@1
                                                                          $ly@@214
                                                                          |m#0@@15|
                                                                          |k#0@@18|))
                                                          |j#0@@7|))
                                :pattern ((MapType0Select (|Map#Domain| |m#0@@15|)
                                                          |j#0@@7|))
                                :skolemid |2523|
                                :qid |MapRemovesdfy.15:20|))
                           a!2
                           (forall ((|j#2| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1
                                                                                     MapRemove_s._default.MapRemove1$K@@1
                                                                                     MapRemove_s._default.MapRemove1$V@@1
                                                                                     $ly@@214
                                                                                     |m#0@@15|
                                                                                     |k#0@@18|))
                                                                     |j#2|)))
                                      (a!3 (= (MapType0Select (|Map#Elements| (MapRemove_s.__default.MapRemove1
                                                                                MapRemove_s._default.MapRemove1$K@@1
                                                                                MapRemove_s._default.MapRemove1$V@@1
                                                                                $ly@@214
                                                                                |m#0@@15|
                                                                                |k#0@@18|))
                                                              |j#2|)
                                              (MapType0Select (|Map#Elements| |m#0@@15|)
                                                              |j#2|))))
                                (let ((a!2 (and (and (= (type |j#2|) BoxType)
                                                     ($IsBox |j#2|
                                                             MapRemove_s._default.MapRemove1$K@@1))
                                                a!1)))
                                  (=> a!2 a!3)))
                                :pattern ((MapType0Select (|Map#Elements| |m#0@@15|)
                                                          |j#2|))
                                :pattern ((MapType0Select (|Map#Elements| (MapRemove_s.__default.MapRemove1
                                                                            MapRemove_s._default.MapRemove1$K@@1
                                                                            MapRemove_s._default.MapRemove1$V@@1
                                                                            $ly@@214
                                                                            |m#0@@15|
                                                                            |k#0@@18|))
                                                          |j#2|))
                                :pattern ((MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1
                                                                          MapRemove_s._default.MapRemove1$K@@1
                                                                          MapRemove_s._default.MapRemove1$V@@1
                                                                          $ly@@214
                                                                          |m#0@@15|
                                                                          |k#0@@18|))
                                                          |j#2|))
                                :skolemid |2525|
                                :qid |MapRemovesdfy.17:20|))
                           a!3
                           a!4
                           a!6
                           ($Is (MapRemove_s.__default.MapRemove1
                                  MapRemove_s._default.MapRemove1$K@@1
                                  MapRemove_s._default.MapRemove1$V@@1
                                  $ly@@214
                                  |m#0@@15|
                                  |k#0@@18|)
                                (TMap MapRemove_s._default.MapRemove1$K@@1
                                      MapRemove_s._default.MapRemove1$V@@1))))))
                :pattern ((MapRemove_s.__default.MapRemove1
                            MapRemove_s._default.MapRemove1$K@@1
                            MapRemove_s._default.MapRemove1$V@@1
                            $ly@@214
                            |m#0@@15|
                            |k#0@@18|))
                :skolemid |2526|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((MapRemove_s._default.MapRemove1$K@@2 T@U)
         (MapRemove_s._default.MapRemove1$V@@2 T@U)
         ($ly@@215 T@U)
         (|m#0@@16| T@U)
         (|k#0@@19| T@U))
  (! (=> (and (= (type MapRemove_s._default.MapRemove1$K@@2) TyType)
              (= (type MapRemove_s._default.MapRemove1$V@@2) TyType)
              (= (type $ly@@215) LayerTypeType)
              (= (type |m#0@@16|) (MapType BoxType BoxType))
              (= (type |k#0@@19|) BoxType)
              ($Is |m#0@@16|
                   (TMap MapRemove_s._default.MapRemove1$K@@2
                         MapRemove_s._default.MapRemove1$V@@2))
              ($IsBox |k#0@@19| MapRemove_s._default.MapRemove1$K@@2))
         (= (|MapRemove_s.__default.MapRemove1#requires|
              MapRemove_s._default.MapRemove1$K@@2
              MapRemove_s._default.MapRemove1$V@@2
              $ly@@215
              |m#0@@16|
              |k#0@@19|)
            true))
     :pattern ((|MapRemove_s.__default.MapRemove1#requires|
                 MapRemove_s._default.MapRemove1$K@@2
                 MapRemove_s._default.MapRemove1$V@@2
                 $ly@@215
                 |m#0@@16|
                 |k#0@@19|))
     :skolemid |2527|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((arg0@@496 T@U) (arg1@@233 T@U) (arg2@@127 T@U))
             (! (= (type (|lambda#147| arg0@@496 arg1@@233 arg2@@127))
                   (MapType0Type BoxType boolType))
                :pattern ((|lambda#147| arg0@@496 arg1@@233 arg2@@127))
                :qid |funType:lambda#147|)))
      (a!2 (forall ((arg0@@497 T@U))
             (! (= (type (|lambda#148| arg0@@497))
                   (MapType0Type BoxType BoxType))
                :pattern ((|lambda#148| arg0@@497))
                :qid |funType:lambda#148|))))
  (and a!1 a!2)))
(assert (let ((a!1 (forall ((MapRemove_s._default.MapRemove1$K@@3 T@U)
                    (MapRemove_s._default.MapRemove1$V@@3 T@U)
                    ($ly@@216 T@U)
                    (|m#0@@17| T@U)
                    (|k#0@@20| T@U))
             (! (let ((a!1 (or (|MapRemove_s.__default.MapRemove1#canCall|
                                 MapRemove_s._default.MapRemove1$K@@3
                                 MapRemove_s._default.MapRemove1$V@@3
                                 |m#0@@17|
                                 |k#0@@20|)
                               (and ($Is |m#0@@17|
                                         (TMap MapRemove_s._default.MapRemove1$K@@3
                                               MapRemove_s._default.MapRemove1$V@@3))
                                    ($IsBox |k#0@@20|
                                            MapRemove_s._default.MapRemove1$K@@3))))
                      (a!2 (= (MapRemove_s.__default.MapRemove1
                                MapRemove_s._default.MapRemove1$K@@3
                                MapRemove_s._default.MapRemove1$V@@3
                                ($LS $ly@@216)
                                |m#0@@17|
                                |k#0@@20|)
                              (|Map#Glue| (|lambda#147| MapRemove_s._default.MapRemove1$K@@3
                                                        (|Map#Domain| |m#0@@17|)
                                                        |k#0@@20|)
                                          (|lambda#148| (|Map#Elements| |m#0@@17|))
                                          (TMap MapRemove_s._default.MapRemove1$K@@3
                                                MapRemove_s._default.MapRemove1$V@@3)))))
                  (=> (and (= (type MapRemove_s._default.MapRemove1$K@@3)
                              TyType)
                           (= (type MapRemove_s._default.MapRemove1$V@@3)
                              TyType)
                           (= (type $ly@@216) LayerTypeType)
                           (= (type |m#0@@17|) (MapType BoxType BoxType))
                           (= (type |k#0@@20|) BoxType)
                           a!1)
                      a!2))
                :pattern ((MapRemove_s.__default.MapRemove1
                            MapRemove_s._default.MapRemove1$K@@3
                            MapRemove_s._default.MapRemove1$V@@3
                            ($LS $ly@@216)
                            |m#0@@17|
                            |k#0@@20|))
                :skolemid |2528|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((MapRemove_s._default.MapRemove1$K@@4 T@U)
                    (MapRemove_s._default.MapRemove1$V@@4 T@U)
                    ($ly@@217 T@U)
                    (|m#0@@18| T@U)
                    (|k#0@@21| T@U))
             (! (let ((a!1 (or (|MapRemove_s.__default.MapRemove1#canCall|
                                 MapRemove_s._default.MapRemove1$K@@4
                                 MapRemove_s._default.MapRemove1$V@@4
                                 (Lit |m#0@@18|)
                                 |k#0@@21|)
                               (and ($Is |m#0@@18|
                                         (TMap MapRemove_s._default.MapRemove1$K@@4
                                               MapRemove_s._default.MapRemove1$V@@4))
                                    ($IsBox |k#0@@21|
                                            MapRemove_s._default.MapRemove1$K@@4))))
                      (a!2 (|Map#Glue| (|lambda#147| MapRemove_s._default.MapRemove1$K@@4
                                                     (|Map#Domain| |m#0@@18|)
                                                     |k#0@@21|)
                                       (|lambda#148| (|Map#Elements| (Lit |m#0@@18|)))
                                       (TMap MapRemove_s._default.MapRemove1$K@@4
                                             MapRemove_s._default.MapRemove1$V@@4))))
                  (=> (and (= (type MapRemove_s._default.MapRemove1$K@@4)
                              TyType)
                           (= (type MapRemove_s._default.MapRemove1$V@@4)
                              TyType)
                           (= (type $ly@@217) LayerTypeType)
                           (= (type |m#0@@18|) (MapType BoxType BoxType))
                           (= (type |k#0@@21|) BoxType)
                           a!1)
                      (= (MapRemove_s.__default.MapRemove1
                           MapRemove_s._default.MapRemove1$K@@4
                           MapRemove_s._default.MapRemove1$V@@4
                           ($LS $ly@@217)
                           (Lit |m#0@@18|)
                           |k#0@@21|)
                         a!2)))
                :pattern ((MapRemove_s.__default.MapRemove1
                            MapRemove_s._default.MapRemove1$K@@4
                            MapRemove_s._default.MapRemove1$V@@4
                            ($LS $ly@@217)
                            (Lit |m#0@@18|)
                            |k#0@@21|))
                :weight 3
                :skolemid |2529|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((MapRemove_s._default.MapRemove1$K@@5 T@U)
                    (MapRemove_s._default.MapRemove1$V@@5 T@U)
                    ($ly@@218 T@U)
                    (|m#0@@19| T@U)
                    (|k#0@@22| T@U))
             (! (let ((a!1 (or (|MapRemove_s.__default.MapRemove1#canCall|
                                 MapRemove_s._default.MapRemove1$K@@5
                                 MapRemove_s._default.MapRemove1$V@@5
                                 (Lit |m#0@@19|)
                                 (Lit |k#0@@22|))
                               (and ($Is |m#0@@19|
                                         (TMap MapRemove_s._default.MapRemove1$K@@5
                                               MapRemove_s._default.MapRemove1$V@@5))
                                    ($IsBox |k#0@@22|
                                            MapRemove_s._default.MapRemove1$K@@5))))
                      (a!2 (|Map#Glue| (|lambda#147| MapRemove_s._default.MapRemove1$K@@5
                                                     (|Map#Domain| |m#0@@19|)
                                                     |k#0@@22|)
                                       (|lambda#148| (|Map#Elements| (Lit |m#0@@19|)))
                                       (TMap MapRemove_s._default.MapRemove1$K@@5
                                             MapRemove_s._default.MapRemove1$V@@5))))
                  (=> (and (= (type MapRemove_s._default.MapRemove1$K@@5)
                              TyType)
                           (= (type MapRemove_s._default.MapRemove1$V@@5)
                              TyType)
                           (= (type $ly@@218) LayerTypeType)
                           (= (type |m#0@@19|) (MapType BoxType BoxType))
                           (= (type |k#0@@22|) BoxType)
                           a!1)
                      (= (MapRemove_s.__default.MapRemove1
                           MapRemove_s._default.MapRemove1$K@@5
                           MapRemove_s._default.MapRemove1$V@@5
                           ($LS $ly@@218)
                           (Lit |m#0@@19|)
                           (Lit |k#0@@22|))
                         a!2)))
                :pattern ((MapRemove_s.__default.MapRemove1
                            MapRemove_s._default.MapRemove1$K@@5
                            MapRemove_s._default.MapRemove1$V@@5
                            ($LS $ly@@218)
                            (Lit |m#0@@19|)
                            (Lit |k#0@@22|)))
                :weight 3
                :skolemid |2530|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type Tclass.Maps.__default) TyType))
(assert (= (Tag Tclass.Maps.__default) Tagclass.Maps.__default))
(assert (= (TagFamily Tclass.Maps.__default) tytagFamily$_default))
(assert (forall ((bx@@155 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@155)) bx@@155)
                     ($Is ($Unbox refType bx@@155) Tclass.Maps.__default))))
       (=> (and (= (type bx@@155) BoxType)
                ($IsBox bx@@155 Tclass.Maps.__default))
           a!1))
     :pattern (($IsBox bx@@155 Tclass.Maps.__default))
     :skolemid |2531|
     :qid |unknown.0:0|)))
(assert (forall (($o@@43 T@U))
  (! (let ((a!1 (= ($Is $o@@43 Tclass.Maps.__default)
                   (or (= $o@@43 null) (= (dtype $o@@43) Tclass.Maps.__default)))))
       (=> (= (type $o@@43) refType) a!1))
     :pattern (($Is $o@@43 Tclass.Maps.__default))
     :skolemid |2532|
     :qid |unknown.0:0|)))
(assert (forall (($o@@44 T@U) ($h@@92 T@U))
  (! (let ((a!1 (or (= $o@@44 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@92 $o@@44)
                                              alloc)))))
       (=> (and (= (type $o@@44) refType)
                (= (type $h@@92) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@44 Tclass.Maps.__default $h@@92) a!1)))
     :pattern (($IsAlloc $o@@44 Tclass.Maps.__default $h@@92))
     :skolemid |2533|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapsTo$K T@U)
                    (Maps._default.IMapsTo$V T@U)
                    (|m#0@@20| T@U)
                    (|k#0@@23| T@U)
                    (|v#0@@31| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapsTo#canCall|
                                 Maps._default.IMapsTo$K
                                 Maps._default.IMapsTo$V
                                 |m#0@@20|
                                 |k#0@@23|
                                 |v#0@@31|)
                               (and ($Is |m#0@@20|
                                         (TIMap Maps._default.IMapsTo$K
                                                Maps._default.IMapsTo$V))
                                    ($IsBox |k#0@@23| Maps._default.IMapsTo$K)
                                    ($IsBox |v#0@@31| Maps._default.IMapsTo$V)))))
                  (=> (and (= (type Maps._default.IMapsTo$K) TyType)
                           (= (type Maps._default.IMapsTo$V) TyType)
                           (= (type |m#0@@20|) (IMapType BoxType BoxType))
                           (= (type |k#0@@23|) BoxType)
                           (= (type |v#0@@31|) BoxType)
                           a!1)
                      true))
                :pattern ((Maps.__default.IMapsTo
                            Maps._default.IMapsTo$K
                            Maps._default.IMapsTo$V
                            |m#0@@20|
                            |k#0@@23|
                            |v#0@@31|))
                :skolemid |2534|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapsTo$K@@0 T@U)
         (Maps._default.IMapsTo$V@@0 T@U)
         (|m#0@@21| T@U)
         (|k#0@@24| T@U)
         (|v#0@@32| T@U))
  (! (=> (and (= (type Maps._default.IMapsTo$K@@0) TyType)
              (= (type Maps._default.IMapsTo$V@@0) TyType)
              (= (type |m#0@@21|) (IMapType BoxType BoxType))
              (= (type |k#0@@24|) BoxType)
              (= (type |v#0@@32|) BoxType)
              ($Is |m#0@@21|
                   (TIMap Maps._default.IMapsTo$K@@0 Maps._default.IMapsTo$V@@0))
              ($IsBox |k#0@@24| Maps._default.IMapsTo$K@@0)
              ($IsBox |v#0@@32| Maps._default.IMapsTo$V@@0))
         (= (|Maps.__default.IMapsTo#requires|
              Maps._default.IMapsTo$K@@0
              Maps._default.IMapsTo$V@@0
              |m#0@@21|
              |k#0@@24|
              |v#0@@32|)
            true))
     :pattern ((|Maps.__default.IMapsTo#requires|
                 Maps._default.IMapsTo$K@@0
                 Maps._default.IMapsTo$V@@0
                 |m#0@@21|
                 |k#0@@24|
                 |v#0@@32|))
     :skolemid |2535|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapsTo$K@@1 T@U)
                    (Maps._default.IMapsTo$V@@1 T@U)
                    (|m#0@@22| T@U)
                    (|k#0@@25| T@U)
                    (|v#0@@33| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapsTo#canCall|
                                 Maps._default.IMapsTo$K@@1
                                 Maps._default.IMapsTo$V@@1
                                 |m#0@@22|
                                 |k#0@@25|
                                 |v#0@@33|)
                               (and ($Is |m#0@@22|
                                         (TIMap Maps._default.IMapsTo$K@@1
                                                Maps._default.IMapsTo$V@@1))
                                    ($IsBox |k#0@@25|
                                            Maps._default.IMapsTo$K@@1)
                                    ($IsBox |v#0@@33|
                                            Maps._default.IMapsTo$V@@1))))
                      (a!2 (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@22|)
                                                          |k#0@@25|))
                                (= (MapType0Select (|IMap#Elements| |m#0@@22|)
                                                   |k#0@@25|)
                                   |v#0@@33|))))
                  (=> (and (= (type Maps._default.IMapsTo$K@@1) TyType)
                           (= (type Maps._default.IMapsTo$V@@1) TyType)
                           (= (type |m#0@@22|) (IMapType BoxType BoxType))
                           (= (type |k#0@@25|) BoxType)
                           (= (type |v#0@@33|) BoxType)
                           a!1)
                      (= (Maps.__default.IMapsTo
                           Maps._default.IMapsTo$K@@1
                           Maps._default.IMapsTo$V@@1
                           |m#0@@22|
                           |k#0@@25|
                           |v#0@@33|)
                         a!2)))
                :pattern ((Maps.__default.IMapsTo
                            Maps._default.IMapsTo$K@@1
                            Maps._default.IMapsTo$V@@1
                            |m#0@@22|
                            |k#0@@25|
                            |v#0@@33|))
                :skolemid |2536|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapsTo$K@@2 T@U)
                    (Maps._default.IMapsTo$V@@2 T@U)
                    (|m#0@@23| T@U)
                    (|k#0@@26| T@U)
                    (|v#0@@34| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapsTo#canCall|
                                 Maps._default.IMapsTo$K@@2
                                 Maps._default.IMapsTo$V@@2
                                 (Lit |m#0@@23|)
                                 (Lit |k#0@@26|)
                                 (Lit |v#0@@34|))
                               (and ($Is |m#0@@23|
                                         (TIMap Maps._default.IMapsTo$K@@2
                                                Maps._default.IMapsTo$V@@2))
                                    ($IsBox |k#0@@26|
                                            Maps._default.IMapsTo$K@@2)
                                    ($IsBox |v#0@@34|
                                            Maps._default.IMapsTo$V@@2))))
                      (a!2 (= (MapType0Select (|IMap#Elements| (Lit |m#0@@23|))
                                              (Lit |k#0@@26|))
                              (Lit |v#0@@34|))))
                (let ((a!3 (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@23|)
                                                          |k#0@@26|))
                                a!2)))
                  (=> (and (= (type Maps._default.IMapsTo$K@@2) TyType)
                           (= (type Maps._default.IMapsTo$V@@2) TyType)
                           (= (type |m#0@@23|) (IMapType BoxType BoxType))
                           (= (type |k#0@@26|) BoxType)
                           (= (type |v#0@@34|) BoxType)
                           a!1)
                      (= (Maps.__default.IMapsTo
                           Maps._default.IMapsTo$K@@2
                           Maps._default.IMapsTo$V@@2
                           (Lit |m#0@@23|)
                           (Lit |k#0@@26|)
                           (Lit |v#0@@34|))
                         a!3))))
                :pattern ((Maps.__default.IMapsTo
                            Maps._default.IMapsTo$K@@2
                            Maps._default.IMapsTo$V@@2
                            (Lit |m#0@@23|)
                            (Lit |k#0@@26|)
                            (Lit |v#0@@34|)))
                :weight 3
                :skolemid |2537|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsTo$K T@U)
                    (Maps._default.MapsTo$V T@U)
                    (|m#0@@24| T@U)
                    (|k#0@@27| T@U)
                    (|v#0@@35| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsTo#canCall|
                                 Maps._default.MapsTo$K
                                 Maps._default.MapsTo$V
                                 |m#0@@24|
                                 |k#0@@27|
                                 |v#0@@35|)
                               (and ($Is |m#0@@24|
                                         (TMap Maps._default.MapsTo$K
                                               Maps._default.MapsTo$V))
                                    ($IsBox |k#0@@27| Maps._default.MapsTo$K)
                                    ($IsBox |v#0@@35| Maps._default.MapsTo$V)))))
                  (=> (and (= (type Maps._default.MapsTo$K) TyType)
                           (= (type Maps._default.MapsTo$V) TyType)
                           (= (type |m#0@@24|) (MapType BoxType BoxType))
                           (= (type |k#0@@27|) BoxType)
                           (= (type |v#0@@35|) BoxType)
                           a!1)
                      true))
                :pattern ((Maps.__default.MapsTo
                            Maps._default.MapsTo$K
                            Maps._default.MapsTo$V
                            |m#0@@24|
                            |k#0@@27|
                            |v#0@@35|))
                :skolemid |2538|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapsTo$K@@0 T@U)
         (Maps._default.MapsTo$V@@0 T@U)
         (|m#0@@25| T@U)
         (|k#0@@28| T@U)
         (|v#0@@36| T@U))
  (! (=> (and (= (type Maps._default.MapsTo$K@@0) TyType)
              (= (type Maps._default.MapsTo$V@@0) TyType)
              (= (type |m#0@@25|) (MapType BoxType BoxType))
              (= (type |k#0@@28|) BoxType)
              (= (type |v#0@@36|) BoxType)
              ($Is |m#0@@25|
                   (TMap Maps._default.MapsTo$K@@0 Maps._default.MapsTo$V@@0))
              ($IsBox |k#0@@28| Maps._default.MapsTo$K@@0)
              ($IsBox |v#0@@36| Maps._default.MapsTo$V@@0))
         (= (|Maps.__default.MapsTo#requires|
              Maps._default.MapsTo$K@@0
              Maps._default.MapsTo$V@@0
              |m#0@@25|
              |k#0@@28|
              |v#0@@36|)
            true))
     :pattern ((|Maps.__default.MapsTo#requires|
                 Maps._default.MapsTo$K@@0
                 Maps._default.MapsTo$V@@0
                 |m#0@@25|
                 |k#0@@28|
                 |v#0@@36|))
     :skolemid |2539|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapsTo$K@@1 T@U)
                    (Maps._default.MapsTo$V@@1 T@U)
                    (|m#0@@26| T@U)
                    (|k#0@@29| T@U)
                    (|v#0@@37| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsTo#canCall|
                                 Maps._default.MapsTo$K@@1
                                 Maps._default.MapsTo$V@@1
                                 |m#0@@26|
                                 |k#0@@29|
                                 |v#0@@37|)
                               (and ($Is |m#0@@26|
                                         (TMap Maps._default.MapsTo$K@@1
                                               Maps._default.MapsTo$V@@1))
                                    ($IsBox |k#0@@29| Maps._default.MapsTo$K@@1)
                                    ($IsBox |v#0@@37| Maps._default.MapsTo$V@@1))))
                      (a!2 (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@26|)
                                                          |k#0@@29|))
                                (= (MapType0Select (|Map#Elements| |m#0@@26|)
                                                   |k#0@@29|)
                                   |v#0@@37|))))
                  (=> (and (= (type Maps._default.MapsTo$K@@1) TyType)
                           (= (type Maps._default.MapsTo$V@@1) TyType)
                           (= (type |m#0@@26|) (MapType BoxType BoxType))
                           (= (type |k#0@@29|) BoxType)
                           (= (type |v#0@@37|) BoxType)
                           a!1)
                      (= (Maps.__default.MapsTo
                           Maps._default.MapsTo$K@@1
                           Maps._default.MapsTo$V@@1
                           |m#0@@26|
                           |k#0@@29|
                           |v#0@@37|)
                         a!2)))
                :pattern ((Maps.__default.MapsTo
                            Maps._default.MapsTo$K@@1
                            Maps._default.MapsTo$V@@1
                            |m#0@@26|
                            |k#0@@29|
                            |v#0@@37|))
                :skolemid |2540|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsTo$K@@2 T@U)
                    (Maps._default.MapsTo$V@@2 T@U)
                    (|m#0@@27| T@U)
                    (|k#0@@30| T@U)
                    (|v#0@@38| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsTo#canCall|
                                 Maps._default.MapsTo$K@@2
                                 Maps._default.MapsTo$V@@2
                                 (Lit |m#0@@27|)
                                 |k#0@@30|
                                 |v#0@@38|)
                               (and ($Is |m#0@@27|
                                         (TMap Maps._default.MapsTo$K@@2
                                               Maps._default.MapsTo$V@@2))
                                    ($IsBox |k#0@@30| Maps._default.MapsTo$K@@2)
                                    ($IsBox |v#0@@38| Maps._default.MapsTo$V@@2))))
                      (a!2 (= (MapType0Select (|Map#Elements| (Lit |m#0@@27|))
                                              |k#0@@30|)
                              |v#0@@38|)))
                (let ((a!3 (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@27|)
                                                          |k#0@@30|))
                                a!2)))
                  (=> (and (= (type Maps._default.MapsTo$K@@2) TyType)
                           (= (type Maps._default.MapsTo$V@@2) TyType)
                           (= (type |m#0@@27|) (MapType BoxType BoxType))
                           (= (type |k#0@@30|) BoxType)
                           (= (type |v#0@@38|) BoxType)
                           a!1)
                      (= (Maps.__default.MapsTo
                           Maps._default.MapsTo$K@@2
                           Maps._default.MapsTo$V@@2
                           (Lit |m#0@@27|)
                           |k#0@@30|
                           |v#0@@38|)
                         a!3))))
                :pattern ((Maps.__default.MapsTo
                            Maps._default.MapsTo$K@@2
                            Maps._default.MapsTo$V@@2
                            (Lit |m#0@@27|)
                            |k#0@@30|
                            |v#0@@38|))
                :weight 3
                :skolemid |2541|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsTo$K@@3 T@U)
                    (Maps._default.MapsTo$V@@3 T@U)
                    (|m#0@@28| T@U)
                    (|k#0@@31| T@U)
                    (|v#0@@39| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsTo#canCall|
                                 Maps._default.MapsTo$K@@3
                                 Maps._default.MapsTo$V@@3
                                 (Lit |m#0@@28|)
                                 (Lit |k#0@@31|)
                                 (Lit |v#0@@39|))
                               (and ($Is |m#0@@28|
                                         (TMap Maps._default.MapsTo$K@@3
                                               Maps._default.MapsTo$V@@3))
                                    ($IsBox |k#0@@31| Maps._default.MapsTo$K@@3)
                                    ($IsBox |v#0@@39| Maps._default.MapsTo$V@@3))))
                      (a!2 (= (MapType0Select (|Map#Elements| (Lit |m#0@@28|))
                                              (Lit |k#0@@31|))
                              (Lit |v#0@@39|))))
                (let ((a!3 (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@28|)
                                                          |k#0@@31|))
                                a!2)))
                  (=> (and (= (type Maps._default.MapsTo$K@@3) TyType)
                           (= (type Maps._default.MapsTo$V@@3) TyType)
                           (= (type |m#0@@28|) (MapType BoxType BoxType))
                           (= (type |k#0@@31|) BoxType)
                           (= (type |v#0@@39|) BoxType)
                           a!1)
                      (= (Maps.__default.MapsTo
                           Maps._default.MapsTo$K@@3
                           Maps._default.MapsTo$V@@3
                           (Lit |m#0@@28|)
                           (Lit |k#0@@31|)
                           (Lit |v#0@@39|))
                         a!3))))
                :pattern ((Maps.__default.MapsTo
                            Maps._default.MapsTo$K@@3
                            Maps._default.MapsTo$V@@3
                            (Lit |m#0@@28|)
                            (Lit |k#0@@31|)
                            (Lit |v#0@@39|)))
                :weight 3
                :skolemid |2542|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (=> true
    (forall ((Maps._default.IMapInjective$K T@U)
             (Maps._default.IMapInjective$V T@U)
             (|m#0@@29| T@U))
      (! (let ((a!1 (and (= (type Maps._default.IMapInjective$K) TyType)
                         (= (type Maps._default.IMapInjective$V) TyType)
                         (= (type |m#0@@29|) (IMapType BoxType BoxType))
                         (or (|Maps.__default.IMapInjective#canCall|
                               Maps._default.IMapInjective$K
                               Maps._default.IMapInjective$V
                               |m#0@@29|)
                             ($Is |m#0@@29|
                                  (TIMap Maps._default.IMapInjective$K
                                         Maps._default.IMapInjective$V))))))
           (=> a!1 true))
         :pattern ((Maps.__default.IMapInjective
                     Maps._default.IMapInjective$K
                     Maps._default.IMapInjective$V
                     |m#0@@29|))
         :skolemid |2543|
         :qid |unknown.0:0|))))
(assert (forall ((Maps._default.IMapInjective$K@@0 T@U)
         (Maps._default.IMapInjective$V@@0 T@U)
         (|m#0@@30| T@U))
  (! (=> (and (= (type Maps._default.IMapInjective$K@@0) TyType)
              (= (type Maps._default.IMapInjective$V@@0) TyType)
              (= (type |m#0@@30|) (IMapType BoxType BoxType))
              ($Is |m#0@@30|
                   (TIMap Maps._default.IMapInjective$K@@0
                          Maps._default.IMapInjective$V@@0)))
         (= (|Maps.__default.IMapInjective#requires|
              Maps._default.IMapInjective$K@@0
              Maps._default.IMapInjective$V@@0
              |m#0@@30|)
            true))
     :pattern ((|Maps.__default.IMapInjective#requires|
                 Maps._default.IMapInjective$K@@0
                 Maps._default.IMapInjective$V@@0
                 |m#0@@30|))
     :skolemid |2544|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapInjective$K@@1 T@U)
                    (Maps._default.IMapInjective$V@@1 T@U)
                    (|m#0@@31| T@U))
             (! (let ((a!1 (and (= (type Maps._default.IMapInjective$K@@1)
                                   TyType)
                                (= (type Maps._default.IMapInjective$V@@1)
                                   TyType)
                                (= (type |m#0@@31|) (IMapType BoxType BoxType))
                                (or (|Maps.__default.IMapInjective#canCall|
                                      Maps._default.IMapInjective$K@@1
                                      Maps._default.IMapInjective$V@@1
                                      |m#0@@31|)
                                    ($Is |m#0@@31|
                                         (TIMap Maps._default.IMapInjective$K@@1
                                                Maps._default.IMapInjective$V@@1)))))
                      (a!2 (forall ((|k1#0| T@U) (|k2#0| T@U))
                             (! (let ((a!1 (and ($IsBox |k1#0|
                                                        Maps._default.IMapInjective$K@@1)
                                                ($IsBox |k2#0|
                                                        Maps._default.IMapInjective$K@@1)
                                                (not (= |k1#0| |k2#0|))
                                                (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@31|)
                                                                          |k1#0|))
                                                (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@31|)
                                                                          |k2#0|))))
                                      (a!2 (not (= (MapType0Select (|IMap#Elements| |m#0@@31|)
                                                                   |k1#0|)
                                                   (MapType0Select (|IMap#Elements| |m#0@@31|)
                                                                   |k2#0|)))))
                                  (=> (and (= (type |k1#0|) BoxType)
                                           (= (type |k2#0|) BoxType))
                                      (=> a!1 a!2)))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@31|)
                                                          |k2#0|)
                                          (MapType0Select (|IMap#Elements| |m#0@@31|)
                                                          |k1#0|))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@31|)
                                                          |k2#0|)
                                          (MapType0Select (|IMap#Domain| |m#0@@31|)
                                                          |k1#0|))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@31|)
                                                          |k1#0|)
                                          (MapType0Select (|IMap#Domain| |m#0@@31|)
                                                          |k2#0|))
                                :pattern ((MapType0Select (|IMap#Domain| |m#0@@31|)
                                                          |k2#0|)
                                          (MapType0Select (|IMap#Domain| |m#0@@31|)
                                                          |k1#0|))
                                :skolemid |2545|
                                :qid |Mapsidfy.22:16|))))
                  (=> a!1
                      (= (Maps.__default.IMapInjective
                           Maps._default.IMapInjective$K@@1
                           Maps._default.IMapInjective$V@@1
                           |m#0@@31|)
                         (and true a!2))))
                :pattern ((Maps.__default.IMapInjective
                            Maps._default.IMapInjective$K@@1
                            Maps._default.IMapInjective$V@@1
                            |m#0@@31|))
                :skolemid |2546|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapInjective$K@@2 T@U)
                    (Maps._default.IMapInjective$V@@2 T@U)
                    (|m#0@@32| T@U))
             (! (let ((a!1 (and (= (type Maps._default.IMapInjective$K@@2)
                                   TyType)
                                (= (type Maps._default.IMapInjective$V@@2)
                                   TyType)
                                (= (type |m#0@@32|) (IMapType BoxType BoxType))
                                (or (|Maps.__default.IMapInjective#canCall|
                                      Maps._default.IMapInjective$K@@2
                                      Maps._default.IMapInjective$V@@2
                                      (Lit |m#0@@32|))
                                    ($Is |m#0@@32|
                                         (TIMap Maps._default.IMapInjective$K@@2
                                                Maps._default.IMapInjective$V@@2)))))
                      (a!2 (forall ((|k1#1| T@U) (|k2#1| T@U))
                             (! (let ((a!1 (and ($IsBox |k1#1|
                                                        Maps._default.IMapInjective$K@@2)
                                                ($IsBox |k2#1|
                                                        Maps._default.IMapInjective$K@@2)
                                                (not (= |k1#1| |k2#1|))
                                                (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@32|)
                                                                          |k1#1|))
                                                (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@32|)
                                                                          |k2#1|))))
                                      (a!2 (= (MapType0Select (|IMap#Elements| (Lit |m#0@@32|))
                                                              |k1#1|)
                                              (MapType0Select (|IMap#Elements| (Lit |m#0@@32|))
                                                              |k2#1|))))
                                  (=> (and (= (type |k1#1|) BoxType)
                                           (= (type |k2#1|) BoxType))
                                      (=> a!1 (not a!2))))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@32|)
                                                          |k2#1|)
                                          (MapType0Select (|IMap#Elements| |m#0@@32|)
                                                          |k1#1|))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@32|)
                                                          |k2#1|)
                                          (MapType0Select (|IMap#Domain| |m#0@@32|)
                                                          |k1#1|))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@32|)
                                                          |k1#1|)
                                          (MapType0Select (|IMap#Domain| |m#0@@32|)
                                                          |k2#1|))
                                :pattern ((MapType0Select (|IMap#Domain| |m#0@@32|)
                                                          |k2#1|)
                                          (MapType0Select (|IMap#Domain| |m#0@@32|)
                                                          |k1#1|))
                                :skolemid |2547|
                                :qid |Mapsidfy.22:16|))))
                  (=> a!1
                      (= (Maps.__default.IMapInjective
                           Maps._default.IMapInjective$K@@2
                           Maps._default.IMapInjective$V@@2
                           (Lit |m#0@@32|))
                         (and true a!2))))
                :pattern ((Maps.__default.IMapInjective
                            Maps._default.IMapInjective$K@@2
                            Maps._default.IMapInjective$V@@2
                            (Lit |m#0@@32|)))
                :weight 3
                :skolemid |2548|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsAgreeOnKey$K T@U)
                    (Maps._default.MapsAgreeOnKey$V T@U)
                    (|m#0@@33| T@U)
                    (|m'#0@@0| T@U)
                    (|k#0@@32| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsAgreeOnKey#canCall|
                                 Maps._default.MapsAgreeOnKey$K
                                 Maps._default.MapsAgreeOnKey$V
                                 |m#0@@33|
                                 |m'#0@@0|
                                 |k#0@@32|)
                               (and ($Is |m#0@@33|
                                         (TMap Maps._default.MapsAgreeOnKey$K
                                               Maps._default.MapsAgreeOnKey$V))
                                    ($Is |m'#0@@0|
                                         (TMap Maps._default.MapsAgreeOnKey$K
                                               Maps._default.MapsAgreeOnKey$V))
                                    ($IsBox |k#0@@32|
                                            Maps._default.MapsAgreeOnKey$K)))))
                  (=> (and (= (type Maps._default.MapsAgreeOnKey$K) TyType)
                           (= (type Maps._default.MapsAgreeOnKey$V) TyType)
                           (= (type |m#0@@33|) (MapType BoxType BoxType))
                           (= (type |m'#0@@0|) (MapType BoxType BoxType))
                           (= (type |k#0@@32|) BoxType)
                           a!1)
                      true))
                :pattern ((Maps.__default.MapsAgreeOnKey
                            Maps._default.MapsAgreeOnKey$K
                            Maps._default.MapsAgreeOnKey$V
                            |m#0@@33|
                            |m'#0@@0|
                            |k#0@@32|))
                :skolemid |2549|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapsAgreeOnKey$K@@0 T@U)
         (Maps._default.MapsAgreeOnKey$V@@0 T@U)
         (|m#0@@34| T@U)
         (|m'#0@@1| T@U)
         (|k#0@@33| T@U))
  (! (=> (and (= (type Maps._default.MapsAgreeOnKey$K@@0) TyType)
              (= (type Maps._default.MapsAgreeOnKey$V@@0) TyType)
              (= (type |m#0@@34|) (MapType BoxType BoxType))
              (= (type |m'#0@@1|) (MapType BoxType BoxType))
              (= (type |k#0@@33|) BoxType)
              ($Is |m#0@@34|
                   (TMap Maps._default.MapsAgreeOnKey$K@@0
                         Maps._default.MapsAgreeOnKey$V@@0))
              ($Is |m'#0@@1|
                   (TMap Maps._default.MapsAgreeOnKey$K@@0
                         Maps._default.MapsAgreeOnKey$V@@0))
              ($IsBox |k#0@@33| Maps._default.MapsAgreeOnKey$K@@0))
         (= (|Maps.__default.MapsAgreeOnKey#requires|
              Maps._default.MapsAgreeOnKey$K@@0
              Maps._default.MapsAgreeOnKey$V@@0
              |m#0@@34|
              |m'#0@@1|
              |k#0@@33|)
            true))
     :pattern ((|Maps.__default.MapsAgreeOnKey#requires|
                 Maps._default.MapsAgreeOnKey$K@@0
                 Maps._default.MapsAgreeOnKey$V@@0
                 |m#0@@34|
                 |m'#0@@1|
                 |k#0@@33|))
     :skolemid |2550|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapsAgreeOnKey$K@@1 T@U)
                    (Maps._default.MapsAgreeOnKey$V@@1 T@U)
                    (|m#0@@35| T@U)
                    (|m'#0@@2| T@U)
                    (|k#0@@34| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsAgreeOnKey#canCall|
                                 Maps._default.MapsAgreeOnKey$K@@1
                                 Maps._default.MapsAgreeOnKey$V@@1
                                 |m#0@@35|
                                 |m'#0@@2|
                                 |k#0@@34|)
                               (and ($Is |m#0@@35|
                                         (TMap Maps._default.MapsAgreeOnKey$K@@1
                                               Maps._default.MapsAgreeOnKey$V@@1))
                                    ($Is |m'#0@@2|
                                         (TMap Maps._default.MapsAgreeOnKey$K@@1
                                               Maps._default.MapsAgreeOnKey$V@@1))
                                    ($IsBox |k#0@@34|
                                            Maps._default.MapsAgreeOnKey$K@@1))))
                      (a!2 (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@35|)
                                                          |k#0@@34|))))
                      (a!3 (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@2|)
                                                          |k#0@@34|))))
                      (a!4 (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@35|)
                                                          |k#0@@34|))
                                (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@2|)
                                                          |k#0@@34|))
                                (= (MapType0Select (|Map#Elements| |m#0@@35|)
                                                   |k#0@@34|)
                                   (MapType0Select (|Map#Elements| |m'#0@@2|)
                                                   |k#0@@34|)))))
                  (=> (and (= (type Maps._default.MapsAgreeOnKey$K@@1) TyType)
                           (= (type Maps._default.MapsAgreeOnKey$V@@1) TyType)
                           (= (type |m#0@@35|) (MapType BoxType BoxType))
                           (= (type |m'#0@@2|) (MapType BoxType BoxType))
                           (= (type |k#0@@34|) BoxType)
                           a!1)
                      (= (Maps.__default.MapsAgreeOnKey
                           Maps._default.MapsAgreeOnKey$K@@1
                           Maps._default.MapsAgreeOnKey$V@@1
                           |m#0@@35|
                           |m'#0@@2|
                           |k#0@@34|)
                         (or (and a!2 a!3) a!4))))
                :pattern ((Maps.__default.MapsAgreeOnKey
                            Maps._default.MapsAgreeOnKey$K@@1
                            Maps._default.MapsAgreeOnKey$V@@1
                            |m#0@@35|
                            |m'#0@@2|
                            |k#0@@34|))
                :skolemid |2551|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsAgreeOnKey$K@@2 T@U)
                    (Maps._default.MapsAgreeOnKey$V@@2 T@U)
                    (|m#0@@36| T@U)
                    (|m'#0@@3| T@U)
                    (|k#0@@35| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsAgreeOnKey#canCall|
                                 Maps._default.MapsAgreeOnKey$K@@2
                                 Maps._default.MapsAgreeOnKey$V@@2
                                 (Lit |m#0@@36|)
                                 (Lit |m'#0@@3|)
                                 |k#0@@35|)
                               (and ($Is |m#0@@36|
                                         (TMap Maps._default.MapsAgreeOnKey$K@@2
                                               Maps._default.MapsAgreeOnKey$V@@2))
                                    ($Is |m'#0@@3|
                                         (TMap Maps._default.MapsAgreeOnKey$K@@2
                                               Maps._default.MapsAgreeOnKey$V@@2))
                                    ($IsBox |k#0@@35|
                                            Maps._default.MapsAgreeOnKey$K@@2))))
                      (a!2 (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@36|)
                                                          |k#0@@35|))))
                      (a!3 (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@3|)
                                                          |k#0@@35|))))
                      (a!4 (= (MapType0Select (|Map#Elements| (Lit |m#0@@36|))
                                              |k#0@@35|)
                              (MapType0Select (|Map#Elements| (Lit |m'#0@@3|))
                                              |k#0@@35|))))
                (let ((a!5 (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@36|)
                                                          |k#0@@35|))
                                (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@3|)
                                                          |k#0@@35|))
                                a!4)))
                  (=> (and (= (type Maps._default.MapsAgreeOnKey$K@@2) TyType)
                           (= (type Maps._default.MapsAgreeOnKey$V@@2) TyType)
                           (= (type |m#0@@36|) (MapType BoxType BoxType))
                           (= (type |m'#0@@3|) (MapType BoxType BoxType))
                           (= (type |k#0@@35|) BoxType)
                           a!1)
                      (= (Maps.__default.MapsAgreeOnKey
                           Maps._default.MapsAgreeOnKey$K@@2
                           Maps._default.MapsAgreeOnKey$V@@2
                           (Lit |m#0@@36|)
                           (Lit |m'#0@@3|)
                           |k#0@@35|)
                         (or (and a!2 a!3) a!5)))))
                :pattern ((Maps.__default.MapsAgreeOnKey
                            Maps._default.MapsAgreeOnKey$K@@2
                            Maps._default.MapsAgreeOnKey$V@@2
                            (Lit |m#0@@36|)
                            (Lit |m'#0@@3|)
                            |k#0@@35|))
                :weight 3
                :skolemid |2552|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsAgreeOnKey$K@@3 T@U)
                    (Maps._default.MapsAgreeOnKey$V@@3 T@U)
                    (|m#0@@37| T@U)
                    (|m'#0@@4| T@U)
                    (|k#0@@36| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsAgreeOnKey#canCall|
                                 Maps._default.MapsAgreeOnKey$K@@3
                                 Maps._default.MapsAgreeOnKey$V@@3
                                 (Lit |m#0@@37|)
                                 (Lit |m'#0@@4|)
                                 (Lit |k#0@@36|))
                               (and ($Is |m#0@@37|
                                         (TMap Maps._default.MapsAgreeOnKey$K@@3
                                               Maps._default.MapsAgreeOnKey$V@@3))
                                    ($Is |m'#0@@4|
                                         (TMap Maps._default.MapsAgreeOnKey$K@@3
                                               Maps._default.MapsAgreeOnKey$V@@3))
                                    ($IsBox |k#0@@36|
                                            Maps._default.MapsAgreeOnKey$K@@3))))
                      (a!2 (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@37|)
                                                          |k#0@@36|))))
                      (a!3 (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@4|)
                                                          |k#0@@36|))))
                      (a!4 (= (MapType0Select (|Map#Elements| (Lit |m#0@@37|))
                                              (Lit |k#0@@36|))
                              (MapType0Select (|Map#Elements| (Lit |m'#0@@4|))
                                              (Lit |k#0@@36|)))))
                (let ((a!5 (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@37|)
                                                          |k#0@@36|))
                                (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@4|)
                                                          |k#0@@36|))
                                a!4)))
                  (=> (and (= (type Maps._default.MapsAgreeOnKey$K@@3) TyType)
                           (= (type Maps._default.MapsAgreeOnKey$V@@3) TyType)
                           (= (type |m#0@@37|) (MapType BoxType BoxType))
                           (= (type |m'#0@@4|) (MapType BoxType BoxType))
                           (= (type |k#0@@36|) BoxType)
                           a!1)
                      (= (Maps.__default.MapsAgreeOnKey
                           Maps._default.MapsAgreeOnKey$K@@3
                           Maps._default.MapsAgreeOnKey$V@@3
                           (Lit |m#0@@37|)
                           (Lit |m'#0@@4|)
                           (Lit |k#0@@36|))
                         (or (and a!2 a!3) a!5)))))
                :pattern ((Maps.__default.MapsAgreeOnKey
                            Maps._default.MapsAgreeOnKey$K@@3
                            Maps._default.MapsAgreeOnKey$V@@3
                            (Lit |m#0@@37|)
                            (Lit |m'#0@@4|)
                            (Lit |k#0@@36|)))
                :weight 3
                :skolemid |2553|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapsAgreeOnKey$K T@U)
                    (Maps._default.IMapsAgreeOnKey$V T@U)
                    (|m#0@@38| T@U)
                    (|m'#0@@5| T@U)
                    (|k#0@@37| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapsAgreeOnKey#canCall|
                                 Maps._default.IMapsAgreeOnKey$K
                                 Maps._default.IMapsAgreeOnKey$V
                                 |m#0@@38|
                                 |m'#0@@5|
                                 |k#0@@37|)
                               (and ($Is |m#0@@38|
                                         (TIMap Maps._default.IMapsAgreeOnKey$K
                                                Maps._default.IMapsAgreeOnKey$V))
                                    ($Is |m'#0@@5|
                                         (TIMap Maps._default.IMapsAgreeOnKey$K
                                                Maps._default.IMapsAgreeOnKey$V))
                                    ($IsBox |k#0@@37|
                                            Maps._default.IMapsAgreeOnKey$K)))))
                  (=> (and (= (type Maps._default.IMapsAgreeOnKey$K) TyType)
                           (= (type Maps._default.IMapsAgreeOnKey$V) TyType)
                           (= (type |m#0@@38|) (IMapType BoxType BoxType))
                           (= (type |m'#0@@5|) (IMapType BoxType BoxType))
                           (= (type |k#0@@37|) BoxType)
                           a!1)
                      true))
                :pattern ((Maps.__default.IMapsAgreeOnKey
                            Maps._default.IMapsAgreeOnKey$K
                            Maps._default.IMapsAgreeOnKey$V
                            |m#0@@38|
                            |m'#0@@5|
                            |k#0@@37|))
                :skolemid |2554|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapsAgreeOnKey$K@@0 T@U)
         (Maps._default.IMapsAgreeOnKey$V@@0 T@U)
         (|m#0@@39| T@U)
         (|m'#0@@6| T@U)
         (|k#0@@38| T@U))
  (! (=> (and (= (type Maps._default.IMapsAgreeOnKey$K@@0) TyType)
              (= (type Maps._default.IMapsAgreeOnKey$V@@0) TyType)
              (= (type |m#0@@39|) (IMapType BoxType BoxType))
              (= (type |m'#0@@6|) (IMapType BoxType BoxType))
              (= (type |k#0@@38|) BoxType)
              ($Is |m#0@@39|
                   (TIMap Maps._default.IMapsAgreeOnKey$K@@0
                          Maps._default.IMapsAgreeOnKey$V@@0))
              ($Is |m'#0@@6|
                   (TIMap Maps._default.IMapsAgreeOnKey$K@@0
                          Maps._default.IMapsAgreeOnKey$V@@0))
              ($IsBox |k#0@@38| Maps._default.IMapsAgreeOnKey$K@@0))
         (= (|Maps.__default.IMapsAgreeOnKey#requires|
              Maps._default.IMapsAgreeOnKey$K@@0
              Maps._default.IMapsAgreeOnKey$V@@0
              |m#0@@39|
              |m'#0@@6|
              |k#0@@38|)
            true))
     :pattern ((|Maps.__default.IMapsAgreeOnKey#requires|
                 Maps._default.IMapsAgreeOnKey$K@@0
                 Maps._default.IMapsAgreeOnKey$V@@0
                 |m#0@@39|
                 |m'#0@@6|
                 |k#0@@38|))
     :skolemid |2555|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapsAgreeOnKey$K@@1 T@U)
                    (Maps._default.IMapsAgreeOnKey$V@@1 T@U)
                    (|m#0@@40| T@U)
                    (|m'#0@@7| T@U)
                    (|k#0@@39| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapsAgreeOnKey#canCall|
                                 Maps._default.IMapsAgreeOnKey$K@@1
                                 Maps._default.IMapsAgreeOnKey$V@@1
                                 |m#0@@40|
                                 |m'#0@@7|
                                 |k#0@@39|)
                               (and ($Is |m#0@@40|
                                         (TIMap Maps._default.IMapsAgreeOnKey$K@@1
                                                Maps._default.IMapsAgreeOnKey$V@@1))
                                    ($Is |m'#0@@7|
                                         (TIMap Maps._default.IMapsAgreeOnKey$K@@1
                                                Maps._default.IMapsAgreeOnKey$V@@1))
                                    ($IsBox |k#0@@39|
                                            Maps._default.IMapsAgreeOnKey$K@@1))))
                      (a!2 (not (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@40|)
                                                          |k#0@@39|))))
                      (a!3 (not (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@7|)
                                                          |k#0@@39|))))
                      (a!4 (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@40|)
                                                          |k#0@@39|))
                                (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@7|)
                                                          |k#0@@39|))
                                (= (MapType0Select (|IMap#Elements| |m#0@@40|)
                                                   |k#0@@39|)
                                   (MapType0Select (|IMap#Elements| |m'#0@@7|)
                                                   |k#0@@39|)))))
                  (=> (and (= (type Maps._default.IMapsAgreeOnKey$K@@1) TyType)
                           (= (type Maps._default.IMapsAgreeOnKey$V@@1) TyType)
                           (= (type |m#0@@40|) (IMapType BoxType BoxType))
                           (= (type |m'#0@@7|) (IMapType BoxType BoxType))
                           (= (type |k#0@@39|) BoxType)
                           a!1)
                      (= (Maps.__default.IMapsAgreeOnKey
                           Maps._default.IMapsAgreeOnKey$K@@1
                           Maps._default.IMapsAgreeOnKey$V@@1
                           |m#0@@40|
                           |m'#0@@7|
                           |k#0@@39|)
                         (or (and a!2 a!3) a!4))))
                :pattern ((Maps.__default.IMapsAgreeOnKey
                            Maps._default.IMapsAgreeOnKey$K@@1
                            Maps._default.IMapsAgreeOnKey$V@@1
                            |m#0@@40|
                            |m'#0@@7|
                            |k#0@@39|))
                :skolemid |2556|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapsAgreeOnKey$K@@2 T@U)
                    (Maps._default.IMapsAgreeOnKey$V@@2 T@U)
                    (|m#0@@41| T@U)
                    (|m'#0@@8| T@U)
                    (|k#0@@40| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapsAgreeOnKey#canCall|
                                 Maps._default.IMapsAgreeOnKey$K@@2
                                 Maps._default.IMapsAgreeOnKey$V@@2
                                 (Lit |m#0@@41|)
                                 (Lit |m'#0@@8|)
                                 (Lit |k#0@@40|))
                               (and ($Is |m#0@@41|
                                         (TIMap Maps._default.IMapsAgreeOnKey$K@@2
                                                Maps._default.IMapsAgreeOnKey$V@@2))
                                    ($Is |m'#0@@8|
                                         (TIMap Maps._default.IMapsAgreeOnKey$K@@2
                                                Maps._default.IMapsAgreeOnKey$V@@2))
                                    ($IsBox |k#0@@40|
                                            Maps._default.IMapsAgreeOnKey$K@@2))))
                      (a!2 (not (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@41|)
                                                          |k#0@@40|))))
                      (a!3 (not (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@8|)
                                                          |k#0@@40|))))
                      (a!4 (= (MapType0Select (|IMap#Elements| (Lit |m#0@@41|))
                                              (Lit |k#0@@40|))
                              (MapType0Select (|IMap#Elements| (Lit |m'#0@@8|))
                                              (Lit |k#0@@40|)))))
                (let ((a!5 (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@41|)
                                                          |k#0@@40|))
                                (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@8|)
                                                          |k#0@@40|))
                                a!4)))
                  (=> (and (= (type Maps._default.IMapsAgreeOnKey$K@@2) TyType)
                           (= (type Maps._default.IMapsAgreeOnKey$V@@2) TyType)
                           (= (type |m#0@@41|) (IMapType BoxType BoxType))
                           (= (type |m'#0@@8|) (IMapType BoxType BoxType))
                           (= (type |k#0@@40|) BoxType)
                           a!1)
                      (= (Maps.__default.IMapsAgreeOnKey
                           Maps._default.IMapsAgreeOnKey$K@@2
                           Maps._default.IMapsAgreeOnKey$V@@2
                           (Lit |m#0@@41|)
                           (Lit |m'#0@@8|)
                           (Lit |k#0@@40|))
                         (or (and a!2 a!3) a!5)))))
                :pattern ((Maps.__default.IMapsAgreeOnKey
                            Maps._default.IMapsAgreeOnKey$K@@2
                            Maps._default.IMapsAgreeOnKey$V@@2
                            (Lit |m#0@@41|)
                            (Lit |m'#0@@8|)
                            (Lit |k#0@@40|)))
                :weight 3
                :skolemid |2557|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IsSubIMap$K T@U)
                    (Maps._default.IsSubIMap$V T@U)
                    (|sub#0| T@U)
                    (|sup#0| T@U))
             (! (let ((a!1 (or (|Maps.__default.IsSubIMap#canCall|
                                 Maps._default.IsSubIMap$K
                                 Maps._default.IsSubIMap$V
                                 |sub#0|
                                 |sup#0|)
                               (and ($Is |sub#0|
                                         (TIMap Maps._default.IsSubIMap$K
                                                Maps._default.IsSubIMap$V))
                                    ($Is |sup#0|
                                         (TIMap Maps._default.IsSubIMap$K
                                                Maps._default.IsSubIMap$V))))))
                  (=> (and (= (type Maps._default.IsSubIMap$K) TyType)
                           (= (type Maps._default.IsSubIMap$V) TyType)
                           (= (type |sub#0|) (IMapType BoxType BoxType))
                           (= (type |sup#0|) (IMapType BoxType BoxType))
                           a!1)
                      true))
                :pattern ((Maps.__default.IsSubIMap
                            Maps._default.IsSubIMap$K
                            Maps._default.IsSubIMap$V
                            |sub#0|
                            |sup#0|))
                :skolemid |2558|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IsSubIMap$K@@0 T@U)
         (Maps._default.IsSubIMap$V@@0 T@U)
         (|sub#0@@0| T@U)
         (|sup#0@@0| T@U))
  (! (=> (and (= (type Maps._default.IsSubIMap$K@@0) TyType)
              (= (type Maps._default.IsSubIMap$V@@0) TyType)
              (= (type |sub#0@@0|) (IMapType BoxType BoxType))
              (= (type |sup#0@@0|) (IMapType BoxType BoxType))
              ($Is |sub#0@@0|
                   (TIMap Maps._default.IsSubIMap$K@@0
                          Maps._default.IsSubIMap$V@@0))
              ($Is |sup#0@@0|
                   (TIMap Maps._default.IsSubIMap$K@@0
                          Maps._default.IsSubIMap$V@@0)))
         (= (|Maps.__default.IsSubIMap#requires|
              Maps._default.IsSubIMap$K@@0
              Maps._default.IsSubIMap$V@@0
              |sub#0@@0|
              |sup#0@@0|)
            true))
     :pattern ((|Maps.__default.IsSubIMap#requires|
                 Maps._default.IsSubIMap$K@@0
                 Maps._default.IsSubIMap$V@@0
                 |sub#0@@0|
                 |sup#0@@0|))
     :skolemid |2559|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IsSubIMap$K@@1 T@U)
                    (Maps._default.IsSubIMap$V@@1 T@U)
                    (|sub#0@@1| T@U)
                    (|sup#0@@1| T@U))
             (! (let ((a!1 (or (|Maps.__default.IsSubIMap#canCall|
                                 Maps._default.IsSubIMap$K@@1
                                 Maps._default.IsSubIMap$V@@1
                                 |sub#0@@1|
                                 |sup#0@@1|)
                               (and ($Is |sub#0@@1|
                                         (TIMap Maps._default.IsSubIMap$K@@1
                                                Maps._default.IsSubIMap$V@@1))
                                    ($Is |sup#0@@1|
                                         (TIMap Maps._default.IsSubIMap$K@@1
                                                Maps._default.IsSubIMap$V@@1)))))
                      (a!2 (=> (|ISet#Subset| (|IMap#Domain| |sub#0@@1|)
                                              (|IMap#Domain| |sup#0@@1|))
                               (forall ((|key#0@@13| T@U))
                                 (! (let ((a!1 (and (= (type |key#0@@13|)
                                                       BoxType)
                                                    ($IsBox |key#0@@13|
                                                            Maps._default.IsSubIMap$K@@1)
                                                    (U_2_bool (MapType0Select (|IMap#Domain| |sub#0@@1|)
                                                                              |key#0@@13|)))))
                                      (=> a!1
                                          (|Maps.__default.IMapsAgreeOnKey#canCall|
                                            Maps._default.IsSubIMap$K@@1
                                            Maps._default.IsSubIMap$V@@1
                                            |sub#0@@1|
                                            |sup#0@@1|
                                            |key#0@@13|)))
                                    :pattern ((Maps.__default.IMapsAgreeOnKey
                                                Maps._default.IsSubIMap$K@@1
                                                Maps._default.IsSubIMap$V@@1
                                                |sub#0@@1|
                                                |sup#0@@1|
                                                |key#0@@13|))
                                    :pattern ((MapType0Select (|IMap#Domain| |sub#0@@1|)
                                                              |key#0@@13|))
                                    :skolemid |2561|
                                    :qid |Mapsidfy.35:16|))))
                      (a!3 (and (|ISet#Subset| (|IMap#Domain| |sub#0@@1|)
                                               (|IMap#Domain| |sup#0@@1|))
                                (forall ((|key#0@@14| T@U))
                                  (! (let ((a!1 (and (= (type |key#0@@14|)
                                                        BoxType)
                                                     ($IsBox |key#0@@14|
                                                             Maps._default.IsSubIMap$K@@1)
                                                     (U_2_bool (MapType0Select (|IMap#Domain| |sub#0@@1|)
                                                                               |key#0@@14|)))))
                                       (=> a!1
                                           (Maps.__default.IMapsAgreeOnKey
                                             Maps._default.IsSubIMap$K@@1
                                             Maps._default.IsSubIMap$V@@1
                                             |sub#0@@1|
                                             |sup#0@@1|
                                             |key#0@@14|)))
                                     :pattern ((Maps.__default.IMapsAgreeOnKey
                                                 Maps._default.IsSubIMap$K@@1
                                                 Maps._default.IsSubIMap$V@@1
                                                 |sub#0@@1|
                                                 |sup#0@@1|
                                                 |key#0@@14|))
                                     :pattern ((MapType0Select (|IMap#Domain| |sub#0@@1|)
                                                               |key#0@@14|))
                                     :skolemid |2560|
                                     :qid |Mapsidfy.35:16|)))))
                  (=> (and (= (type Maps._default.IsSubIMap$K@@1) TyType)
                           (= (type Maps._default.IsSubIMap$V@@1) TyType)
                           (= (type |sub#0@@1|) (IMapType BoxType BoxType))
                           (= (type |sup#0@@1|) (IMapType BoxType BoxType))
                           a!1)
                      (and a!2
                           (= (Maps.__default.IsSubIMap
                                Maps._default.IsSubIMap$K@@1
                                Maps._default.IsSubIMap$V@@1
                                |sub#0@@1|
                                |sup#0@@1|)
                              a!3))))
                :pattern ((Maps.__default.IsSubIMap
                            Maps._default.IsSubIMap$K@@1
                            Maps._default.IsSubIMap$V@@1
                            |sub#0@@1|
                            |sup#0@@1|))
                :skolemid |2562|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IsSubIMap$K@@2 T@U)
                    (Maps._default.IsSubIMap$V@@2 T@U)
                    (|sub#0@@2| T@U)
                    (|sup#0@@2| T@U))
             (! (let ((a!1 (or (|Maps.__default.IsSubIMap#canCall|
                                 Maps._default.IsSubIMap$K@@2
                                 Maps._default.IsSubIMap$V@@2
                                 (Lit |sub#0@@2|)
                                 (Lit |sup#0@@2|))
                               (and ($Is |sub#0@@2|
                                         (TIMap Maps._default.IsSubIMap$K@@2
                                                Maps._default.IsSubIMap$V@@2))
                                    ($Is |sup#0@@2|
                                         (TIMap Maps._default.IsSubIMap$K@@2
                                                Maps._default.IsSubIMap$V@@2)))))
                      (a!2 (forall ((|key#1| T@U))
                             (! (let ((a!1 (MapType0Select (Lit (|IMap#Domain| (Lit |sub#0@@2|)))
                                                           |key#1|)))
                                (let ((a!2 (and (= (type |key#1|) BoxType)
                                                ($IsBox |key#1|
                                                        Maps._default.IsSubIMap$K@@2)
                                                (U_2_bool a!1))))
                                  (=> a!2
                                      (|Maps.__default.IMapsAgreeOnKey#canCall|
                                        Maps._default.IsSubIMap$K@@2
                                        Maps._default.IsSubIMap$V@@2
                                        (Lit |sub#0@@2|)
                                        (Lit |sup#0@@2|)
                                        |key#1|))))
                                :pattern ((Maps.__default.IMapsAgreeOnKey
                                            Maps._default.IsSubIMap$K@@2
                                            Maps._default.IsSubIMap$V@@2
                                            |sub#0@@2|
                                            |sup#0@@2|
                                            |key#1|))
                                :pattern ((MapType0Select (|IMap#Domain| |sub#0@@2|)
                                                          |key#1|))
                                :skolemid |2564|
                                :qid |Mapsidfy.35:16|)))
                      (a!4 (forall ((|key#1@@0| T@U))
                             (! (let ((a!1 (MapType0Select (Lit (|IMap#Domain| (Lit |sub#0@@2|)))
                                                           |key#1@@0|)))
                                (let ((a!2 (and (= (type |key#1@@0|) BoxType)
                                                ($IsBox |key#1@@0|
                                                        Maps._default.IsSubIMap$K@@2)
                                                (U_2_bool a!1))))
                                  (=> a!2
                                      (Maps.__default.IMapsAgreeOnKey
                                        Maps._default.IsSubIMap$K@@2
                                        Maps._default.IsSubIMap$V@@2
                                        (Lit |sub#0@@2|)
                                        (Lit |sup#0@@2|)
                                        |key#1@@0|))))
                                :pattern ((Maps.__default.IMapsAgreeOnKey
                                            Maps._default.IsSubIMap$K@@2
                                            Maps._default.IsSubIMap$V@@2
                                            |sub#0@@2|
                                            |sup#0@@2|
                                            |key#1@@0|))
                                :pattern ((MapType0Select (|IMap#Domain| |sub#0@@2|)
                                                          |key#1@@0|))
                                :skolemid |2563|
                                :qid |Mapsidfy.35:16|))))
                (let ((a!3 (=> (|ISet#Subset| (|IMap#Domain| (Lit |sub#0@@2|))
                                              (|IMap#Domain| (Lit |sup#0@@2|)))
                               a!2))
                      (a!5 (and (|ISet#Subset| (|IMap#Domain| (Lit |sub#0@@2|))
                                               (|IMap#Domain| (Lit |sup#0@@2|)))
                                a!4)))
                (let ((a!6 (and a!3
                                (= (Maps.__default.IsSubIMap
                                     Maps._default.IsSubIMap$K@@2
                                     Maps._default.IsSubIMap$V@@2
                                     (Lit |sub#0@@2|)
                                     (Lit |sup#0@@2|))
                                   a!5))))
                  (=> (and (= (type Maps._default.IsSubIMap$K@@2) TyType)
                           (= (type Maps._default.IsSubIMap$V@@2) TyType)
                           (= (type |sub#0@@2|) (IMapType BoxType BoxType))
                           (= (type |sup#0@@2|) (IMapType BoxType BoxType))
                           a!1)
                      a!6))))
                :pattern ((Maps.__default.IsSubIMap
                            Maps._default.IsSubIMap$K@@2
                            Maps._default.IsSubIMap$V@@2
                            (Lit |sub#0@@2|)
                            (Lit |sup#0@@2|)))
                :weight 3
                :skolemid |2565|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IsSubMap$K T@U)
                    (Maps._default.IsSubMap$V T@U)
                    (|sub#0@@3| T@U)
                    (|sup#0@@3| T@U))
             (! (let ((a!1 (or (|Maps.__default.IsSubMap#canCall|
                                 Maps._default.IsSubMap$K
                                 Maps._default.IsSubMap$V
                                 |sub#0@@3|
                                 |sup#0@@3|)
                               (and ($Is |sub#0@@3|
                                         (TMap Maps._default.IsSubMap$K
                                               Maps._default.IsSubMap$V))
                                    ($Is |sup#0@@3|
                                         (TMap Maps._default.IsSubMap$K
                                               Maps._default.IsSubMap$V))))))
                  (=> (and (= (type Maps._default.IsSubMap$K) TyType)
                           (= (type Maps._default.IsSubMap$V) TyType)
                           (= (type |sub#0@@3|) (MapType BoxType BoxType))
                           (= (type |sup#0@@3|) (MapType BoxType BoxType))
                           a!1)
                      true))
                :pattern ((Maps.__default.IsSubMap
                            Maps._default.IsSubMap$K
                            Maps._default.IsSubMap$V
                            |sub#0@@3|
                            |sup#0@@3|))
                :skolemid |2566|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IsSubMap$K@@0 T@U)
         (Maps._default.IsSubMap$V@@0 T@U)
         (|sub#0@@4| T@U)
         (|sup#0@@4| T@U))
  (! (=> (and (= (type Maps._default.IsSubMap$K@@0) TyType)
              (= (type Maps._default.IsSubMap$V@@0) TyType)
              (= (type |sub#0@@4|) (MapType BoxType BoxType))
              (= (type |sup#0@@4|) (MapType BoxType BoxType))
              ($Is |sub#0@@4|
                   (TMap Maps._default.IsSubMap$K@@0
                         Maps._default.IsSubMap$V@@0))
              ($Is |sup#0@@4|
                   (TMap Maps._default.IsSubMap$K@@0
                         Maps._default.IsSubMap$V@@0)))
         (= (|Maps.__default.IsSubMap#requires|
              Maps._default.IsSubMap$K@@0
              Maps._default.IsSubMap$V@@0
              |sub#0@@4|
              |sup#0@@4|)
            true))
     :pattern ((|Maps.__default.IsSubMap#requires|
                 Maps._default.IsSubMap$K@@0
                 Maps._default.IsSubMap$V@@0
                 |sub#0@@4|
                 |sup#0@@4|))
     :skolemid |2567|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IsSubMap$K@@1 T@U)
                    (Maps._default.IsSubMap$V@@1 T@U)
                    (|sub#0@@5| T@U)
                    (|sup#0@@5| T@U))
             (! (let ((a!1 (or (|Maps.__default.IsSubMap#canCall|
                                 Maps._default.IsSubMap$K@@1
                                 Maps._default.IsSubMap$V@@1
                                 |sub#0@@5|
                                 |sup#0@@5|)
                               (and ($Is |sub#0@@5|
                                         (TMap Maps._default.IsSubMap$K@@1
                                               Maps._default.IsSubMap$V@@1))
                                    ($Is |sup#0@@5|
                                         (TMap Maps._default.IsSubMap$K@@1
                                               Maps._default.IsSubMap$V@@1)))))
                      (a!2 (=> (|Set#Subset| (|Map#Domain| |sub#0@@5|)
                                             (|Map#Domain| |sup#0@@5|))
                               (forall ((|key#0@@15| T@U))
                                 (! (let ((a!1 (and (= (type |key#0@@15|)
                                                       BoxType)
                                                    ($IsBox |key#0@@15|
                                                            Maps._default.IsSubMap$K@@1)
                                                    (U_2_bool (MapType0Select (|Map#Domain| |sub#0@@5|)
                                                                              |key#0@@15|)))))
                                      (=> a!1
                                          (|Maps.__default.MapsAgreeOnKey#canCall|
                                            Maps._default.IsSubMap$K@@1
                                            Maps._default.IsSubMap$V@@1
                                            |sub#0@@5|
                                            |sup#0@@5|
                                            |key#0@@15|)))
                                    :pattern ((Maps.__default.MapsAgreeOnKey
                                                Maps._default.IsSubMap$K@@1
                                                Maps._default.IsSubMap$V@@1
                                                |sub#0@@5|
                                                |sup#0@@5|
                                                |key#0@@15|))
                                    :pattern ((MapType0Select (|Map#Domain| |sub#0@@5|)
                                                              |key#0@@15|))
                                    :skolemid |2569|
                                    :qid |Mapsidfy.40:16|))))
                      (a!3 (and (|Set#Subset| (|Map#Domain| |sub#0@@5|)
                                              (|Map#Domain| |sup#0@@5|))
                                (forall ((|key#0@@16| T@U))
                                  (! (let ((a!1 (and (= (type |key#0@@16|)
                                                        BoxType)
                                                     ($IsBox |key#0@@16|
                                                             Maps._default.IsSubMap$K@@1)
                                                     (U_2_bool (MapType0Select (|Map#Domain| |sub#0@@5|)
                                                                               |key#0@@16|)))))
                                       (=> a!1
                                           (Maps.__default.MapsAgreeOnKey
                                             Maps._default.IsSubMap$K@@1
                                             Maps._default.IsSubMap$V@@1
                                             |sub#0@@5|
                                             |sup#0@@5|
                                             |key#0@@16|)))
                                     :pattern ((Maps.__default.MapsAgreeOnKey
                                                 Maps._default.IsSubMap$K@@1
                                                 Maps._default.IsSubMap$V@@1
                                                 |sub#0@@5|
                                                 |sup#0@@5|
                                                 |key#0@@16|))
                                     :pattern ((MapType0Select (|Map#Domain| |sub#0@@5|)
                                                               |key#0@@16|))
                                     :skolemid |2568|
                                     :qid |Mapsidfy.40:16|)))))
                  (=> (and (= (type Maps._default.IsSubMap$K@@1) TyType)
                           (= (type Maps._default.IsSubMap$V@@1) TyType)
                           (= (type |sub#0@@5|) (MapType BoxType BoxType))
                           (= (type |sup#0@@5|) (MapType BoxType BoxType))
                           a!1)
                      (and a!2
                           (= (Maps.__default.IsSubMap
                                Maps._default.IsSubMap$K@@1
                                Maps._default.IsSubMap$V@@1
                                |sub#0@@5|
                                |sup#0@@5|)
                              a!3))))
                :pattern ((Maps.__default.IsSubMap
                            Maps._default.IsSubMap$K@@1
                            Maps._default.IsSubMap$V@@1
                            |sub#0@@5|
                            |sup#0@@5|))
                :skolemid |2570|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IsSubMap$K@@2 T@U)
                    (Maps._default.IsSubMap$V@@2 T@U)
                    (|sub#0@@6| T@U)
                    (|sup#0@@6| T@U))
             (! (let ((a!1 (or (|Maps.__default.IsSubMap#canCall|
                                 Maps._default.IsSubMap$K@@2
                                 Maps._default.IsSubMap$V@@2
                                 (Lit |sub#0@@6|)
                                 (Lit |sup#0@@6|))
                               (and ($Is |sub#0@@6|
                                         (TMap Maps._default.IsSubMap$K@@2
                                               Maps._default.IsSubMap$V@@2))
                                    ($Is |sup#0@@6|
                                         (TMap Maps._default.IsSubMap$K@@2
                                               Maps._default.IsSubMap$V@@2)))))
                      (a!2 (forall ((|key#1@@1| T@U))
                             (! (let ((a!1 (MapType0Select (Lit (|Map#Domain| (Lit |sub#0@@6|)))
                                                           |key#1@@1|)))
                                (let ((a!2 (and (= (type |key#1@@1|) BoxType)
                                                ($IsBox |key#1@@1|
                                                        Maps._default.IsSubMap$K@@2)
                                                (U_2_bool a!1))))
                                  (=> a!2
                                      (|Maps.__default.MapsAgreeOnKey#canCall|
                                        Maps._default.IsSubMap$K@@2
                                        Maps._default.IsSubMap$V@@2
                                        (Lit |sub#0@@6|)
                                        (Lit |sup#0@@6|)
                                        |key#1@@1|))))
                                :pattern ((Maps.__default.MapsAgreeOnKey
                                            Maps._default.IsSubMap$K@@2
                                            Maps._default.IsSubMap$V@@2
                                            |sub#0@@6|
                                            |sup#0@@6|
                                            |key#1@@1|))
                                :pattern ((MapType0Select (|Map#Domain| |sub#0@@6|)
                                                          |key#1@@1|))
                                :skolemid |2572|
                                :qid |Mapsidfy.40:16|)))
                      (a!4 (forall ((|key#1@@2| T@U))
                             (! (let ((a!1 (MapType0Select (Lit (|Map#Domain| (Lit |sub#0@@6|)))
                                                           |key#1@@2|)))
                                (let ((a!2 (and (= (type |key#1@@2|) BoxType)
                                                ($IsBox |key#1@@2|
                                                        Maps._default.IsSubMap$K@@2)
                                                (U_2_bool a!1))))
                                  (=> a!2
                                      (Maps.__default.MapsAgreeOnKey
                                        Maps._default.IsSubMap$K@@2
                                        Maps._default.IsSubMap$V@@2
                                        (Lit |sub#0@@6|)
                                        (Lit |sup#0@@6|)
                                        |key#1@@2|))))
                                :pattern ((Maps.__default.MapsAgreeOnKey
                                            Maps._default.IsSubMap$K@@2
                                            Maps._default.IsSubMap$V@@2
                                            |sub#0@@6|
                                            |sup#0@@6|
                                            |key#1@@2|))
                                :pattern ((MapType0Select (|Map#Domain| |sub#0@@6|)
                                                          |key#1@@2|))
                                :skolemid |2571|
                                :qid |Mapsidfy.40:16|))))
                (let ((a!3 (=> (|Set#Subset| (|Map#Domain| (Lit |sub#0@@6|))
                                             (|Map#Domain| (Lit |sup#0@@6|)))
                               a!2))
                      (a!5 (and (|Set#Subset| (|Map#Domain| (Lit |sub#0@@6|))
                                              (|Map#Domain| (Lit |sup#0@@6|)))
                                a!4)))
                (let ((a!6 (and a!3
                                (= (Maps.__default.IsSubMap
                                     Maps._default.IsSubMap$K@@2
                                     Maps._default.IsSubMap$V@@2
                                     (Lit |sub#0@@6|)
                                     (Lit |sup#0@@6|))
                                   a!5))))
                  (=> (and (= (type Maps._default.IsSubMap$K@@2) TyType)
                           (= (type Maps._default.IsSubMap$V@@2) TyType)
                           (= (type |sub#0@@6|) (MapType BoxType BoxType))
                           (= (type |sup#0@@6|) (MapType BoxType BoxType))
                           a!1)
                      a!6))))
                :pattern ((Maps.__default.IsSubMap
                            Maps._default.IsSubMap$K@@2
                            Maps._default.IsSubMap$V@@2
                            (Lit |sub#0@@6|)
                            (Lit |sup#0@@6|)))
                :weight 3
                :skolemid |2573|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsAgree$K T@U)
                    (Maps._default.MapsAgree$V T@U)
                    (|ma#0| T@U)
                    (|mb#0| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsAgree#canCall|
                                 Maps._default.MapsAgree$K
                                 Maps._default.MapsAgree$V
                                 |ma#0|
                                 |mb#0|)
                               (and ($Is |ma#0|
                                         (TMap Maps._default.MapsAgree$K
                                               Maps._default.MapsAgree$V))
                                    ($Is |mb#0|
                                         (TMap Maps._default.MapsAgree$K
                                               Maps._default.MapsAgree$V))))))
                  (=> (and (= (type Maps._default.MapsAgree$K) TyType)
                           (= (type Maps._default.MapsAgree$V) TyType)
                           (= (type |ma#0|) (MapType BoxType BoxType))
                           (= (type |mb#0|) (MapType BoxType BoxType))
                           a!1)
                      true))
                :pattern ((Maps.__default.MapsAgree
                            Maps._default.MapsAgree$K
                            Maps._default.MapsAgree$V
                            |ma#0|
                            |mb#0|))
                :skolemid |2574|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapsAgree$K@@0 T@U)
         (Maps._default.MapsAgree$V@@0 T@U)
         (|ma#0@@0| T@U)
         (|mb#0@@0| T@U))
  (! (=> (and (= (type Maps._default.MapsAgree$K@@0) TyType)
              (= (type Maps._default.MapsAgree$V@@0) TyType)
              (= (type |ma#0@@0|) (MapType BoxType BoxType))
              (= (type |mb#0@@0|) (MapType BoxType BoxType))
              ($Is |ma#0@@0|
                   (TMap Maps._default.MapsAgree$K@@0
                         Maps._default.MapsAgree$V@@0))
              ($Is |mb#0@@0|
                   (TMap Maps._default.MapsAgree$K@@0
                         Maps._default.MapsAgree$V@@0)))
         (= (|Maps.__default.MapsAgree#requires|
              Maps._default.MapsAgree$K@@0
              Maps._default.MapsAgree$V@@0
              |ma#0@@0|
              |mb#0@@0|)
            true))
     :pattern ((|Maps.__default.MapsAgree#requires|
                 Maps._default.MapsAgree$K@@0
                 Maps._default.MapsAgree$V@@0
                 |ma#0@@0|
                 |mb#0@@0|))
     :skolemid |2575|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapsAgree$K@@1 T@U)
                    (Maps._default.MapsAgree$V@@1 T@U)
                    (|ma#0@@1| T@U)
                    (|mb#0@@1| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsAgree#canCall|
                                 Maps._default.MapsAgree$K@@1
                                 Maps._default.MapsAgree$V@@1
                                 |ma#0@@1|
                                 |mb#0@@1|)
                               (and ($Is |ma#0@@1|
                                         (TMap Maps._default.MapsAgree$K@@1
                                               Maps._default.MapsAgree$V@@1))
                                    ($Is |mb#0@@1|
                                         (TMap Maps._default.MapsAgree$K@@1
                                               Maps._default.MapsAgree$V@@1)))))
                      (a!2 (forall ((|key#0@@17| T@U))
                             (! (let ((a!1 (and (U_2_bool (MapType0Select (|Map#Domain| |ma#0@@1|)
                                                                          |key#0@@17|))
                                                (U_2_bool (MapType0Select (|Map#Domain| |mb#0@@1|)
                                                                          |key#0@@17|)))))
                                  (=> (and (= (type |key#0@@17|) BoxType)
                                           ($IsBox |key#0@@17|
                                                   Maps._default.MapsAgree$K@@1)
                                           a!1)
                                      (|Maps.__default.MapsAgreeOnKey#canCall|
                                        Maps._default.MapsAgree$K@@1
                                        Maps._default.MapsAgree$V@@1
                                        |ma#0@@1|
                                        |mb#0@@1|
                                        |key#0@@17|)))
                                :pattern ((Maps.__default.MapsAgreeOnKey
                                            Maps._default.MapsAgree$K@@1
                                            Maps._default.MapsAgree$V@@1
                                            |ma#0@@1|
                                            |mb#0@@1|
                                            |key#0@@17|))
                                :pattern ((MapType0Select (|Map#Domain| |mb#0@@1|)
                                                          |key#0@@17|))
                                :pattern ((MapType0Select (|Map#Domain| |ma#0@@1|)
                                                          |key#0@@17|))
                                :skolemid |2577|
                                :qid |Mapsidfy.44:16|)))
                      (a!4 (forall ((|key#0@@18| T@U))
                             (! (let ((a!1 (and (U_2_bool (MapType0Select (|Map#Domain| |ma#0@@1|)
                                                                          |key#0@@18|))
                                                (U_2_bool (MapType0Select (|Map#Domain| |mb#0@@1|)
                                                                          |key#0@@18|)))))
                                  (=> (= (type |key#0@@18|) BoxType)
                                      (=> (and ($IsBox |key#0@@18|
                                                       Maps._default.MapsAgree$K@@1)
                                               a!1)
                                          (Maps.__default.MapsAgreeOnKey
                                            Maps._default.MapsAgree$K@@1
                                            Maps._default.MapsAgree$V@@1
                                            |ma#0@@1|
                                            |mb#0@@1|
                                            |key#0@@18|))))
                                :pattern ((Maps.__default.MapsAgreeOnKey
                                            Maps._default.MapsAgree$K@@1
                                            Maps._default.MapsAgree$V@@1
                                            |ma#0@@1|
                                            |mb#0@@1|
                                            |key#0@@18|))
                                :pattern ((MapType0Select (|Map#Domain| |mb#0@@1|)
                                                          |key#0@@18|))
                                :pattern ((MapType0Select (|Map#Domain| |ma#0@@1|)
                                                          |key#0@@18|))
                                :skolemid |2576|
                                :qid |Mapsidfy.44:16|))))
                (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true))) a!2)))
                  (=> (and (= (type Maps._default.MapsAgree$K@@1) TyType)
                           (= (type Maps._default.MapsAgree$V@@1) TyType)
                           (= (type |ma#0@@1|) (MapType BoxType BoxType))
                           (= (type |mb#0@@1|) (MapType BoxType BoxType))
                           a!1)
                      (and a!3
                           (= (Maps.__default.MapsAgree
                                Maps._default.MapsAgree$K@@1
                                Maps._default.MapsAgree$V@@1
                                |ma#0@@1|
                                |mb#0@@1|)
                              (and true a!4))))))
                :pattern ((Maps.__default.MapsAgree
                            Maps._default.MapsAgree$K@@1
                            Maps._default.MapsAgree$V@@1
                            |ma#0@@1|
                            |mb#0@@1|))
                :skolemid |2578|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapsAgree$K@@2 T@U)
                    (Maps._default.MapsAgree$V@@2 T@U)
                    (|ma#0@@2| T@U)
                    (|mb#0@@2| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapsAgree#canCall|
                                 Maps._default.MapsAgree$K@@2
                                 Maps._default.MapsAgree$V@@2
                                 (Lit |ma#0@@2|)
                                 (Lit |mb#0@@2|))
                               (and ($Is |ma#0@@2|
                                         (TMap Maps._default.MapsAgree$K@@2
                                               Maps._default.MapsAgree$V@@2))
                                    ($Is |mb#0@@2|
                                         (TMap Maps._default.MapsAgree$K@@2
                                               Maps._default.MapsAgree$V@@2)))))
                      (a!2 (forall ((|key#1@@3| T@U))
                             (! (let ((a!1 (MapType0Select (Lit (|Map#Domain| (Lit |ma#0@@2|)))
                                                           |key#1@@3|))
                                      (a!2 (MapType0Select (Lit (|Map#Domain| (Lit |mb#0@@2|)))
                                                           |key#1@@3|)))
                                  (=> (and (= (type |key#1@@3|) BoxType)
                                           ($IsBox |key#1@@3|
                                                   Maps._default.MapsAgree$K@@2)
                                           (and (U_2_bool a!1) (U_2_bool a!2)))
                                      (|Maps.__default.MapsAgreeOnKey#canCall|
                                        Maps._default.MapsAgree$K@@2
                                        Maps._default.MapsAgree$V@@2
                                        (Lit |ma#0@@2|)
                                        (Lit |mb#0@@2|)
                                        |key#1@@3|)))
                                :pattern ((Maps.__default.MapsAgreeOnKey
                                            Maps._default.MapsAgree$K@@2
                                            Maps._default.MapsAgree$V@@2
                                            |ma#0@@2|
                                            |mb#0@@2|
                                            |key#1@@3|))
                                :pattern ((MapType0Select (|Map#Domain| |mb#0@@2|)
                                                          |key#1@@3|))
                                :pattern ((MapType0Select (|Map#Domain| |ma#0@@2|)
                                                          |key#1@@3|))
                                :skolemid |2580|
                                :qid |Mapsidfy.44:16|)))
                      (a!4 (forall ((|key#1@@4| T@U))
                             (! (let ((a!1 (MapType0Select (Lit (|Map#Domain| (Lit |ma#0@@2|)))
                                                           |key#1@@4|))
                                      (a!2 (MapType0Select (Lit (|Map#Domain| (Lit |mb#0@@2|)))
                                                           |key#1@@4|)))
                                (let ((a!3 (=> (and ($IsBox |key#1@@4|
                                                            Maps._default.MapsAgree$K@@2)
                                                    (and (U_2_bool a!1)
                                                         (U_2_bool a!2)))
                                               (Maps.__default.MapsAgreeOnKey
                                                 Maps._default.MapsAgree$K@@2
                                                 Maps._default.MapsAgree$V@@2
                                                 (Lit |ma#0@@2|)
                                                 (Lit |mb#0@@2|)
                                                 |key#1@@4|))))
                                  (=> (= (type |key#1@@4|) BoxType) a!3)))
                                :pattern ((Maps.__default.MapsAgreeOnKey
                                            Maps._default.MapsAgree$K@@2
                                            Maps._default.MapsAgree$V@@2
                                            |ma#0@@2|
                                            |mb#0@@2|
                                            |key#1@@4|))
                                :pattern ((MapType0Select (|Map#Domain| |mb#0@@2|)
                                                          |key#1@@4|))
                                :pattern ((MapType0Select (|Map#Domain| |ma#0@@2|)
                                                          |key#1@@4|))
                                :skolemid |2579|
                                :qid |Mapsidfy.44:16|))))
                (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true))) a!2)))
                (let ((a!5 (and a!3
                                (= (Maps.__default.MapsAgree
                                     Maps._default.MapsAgree$K@@2
                                     Maps._default.MapsAgree$V@@2
                                     (Lit |ma#0@@2|)
                                     (Lit |mb#0@@2|))
                                   (and true a!4)))))
                  (=> (and (= (type Maps._default.MapsAgree$K@@2) TyType)
                           (= (type Maps._default.MapsAgree$V@@2) TyType)
                           (= (type |ma#0@@2|) (MapType BoxType BoxType))
                           (= (type |mb#0@@2|) (MapType BoxType BoxType))
                           a!1)
                      a!5))))
                :pattern ((Maps.__default.MapsAgree
                            Maps._default.MapsAgree$K@@2
                            Maps._default.MapsAgree$V@@2
                            (Lit |ma#0@@2|)
                            (Lit |mb#0@@2|)))
                :weight 3
                :skolemid |2581|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@498 T@U)
         (arg1@@234 T@U)
         (arg2@@128 T@U)
         (arg3@@73 T@U)
         (arg4@@44 T@U))
  (! (= (type (Maps.__default.MapRemove
                arg0@@498
                arg1@@234
                arg2@@128
                arg3@@73
                arg4@@44))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapRemove
                 arg0@@498
                 arg1@@234
                 arg2@@128
                 arg3@@73
                 arg4@@44))
     :qid |funType:Maps.__default.MapRemove|)))
(assert (forall ((Maps._default.MapRemove$K T@U)
         (Maps._default.MapRemove$V T@U)
         ($ly@@219 T@U)
         (|m#0@@42| T@U)
         (|ks#0| T@U))
  (! (=> (and (= (type Maps._default.MapRemove$K) TyType)
              (= (type Maps._default.MapRemove$V) TyType)
              (= (type $ly@@219) LayerTypeType)
              (= (type |m#0@@42|) (MapType BoxType BoxType))
              (= (type |ks#0|) (MapType0Type BoxType boolType)))
         (= (Maps.__default.MapRemove
              Maps._default.MapRemove$K
              Maps._default.MapRemove$V
              ($LS $ly@@219)
              |m#0@@42|
              |ks#0|)
            (Maps.__default.MapRemove
              Maps._default.MapRemove$K
              Maps._default.MapRemove$V
              $ly@@219
              |m#0@@42|
              |ks#0|)))
     :pattern ((Maps.__default.MapRemove
                 Maps._default.MapRemove$K
                 Maps._default.MapRemove$V
                 ($LS $ly@@219)
                 |m#0@@42|
                 |ks#0|))
     :skolemid |2582|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapRemove$K@@0 T@U)
         (Maps._default.MapRemove$V@@0 T@U)
         ($ly@@220 T@U)
         (|m#0@@43| T@U)
         (|ks#0@@0| T@U))
  (! (=> (and (= (type Maps._default.MapRemove$K@@0) TyType)
              (= (type Maps._default.MapRemove$V@@0) TyType)
              (= (type $ly@@220) LayerTypeType)
              (= (type |m#0@@43|) (MapType BoxType BoxType))
              (= (type |ks#0@@0|) (MapType0Type BoxType boolType)))
         (= (Maps.__default.MapRemove
              Maps._default.MapRemove$K@@0
              Maps._default.MapRemove$V@@0
              $ly@@220
              |m#0@@43|
              |ks#0@@0|)
            (Maps.__default.MapRemove
              Maps._default.MapRemove$K@@0
              Maps._default.MapRemove$V@@0
              $LZ
              |m#0@@43|
              |ks#0@@0|)))
     :pattern ((Maps.__default.MapRemove
                 Maps._default.MapRemove$K@@0
                 Maps._default.MapRemove$V@@0
                 (AsFuelBottom $ly@@220)
                 |m#0@@43|
                 |ks#0@@0|))
     :skolemid |2583|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove$K@@1 T@U)
                    (Maps._default.MapRemove$V@@1 T@U)
                    ($ly@@221 T@U)
                    (|m#0@@44| T@U)
                    (|ks#0@@1| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove#canCall|
                                 Maps._default.MapRemove$K@@1
                                 Maps._default.MapRemove$V@@1
                                 |m#0@@44|
                                 |ks#0@@1|)
                               (and ($Is |m#0@@44|
                                         (TMap Maps._default.MapRemove$K@@1
                                               Maps._default.MapRemove$V@@1))
                                    ($Is |ks#0@@1|
                                         (TSet Maps._default.MapRemove$K@@1)))))
                      (a!2 (forall ((|k#1@@1| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove
                                                                                     Maps._default.MapRemove$K@@1
                                                                                     Maps._default.MapRemove$V@@1
                                                                                     $ly@@221
                                                                                     |m#0@@44|
                                                                                     |ks#0@@1|))
                                                                     |k#1@@1|))))
                                (let ((a!2 (=> a!1
                                               (U_2_bool (MapType0Select (|Map#Domain| |m#0@@44|)
                                                                         |k#1@@1|))))
                                      (a!3 (=> a!1
                                               (not (U_2_bool (MapType0Select |ks#0@@1|
                                                                              |k#1@@1|))))))
                                  (=> (and (= (type |k#1@@1|) BoxType)
                                           ($IsBox |k#1@@1|
                                                   Maps._default.MapRemove$K@@1))
                                      (and a!2 a!3))))
                                :pattern ((MapType0Select |ks#0@@1| |k#1@@1|))
                                :pattern ((MapType0Select (|Map#Domain| |m#0@@44|)
                                                          |k#1@@1|))
                                :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemove
                                                                          Maps._default.MapRemove$K@@1
                                                                          Maps._default.MapRemove$V@@1
                                                                          $ly@@221
                                                                          |m#0@@44|
                                                                          |ks#0@@1|))
                                                          |k#1@@1|))
                                :skolemid |2585|
                                :qid |Mapsidfy.49:20|)))
                      (a!3 (INTERNAL_le_boogie
                             (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove
                                                         Maps._default.MapRemove$K@@1
                                                         Maps._default.MapRemove$V@@1
                                                         $ly@@221
                                                         |m#0@@44|
                                                         |ks#0@@1|)))
                             (|Set#Card| (|Map#Domain| |m#0@@44|)))))
                (let ((a!4 (and (forall ((|k#0@@41| T@U))
                                  (! (let ((a!1 (and (and (= (type |k#0@@41|)
                                                             BoxType)
                                                          ($IsBox |k#0@@41|
                                                                  Maps._default.MapRemove$K@@1))
                                                     (U_2_bool (MapType0Select (|Map#Domain| |m#0@@44|)
                                                                               |k#0@@41|))
                                                     (not (U_2_bool (MapType0Select |ks#0@@1|
                                                                                    |k#0@@41|)))))
                                           (a!2 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove
                                                                                          Maps._default.MapRemove$K@@1
                                                                                          Maps._default.MapRemove$V@@1
                                                                                          $ly@@221
                                                                                          |m#0@@44|
                                                                                          |ks#0@@1|))
                                                                          |k#0@@41|))))
                                       (=> a!1 a!2))
                                     :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemove
                                                                               Maps._default.MapRemove$K@@1
                                                                               Maps._default.MapRemove$V@@1
                                                                               $ly@@221
                                                                               |m#0@@44|
                                                                               |ks#0@@1|))
                                                               |k#0@@41|))
                                     :pattern ((MapType0Select |ks#0@@1|
                                                               |k#0@@41|))
                                     :pattern ((MapType0Select (|Map#Domain| |m#0@@44|)
                                                               |k#0@@41|))
                                     :skolemid |2584|
                                     :qid |Mapsidfy.48:20|))
                                a!2
                                (forall ((|j#0@@8| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove
                                                                                          Maps._default.MapRemove$K@@1
                                                                                          Maps._default.MapRemove$V@@1
                                                                                          $ly@@221
                                                                                          |m#0@@44|
                                                                                          |ks#0@@1|))
                                                                          |j#0@@8|)))
                                           (a!3 (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove
                                                                                     Maps._default.MapRemove$K@@1
                                                                                     Maps._default.MapRemove$V@@1
                                                                                     $ly@@221
                                                                                     |m#0@@44|
                                                                                     |ks#0@@1|))
                                                                   |j#0@@8|)
                                                   (MapType0Select (|Map#Elements| |m#0@@44|)
                                                                   |j#0@@8|))))
                                     (let ((a!2 (and (and (= (type |j#0@@8|)
                                                             BoxType)
                                                          ($IsBox |j#0@@8|
                                                                  Maps._default.MapRemove$K@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|Map#Elements| |m#0@@44|)
                                                               |j#0@@8|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapRemove
                                                                                 Maps._default.MapRemove$K@@1
                                                                                 Maps._default.MapRemove$V@@1
                                                                                 $ly@@221
                                                                                 |m#0@@44|
                                                                                 |ks#0@@1|))
                                                               |j#0@@8|))
                                     :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemove
                                                                               Maps._default.MapRemove$K@@1
                                                                               Maps._default.MapRemove$V@@1
                                                                               $ly@@221
                                                                               |m#0@@44|
                                                                               |ks#0@@1|))
                                                               |j#0@@8|))
                                     :skolemid |2586|
                                     :qid |Mapsidfy.50:20|))
                                a!3
                                (INTERNAL_le_boogie
                                  (|Map#Card| (Maps.__default.MapRemove
                                                Maps._default.MapRemove$K@@1
                                                Maps._default.MapRemove$V@@1
                                                $ly@@221
                                                |m#0@@44|
                                                |ks#0@@1|))
                                  (|Map#Card| |m#0@@44|))
                                ($Is (Maps.__default.MapRemove
                                       Maps._default.MapRemove$K@@1
                                       Maps._default.MapRemove$V@@1
                                       $ly@@221
                                       |m#0@@44|
                                       |ks#0@@1|)
                                     (TMap Maps._default.MapRemove$K@@1
                                           Maps._default.MapRemove$V@@1)))))
                  (=> (and (= (type Maps._default.MapRemove$K@@1) TyType)
                           (= (type Maps._default.MapRemove$V@@1) TyType)
                           (= (type $ly@@221) LayerTypeType)
                           (= (type |m#0@@44|) (MapType BoxType BoxType))
                           (= (type |ks#0@@1|) (MapType0Type BoxType boolType))
                           a!1)
                      a!4)))
                :pattern ((Maps.__default.MapRemove
                            Maps._default.MapRemove$K@@1
                            Maps._default.MapRemove$V@@1
                            $ly@@221
                            |m#0@@44|
                            |ks#0@@1|))
                :skolemid |2587|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapRemove$K@@2 T@U)
         (Maps._default.MapRemove$V@@2 T@U)
         ($ly@@222 T@U)
         (|m#0@@45| T@U)
         (|ks#0@@2| T@U))
  (! (=> (and (= (type Maps._default.MapRemove$K@@2) TyType)
              (= (type Maps._default.MapRemove$V@@2) TyType)
              (= (type $ly@@222) LayerTypeType)
              (= (type |m#0@@45|) (MapType BoxType BoxType))
              (= (type |ks#0@@2|) (MapType0Type BoxType boolType))
              ($Is |m#0@@45|
                   (TMap Maps._default.MapRemove$K@@2
                         Maps._default.MapRemove$V@@2))
              ($Is |ks#0@@2| (TSet Maps._default.MapRemove$K@@2)))
         (= (|Maps.__default.MapRemove#requires|
              Maps._default.MapRemove$K@@2
              Maps._default.MapRemove$V@@2
              $ly@@222
              |m#0@@45|
              |ks#0@@2|)
            true))
     :pattern ((|Maps.__default.MapRemove#requires|
                 Maps._default.MapRemove$K@@2
                 Maps._default.MapRemove$V@@2
                 $ly@@222
                 |m#0@@45|
                 |ks#0@@2|))
     :skolemid |2588|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@499 T@U) (arg1@@235 T@U) (arg2@@129 T@U))
  (! (= (type (|lambda#153| arg0@@499 arg1@@235 arg2@@129))
        (MapType0Type BoxType boolType))
     :pattern ((|lambda#153| arg0@@499 arg1@@235 arg2@@129))
     :qid |funType:lambda#153|)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove$K@@3 T@U)
                    (Maps._default.MapRemove$V@@3 T@U)
                    ($ly@@223 T@U)
                    (|m#0@@46| T@U)
                    (|ks#0@@3| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove#canCall|
                                 Maps._default.MapRemove$K@@3
                                 Maps._default.MapRemove$V@@3
                                 |m#0@@46|
                                 |ks#0@@3|)
                               (and ($Is |m#0@@46|
                                         (TMap Maps._default.MapRemove$K@@3
                                               Maps._default.MapRemove$V@@3))
                                    ($Is |ks#0@@3|
                                         (TSet Maps._default.MapRemove$K@@3)))))
                      (a!2 (= (Maps.__default.MapRemove
                                Maps._default.MapRemove$K@@3
                                Maps._default.MapRemove$V@@3
                                ($LS $ly@@223)
                                |m#0@@46|
                                |ks#0@@3|)
                              (|Map#Glue| (|lambda#153| Maps._default.MapRemove$K@@3
                                                        (|Map#Domain| |m#0@@46|)
                                                        |ks#0@@3|)
                                          (|lambda#148| (|Map#Elements| |m#0@@46|))
                                          (TMap Maps._default.MapRemove$K@@3
                                                Maps._default.MapRemove$V@@3)))))
                  (=> (and (= (type Maps._default.MapRemove$K@@3) TyType)
                           (= (type Maps._default.MapRemove$V@@3) TyType)
                           (= (type $ly@@223) LayerTypeType)
                           (= (type |m#0@@46|) (MapType BoxType BoxType))
                           (= (type |ks#0@@3|) (MapType0Type BoxType boolType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRemove
                            Maps._default.MapRemove$K@@3
                            Maps._default.MapRemove$V@@3
                            ($LS $ly@@223)
                            |m#0@@46|
                            |ks#0@@3|))
                :skolemid |2589|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove$K@@4 T@U)
                    (Maps._default.MapRemove$V@@4 T@U)
                    ($ly@@224 T@U)
                    (|m#0@@47| T@U)
                    (|ks#0@@4| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove#canCall|
                                 Maps._default.MapRemove$K@@4
                                 Maps._default.MapRemove$V@@4
                                 (Lit |m#0@@47|)
                                 (Lit |ks#0@@4|))
                               (and ($Is |m#0@@47|
                                         (TMap Maps._default.MapRemove$K@@4
                                               Maps._default.MapRemove$V@@4))
                                    ($Is |ks#0@@4|
                                         (TSet Maps._default.MapRemove$K@@4)))))
                      (a!2 (|Map#Glue| (|lambda#153| Maps._default.MapRemove$K@@4
                                                     (|Map#Domain| |m#0@@47|)
                                                     (Lit |ks#0@@4|))
                                       (|lambda#148| (|Map#Elements| (Lit |m#0@@47|)))
                                       (TMap Maps._default.MapRemove$K@@4
                                             Maps._default.MapRemove$V@@4))))
                  (=> (and (= (type Maps._default.MapRemove$K@@4) TyType)
                           (= (type Maps._default.MapRemove$V@@4) TyType)
                           (= (type $ly@@224) LayerTypeType)
                           (= (type |m#0@@47|) (MapType BoxType BoxType))
                           (= (type |ks#0@@4|) (MapType0Type BoxType boolType))
                           a!1)
                      (= (Maps.__default.MapRemove
                           Maps._default.MapRemove$K@@4
                           Maps._default.MapRemove$V@@4
                           ($LS $ly@@224)
                           (Lit |m#0@@47|)
                           (Lit |ks#0@@4|))
                         a!2)))
                :pattern ((Maps.__default.MapRemove
                            Maps._default.MapRemove$K@@4
                            Maps._default.MapRemove$V@@4
                            ($LS $ly@@224)
                            (Lit |m#0@@47|)
                            (Lit |ks#0@@4|)))
                :weight 3
                :skolemid |2590|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@500 T@U)
         (arg1@@236 T@U)
         (arg2@@130 T@U)
         (arg3@@74 T@U)
         (arg4@@45 T@U))
  (! (= (type (Maps.__default.MapRemoveStrong
                arg0@@500
                arg1@@236
                arg2@@130
                arg3@@74
                arg4@@45))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapRemoveStrong
                 arg0@@500
                 arg1@@236
                 arg2@@130
                 arg3@@74
                 arg4@@45))
     :qid |funType:Maps.__default.MapRemoveStrong|)))
(assert (forall ((Maps._default.MapRemoveStrong$K T@U)
         (Maps._default.MapRemoveStrong$V T@U)
         ($ly@@225 T@U)
         (|m#0@@48| T@U)
         (|ks#0@@5| T@U))
  (! (=> (and (= (type Maps._default.MapRemoveStrong$K) TyType)
              (= (type Maps._default.MapRemoveStrong$V) TyType)
              (= (type $ly@@225) LayerTypeType)
              (= (type |m#0@@48|) (MapType BoxType BoxType))
              (= (type |ks#0@@5|) (MapType0Type BoxType boolType)))
         (= (Maps.__default.MapRemoveStrong
              Maps._default.MapRemoveStrong$K
              Maps._default.MapRemoveStrong$V
              ($LS $ly@@225)
              |m#0@@48|
              |ks#0@@5|)
            (Maps.__default.MapRemoveStrong
              Maps._default.MapRemoveStrong$K
              Maps._default.MapRemoveStrong$V
              $ly@@225
              |m#0@@48|
              |ks#0@@5|)))
     :pattern ((Maps.__default.MapRemoveStrong
                 Maps._default.MapRemoveStrong$K
                 Maps._default.MapRemoveStrong$V
                 ($LS $ly@@225)
                 |m#0@@48|
                 |ks#0@@5|))
     :skolemid |2591|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapRemoveStrong$K@@0 T@U)
         (Maps._default.MapRemoveStrong$V@@0 T@U)
         ($ly@@226 T@U)
         (|m#0@@49| T@U)
         (|ks#0@@6| T@U))
  (! (=> (and (= (type Maps._default.MapRemoveStrong$K@@0) TyType)
              (= (type Maps._default.MapRemoveStrong$V@@0) TyType)
              (= (type $ly@@226) LayerTypeType)
              (= (type |m#0@@49|) (MapType BoxType BoxType))
              (= (type |ks#0@@6|) (MapType0Type BoxType boolType)))
         (= (Maps.__default.MapRemoveStrong
              Maps._default.MapRemoveStrong$K@@0
              Maps._default.MapRemoveStrong$V@@0
              $ly@@226
              |m#0@@49|
              |ks#0@@6|)
            (Maps.__default.MapRemoveStrong
              Maps._default.MapRemoveStrong$K@@0
              Maps._default.MapRemoveStrong$V@@0
              $LZ
              |m#0@@49|
              |ks#0@@6|)))
     :pattern ((Maps.__default.MapRemoveStrong
                 Maps._default.MapRemoveStrong$K@@0
                 Maps._default.MapRemoveStrong$V@@0
                 (AsFuelBottom $ly@@226)
                 |m#0@@49|
                 |ks#0@@6|))
     :skolemid |2592|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapRemoveStrong$K@@1 T@U)
                    (Maps._default.MapRemoveStrong$V@@1 T@U)
                    ($ly@@227 T@U)
                    (|m#0@@50| T@U)
                    (|ks#0@@7| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemoveStrong#canCall|
                                 Maps._default.MapRemoveStrong$K@@1
                                 Maps._default.MapRemoveStrong$V@@1
                                 |m#0@@50|
                                 |ks#0@@7|)
                               (and ($Is |m#0@@50|
                                         (TMap Maps._default.MapRemoveStrong$K@@1
                                               Maps._default.MapRemoveStrong$V@@1))
                                    ($Is |ks#0@@7|
                                         (TSet Maps._default.MapRemoveStrong$K@@1)))))
                      (a!2 (forall ((|j#0@@9| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemoveStrong
                                                                                     Maps._default.MapRemoveStrong$K@@1
                                                                                     Maps._default.MapRemoveStrong$V@@1
                                                                                     $ly@@227
                                                                                     |m#0@@50|
                                                                                     |ks#0@@7|))
                                                                     |j#0@@9|)))
                                      (a!2 (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemoveStrong
                                                                                Maps._default.MapRemoveStrong$K@@1
                                                                                Maps._default.MapRemoveStrong$V@@1
                                                                                $ly@@227
                                                                                |m#0@@50|
                                                                                |ks#0@@7|))
                                                              |j#0@@9|)
                                              (MapType0Select (|Map#Elements| |m#0@@50|)
                                                              |j#0@@9|))))
                                  (=> (and (= (type |j#0@@9|) BoxType)
                                           ($IsBox |j#0@@9|
                                                   Maps._default.MapRemoveStrong$K@@1)
                                           a!1)
                                      a!2))
                                :pattern ((MapType0Select (|Map#Elements| |m#0@@50|)
                                                          |j#0@@9|))
                                :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapRemoveStrong
                                                                            Maps._default.MapRemoveStrong$K@@1
                                                                            Maps._default.MapRemoveStrong$V@@1
                                                                            $ly@@227
                                                                            |m#0@@50|
                                                                            |ks#0@@7|))
                                                          |j#0@@9|))
                                :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemoveStrong
                                                                          Maps._default.MapRemoveStrong$K@@1
                                                                          Maps._default.MapRemoveStrong$V@@1
                                                                          $ly@@227
                                                                          |m#0@@50|
                                                                          |ks#0@@7|))
                                                          |j#0@@9|))
                                :skolemid |2593|
                                :qid |Mapsidfy.61:20|)))
                      (a!3 (INTERNAL_le_boogie
                             (|Set#Card| (|Map#Domain| (Maps.__default.MapRemoveStrong
                                                         Maps._default.MapRemoveStrong$K@@1
                                                         Maps._default.MapRemoveStrong$V@@1
                                                         $ly@@227
                                                         |m#0@@50|
                                                         |ks#0@@7|)))
                             (|Set#Card| (|Map#Domain| |m#0@@50|)))))
                (let ((a!4 (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapRemoveStrong
                                                             Maps._default.MapRemoveStrong$K@@1
                                                             Maps._default.MapRemoveStrong$V@@1
                                                             $ly@@227
                                                             |m#0@@50|
                                                             |ks#0@@7|))
                                             (|Set#Difference| (|Map#Domain| |m#0@@50|)
                                                               |ks#0@@7|))
                                a!2
                                a!3
                                (INTERNAL_le_boogie
                                  (|Map#Card| (Maps.__default.MapRemoveStrong
                                                Maps._default.MapRemoveStrong$K@@1
                                                Maps._default.MapRemoveStrong$V@@1
                                                $ly@@227
                                                |m#0@@50|
                                                |ks#0@@7|))
                                  (|Map#Card| |m#0@@50|))
                                ($Is (Maps.__default.MapRemoveStrong
                                       Maps._default.MapRemoveStrong$K@@1
                                       Maps._default.MapRemoveStrong$V@@1
                                       $ly@@227
                                       |m#0@@50|
                                       |ks#0@@7|)
                                     (TMap Maps._default.MapRemoveStrong$K@@1
                                           Maps._default.MapRemoveStrong$V@@1)))))
                  (=> (and (= (type Maps._default.MapRemoveStrong$K@@1) TyType)
                           (= (type Maps._default.MapRemoveStrong$V@@1) TyType)
                           (= (type $ly@@227) LayerTypeType)
                           (= (type |m#0@@50|) (MapType BoxType BoxType))
                           (= (type |ks#0@@7|) (MapType0Type BoxType boolType))
                           a!1)
                      a!4)))
                :pattern ((Maps.__default.MapRemoveStrong
                            Maps._default.MapRemoveStrong$K@@1
                            Maps._default.MapRemoveStrong$V@@1
                            $ly@@227
                            |m#0@@50|
                            |ks#0@@7|))
                :skolemid |2594|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapRemoveStrong$K@@2 T@U)
         (Maps._default.MapRemoveStrong$V@@2 T@U)
         ($ly@@228 T@U)
         (|m#0@@51| T@U)
         (|ks#0@@8| T@U))
  (! (=> (and (= (type Maps._default.MapRemoveStrong$K@@2) TyType)
              (= (type Maps._default.MapRemoveStrong$V@@2) TyType)
              (= (type $ly@@228) LayerTypeType)
              (= (type |m#0@@51|) (MapType BoxType BoxType))
              (= (type |ks#0@@8|) (MapType0Type BoxType boolType))
              ($Is |m#0@@51|
                   (TMap Maps._default.MapRemoveStrong$K@@2
                         Maps._default.MapRemoveStrong$V@@2))
              ($Is |ks#0@@8| (TSet Maps._default.MapRemoveStrong$K@@2)))
         (= (|Maps.__default.MapRemoveStrong#requires|
              Maps._default.MapRemoveStrong$K@@2
              Maps._default.MapRemoveStrong$V@@2
              $ly@@228
              |m#0@@51|
              |ks#0@@8|)
            true))
     :pattern ((|Maps.__default.MapRemoveStrong#requires|
                 Maps._default.MapRemoveStrong$K@@2
                 Maps._default.MapRemoveStrong$V@@2
                 $ly@@228
                 |m#0@@51|
                 |ks#0@@8|))
     :skolemid |2595|
     :qid |unknown.0:0|)))
(assert (and (= (type StartFuel_Maps._default.MapRemove) LayerTypeType)
     (= (type MoreFuel_Maps._default.MapRemove0) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapRemove) LayerTypeType)))
(assert (let ((a!1 (forall ((Maps._default.MapRemoveStrong$K@@3 T@U)
                    (Maps._default.MapRemoveStrong$V@@3 T@U)
                    ($ly@@229 T@U)
                    (|m#0@@52| T@U)
                    (|ks#0@@9| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemoveStrong#canCall|
                                 Maps._default.MapRemoveStrong$K@@3
                                 Maps._default.MapRemoveStrong$V@@3
                                 |m#0@@52|
                                 |ks#0@@9|)
                               (and ($Is |m#0@@52|
                                         (TMap Maps._default.MapRemoveStrong$K@@3
                                               Maps._default.MapRemoveStrong$V@@3))
                                    ($Is |ks#0@@9|
                                         (TSet Maps._default.MapRemoveStrong$K@@3)))))
                      (a!2 (and (|Maps.__default.MapRemove#canCall|
                                  Maps._default.MapRemoveStrong$K@@3
                                  Maps._default.MapRemoveStrong$V@@3
                                  |m#0@@52|
                                  |ks#0@@9|)
                                (= StartFuel_Maps._default.MapRemove
                                   ($LS MoreFuel_Maps._default.MapRemove0))
                                (= StartFuelAssert_Maps._default.MapRemove
                                   ($LS ($LS MoreFuel_Maps._default.MapRemove0)))
                                (= (AsFuelBottom MoreFuel_Maps._default.MapRemove0)
                                   MoreFuel_Maps._default.MapRemove0)
                                (= (Maps.__default.MapRemoveStrong
                                     Maps._default.MapRemoveStrong$K@@3
                                     Maps._default.MapRemoveStrong$V@@3
                                     ($LS $ly@@229)
                                     |m#0@@52|
                                     |ks#0@@9|)
                                   (Maps.__default.MapRemove
                                     Maps._default.MapRemoveStrong$K@@3
                                     Maps._default.MapRemoveStrong$V@@3
                                     StartFuel_Maps._default.MapRemove
                                     |m#0@@52|
                                     |ks#0@@9|)))))
                  (=> (and (= (type Maps._default.MapRemoveStrong$K@@3) TyType)
                           (= (type Maps._default.MapRemoveStrong$V@@3) TyType)
                           (= (type $ly@@229) LayerTypeType)
                           (= (type |m#0@@52|) (MapType BoxType BoxType))
                           (= (type |ks#0@@9|) (MapType0Type BoxType boolType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRemoveStrong
                            Maps._default.MapRemoveStrong$K@@3
                            Maps._default.MapRemoveStrong$V@@3
                            ($LS $ly@@229)
                            |m#0@@52|
                            |ks#0@@9|))
                :skolemid |2596|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type MoreFuel_Maps._default.MapRemove1) LayerTypeType))
(assert (let ((a!1 (forall ((Maps._default.MapRemoveStrong$K@@4 T@U)
                    (Maps._default.MapRemoveStrong$V@@4 T@U)
                    ($ly@@230 T@U)
                    (|m#0@@53| T@U)
                    (|ks#0@@10| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemoveStrong#canCall|
                                 Maps._default.MapRemoveStrong$K@@4
                                 Maps._default.MapRemoveStrong$V@@4
                                 (Lit |m#0@@53|)
                                 (Lit |ks#0@@10|))
                               (and ($Is |m#0@@53|
                                         (TMap Maps._default.MapRemoveStrong$K@@4
                                               Maps._default.MapRemoveStrong$V@@4))
                                    ($Is |ks#0@@10|
                                         (TSet Maps._default.MapRemoveStrong$K@@4)))))
                      (a!2 (and (|Maps.__default.MapRemove#canCall|
                                  Maps._default.MapRemoveStrong$K@@4
                                  Maps._default.MapRemoveStrong$V@@4
                                  (Lit |m#0@@53|)
                                  (Lit |ks#0@@10|))
                                (= StartFuel_Maps._default.MapRemove
                                   ($LS MoreFuel_Maps._default.MapRemove1))
                                (= StartFuelAssert_Maps._default.MapRemove
                                   ($LS ($LS MoreFuel_Maps._default.MapRemove1)))
                                (= (AsFuelBottom MoreFuel_Maps._default.MapRemove1)
                                   MoreFuel_Maps._default.MapRemove1)
                                (= (Maps.__default.MapRemoveStrong
                                     Maps._default.MapRemoveStrong$K@@4
                                     Maps._default.MapRemoveStrong$V@@4
                                     ($LS $ly@@230)
                                     (Lit |m#0@@53|)
                                     (Lit |ks#0@@10|))
                                   (Maps.__default.MapRemove
                                     Maps._default.MapRemoveStrong$K@@4
                                     Maps._default.MapRemoveStrong$V@@4
                                     StartFuel_Maps._default.MapRemove
                                     (Lit |m#0@@53|)
                                     (Lit |ks#0@@10|))))))
                  (=> (and (= (type Maps._default.MapRemoveStrong$K@@4) TyType)
                           (= (type Maps._default.MapRemoveStrong$V@@4) TyType)
                           (= (type $ly@@230) LayerTypeType)
                           (= (type |m#0@@53|) (MapType BoxType BoxType))
                           (= (type |ks#0@@10|) (MapType0Type BoxType boolType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRemoveStrong
                            Maps._default.MapRemoveStrong$K@@4
                            Maps._default.MapRemoveStrong$V@@4
                            ($LS $ly@@230)
                            (Lit |m#0@@53|)
                            (Lit |ks#0@@10|)))
                :weight 3
                :skolemid |2597|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@501 T@U) (arg1@@237 T@U) (arg2@@131 T@U) (arg3@@75 T@U))
  (! (= (type (Maps.__default.MapRemove1 arg0@@501 arg1@@237 arg2@@131 arg3@@75))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapRemove1
                 arg0@@501
                 arg1@@237
                 arg2@@131
                 arg3@@75))
     :qid |funType:Maps.__default.MapRemove1|)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1$K T@U)
                    (Maps._default.MapRemove1$V T@U)
                    (|m#0@@54| T@U)
                    (|k#0@@42| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1#canCall|
                                 Maps._default.MapRemove1$K
                                 Maps._default.MapRemove1$V
                                 |m#0@@54|
                                 |k#0@@42|)
                               (and ($Is |m#0@@54|
                                         (TMap Maps._default.MapRemove1$K
                                               Maps._default.MapRemove1$V))
                                    ($IsBox |k#0@@42|
                                            Maps._default.MapRemove1$K))))
                      (a!2 (forall ((|j#1@@2| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1
                                                                                     Maps._default.MapRemove1$K
                                                                                     Maps._default.MapRemove1$V
                                                                                     |m#0@@54|
                                                                                     |k#0@@42|))
                                                                     |j#1@@2|))))
                                (let ((a!2 (=> a!1
                                               (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|)
                                                                         |j#1@@2|)))))
                                (let ((a!3 (and a!2
                                                (=> a!1
                                                    (not (= |j#1@@2| |k#0@@42|))))))
                                  (=> (and (= (type |j#1@@2|) BoxType)
                                           ($IsBox |j#1@@2|
                                                   Maps._default.MapRemove1$K))
                                      a!3))))
                                :pattern ((MapType0Select (|Map#Domain| |m#0@@54|)
                                                          |j#1@@2|))
                                :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemove1
                                                                          Maps._default.MapRemove1$K
                                                                          Maps._default.MapRemove1$V
                                                                          |m#0@@54|
                                                                          |k#0@@42|))
                                                          |j#1@@2|))
                                :skolemid |2599|
                                :qid |Mapsidfy.71:18|)))
                      (a!3 (INTERNAL_le_boogie
                             (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove1
                                                         Maps._default.MapRemove1$K
                                                         Maps._default.MapRemove1$V
                                                         |m#0@@54|
                                                         |k#0@@42|)))
                             (|Set#Card| (|Map#Domain| |m#0@@54|))))
                      (a!4 (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|)
                                                         |k#0@@42|))
                               (= (|Map#Card| (Maps.__default.MapRemove1
                                                Maps._default.MapRemove1$K
                                                Maps._default.MapRemove1$V
                                                |m#0@@54|
                                                |k#0@@42|))
                                  (INTERNAL_sub_boogie (|Map#Card| |m#0@@54|) 1))))
                      (a!5 (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|)
                                                          |k#0@@42|)))))
                (let ((a!6 (=> a!5
                               (= (|Map#Card| (Maps.__default.MapRemove1
                                                Maps._default.MapRemove1$K
                                                Maps._default.MapRemove1$V
                                                |m#0@@54|
                                                |k#0@@42|))
                                  (|Map#Card| |m#0@@54|)))))
                  (=> (and (= (type Maps._default.MapRemove1$K) TyType)
                           (= (type Maps._default.MapRemove1$V) TyType)
                           (= (type |m#0@@54|) (MapType BoxType BoxType))
                           (= (type |k#0@@42|) BoxType)
                           a!1)
                      (and (forall ((|j#0@@10| T@U))
                             (! (let ((a!1 (and (and (= (type |j#0@@10|)
                                                        BoxType)
                                                     ($IsBox |j#0@@10|
                                                             Maps._default.MapRemove1$K))
                                                (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|)
                                                                          |j#0@@10|))
                                                (not (= |j#0@@10| |k#0@@42|))))
                                      (a!2 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1
                                                                                     Maps._default.MapRemove1$K
                                                                                     Maps._default.MapRemove1$V
                                                                                     |m#0@@54|
                                                                                     |k#0@@42|))
                                                                     |j#0@@10|))))
                                  (=> a!1 a!2))
                                :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemove1
                                                                          Maps._default.MapRemove1$K
                                                                          Maps._default.MapRemove1$V
                                                                          |m#0@@54|
                                                                          |k#0@@42|))
                                                          |j#0@@10|))
                                :pattern ((MapType0Select (|Map#Domain| |m#0@@54|)
                                                          |j#0@@10|))
                                :skolemid |2598|
                                :qid |Mapsidfy.70:18|))
                           a!2
                           (forall ((|j#2@@0| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1
                                                                                     Maps._default.MapRemove1$K
                                                                                     Maps._default.MapRemove1$V
                                                                                     |m#0@@54|
                                                                                     |k#0@@42|))
                                                                     |j#2@@0|)))
                                      (a!3 (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1
                                                                                Maps._default.MapRemove1$K
                                                                                Maps._default.MapRemove1$V
                                                                                |m#0@@54|
                                                                                |k#0@@42|))
                                                              |j#2@@0|)
                                              (MapType0Select (|Map#Elements| |m#0@@54|)
                                                              |j#2@@0|))))
                                (let ((a!2 (and (and (= (type |j#2@@0|) BoxType)
                                                     ($IsBox |j#2@@0|
                                                             Maps._default.MapRemove1$K))
                                                a!1)))
                                  (=> a!2 a!3)))
                                :pattern ((MapType0Select (|Map#Elements| |m#0@@54|)
                                                          |j#2@@0|))
                                :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapRemove1
                                                                            Maps._default.MapRemove1$K
                                                                            Maps._default.MapRemove1$V
                                                                            |m#0@@54|
                                                                            |k#0@@42|))
                                                          |j#2@@0|))
                                :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemove1
                                                                          Maps._default.MapRemove1$K
                                                                          Maps._default.MapRemove1$V
                                                                          |m#0@@54|
                                                                          |k#0@@42|))
                                                          |j#2@@0|))
                                :skolemid |2600|
                                :qid |Mapsidfy.72:18|))
                           a!3
                           a!4
                           a!6
                           ($Is (Maps.__default.MapRemove1
                                  Maps._default.MapRemove1$K
                                  Maps._default.MapRemove1$V
                                  |m#0@@54|
                                  |k#0@@42|)
                                (TMap Maps._default.MapRemove1$K
                                      Maps._default.MapRemove1$V))))))
                :pattern ((Maps.__default.MapRemove1
                            Maps._default.MapRemove1$K
                            Maps._default.MapRemove1$V
                            |m#0@@54|
                            |k#0@@42|))
                :skolemid |2601|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapRemove1$K@@0 T@U)
         (Maps._default.MapRemove1$V@@0 T@U)
         (|m#0@@55| T@U)
         (|k#0@@43| T@U))
  (! (=> (and (= (type Maps._default.MapRemove1$K@@0) TyType)
              (= (type Maps._default.MapRemove1$V@@0) TyType)
              (= (type |m#0@@55|) (MapType BoxType BoxType))
              (= (type |k#0@@43|) BoxType)
              ($Is |m#0@@55|
                   (TMap Maps._default.MapRemove1$K@@0
                         Maps._default.MapRemove1$V@@0))
              ($IsBox |k#0@@43| Maps._default.MapRemove1$K@@0))
         (= (|Maps.__default.MapRemove1#requires|
              Maps._default.MapRemove1$K@@0
              Maps._default.MapRemove1$V@@0
              |m#0@@55|
              |k#0@@43|)
            true))
     :pattern ((|Maps.__default.MapRemove1#requires|
                 Maps._default.MapRemove1$K@@0
                 Maps._default.MapRemove1$V@@0
                 |m#0@@55|
                 |k#0@@43|))
     :skolemid |2602|
     :qid |unknown.0:0|)))
(assert (= (type StartFuel_MapRemove_s._default.MapRemove1) LayerTypeType))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1$K@@1 T@U)
                    (Maps._default.MapRemove1$V@@1 T@U)
                    (|m#0@@56| T@U)
                    (|k#0@@44| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1#canCall|
                                 Maps._default.MapRemove1$K@@1
                                 Maps._default.MapRemove1$V@@1
                                 |m#0@@56|
                                 |k#0@@44|)
                               (and ($Is |m#0@@56|
                                         (TMap Maps._default.MapRemove1$K@@1
                                               Maps._default.MapRemove1$V@@1))
                                    ($IsBox |k#0@@44|
                                            Maps._default.MapRemove1$K@@1)))))
                  (=> (and (= (type Maps._default.MapRemove1$K@@1) TyType)
                           (= (type Maps._default.MapRemove1$V@@1) TyType)
                           (= (type |m#0@@56|) (MapType BoxType BoxType))
                           (= (type |k#0@@44|) BoxType)
                           a!1)
                      (and (|MapRemove_s.__default.MapRemove1#canCall|
                             Maps._default.MapRemove1$K@@1
                             Maps._default.MapRemove1$V@@1
                             |m#0@@56|
                             |k#0@@44|)
                           (= (Maps.__default.MapRemove1
                                Maps._default.MapRemove1$K@@1
                                Maps._default.MapRemove1$V@@1
                                |m#0@@56|
                                |k#0@@44|)
                              (MapRemove_s.__default.MapRemove1
                                Maps._default.MapRemove1$K@@1
                                Maps._default.MapRemove1$V@@1
                                StartFuel_MapRemove_s._default.MapRemove1
                                |m#0@@56|
                                |k#0@@44|)))))
                :pattern ((Maps.__default.MapRemove1
                            Maps._default.MapRemove1$K@@1
                            Maps._default.MapRemove1$V@@1
                            |m#0@@56|
                            |k#0@@44|))
                :skolemid |2603|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1$K@@2 T@U)
                    (Maps._default.MapRemove1$V@@2 T@U)
                    (|m#0@@57| T@U)
                    (|k#0@@45| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1#canCall|
                                 Maps._default.MapRemove1$K@@2
                                 Maps._default.MapRemove1$V@@2
                                 (Lit |m#0@@57|)
                                 |k#0@@45|)
                               (and ($Is |m#0@@57|
                                         (TMap Maps._default.MapRemove1$K@@2
                                               Maps._default.MapRemove1$V@@2))
                                    ($IsBox |k#0@@45|
                                            Maps._default.MapRemove1$K@@2))))
                      (a!2 (and (|MapRemove_s.__default.MapRemove1#canCall|
                                  Maps._default.MapRemove1$K@@2
                                  Maps._default.MapRemove1$V@@2
                                  (Lit |m#0@@57|)
                                  |k#0@@45|)
                                (= (Maps.__default.MapRemove1
                                     Maps._default.MapRemove1$K@@2
                                     Maps._default.MapRemove1$V@@2
                                     (Lit |m#0@@57|)
                                     |k#0@@45|)
                                   (MapRemove_s.__default.MapRemove1
                                     Maps._default.MapRemove1$K@@2
                                     Maps._default.MapRemove1$V@@2
                                     StartFuel_MapRemove_s._default.MapRemove1
                                     (Lit |m#0@@57|)
                                     |k#0@@45|)))))
                  (=> (and (= (type Maps._default.MapRemove1$K@@2) TyType)
                           (= (type Maps._default.MapRemove1$V@@2) TyType)
                           (= (type |m#0@@57|) (MapType BoxType BoxType))
                           (= (type |k#0@@45|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRemove1
                            Maps._default.MapRemove1$K@@2
                            Maps._default.MapRemove1$V@@2
                            (Lit |m#0@@57|)
                            |k#0@@45|))
                :weight 3
                :skolemid |2604|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1$K@@3 T@U)
                    (Maps._default.MapRemove1$V@@3 T@U)
                    (|m#0@@58| T@U)
                    (|k#0@@46| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1#canCall|
                                 Maps._default.MapRemove1$K@@3
                                 Maps._default.MapRemove1$V@@3
                                 (Lit |m#0@@58|)
                                 (Lit |k#0@@46|))
                               (and ($Is |m#0@@58|
                                         (TMap Maps._default.MapRemove1$K@@3
                                               Maps._default.MapRemove1$V@@3))
                                    ($IsBox |k#0@@46|
                                            Maps._default.MapRemove1$K@@3))))
                      (a!2 (and (|MapRemove_s.__default.MapRemove1#canCall|
                                  Maps._default.MapRemove1$K@@3
                                  Maps._default.MapRemove1$V@@3
                                  (Lit |m#0@@58|)
                                  (Lit |k#0@@46|))
                                (= (Maps.__default.MapRemove1
                                     Maps._default.MapRemove1$K@@3
                                     Maps._default.MapRemove1$V@@3
                                     (Lit |m#0@@58|)
                                     (Lit |k#0@@46|))
                                   (MapRemove_s.__default.MapRemove1
                                     Maps._default.MapRemove1$K@@3
                                     Maps._default.MapRemove1$V@@3
                                     StartFuel_MapRemove_s._default.MapRemove1
                                     (Lit |m#0@@58|)
                                     (Lit |k#0@@46|))))))
                  (=> (and (= (type Maps._default.MapRemove1$K@@3) TyType)
                           (= (type Maps._default.MapRemove1$V@@3) TyType)
                           (= (type |m#0@@58|) (MapType BoxType BoxType))
                           (= (type |k#0@@46|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRemove1
                            Maps._default.MapRemove1$K@@3
                            Maps._default.MapRemove1$V@@3
                            (Lit |m#0@@58|)
                            (Lit |k#0@@46|)))
                :weight 3
                :skolemid |2605|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@502 T@U)
         (arg1@@238 T@U)
         (arg2@@132 T@U)
         (arg3@@76 T@U)
         (arg4@@46 T@U))
  (! (= (type (Maps.__default.MapRemove1Strong
                arg0@@502
                arg1@@238
                arg2@@132
                arg3@@76
                arg4@@46))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapRemove1Strong
                 arg0@@502
                 arg1@@238
                 arg2@@132
                 arg3@@76
                 arg4@@46))
     :qid |funType:Maps.__default.MapRemove1Strong|)))
(assert (forall ((Maps._default.MapRemove1Strong$K T@U)
         (Maps._default.MapRemove1Strong$V T@U)
         ($ly@@231 T@U)
         (|m#0@@59| T@U)
         (|k#0@@47| T@U))
  (! (=> (and (= (type Maps._default.MapRemove1Strong$K) TyType)
              (= (type Maps._default.MapRemove1Strong$V) TyType)
              (= (type $ly@@231) LayerTypeType)
              (= (type |m#0@@59|) (MapType BoxType BoxType))
              (= (type |k#0@@47|) BoxType))
         (= (Maps.__default.MapRemove1Strong
              Maps._default.MapRemove1Strong$K
              Maps._default.MapRemove1Strong$V
              ($LS $ly@@231)
              |m#0@@59|
              |k#0@@47|)
            (Maps.__default.MapRemove1Strong
              Maps._default.MapRemove1Strong$K
              Maps._default.MapRemove1Strong$V
              $ly@@231
              |m#0@@59|
              |k#0@@47|)))
     :pattern ((Maps.__default.MapRemove1Strong
                 Maps._default.MapRemove1Strong$K
                 Maps._default.MapRemove1Strong$V
                 ($LS $ly@@231)
                 |m#0@@59|
                 |k#0@@47|))
     :skolemid |2606|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapRemove1Strong$K@@0 T@U)
         (Maps._default.MapRemove1Strong$V@@0 T@U)
         ($ly@@232 T@U)
         (|m#0@@60| T@U)
         (|k#0@@48| T@U))
  (! (=> (and (= (type Maps._default.MapRemove1Strong$K@@0) TyType)
              (= (type Maps._default.MapRemove1Strong$V@@0) TyType)
              (= (type $ly@@232) LayerTypeType)
              (= (type |m#0@@60|) (MapType BoxType BoxType))
              (= (type |k#0@@48|) BoxType))
         (= (Maps.__default.MapRemove1Strong
              Maps._default.MapRemove1Strong$K@@0
              Maps._default.MapRemove1Strong$V@@0
              $ly@@232
              |m#0@@60|
              |k#0@@48|)
            (Maps.__default.MapRemove1Strong
              Maps._default.MapRemove1Strong$K@@0
              Maps._default.MapRemove1Strong$V@@0
              $LZ
              |m#0@@60|
              |k#0@@48|)))
     :pattern ((Maps.__default.MapRemove1Strong
                 Maps._default.MapRemove1Strong$K@@0
                 Maps._default.MapRemove1Strong$V@@0
                 (AsFuelBottom $ly@@232)
                 |m#0@@60|
                 |k#0@@48|))
     :skolemid |2607|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1Strong$K@@1 T@U)
                    (Maps._default.MapRemove1Strong$V@@1 T@U)
                    ($ly@@233 T@U)
                    (|m#0@@61| T@U)
                    (|k#0@@49| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1Strong#canCall|
                                 Maps._default.MapRemove1Strong$K@@1
                                 Maps._default.MapRemove1Strong$V@@1
                                 |m#0@@61|
                                 |k#0@@49|)
                               (and ($Is |m#0@@61|
                                         (TMap Maps._default.MapRemove1Strong$K@@1
                                               Maps._default.MapRemove1Strong$V@@1))
                                    ($IsBox |k#0@@49|
                                            Maps._default.MapRemove1Strong$K@@1))))
                      (a!2 (|Set#Equal| (|Map#Domain| (Maps.__default.MapRemove1Strong
                                                        Maps._default.MapRemove1Strong$K@@1
                                                        Maps._default.MapRemove1Strong$V@@1
                                                        $ly@@233
                                                        |m#0@@61|
                                                        |k#0@@49|))
                                        (|Set#Difference| (|Map#Domain| |m#0@@61|)
                                                          (|Set#UnionOne| (|Set#Empty| BoxType)
                                                                          |k#0@@49|))))
                      (a!3 (forall ((|j#0@@11| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1Strong
                                                                                     Maps._default.MapRemove1Strong$K@@1
                                                                                     Maps._default.MapRemove1Strong$V@@1
                                                                                     $ly@@233
                                                                                     |m#0@@61|
                                                                                     |k#0@@49|))
                                                                     |j#0@@11|)))
                                      (a!2 (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1Strong
                                                                                Maps._default.MapRemove1Strong$K@@1
                                                                                Maps._default.MapRemove1Strong$V@@1
                                                                                $ly@@233
                                                                                |m#0@@61|
                                                                                |k#0@@49|))
                                                              |j#0@@11|)
                                              (MapType0Select (|Map#Elements| |m#0@@61|)
                                                              |j#0@@11|))))
                                  (=> (and (= (type |j#0@@11|) BoxType)
                                           ($IsBox |j#0@@11|
                                                   Maps._default.MapRemove1Strong$K@@1)
                                           a!1)
                                      a!2))
                                :pattern ((MapType0Select (|Map#Elements| |m#0@@61|)
                                                          |j#0@@11|))
                                :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapRemove1Strong
                                                                            Maps._default.MapRemove1Strong$K@@1
                                                                            Maps._default.MapRemove1Strong$V@@1
                                                                            $ly@@233
                                                                            |m#0@@61|
                                                                            |k#0@@49|))
                                                          |j#0@@11|))
                                :pattern ((MapType0Select (|Map#Domain| (Maps.__default.MapRemove1Strong
                                                                          Maps._default.MapRemove1Strong$K@@1
                                                                          Maps._default.MapRemove1Strong$V@@1
                                                                          $ly@@233
                                                                          |m#0@@61|
                                                                          |k#0@@49|))
                                                          |j#0@@11|))
                                :skolemid |2608|
                                :qid |Mapsidfy.82:20|)))
                      (a!4 (INTERNAL_le_boogie
                             (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove1Strong
                                                         Maps._default.MapRemove1Strong$K@@1
                                                         Maps._default.MapRemove1Strong$V@@1
                                                         $ly@@233
                                                         |m#0@@61|
                                                         |k#0@@49|)))
                             (|Set#Card| (|Map#Domain| |m#0@@61|)))))
                (let ((a!5 (and a!2
                                a!3
                                a!4
                                (INTERNAL_le_boogie
                                  (|Map#Card| (Maps.__default.MapRemove1Strong
                                                Maps._default.MapRemove1Strong$K@@1
                                                Maps._default.MapRemove1Strong$V@@1
                                                $ly@@233
                                                |m#0@@61|
                                                |k#0@@49|))
                                  (|Map#Card| |m#0@@61|))
                                ($Is (Maps.__default.MapRemove1Strong
                                       Maps._default.MapRemove1Strong$K@@1
                                       Maps._default.MapRemove1Strong$V@@1
                                       $ly@@233
                                       |m#0@@61|
                                       |k#0@@49|)
                                     (TMap Maps._default.MapRemove1Strong$K@@1
                                           Maps._default.MapRemove1Strong$V@@1)))))
                  (=> (and (= (type Maps._default.MapRemove1Strong$K@@1) TyType)
                           (= (type Maps._default.MapRemove1Strong$V@@1) TyType)
                           (= (type $ly@@233) LayerTypeType)
                           (= (type |m#0@@61|) (MapType BoxType BoxType))
                           (= (type |k#0@@49|) BoxType)
                           a!1)
                      a!5)))
                :pattern ((Maps.__default.MapRemove1Strong
                            Maps._default.MapRemove1Strong$K@@1
                            Maps._default.MapRemove1Strong$V@@1
                            $ly@@233
                            |m#0@@61|
                            |k#0@@49|))
                :skolemid |2609|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapRemove1Strong$K@@2 T@U)
         (Maps._default.MapRemove1Strong$V@@2 T@U)
         ($ly@@234 T@U)
         (|m#0@@62| T@U)
         (|k#0@@50| T@U))
  (! (=> (and (= (type Maps._default.MapRemove1Strong$K@@2) TyType)
              (= (type Maps._default.MapRemove1Strong$V@@2) TyType)
              (= (type $ly@@234) LayerTypeType)
              (= (type |m#0@@62|) (MapType BoxType BoxType))
              (= (type |k#0@@50|) BoxType)
              ($Is |m#0@@62|
                   (TMap Maps._default.MapRemove1Strong$K@@2
                         Maps._default.MapRemove1Strong$V@@2))
              ($IsBox |k#0@@50| Maps._default.MapRemove1Strong$K@@2))
         (= (|Maps.__default.MapRemove1Strong#requires|
              Maps._default.MapRemove1Strong$K@@2
              Maps._default.MapRemove1Strong$V@@2
              $ly@@234
              |m#0@@62|
              |k#0@@50|)
            true))
     :pattern ((|Maps.__default.MapRemove1Strong#requires|
                 Maps._default.MapRemove1Strong$K@@2
                 Maps._default.MapRemove1Strong$V@@2
                 $ly@@234
                 |m#0@@62|
                 |k#0@@50|))
     :skolemid |2610|
     :qid |unknown.0:0|)))
(assert (and (= (type MoreFuel_MapRemove_s._default.MapRemove10) LayerTypeType)
     (= (type StartFuelAssert_MapRemove_s._default.MapRemove1) LayerTypeType)))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1Strong$K@@3 T@U)
                    (Maps._default.MapRemove1Strong$V@@3 T@U)
                    ($ly@@235 T@U)
                    (|m#0@@63| T@U)
                    (|k#0@@51| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1Strong#canCall|
                                 Maps._default.MapRemove1Strong$K@@3
                                 Maps._default.MapRemove1Strong$V@@3
                                 |m#0@@63|
                                 |k#0@@51|)
                               (and ($Is |m#0@@63|
                                         (TMap Maps._default.MapRemove1Strong$K@@3
                                               Maps._default.MapRemove1Strong$V@@3))
                                    ($IsBox |k#0@@51|
                                            Maps._default.MapRemove1Strong$K@@3))))
                      (a!2 (and (|Maps.__default.MapRemove1#canCall|
                                  Maps._default.MapRemove1Strong$K@@3
                                  Maps._default.MapRemove1Strong$V@@3
                                  |m#0@@63|
                                  |k#0@@51|)
                                (= StartFuel_MapRemove_s._default.MapRemove1
                                   ($LS MoreFuel_MapRemove_s._default.MapRemove10))
                                (= StartFuelAssert_MapRemove_s._default.MapRemove1
                                   ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove10)))
                                (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove10)
                                   MoreFuel_MapRemove_s._default.MapRemove10)
                                (= (Maps.__default.MapRemove1Strong
                                     Maps._default.MapRemove1Strong$K@@3
                                     Maps._default.MapRemove1Strong$V@@3
                                     ($LS $ly@@235)
                                     |m#0@@63|
                                     |k#0@@51|)
                                   (Maps.__default.MapRemove1
                                     Maps._default.MapRemove1Strong$K@@3
                                     Maps._default.MapRemove1Strong$V@@3
                                     |m#0@@63|
                                     |k#0@@51|)))))
                  (=> (and (= (type Maps._default.MapRemove1Strong$K@@3) TyType)
                           (= (type Maps._default.MapRemove1Strong$V@@3) TyType)
                           (= (type $ly@@235) LayerTypeType)
                           (= (type |m#0@@63|) (MapType BoxType BoxType))
                           (= (type |k#0@@51|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRemove1Strong
                            Maps._default.MapRemove1Strong$K@@3
                            Maps._default.MapRemove1Strong$V@@3
                            ($LS $ly@@235)
                            |m#0@@63|
                            |k#0@@51|))
                :skolemid |2611|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type MoreFuel_MapRemove_s._default.MapRemove11) LayerTypeType))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1Strong$K@@4 T@U)
                    (Maps._default.MapRemove1Strong$V@@4 T@U)
                    ($ly@@236 T@U)
                    (|m#0@@64| T@U)
                    (|k#0@@52| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1Strong#canCall|
                                 Maps._default.MapRemove1Strong$K@@4
                                 Maps._default.MapRemove1Strong$V@@4
                                 (Lit |m#0@@64|)
                                 |k#0@@52|)
                               (and ($Is |m#0@@64|
                                         (TMap Maps._default.MapRemove1Strong$K@@4
                                               Maps._default.MapRemove1Strong$V@@4))
                                    ($IsBox |k#0@@52|
                                            Maps._default.MapRemove1Strong$K@@4))))
                      (a!2 (and (|Maps.__default.MapRemove1#canCall|
                                  Maps._default.MapRemove1Strong$K@@4
                                  Maps._default.MapRemove1Strong$V@@4
                                  (Lit |m#0@@64|)
                                  |k#0@@52|)
                                (= StartFuel_MapRemove_s._default.MapRemove1
                                   ($LS MoreFuel_MapRemove_s._default.MapRemove11))
                                (= StartFuelAssert_MapRemove_s._default.MapRemove1
                                   ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove11)))
                                (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove11)
                                   MoreFuel_MapRemove_s._default.MapRemove11)
                                (= (Maps.__default.MapRemove1Strong
                                     Maps._default.MapRemove1Strong$K@@4
                                     Maps._default.MapRemove1Strong$V@@4
                                     ($LS $ly@@236)
                                     (Lit |m#0@@64|)
                                     |k#0@@52|)
                                   (Maps.__default.MapRemove1
                                     Maps._default.MapRemove1Strong$K@@4
                                     Maps._default.MapRemove1Strong$V@@4
                                     (Lit |m#0@@64|)
                                     |k#0@@52|)))))
                  (=> (and (= (type Maps._default.MapRemove1Strong$K@@4) TyType)
                           (= (type Maps._default.MapRemove1Strong$V@@4) TyType)
                           (= (type $ly@@236) LayerTypeType)
                           (= (type |m#0@@64|) (MapType BoxType BoxType))
                           (= (type |k#0@@52|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRemove1Strong
                            Maps._default.MapRemove1Strong$K@@4
                            Maps._default.MapRemove1Strong$V@@4
                            ($LS $ly@@236)
                            (Lit |m#0@@64|)
                            |k#0@@52|))
                :weight 3
                :skolemid |2612|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (= (type MoreFuel_MapRemove_s._default.MapRemove12) LayerTypeType))
(assert (let ((a!1 (forall ((Maps._default.MapRemove1Strong$K@@5 T@U)
                    (Maps._default.MapRemove1Strong$V@@5 T@U)
                    ($ly@@237 T@U)
                    (|m#0@@65| T@U)
                    (|k#0@@53| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRemove1Strong#canCall|
                                 Maps._default.MapRemove1Strong$K@@5
                                 Maps._default.MapRemove1Strong$V@@5
                                 (Lit |m#0@@65|)
                                 (Lit |k#0@@53|))
                               (and ($Is |m#0@@65|
                                         (TMap Maps._default.MapRemove1Strong$K@@5
                                               Maps._default.MapRemove1Strong$V@@5))
                                    ($IsBox |k#0@@53|
                                            Maps._default.MapRemove1Strong$K@@5))))
                      (a!2 (= (Maps.__default.MapRemove1Strong
                                Maps._default.MapRemove1Strong$K@@5
                                Maps._default.MapRemove1Strong$V@@5
                                ($LS $ly@@237)
                                (Lit |m#0@@65|)
                                (Lit |k#0@@53|))
                              (Lit (Maps.__default.MapRemove1
                                     Maps._default.MapRemove1Strong$K@@5
                                     Maps._default.MapRemove1Strong$V@@5
                                     (Lit |m#0@@65|)
                                     (Lit |k#0@@53|))))))
                (let ((a!3 (and (|Maps.__default.MapRemove1#canCall|
                                  Maps._default.MapRemove1Strong$K@@5
                                  Maps._default.MapRemove1Strong$V@@5
                                  (Lit |m#0@@65|)
                                  (Lit |k#0@@53|))
                                (= StartFuel_MapRemove_s._default.MapRemove1
                                   ($LS MoreFuel_MapRemove_s._default.MapRemove12))
                                (= StartFuelAssert_MapRemove_s._default.MapRemove1
                                   ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove12)))
                                (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove12)
                                   MoreFuel_MapRemove_s._default.MapRemove12)
                                a!2)))
                  (=> (and (= (type Maps._default.MapRemove1Strong$K@@5) TyType)
                           (= (type Maps._default.MapRemove1Strong$V@@5) TyType)
                           (= (type $ly@@237) LayerTypeType)
                           (= (type |m#0@@65|) (MapType BoxType BoxType))
                           (= (type |k#0@@53|) BoxType)
                           a!1)
                      a!3)))
                :pattern ((Maps.__default.MapRemove1Strong
                            Maps._default.MapRemove1Strong$K@@5
                            Maps._default.MapRemove1Strong$V@@5
                            ($LS $ly@@237)
                            (Lit |m#0@@65|)
                            (Lit |k#0@@53|)))
                :weight 3
                :skolemid |2613|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@503 T@U) (arg1@@239 T@U) (arg2@@133 T@U) (arg3@@77 T@U))
  (! (= (type (Maps.__default.IMapInvert arg0@@503 arg1@@239 arg2@@133 arg3@@77))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.IMapInvert
                 arg0@@503
                 arg1@@239
                 arg2@@133
                 arg3@@77))
     :qid |funType:Maps.__default.IMapInvert|)))
(assert (forall ((Maps._default.IMapInvert$K T@U)
         (Maps._default.IMapInvert$V T@U)
         ($ly@@238 T@U)
         (|m#0@@66| T@U))
  (! (=> (and (= (type Maps._default.IMapInvert$K) TyType)
              (= (type Maps._default.IMapInvert$V) TyType)
              (= (type $ly@@238) LayerTypeType)
              (= (type |m#0@@66|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapInvert
              Maps._default.IMapInvert$K
              Maps._default.IMapInvert$V
              ($LS $ly@@238)
              |m#0@@66|)
            (Maps.__default.IMapInvert
              Maps._default.IMapInvert$K
              Maps._default.IMapInvert$V
              $ly@@238
              |m#0@@66|)))
     :pattern ((Maps.__default.IMapInvert
                 Maps._default.IMapInvert$K
                 Maps._default.IMapInvert$V
                 ($LS $ly@@238)
                 |m#0@@66|))
     :skolemid |2614|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.IMapInvert$K@@0 T@U)
         (Maps._default.IMapInvert$V@@0 T@U)
         ($ly@@239 T@U)
         (|m#0@@67| T@U))
  (! (=> (and (= (type Maps._default.IMapInvert$K@@0) TyType)
              (= (type Maps._default.IMapInvert$V@@0) TyType)
              (= (type $ly@@239) LayerTypeType)
              (= (type |m#0@@67|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapInvert
              Maps._default.IMapInvert$K@@0
              Maps._default.IMapInvert$V@@0
              $ly@@239
              |m#0@@67|)
            (Maps.__default.IMapInvert
              Maps._default.IMapInvert$K@@0
              Maps._default.IMapInvert$V@@0
              $LZ
              |m#0@@67|)))
     :pattern ((Maps.__default.IMapInvert
                 Maps._default.IMapInvert$K@@0
                 Maps._default.IMapInvert$V@@0
                 (AsFuelBottom $ly@@239)
                 |m#0@@67|))
     :skolemid |2615|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapInvert$K@@1 T@U)
                    (Maps._default.IMapInvert$V@@1 T@U)
                    ($ly@@240 T@U)
                    (|m#0@@68| T@U))
             (! (let ((a!1 (and (= (type Maps._default.IMapInvert$K@@1) TyType)
                                (= (type Maps._default.IMapInvert$V@@1) TyType)
                                (= (type $ly@@240) LayerTypeType)
                                (= (type |m#0@@68|) (IMapType BoxType BoxType))
                                (or (|Maps.__default.IMapInvert#canCall|
                                      Maps._default.IMapInvert$K@@1
                                      Maps._default.IMapInvert$V@@1
                                      |m#0@@68|)
                                    ($Is |m#0@@68|
                                         (TIMap Maps._default.IMapInvert$K@@1
                                                Maps._default.IMapInvert$V@@1))))))
                  (=> a!1
                      ($Is (Maps.__default.IMapInvert
                             Maps._default.IMapInvert$K@@1
                             Maps._default.IMapInvert$V@@1
                             $ly@@240
                             |m#0@@68|)
                           (TIMap Maps._default.IMapInvert$V@@1
                                  Maps._default.IMapInvert$K@@1))))
                :pattern ((Maps.__default.IMapInvert
                            Maps._default.IMapInvert$K@@1
                            Maps._default.IMapInvert$V@@1
                            $ly@@240
                            |m#0@@68|))
                :skolemid |2616|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapInvert$K@@2 T@U)
         (Maps._default.IMapInvert$V@@2 T@U)
         ($ly@@241 T@U)
         ($Heap@@43 T@U)
         (|m#0@@69| T@U))
  (! (=> (and (= (type Maps._default.IMapInvert$K@@2) TyType)
              (= (type Maps._default.IMapInvert$V@@2) TyType)
              (= (type $ly@@241) LayerTypeType)
              (= (type $Heap@@43) (MapType0Type refType MapType1Type))
              (= (type |m#0@@69|) (IMapType BoxType BoxType))
              ($IsGoodHeap $Heap@@43)
              ($Is |m#0@@69|
                   (TIMap Maps._default.IMapInvert$K@@2
                          Maps._default.IMapInvert$V@@2)))
         (= (|Maps.__default.IMapInvert#requires|
              Maps._default.IMapInvert$K@@2
              Maps._default.IMapInvert$V@@2
              $ly@@241
              |m#0@@69|)
            true))
     :pattern ((|Maps.__default.IMapInvert#requires|
                 Maps._default.IMapInvert$K@@2
                 Maps._default.IMapInvert$V@@2
                 $ly@@241
                 |m#0@@69|)
               ($IsGoodHeap $Heap@@43))
     :skolemid |2617|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@504 T@U) (arg1@@240 T@U) (arg2@@134 T@U) (arg3@@78 T@U))
  (! (= (type (|$let#8_a| arg0@@504 arg1@@240 arg2@@134 arg3@@78)) BoxType)
     :pattern ((|$let#8_a| arg0@@504 arg1@@240 arg2@@134 arg3@@78))
     :qid |funType:$let#8_a|)))
(assert (forall ((Maps._default.IMapInvert$K@@3 T@U)
         (Maps._default.IMapInvert$V@@3 T@U)
         (m@@67 T@U)
         (b@@77 T@U))
  (! (let ((a!1 (and (U_2_bool (MapType0Select (|IMap#Domain| m@@67)
                                               (|$let#8_a| Maps._default.IMapInvert$K@@3
                                                           Maps._default.IMapInvert$V@@3
                                                           m@@67
                                                           b@@77)))
                     (= (MapType0Select (|IMap#Elements| m@@67)
                                        (|$let#8_a| Maps._default.IMapInvert$K@@3
                                                    Maps._default.IMapInvert$V@@3
                                                    m@@67
                                                    b@@77))
                        b@@77))))
       (=> (and (= (type Maps._default.IMapInvert$K@@3) TyType)
                (= (type Maps._default.IMapInvert$V@@3) TyType)
                (= (type m@@67) (IMapType BoxType BoxType))
                (= (type b@@77) BoxType)
                (|$let#8$canCall| Maps._default.IMapInvert$K@@3
                                  Maps._default.IMapInvert$V@@3
                                  m@@67
                                  b@@77))
           a!1))
     :pattern ((|$let#8_a| Maps._default.IMapInvert$K@@3
                           Maps._default.IMapInvert$V@@3
                           m@@67
                           b@@77))
     :skolemid |2618|
     :qid |Mapsidfy.92:31|)))
(assert (forall ((arg0@@505 T@U) (arg1@@241 T@U) (arg2@@135 T@U))
  (! (= (type (|lambda#158| arg0@@505 arg1@@241 arg2@@135))
        (MapType0Type BoxType BoxType))
     :pattern ((|lambda#158| arg0@@505 arg1@@241 arg2@@135))
     :qid |funType:lambda#158|)))
(assert (let ((a!1 (forall ((Maps._default.IMapInvert$K@@4 T@U)
                    (Maps._default.IMapInvert$V@@4 T@U)
                    ($ly@@242 T@U)
                    ($Heap@@44 T@U)
                    (|m#0@@70| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapInvert#canCall|
                                 Maps._default.IMapInvert$K@@4
                                 Maps._default.IMapInvert$V@@4
                                 |m#0@@70|)
                               (and ($IsGoodHeap $Heap@@44)
                                    ($Is |m#0@@70|
                                         (TIMap Maps._default.IMapInvert$K@@4
                                                Maps._default.IMapInvert$V@@4)))))
                      (a!2 (= (Maps.__default.IMapInvert
                                Maps._default.IMapInvert$K@@4
                                Maps._default.IMapInvert$V@@4
                                ($LS $ly@@242)
                                |m#0@@70|)
                              (|IMap#Glue| (|lambda#106| Maps._default.IMapInvert$V@@4
                                                         (|IMap#Values| |m#0@@70|))
                                           (|lambda#158| Maps._default.IMapInvert$K@@4
                                                         Maps._default.IMapInvert$V@@4
                                                         |m#0@@70|)
                                           (TIMap Maps._default.IMapInvert$V@@4
                                                  Maps._default.IMapInvert$K@@4)))))
                (let ((a!3 (and (forall ((|b#0@@48| T@U))
                                  (! (let ((a!1 (and (= (type |b#0@@48|)
                                                        BoxType)
                                                     ($IsBox |b#0@@48|
                                                             Maps._default.IMapInvert$V@@4)
                                                     (U_2_bool (MapType0Select (|IMap#Values| |m#0@@70|)
                                                                               |b#0@@48|)))))
                                       (=> a!1
                                           (|$let#8$canCall| Maps._default.IMapInvert$K@@4
                                                             Maps._default.IMapInvert$V@@4
                                                             |m#0@@70|
                                                             |b#0@@48|)))
                                     :pattern ((MapType0Select (|IMap#Values| |m#0@@70|)
                                                               |b#0@@48|))
                                     :skolemid |2619|
                                     :qid |Mapsidfy.92:10|))
                                a!2)))
                  (=> (and (= (type Maps._default.IMapInvert$K@@4) TyType)
                           (= (type Maps._default.IMapInvert$V@@4) TyType)
                           (= (type $ly@@242) LayerTypeType)
                           (= (type $Heap@@44)
                              (MapType0Type refType MapType1Type))
                           (= (type |m#0@@70|) (IMapType BoxType BoxType))
                           a!1)
                      a!3)))
                :pattern ((Maps.__default.IMapInvert
                            Maps._default.IMapInvert$K@@4
                            Maps._default.IMapInvert$V@@4
                            ($LS $ly@@242)
                            |m#0@@70|)
                          ($IsGoodHeap $Heap@@44))
                :skolemid |2620|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapInvert$K@@5 T@U)
                    (Maps._default.IMapInvert$V@@5 T@U)
                    ($ly@@243 T@U)
                    ($Heap@@45 T@U)
                    (|m#0@@71| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapInvert#canCall|
                                 Maps._default.IMapInvert$K@@5
                                 Maps._default.IMapInvert$V@@5
                                 (Lit |m#0@@71|))
                               (and ($IsGoodHeap $Heap@@45)
                                    ($Is |m#0@@71|
                                         (TIMap Maps._default.IMapInvert$K@@5
                                                Maps._default.IMapInvert$V@@5)))))
                      (a!2 (forall ((|b#0@@49| T@U))
                             (! (let ((a!1 (MapType0Select (Lit (|IMap#Values| (Lit |m#0@@71|)))
                                                           |b#0@@49|)))
                                  (=> (and (= (type |b#0@@49|) BoxType)
                                           ($IsBox |b#0@@49|
                                                   Maps._default.IMapInvert$V@@5)
                                           (U_2_bool a!1))
                                      (|$let#8$canCall| Maps._default.IMapInvert$K@@5
                                                        Maps._default.IMapInvert$V@@5
                                                        (Lit |m#0@@71|)
                                                        |b#0@@49|)))
                                :pattern ((MapType0Select (|IMap#Values| |m#0@@71|)
                                                          |b#0@@49|))
                                :skolemid |2621|
                                :qid |Mapsidfy.92:10|)))
                      (a!3 (|lambda#106| Maps._default.IMapInvert$V@@5
                                         (Lit (|IMap#Values| (Lit |m#0@@71|))))))
                (let ((a!4 (= (Maps.__default.IMapInvert
                                Maps._default.IMapInvert$K@@5
                                Maps._default.IMapInvert$V@@5
                                ($LS $ly@@243)
                                (Lit |m#0@@71|))
                              (|IMap#Glue| a!3
                                           (|lambda#158| Maps._default.IMapInvert$K@@5
                                                         Maps._default.IMapInvert$V@@5
                                                         (Lit |m#0@@71|))
                                           (TIMap Maps._default.IMapInvert$V@@5
                                                  Maps._default.IMapInvert$K@@5)))))
                  (=> (and (= (type Maps._default.IMapInvert$K@@5) TyType)
                           (= (type Maps._default.IMapInvert$V@@5) TyType)
                           (= (type $ly@@243) LayerTypeType)
                           (= (type $Heap@@45)
                              (MapType0Type refType MapType1Type))
                           (= (type |m#0@@71|) (IMapType BoxType BoxType))
                           a!1)
                      (and a!2 a!4))))
                :pattern ((Maps.__default.IMapInvert
                            Maps._default.IMapInvert$K@@5
                            Maps._default.IMapInvert$V@@5
                            ($LS $ly@@243)
                            (Lit |m#0@@71|))
                          ($IsGoodHeap $Heap@@45))
                :weight 3
                :skolemid |2622|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@506 T@U)
         (arg1@@242 T@U)
         (arg2@@136 T@U)
         (arg3@@79 T@U)
         (arg4@@47 T@U))
  (! (= (type (Maps.__default.IMapRemove
                arg0@@506
                arg1@@242
                arg2@@136
                arg3@@79
                arg4@@47))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.IMapRemove
                 arg0@@506
                 arg1@@242
                 arg2@@136
                 arg3@@79
                 arg4@@47))
     :qid |funType:Maps.__default.IMapRemove|)))
(assert (forall ((Maps._default.IMapRemove$K T@U)
         (Maps._default.IMapRemove$V T@U)
         ($ly@@244 T@U)
         (|m#0@@72| T@U)
         (|ks#0@@11| T@U))
  (! (=> (and (= (type Maps._default.IMapRemove$K) TyType)
              (= (type Maps._default.IMapRemove$V) TyType)
              (= (type $ly@@244) LayerTypeType)
              (= (type |m#0@@72|) (IMapType BoxType BoxType))
              (= (type |ks#0@@11|) (MapType0Type BoxType boolType)))
         (= (Maps.__default.IMapRemove
              Maps._default.IMapRemove$K
              Maps._default.IMapRemove$V
              ($LS $ly@@244)
              |m#0@@72|
              |ks#0@@11|)
            (Maps.__default.IMapRemove
              Maps._default.IMapRemove$K
              Maps._default.IMapRemove$V
              $ly@@244
              |m#0@@72|
              |ks#0@@11|)))
     :pattern ((Maps.__default.IMapRemove
                 Maps._default.IMapRemove$K
                 Maps._default.IMapRemove$V
                 ($LS $ly@@244)
                 |m#0@@72|
                 |ks#0@@11|))
     :skolemid |2623|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.IMapRemove$K@@0 T@U)
         (Maps._default.IMapRemove$V@@0 T@U)
         ($ly@@245 T@U)
         (|m#0@@73| T@U)
         (|ks#0@@12| T@U))
  (! (=> (and (= (type Maps._default.IMapRemove$K@@0) TyType)
              (= (type Maps._default.IMapRemove$V@@0) TyType)
              (= (type $ly@@245) LayerTypeType)
              (= (type |m#0@@73|) (IMapType BoxType BoxType))
              (= (type |ks#0@@12|) (MapType0Type BoxType boolType)))
         (= (Maps.__default.IMapRemove
              Maps._default.IMapRemove$K@@0
              Maps._default.IMapRemove$V@@0
              $ly@@245
              |m#0@@73|
              |ks#0@@12|)
            (Maps.__default.IMapRemove
              Maps._default.IMapRemove$K@@0
              Maps._default.IMapRemove$V@@0
              $LZ
              |m#0@@73|
              |ks#0@@12|)))
     :pattern ((Maps.__default.IMapRemove
                 Maps._default.IMapRemove$K@@0
                 Maps._default.IMapRemove$V@@0
                 (AsFuelBottom $ly@@245)
                 |m#0@@73|
                 |ks#0@@12|))
     :skolemid |2624|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapRemove$K@@1 T@U)
                    (Maps._default.IMapRemove$V@@1 T@U)
                    ($ly@@246 T@U)
                    (|m#0@@74| T@U)
                    (|ks#0@@13| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRemove#canCall|
                                 Maps._default.IMapRemove$K@@1
                                 Maps._default.IMapRemove$V@@1
                                 |m#0@@74|
                                 |ks#0@@13|)
                               (and ($Is |m#0@@74|
                                         (TIMap Maps._default.IMapRemove$K@@1
                                                Maps._default.IMapRemove$V@@1))
                                    ($Is |ks#0@@13|
                                         (TISet Maps._default.IMapRemove$K@@1)))))
                      (a!2 (forall ((|j#0@@12| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove
                                                                                      Maps._default.IMapRemove$K@@1
                                                                                      Maps._default.IMapRemove$V@@1
                                                                                      $ly@@246
                                                                                      |m#0@@74|
                                                                                      |ks#0@@13|))
                                                                     |j#0@@12|)))
                                      (a!2 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove
                                                                                 Maps._default.IMapRemove$K@@1
                                                                                 Maps._default.IMapRemove$V@@1
                                                                                 $ly@@246
                                                                                 |m#0@@74|
                                                                                 |ks#0@@13|))
                                                              |j#0@@12|)
                                              (MapType0Select (|IMap#Elements| |m#0@@74|)
                                                              |j#0@@12|))))
                                  (=> (and (= (type |j#0@@12|) BoxType)
                                           ($IsBox |j#0@@12|
                                                   Maps._default.IMapRemove$K@@1)
                                           a!1)
                                      a!2))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@74|)
                                                          |j#0@@12|))
                                :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove
                                                                             Maps._default.IMapRemove$K@@1
                                                                             Maps._default.IMapRemove$V@@1
                                                                             $ly@@246
                                                                             |m#0@@74|
                                                                             |ks#0@@13|))
                                                          |j#0@@12|))
                                :pattern ((MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove
                                                                           Maps._default.IMapRemove$K@@1
                                                                           Maps._default.IMapRemove$V@@1
                                                                           $ly@@246
                                                                           |m#0@@74|
                                                                           |ks#0@@13|))
                                                          |j#0@@12|))
                                :skolemid |2625|
                                :qid |Mapsidfy.103:20|))))
                (let ((a!3 (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapRemove
                                                               Maps._default.IMapRemove$K@@1
                                                               Maps._default.IMapRemove$V@@1
                                                               $ly@@246
                                                               |m#0@@74|
                                                               |ks#0@@13|))
                                              (|ISet#Difference|
                                                (|IMap#Domain| |m#0@@74|)
                                                |ks#0@@13|))
                                a!2
                                ($Is (Maps.__default.IMapRemove
                                       Maps._default.IMapRemove$K@@1
                                       Maps._default.IMapRemove$V@@1
                                       $ly@@246
                                       |m#0@@74|
                                       |ks#0@@13|)
                                     (TIMap Maps._default.IMapRemove$K@@1
                                            Maps._default.IMapRemove$V@@1)))))
                  (=> (and (= (type Maps._default.IMapRemove$K@@1) TyType)
                           (= (type Maps._default.IMapRemove$V@@1) TyType)
                           (= (type $ly@@246) LayerTypeType)
                           (= (type |m#0@@74|) (IMapType BoxType BoxType))
                           (= (type |ks#0@@13|) (MapType0Type BoxType boolType))
                           a!1)
                      a!3)))
                :pattern ((Maps.__default.IMapRemove
                            Maps._default.IMapRemove$K@@1
                            Maps._default.IMapRemove$V@@1
                            $ly@@246
                            |m#0@@74|
                            |ks#0@@13|))
                :skolemid |2626|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapRemove$K@@2 T@U)
         (Maps._default.IMapRemove$V@@2 T@U)
         ($ly@@247 T@U)
         (|m#0@@75| T@U)
         (|ks#0@@14| T@U))
  (! (=> (and (= (type Maps._default.IMapRemove$K@@2) TyType)
              (= (type Maps._default.IMapRemove$V@@2) TyType)
              (= (type $ly@@247) LayerTypeType)
              (= (type |m#0@@75|) (IMapType BoxType BoxType))
              (= (type |ks#0@@14|) (MapType0Type BoxType boolType))
              ($Is |m#0@@75|
                   (TIMap Maps._default.IMapRemove$K@@2
                          Maps._default.IMapRemove$V@@2))
              ($Is |ks#0@@14| (TISet Maps._default.IMapRemove$K@@2)))
         (= (|Maps.__default.IMapRemove#requires|
              Maps._default.IMapRemove$K@@2
              Maps._default.IMapRemove$V@@2
              $ly@@247
              |m#0@@75|
              |ks#0@@14|)
            true))
     :pattern ((|Maps.__default.IMapRemove#requires|
                 Maps._default.IMapRemove$K@@2
                 Maps._default.IMapRemove$V@@2
                 $ly@@247
                 |m#0@@75|
                 |ks#0@@14|))
     :skolemid |2627|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapRemove$K@@3 T@U)
                    (Maps._default.IMapRemove$V@@3 T@U)
                    ($ly@@248 T@U)
                    (|m#0@@76| T@U)
                    (|ks#0@@15| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRemove#canCall|
                                 Maps._default.IMapRemove$K@@3
                                 Maps._default.IMapRemove$V@@3
                                 |m#0@@76|
                                 |ks#0@@15|)
                               (and ($Is |m#0@@76|
                                         (TIMap Maps._default.IMapRemove$K@@3
                                                Maps._default.IMapRemove$V@@3))
                                    ($Is |ks#0@@15|
                                         (TISet Maps._default.IMapRemove$K@@3)))))
                      (a!2 (= (Maps.__default.IMapRemove
                                Maps._default.IMapRemove$K@@3
                                Maps._default.IMapRemove$V@@3
                                ($LS $ly@@248)
                                |m#0@@76|
                                |ks#0@@15|)
                              (|IMap#Glue| (|lambda#153| Maps._default.IMapRemove$K@@3
                                                         (|IMap#Domain| |m#0@@76|)
                                                         |ks#0@@15|)
                                           (|lambda#148| (|IMap#Elements| |m#0@@76|))
                                           (TIMap Maps._default.IMapRemove$K@@3
                                                  Maps._default.IMapRemove$V@@3)))))
                  (=> (and (= (type Maps._default.IMapRemove$K@@3) TyType)
                           (= (type Maps._default.IMapRemove$V@@3) TyType)
                           (= (type $ly@@248) LayerTypeType)
                           (= (type |m#0@@76|) (IMapType BoxType BoxType))
                           (= (type |ks#0@@15|) (MapType0Type BoxType boolType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapRemove
                            Maps._default.IMapRemove$K@@3
                            Maps._default.IMapRemove$V@@3
                            ($LS $ly@@248)
                            |m#0@@76|
                            |ks#0@@15|))
                :skolemid |2628|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapRemove$K@@4 T@U)
                    (Maps._default.IMapRemove$V@@4 T@U)
                    ($ly@@249 T@U)
                    (|m#0@@77| T@U)
                    (|ks#0@@16| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRemove#canCall|
                                 Maps._default.IMapRemove$K@@4
                                 Maps._default.IMapRemove$V@@4
                                 (Lit |m#0@@77|)
                                 (Lit |ks#0@@16|))
                               (and ($Is |m#0@@77|
                                         (TIMap Maps._default.IMapRemove$K@@4
                                                Maps._default.IMapRemove$V@@4))
                                    ($Is |ks#0@@16|
                                         (TISet Maps._default.IMapRemove$K@@4)))))
                      (a!2 (|IMap#Glue| (|lambda#153| Maps._default.IMapRemove$K@@4
                                                      (|IMap#Domain| |m#0@@77|)
                                                      (Lit |ks#0@@16|))
                                        (|lambda#148| (|IMap#Elements| (Lit |m#0@@77|)))
                                        (TIMap Maps._default.IMapRemove$K@@4
                                               Maps._default.IMapRemove$V@@4))))
                  (=> (and (= (type Maps._default.IMapRemove$K@@4) TyType)
                           (= (type Maps._default.IMapRemove$V@@4) TyType)
                           (= (type $ly@@249) LayerTypeType)
                           (= (type |m#0@@77|) (IMapType BoxType BoxType))
                           (= (type |ks#0@@16|) (MapType0Type BoxType boolType))
                           a!1)
                      (= (Maps.__default.IMapRemove
                           Maps._default.IMapRemove$K@@4
                           Maps._default.IMapRemove$V@@4
                           ($LS $ly@@249)
                           (Lit |m#0@@77|)
                           (Lit |ks#0@@16|))
                         a!2)))
                :pattern ((Maps.__default.IMapRemove
                            Maps._default.IMapRemove$K@@4
                            Maps._default.IMapRemove$V@@4
                            ($LS $ly@@249)
                            (Lit |m#0@@77|)
                            (Lit |ks#0@@16|)))
                :weight 3
                :skolemid |2629|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@507 T@U)
         (arg1@@243 T@U)
         (arg2@@137 T@U)
         (arg3@@80 T@U)
         (arg4@@48 T@U))
  (! (= (type (Maps.__default.IMapRemove1
                arg0@@507
                arg1@@243
                arg2@@137
                arg3@@80
                arg4@@48))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.IMapRemove1
                 arg0@@507
                 arg1@@243
                 arg2@@137
                 arg3@@80
                 arg4@@48))
     :qid |funType:Maps.__default.IMapRemove1|)))
(assert (forall ((Maps._default.IMapRemove1$K T@U)
         (Maps._default.IMapRemove1$V T@U)
         ($ly@@250 T@U)
         (|m#0@@78| T@U)
         (|k#0@@54| T@U))
  (! (=> (and (= (type Maps._default.IMapRemove1$K) TyType)
              (= (type Maps._default.IMapRemove1$V) TyType)
              (= (type $ly@@250) LayerTypeType)
              (= (type |m#0@@78|) (IMapType BoxType BoxType))
              (= (type |k#0@@54|) BoxType))
         (= (Maps.__default.IMapRemove1
              Maps._default.IMapRemove1$K
              Maps._default.IMapRemove1$V
              ($LS $ly@@250)
              |m#0@@78|
              |k#0@@54|)
            (Maps.__default.IMapRemove1
              Maps._default.IMapRemove1$K
              Maps._default.IMapRemove1$V
              $ly@@250
              |m#0@@78|
              |k#0@@54|)))
     :pattern ((Maps.__default.IMapRemove1
                 Maps._default.IMapRemove1$K
                 Maps._default.IMapRemove1$V
                 ($LS $ly@@250)
                 |m#0@@78|
                 |k#0@@54|))
     :skolemid |2630|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.IMapRemove1$K@@0 T@U)
         (Maps._default.IMapRemove1$V@@0 T@U)
         ($ly@@251 T@U)
         (|m#0@@79| T@U)
         (|k#0@@55| T@U))
  (! (=> (and (= (type Maps._default.IMapRemove1$K@@0) TyType)
              (= (type Maps._default.IMapRemove1$V@@0) TyType)
              (= (type $ly@@251) LayerTypeType)
              (= (type |m#0@@79|) (IMapType BoxType BoxType))
              (= (type |k#0@@55|) BoxType))
         (= (Maps.__default.IMapRemove1
              Maps._default.IMapRemove1$K@@0
              Maps._default.IMapRemove1$V@@0
              $ly@@251
              |m#0@@79|
              |k#0@@55|)
            (Maps.__default.IMapRemove1
              Maps._default.IMapRemove1$K@@0
              Maps._default.IMapRemove1$V@@0
              $LZ
              |m#0@@79|
              |k#0@@55|)))
     :pattern ((Maps.__default.IMapRemove1
                 Maps._default.IMapRemove1$K@@0
                 Maps._default.IMapRemove1$V@@0
                 (AsFuelBottom $ly@@251)
                 |m#0@@79|
                 |k#0@@55|))
     :skolemid |2631|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapRemove1$K@@1 T@U)
                    (Maps._default.IMapRemove1$V@@1 T@U)
                    ($ly@@252 T@U)
                    (|m#0@@80| T@U)
                    (|k#0@@56| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRemove1#canCall|
                                 Maps._default.IMapRemove1$K@@1
                                 Maps._default.IMapRemove1$V@@1
                                 |m#0@@80|
                                 |k#0@@56|)
                               (and ($Is |m#0@@80|
                                         (TIMap Maps._default.IMapRemove1$K@@1
                                                Maps._default.IMapRemove1$V@@1))
                                    ($IsBox |k#0@@56|
                                            Maps._default.IMapRemove1$K@@1))))
                      (a!2 (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapRemove1
                                                          Maps._default.IMapRemove1$K@@1
                                                          Maps._default.IMapRemove1$V@@1
                                                          $ly@@252
                                                          |m#0@@80|
                                                          |k#0@@56|))
                                         (|ISet#Difference|
                                           (|IMap#Domain| |m#0@@80|)
                                           (|ISet#UnionOne| (|ISet#Empty| BoxType)
                                                            |k#0@@56|))))
                      (a!3 (forall ((|j#0@@13| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove1
                                                                                      Maps._default.IMapRemove1$K@@1
                                                                                      Maps._default.IMapRemove1$V@@1
                                                                                      $ly@@252
                                                                                      |m#0@@80|
                                                                                      |k#0@@56|))
                                                                     |j#0@@13|)))
                                      (a!2 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove1
                                                                                 Maps._default.IMapRemove1$K@@1
                                                                                 Maps._default.IMapRemove1$V@@1
                                                                                 $ly@@252
                                                                                 |m#0@@80|
                                                                                 |k#0@@56|))
                                                              |j#0@@13|)
                                              (MapType0Select (|IMap#Elements| |m#0@@80|)
                                                              |j#0@@13|))))
                                  (=> (and (= (type |j#0@@13|) BoxType)
                                           ($IsBox |j#0@@13|
                                                   Maps._default.IMapRemove1$K@@1)
                                           a!1)
                                      a!2))
                                :pattern ((MapType0Select (|IMap#Elements| |m#0@@80|)
                                                          |j#0@@13|))
                                :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove1
                                                                             Maps._default.IMapRemove1$K@@1
                                                                             Maps._default.IMapRemove1$V@@1
                                                                             $ly@@252
                                                                             |m#0@@80|
                                                                             |k#0@@56|))
                                                          |j#0@@13|))
                                :pattern ((MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove1
                                                                           Maps._default.IMapRemove1$K@@1
                                                                           Maps._default.IMapRemove1$V@@1
                                                                           $ly@@252
                                                                           |m#0@@80|
                                                                           |k#0@@56|))
                                                          |j#0@@13|))
                                :skolemid |2632|
                                :qid |Mapsidfy.110:20|))))
                  (=> (and (= (type Maps._default.IMapRemove1$K@@1) TyType)
                           (= (type Maps._default.IMapRemove1$V@@1) TyType)
                           (= (type $ly@@252) LayerTypeType)
                           (= (type |m#0@@80|) (IMapType BoxType BoxType))
                           (= (type |k#0@@56|) BoxType)
                           a!1)
                      (and a!2
                           a!3
                           ($Is (Maps.__default.IMapRemove1
                                  Maps._default.IMapRemove1$K@@1
                                  Maps._default.IMapRemove1$V@@1
                                  $ly@@252
                                  |m#0@@80|
                                  |k#0@@56|)
                                (TIMap Maps._default.IMapRemove1$K@@1
                                       Maps._default.IMapRemove1$V@@1)))))
                :pattern ((Maps.__default.IMapRemove1
                            Maps._default.IMapRemove1$K@@1
                            Maps._default.IMapRemove1$V@@1
                            $ly@@252
                            |m#0@@80|
                            |k#0@@56|))
                :skolemid |2633|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapRemove1$K@@2 T@U)
         (Maps._default.IMapRemove1$V@@2 T@U)
         ($ly@@253 T@U)
         (|m#0@@81| T@U)
         (|k#0@@57| T@U))
  (! (=> (and (= (type Maps._default.IMapRemove1$K@@2) TyType)
              (= (type Maps._default.IMapRemove1$V@@2) TyType)
              (= (type $ly@@253) LayerTypeType)
              (= (type |m#0@@81|) (IMapType BoxType BoxType))
              (= (type |k#0@@57|) BoxType)
              ($Is |m#0@@81|
                   (TIMap Maps._default.IMapRemove1$K@@2
                          Maps._default.IMapRemove1$V@@2))
              ($IsBox |k#0@@57| Maps._default.IMapRemove1$K@@2))
         (= (|Maps.__default.IMapRemove1#requires|
              Maps._default.IMapRemove1$K@@2
              Maps._default.IMapRemove1$V@@2
              $ly@@253
              |m#0@@81|
              |k#0@@57|)
            true))
     :pattern ((|Maps.__default.IMapRemove1#requires|
                 Maps._default.IMapRemove1$K@@2
                 Maps._default.IMapRemove1$V@@2
                 $ly@@253
                 |m#0@@81|
                 |k#0@@57|))
     :skolemid |2634|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapRemove1$K@@3 T@U)
                    (Maps._default.IMapRemove1$V@@3 T@U)
                    ($ly@@254 T@U)
                    (|m#0@@82| T@U)
                    (|k#0@@58| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRemove1#canCall|
                                 Maps._default.IMapRemove1$K@@3
                                 Maps._default.IMapRemove1$V@@3
                                 |m#0@@82|
                                 |k#0@@58|)
                               (and ($Is |m#0@@82|
                                         (TIMap Maps._default.IMapRemove1$K@@3
                                                Maps._default.IMapRemove1$V@@3))
                                    ($IsBox |k#0@@58|
                                            Maps._default.IMapRemove1$K@@3))))
                      (a!2 (= (Maps.__default.IMapRemove1
                                Maps._default.IMapRemove1$K@@3
                                Maps._default.IMapRemove1$V@@3
                                ($LS $ly@@254)
                                |m#0@@82|
                                |k#0@@58|)
                              (|IMap#Glue| (|lambda#147| Maps._default.IMapRemove1$K@@3
                                                         (|IMap#Domain| |m#0@@82|)
                                                         |k#0@@58|)
                                           (|lambda#148| (|IMap#Elements| |m#0@@82|))
                                           (TIMap Maps._default.IMapRemove1$K@@3
                                                  Maps._default.IMapRemove1$V@@3)))))
                  (=> (and (= (type Maps._default.IMapRemove1$K@@3) TyType)
                           (= (type Maps._default.IMapRemove1$V@@3) TyType)
                           (= (type $ly@@254) LayerTypeType)
                           (= (type |m#0@@82|) (IMapType BoxType BoxType))
                           (= (type |k#0@@58|) BoxType)
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapRemove1
                            Maps._default.IMapRemove1$K@@3
                            Maps._default.IMapRemove1$V@@3
                            ($LS $ly@@254)
                            |m#0@@82|
                            |k#0@@58|))
                :skolemid |2635|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapRemove1$K@@4 T@U)
                    (Maps._default.IMapRemove1$V@@4 T@U)
                    ($ly@@255 T@U)
                    (|m#0@@83| T@U)
                    (|k#0@@59| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRemove1#canCall|
                                 Maps._default.IMapRemove1$K@@4
                                 Maps._default.IMapRemove1$V@@4
                                 (Lit |m#0@@83|)
                                 (Lit |k#0@@59|))
                               (and ($Is |m#0@@83|
                                         (TIMap Maps._default.IMapRemove1$K@@4
                                                Maps._default.IMapRemove1$V@@4))
                                    ($IsBox |k#0@@59|
                                            Maps._default.IMapRemove1$K@@4))))
                      (a!2 (|IMap#Glue| (|lambda#147| Maps._default.IMapRemove1$K@@4
                                                      (|IMap#Domain| |m#0@@83|)
                                                      |k#0@@59|)
                                        (|lambda#148| (|IMap#Elements| (Lit |m#0@@83|)))
                                        (TIMap Maps._default.IMapRemove1$K@@4
                                               Maps._default.IMapRemove1$V@@4))))
                  (=> (and (= (type Maps._default.IMapRemove1$K@@4) TyType)
                           (= (type Maps._default.IMapRemove1$V@@4) TyType)
                           (= (type $ly@@255) LayerTypeType)
                           (= (type |m#0@@83|) (IMapType BoxType BoxType))
                           (= (type |k#0@@59|) BoxType)
                           a!1)
                      (= (Maps.__default.IMapRemove1
                           Maps._default.IMapRemove1$K@@4
                           Maps._default.IMapRemove1$V@@4
                           ($LS $ly@@255)
                           (Lit |m#0@@83|)
                           (Lit |k#0@@59|))
                         a!2)))
                :pattern ((Maps.__default.IMapRemove1
                            Maps._default.IMapRemove1$K@@4
                            Maps._default.IMapRemove1$V@@4
                            ($LS $ly@@255)
                            (Lit |m#0@@83|)
                            (Lit |k#0@@59|)))
                :weight 3
                :skolemid |2636|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@508 T@U) (arg1@@244 T@U) (arg2@@138 T@U) (arg3@@81 T@U))
  (! (= (type (Maps.__default.MapRestrict
                arg0@@508
                arg1@@244
                arg2@@138
                arg3@@81))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapRestrict
                 arg0@@508
                 arg1@@244
                 arg2@@138
                 arg3@@81))
     :qid |funType:Maps.__default.MapRestrict|)))
(assert (let ((a!1 (forall ((Maps._default.MapRestrict$K T@U)
                    (Maps._default.MapRestrict$V T@U)
                    (|m#0@@84| T@U)
                    (|ks#0@@17| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRestrict#canCall|
                                 Maps._default.MapRestrict$K
                                 Maps._default.MapRestrict$V
                                 |m#0@@84|
                                 |ks#0@@17|)
                               (and ($Is |m#0@@84|
                                         (TMap Maps._default.MapRestrict$K
                                               Maps._default.MapRestrict$V))
                                    ($Is |ks#0@@17|
                                         (TSet Maps._default.MapRestrict$K))))))
                  (=> (and (= (type Maps._default.MapRestrict$K) TyType)
                           (= (type Maps._default.MapRestrict$V) TyType)
                           (= (type |m#0@@84|) (MapType BoxType BoxType))
                           (= (type |ks#0@@17|) (MapType0Type BoxType boolType))
                           a!1)
                      ($Is (Maps.__default.MapRestrict
                             Maps._default.MapRestrict$K
                             Maps._default.MapRestrict$V
                             |m#0@@84|
                             |ks#0@@17|)
                           (TMap Maps._default.MapRestrict$K
                                 Maps._default.MapRestrict$V))))
                :pattern ((Maps.__default.MapRestrict
                            Maps._default.MapRestrict$K
                            Maps._default.MapRestrict$V
                            |m#0@@84|
                            |ks#0@@17|))
                :skolemid |2637|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapRestrict$K@@0 T@U)
         (Maps._default.MapRestrict$V@@0 T@U)
         (|m#0@@85| T@U)
         (|ks#0@@18| T@U))
  (! (=> (and (= (type Maps._default.MapRestrict$K@@0) TyType)
              (= (type Maps._default.MapRestrict$V@@0) TyType)
              (= (type |m#0@@85|) (MapType BoxType BoxType))
              (= (type |ks#0@@18|) (MapType0Type BoxType boolType))
              ($Is |m#0@@85|
                   (TMap Maps._default.MapRestrict$K@@0
                         Maps._default.MapRestrict$V@@0))
              ($Is |ks#0@@18| (TSet Maps._default.MapRestrict$K@@0)))
         (= (|Maps.__default.MapRestrict#requires|
              Maps._default.MapRestrict$K@@0
              Maps._default.MapRestrict$V@@0
              |m#0@@85|
              |ks#0@@18|)
            true))
     :pattern ((|Maps.__default.MapRestrict#requires|
                 Maps._default.MapRestrict$K@@0
                 Maps._default.MapRestrict$V@@0
                 |m#0@@85|
                 |ks#0@@18|))
     :skolemid |2638|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@509 T@U) (arg1@@245 T@U) (arg2@@139 T@U))
  (! (= (type (|lambda#169| arg0@@509 arg1@@245 arg2@@139))
        (MapType0Type BoxType boolType))
     :pattern ((|lambda#169| arg0@@509 arg1@@245 arg2@@139))
     :qid |funType:lambda#169|)))
(assert (let ((a!1 (forall ((Maps._default.MapRestrict$K@@1 T@U)
                    (Maps._default.MapRestrict$V@@1 T@U)
                    (|m#0@@86| T@U)
                    (|ks#0@@19| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRestrict#canCall|
                                 Maps._default.MapRestrict$K@@1
                                 Maps._default.MapRestrict$V@@1
                                 |m#0@@86|
                                 |ks#0@@19|)
                               (and ($Is |m#0@@86|
                                         (TMap Maps._default.MapRestrict$K@@1
                                               Maps._default.MapRestrict$V@@1))
                                    ($Is |ks#0@@19|
                                         (TSet Maps._default.MapRestrict$K@@1)))))
                      (a!2 (= (Maps.__default.MapRestrict
                                Maps._default.MapRestrict$K@@1
                                Maps._default.MapRestrict$V@@1
                                |m#0@@86|
                                |ks#0@@19|)
                              (|Map#Glue| (|lambda#169| Maps._default.MapRestrict$K@@1
                                                        |ks#0@@19|
                                                        (|Map#Domain| |m#0@@86|))
                                          (|lambda#148| (|Map#Elements| |m#0@@86|))
                                          (TMap Maps._default.MapRestrict$K@@1
                                                Maps._default.MapRestrict$V@@1)))))
                  (=> (and (= (type Maps._default.MapRestrict$K@@1) TyType)
                           (= (type Maps._default.MapRestrict$V@@1) TyType)
                           (= (type |m#0@@86|) (MapType BoxType BoxType))
                           (= (type |ks#0@@19|) (MapType0Type BoxType boolType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapRestrict
                            Maps._default.MapRestrict$K@@1
                            Maps._default.MapRestrict$V@@1
                            |m#0@@86|
                            |ks#0@@19|))
                :skolemid |2639|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapRestrict$K@@2 T@U)
                    (Maps._default.MapRestrict$V@@2 T@U)
                    (|m#0@@87| T@U)
                    (|ks#0@@20| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapRestrict#canCall|
                                 Maps._default.MapRestrict$K@@2
                                 Maps._default.MapRestrict$V@@2
                                 (Lit |m#0@@87|)
                                 (Lit |ks#0@@20|))
                               (and ($Is |m#0@@87|
                                         (TMap Maps._default.MapRestrict$K@@2
                                               Maps._default.MapRestrict$V@@2))
                                    ($Is |ks#0@@20|
                                         (TSet Maps._default.MapRestrict$K@@2)))))
                      (a!2 (|Map#Glue| (|lambda#169| Maps._default.MapRestrict$K@@2
                                                     (Lit |ks#0@@20|)
                                                     (|Map#Domain| |m#0@@87|))
                                       (|lambda#148| (|Map#Elements| (Lit |m#0@@87|)))
                                       (TMap Maps._default.MapRestrict$K@@2
                                             Maps._default.MapRestrict$V@@2))))
                  (=> (and (= (type Maps._default.MapRestrict$K@@2) TyType)
                           (= (type Maps._default.MapRestrict$V@@2) TyType)
                           (= (type |m#0@@87|) (MapType BoxType BoxType))
                           (= (type |ks#0@@20|) (MapType0Type BoxType boolType))
                           a!1)
                      (= (Maps.__default.MapRestrict
                           Maps._default.MapRestrict$K@@2
                           Maps._default.MapRestrict$V@@2
                           (Lit |m#0@@87|)
                           (Lit |ks#0@@20|))
                         a!2)))
                :pattern ((Maps.__default.MapRestrict
                            Maps._default.MapRestrict$K@@2
                            Maps._default.MapRestrict$V@@2
                            (Lit |m#0@@87|)
                            (Lit |ks#0@@20|)))
                :weight 3
                :skolemid |2640|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@510 T@U) (arg1@@246 T@U) (arg2@@140 T@U) (arg3@@82 T@U))
  (! (= (type (Maps.__default.MapIRestrict
                arg0@@510
                arg1@@246
                arg2@@140
                arg3@@82))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapIRestrict
                 arg0@@510
                 arg1@@246
                 arg2@@140
                 arg3@@82))
     :qid |funType:Maps.__default.MapIRestrict|)))
(assert (let ((a!1 (forall ((Maps._default.MapIRestrict$K T@U)
                    (Maps._default.MapIRestrict$V T@U)
                    (|m#0@@88| T@U)
                    (|ks#0@@21| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapIRestrict#canCall|
                                 Maps._default.MapIRestrict$K
                                 Maps._default.MapIRestrict$V
                                 |m#0@@88|
                                 |ks#0@@21|)
                               (and ($Is |m#0@@88|
                                         (TMap Maps._default.MapIRestrict$K
                                               Maps._default.MapIRestrict$V))
                                    ($Is |ks#0@@21|
                                         (TISet Maps._default.MapIRestrict$K))))))
                  (=> (and (= (type Maps._default.MapIRestrict$K) TyType)
                           (= (type Maps._default.MapIRestrict$V) TyType)
                           (= (type |m#0@@88|) (MapType BoxType BoxType))
                           (= (type |ks#0@@21|) (MapType0Type BoxType boolType))
                           a!1)
                      ($Is (Maps.__default.MapIRestrict
                             Maps._default.MapIRestrict$K
                             Maps._default.MapIRestrict$V
                             |m#0@@88|
                             |ks#0@@21|)
                           (TMap Maps._default.MapIRestrict$K
                                 Maps._default.MapIRestrict$V))))
                :pattern ((Maps.__default.MapIRestrict
                            Maps._default.MapIRestrict$K
                            Maps._default.MapIRestrict$V
                            |m#0@@88|
                            |ks#0@@21|))
                :skolemid |2641|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapIRestrict$K@@0 T@U)
         (Maps._default.MapIRestrict$V@@0 T@U)
         (|m#0@@89| T@U)
         (|ks#0@@22| T@U))
  (! (=> (and (= (type Maps._default.MapIRestrict$K@@0) TyType)
              (= (type Maps._default.MapIRestrict$V@@0) TyType)
              (= (type |m#0@@89|) (MapType BoxType BoxType))
              (= (type |ks#0@@22|) (MapType0Type BoxType boolType))
              ($Is |m#0@@89|
                   (TMap Maps._default.MapIRestrict$K@@0
                         Maps._default.MapIRestrict$V@@0))
              ($Is |ks#0@@22| (TISet Maps._default.MapIRestrict$K@@0)))
         (= (|Maps.__default.MapIRestrict#requires|
              Maps._default.MapIRestrict$K@@0
              Maps._default.MapIRestrict$V@@0
              |m#0@@89|
              |ks#0@@22|)
            true))
     :pattern ((|Maps.__default.MapIRestrict#requires|
                 Maps._default.MapIRestrict$K@@0
                 Maps._default.MapIRestrict$V@@0
                 |m#0@@89|
                 |ks#0@@22|))
     :skolemid |2642|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapIRestrict$K@@1 T@U)
                    (Maps._default.MapIRestrict$V@@1 T@U)
                    (|m#0@@90| T@U)
                    (|ks#0@@23| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapIRestrict#canCall|
                                 Maps._default.MapIRestrict$K@@1
                                 Maps._default.MapIRestrict$V@@1
                                 |m#0@@90|
                                 |ks#0@@23|)
                               (and ($Is |m#0@@90|
                                         (TMap Maps._default.MapIRestrict$K@@1
                                               Maps._default.MapIRestrict$V@@1))
                                    ($Is |ks#0@@23|
                                         (TISet Maps._default.MapIRestrict$K@@1)))))
                      (a!2 (= (Maps.__default.MapIRestrict
                                Maps._default.MapIRestrict$K@@1
                                Maps._default.MapIRestrict$V@@1
                                |m#0@@90|
                                |ks#0@@23|)
                              (|Map#Glue| (|lambda#169| Maps._default.MapIRestrict$K@@1
                                                        (|Map#Domain| |m#0@@90|)
                                                        |ks#0@@23|)
                                          (|lambda#148| (|Map#Elements| |m#0@@90|))
                                          (TMap Maps._default.MapIRestrict$K@@1
                                                Maps._default.MapIRestrict$V@@1)))))
                  (=> (and (= (type Maps._default.MapIRestrict$K@@1) TyType)
                           (= (type Maps._default.MapIRestrict$V@@1) TyType)
                           (= (type |m#0@@90|) (MapType BoxType BoxType))
                           (= (type |ks#0@@23|) (MapType0Type BoxType boolType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapIRestrict
                            Maps._default.MapIRestrict$K@@1
                            Maps._default.MapIRestrict$V@@1
                            |m#0@@90|
                            |ks#0@@23|))
                :skolemid |2643|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapIRestrict$K@@2 T@U)
                    (Maps._default.MapIRestrict$V@@2 T@U)
                    (|m#0@@91| T@U)
                    (|ks#0@@24| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapIRestrict#canCall|
                                 Maps._default.MapIRestrict$K@@2
                                 Maps._default.MapIRestrict$V@@2
                                 (Lit |m#0@@91|)
                                 |ks#0@@24|)
                               (and ($Is |m#0@@91|
                                         (TMap Maps._default.MapIRestrict$K@@2
                                               Maps._default.MapIRestrict$V@@2))
                                    ($Is |ks#0@@24|
                                         (TISet Maps._default.MapIRestrict$K@@2)))))
                      (a!2 (|Map#Glue| (|lambda#169| Maps._default.MapIRestrict$K@@2
                                                     (|Map#Domain| |m#0@@91|)
                                                     |ks#0@@24|)
                                       (|lambda#148| (|Map#Elements| (Lit |m#0@@91|)))
                                       (TMap Maps._default.MapIRestrict$K@@2
                                             Maps._default.MapIRestrict$V@@2))))
                  (=> (and (= (type Maps._default.MapIRestrict$K@@2) TyType)
                           (= (type Maps._default.MapIRestrict$V@@2) TyType)
                           (= (type |m#0@@91|) (MapType BoxType BoxType))
                           (= (type |ks#0@@24|) (MapType0Type BoxType boolType))
                           a!1)
                      (= (Maps.__default.MapIRestrict
                           Maps._default.MapIRestrict$K@@2
                           Maps._default.MapIRestrict$V@@2
                           (Lit |m#0@@91|)
                           |ks#0@@24|)
                         a!2)))
                :pattern ((Maps.__default.MapIRestrict
                            Maps._default.MapIRestrict$K@@2
                            Maps._default.MapIRestrict$V@@2
                            (Lit |m#0@@91|)
                            |ks#0@@24|))
                :weight 3
                :skolemid |2644|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapIRestrict$K@@3 T@U)
                    (Maps._default.MapIRestrict$V@@3 T@U)
                    (|m#0@@92| T@U)
                    (|ks#0@@25| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapIRestrict#canCall|
                                 Maps._default.MapIRestrict$K@@3
                                 Maps._default.MapIRestrict$V@@3
                                 (Lit |m#0@@92|)
                                 (Lit |ks#0@@25|))
                               (and ($Is |m#0@@92|
                                         (TMap Maps._default.MapIRestrict$K@@3
                                               Maps._default.MapIRestrict$V@@3))
                                    ($Is |ks#0@@25|
                                         (TISet Maps._default.MapIRestrict$K@@3)))))
                      (a!2 (|Map#Glue| (|lambda#169| Maps._default.MapIRestrict$K@@3
                                                     (|Map#Domain| |m#0@@92|)
                                                     (Lit |ks#0@@25|))
                                       (|lambda#148| (|Map#Elements| (Lit |m#0@@92|)))
                                       (TMap Maps._default.MapIRestrict$K@@3
                                             Maps._default.MapIRestrict$V@@3))))
                  (=> (and (= (type Maps._default.MapIRestrict$K@@3) TyType)
                           (= (type Maps._default.MapIRestrict$V@@3) TyType)
                           (= (type |m#0@@92|) (MapType BoxType BoxType))
                           (= (type |ks#0@@25|) (MapType0Type BoxType boolType))
                           a!1)
                      (= (Maps.__default.MapIRestrict
                           Maps._default.MapIRestrict$K@@3
                           Maps._default.MapIRestrict$V@@3
                           (Lit |m#0@@92|)
                           (Lit |ks#0@@25|))
                         a!2)))
                :pattern ((Maps.__default.MapIRestrict
                            Maps._default.MapIRestrict$K@@3
                            Maps._default.MapIRestrict$V@@3
                            (Lit |m#0@@92|)
                            (Lit |ks#0@@25|)))
                :weight 3
                :skolemid |2645|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@511 T@U) (arg1@@247 T@U) (arg2@@141 T@U) (arg3@@83 T@U))
  (! (= (type (Maps.__default.IMapRestrict
                arg0@@511
                arg1@@247
                arg2@@141
                arg3@@83))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.IMapRestrict
                 arg0@@511
                 arg1@@247
                 arg2@@141
                 arg3@@83))
     :qid |funType:Maps.__default.IMapRestrict|)))
(assert (let ((a!1 (forall ((Maps._default.IMapRestrict$K T@U)
                    (Maps._default.IMapRestrict$V T@U)
                    (|m#0@@93| T@U)
                    (|ks#0@@26| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRestrict#canCall|
                                 Maps._default.IMapRestrict$K
                                 Maps._default.IMapRestrict$V
                                 |m#0@@93|
                                 |ks#0@@26|)
                               (and ($Is |m#0@@93|
                                         (TIMap Maps._default.IMapRestrict$K
                                                Maps._default.IMapRestrict$V))
                                    ($Is |ks#0@@26|
                                         (TISet Maps._default.IMapRestrict$K))))))
                  (=> (and (= (type Maps._default.IMapRestrict$K) TyType)
                           (= (type Maps._default.IMapRestrict$V) TyType)
                           (= (type |m#0@@93|) (IMapType BoxType BoxType))
                           (= (type |ks#0@@26|) (MapType0Type BoxType boolType))
                           a!1)
                      ($Is (Maps.__default.IMapRestrict
                             Maps._default.IMapRestrict$K
                             Maps._default.IMapRestrict$V
                             |m#0@@93|
                             |ks#0@@26|)
                           (TIMap Maps._default.IMapRestrict$K
                                  Maps._default.IMapRestrict$V))))
                :pattern ((Maps.__default.IMapRestrict
                            Maps._default.IMapRestrict$K
                            Maps._default.IMapRestrict$V
                            |m#0@@93|
                            |ks#0@@26|))
                :skolemid |2646|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapRestrict$K@@0 T@U)
         (Maps._default.IMapRestrict$V@@0 T@U)
         (|m#0@@94| T@U)
         (|ks#0@@27| T@U))
  (! (=> (and (= (type Maps._default.IMapRestrict$K@@0) TyType)
              (= (type Maps._default.IMapRestrict$V@@0) TyType)
              (= (type |m#0@@94|) (IMapType BoxType BoxType))
              (= (type |ks#0@@27|) (MapType0Type BoxType boolType))
              ($Is |m#0@@94|
                   (TIMap Maps._default.IMapRestrict$K@@0
                          Maps._default.IMapRestrict$V@@0))
              ($Is |ks#0@@27| (TISet Maps._default.IMapRestrict$K@@0)))
         (= (|Maps.__default.IMapRestrict#requires|
              Maps._default.IMapRestrict$K@@0
              Maps._default.IMapRestrict$V@@0
              |m#0@@94|
              |ks#0@@27|)
            true))
     :pattern ((|Maps.__default.IMapRestrict#requires|
                 Maps._default.IMapRestrict$K@@0
                 Maps._default.IMapRestrict$V@@0
                 |m#0@@94|
                 |ks#0@@27|))
     :skolemid |2647|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapRestrict$K@@1 T@U)
                    (Maps._default.IMapRestrict$V@@1 T@U)
                    (|m#0@@95| T@U)
                    (|ks#0@@28| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRestrict#canCall|
                                 Maps._default.IMapRestrict$K@@1
                                 Maps._default.IMapRestrict$V@@1
                                 |m#0@@95|
                                 |ks#0@@28|)
                               (and ($Is |m#0@@95|
                                         (TIMap Maps._default.IMapRestrict$K@@1
                                                Maps._default.IMapRestrict$V@@1))
                                    ($Is |ks#0@@28|
                                         (TISet Maps._default.IMapRestrict$K@@1)))))
                      (a!2 (= (Maps.__default.IMapRestrict
                                Maps._default.IMapRestrict$K@@1
                                Maps._default.IMapRestrict$V@@1
                                |m#0@@95|
                                |ks#0@@28|)
                              (|IMap#Glue| (|lambda#169| Maps._default.IMapRestrict$K@@1
                                                         |ks#0@@28|
                                                         (|IMap#Domain| |m#0@@95|))
                                           (|lambda#148| (|IMap#Elements| |m#0@@95|))
                                           (TIMap Maps._default.IMapRestrict$K@@1
                                                  Maps._default.IMapRestrict$V@@1)))))
                  (=> (and (= (type Maps._default.IMapRestrict$K@@1) TyType)
                           (= (type Maps._default.IMapRestrict$V@@1) TyType)
                           (= (type |m#0@@95|) (IMapType BoxType BoxType))
                           (= (type |ks#0@@28|) (MapType0Type BoxType boolType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapRestrict
                            Maps._default.IMapRestrict$K@@1
                            Maps._default.IMapRestrict$V@@1
                            |m#0@@95|
                            |ks#0@@28|))
                :skolemid |2648|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapRestrict$K@@2 T@U)
                    (Maps._default.IMapRestrict$V@@2 T@U)
                    (|m#0@@96| T@U)
                    (|ks#0@@29| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapRestrict#canCall|
                                 Maps._default.IMapRestrict$K@@2
                                 Maps._default.IMapRestrict$V@@2
                                 (Lit |m#0@@96|)
                                 (Lit |ks#0@@29|))
                               (and ($Is |m#0@@96|
                                         (TIMap Maps._default.IMapRestrict$K@@2
                                                Maps._default.IMapRestrict$V@@2))
                                    ($Is |ks#0@@29|
                                         (TISet Maps._default.IMapRestrict$K@@2)))))
                      (a!2 (|IMap#Glue| (|lambda#169| Maps._default.IMapRestrict$K@@2
                                                      (Lit |ks#0@@29|)
                                                      (|IMap#Domain| |m#0@@96|))
                                        (|lambda#148| (|IMap#Elements| (Lit |m#0@@96|)))
                                        (TIMap Maps._default.IMapRestrict$K@@2
                                               Maps._default.IMapRestrict$V@@2))))
                  (=> (and (= (type Maps._default.IMapRestrict$K@@2) TyType)
                           (= (type Maps._default.IMapRestrict$V@@2) TyType)
                           (= (type |m#0@@96|) (IMapType BoxType BoxType))
                           (= (type |ks#0@@29|) (MapType0Type BoxType boolType))
                           a!1)
                      (= (Maps.__default.IMapRestrict
                           Maps._default.IMapRestrict$K@@2
                           Maps._default.IMapRestrict$V@@2
                           (Lit |m#0@@96|)
                           (Lit |ks#0@@29|))
                         a!2)))
                :pattern ((Maps.__default.IMapRestrict
                            Maps._default.IMapRestrict$K@@2
                            Maps._default.IMapRestrict$V@@2
                            (Lit |m#0@@96|)
                            (Lit |ks#0@@29|)))
                :weight 3
                :skolemid |2649|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@512 T@U)
         (arg1@@248 T@U)
         (arg2@@142 T@U)
         (arg3@@84 T@U)
         (arg4@@49 T@U))
  (! (= (type (Maps.__default.MapDisjointUnion
                arg0@@512
                arg1@@248
                arg2@@142
                arg3@@84
                arg4@@49))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapDisjointUnion
                 arg0@@512
                 arg1@@248
                 arg2@@142
                 arg3@@84
                 arg4@@49))
     :qid |funType:Maps.__default.MapDisjointUnion|)))
(assert (forall ((Maps._default.MapDisjointUnion$U T@U)
         (Maps._default.MapDisjointUnion$T T@U)
         ($ly@@256 T@U)
         (|mapa#0| T@U)
         (|mapb#0| T@U))
  (! (=> (and (= (type Maps._default.MapDisjointUnion$U) TyType)
              (= (type Maps._default.MapDisjointUnion$T) TyType)
              (= (type $ly@@256) LayerTypeType)
              (= (type |mapa#0|) (MapType BoxType BoxType))
              (= (type |mapb#0|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapDisjointUnion
              Maps._default.MapDisjointUnion$U
              Maps._default.MapDisjointUnion$T
              ($LS $ly@@256)
              |mapa#0|
              |mapb#0|)
            (Maps.__default.MapDisjointUnion
              Maps._default.MapDisjointUnion$U
              Maps._default.MapDisjointUnion$T
              $ly@@256
              |mapa#0|
              |mapb#0|)))
     :pattern ((Maps.__default.MapDisjointUnion
                 Maps._default.MapDisjointUnion$U
                 Maps._default.MapDisjointUnion$T
                 ($LS $ly@@256)
                 |mapa#0|
                 |mapb#0|))
     :skolemid |2650|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapDisjointUnion$U@@0 T@U)
         (Maps._default.MapDisjointUnion$T@@0 T@U)
         ($ly@@257 T@U)
         (|mapa#0@@0| T@U)
         (|mapb#0@@0| T@U))
  (! (=> (and (= (type Maps._default.MapDisjointUnion$U@@0) TyType)
              (= (type Maps._default.MapDisjointUnion$T@@0) TyType)
              (= (type $ly@@257) LayerTypeType)
              (= (type |mapa#0@@0|) (MapType BoxType BoxType))
              (= (type |mapb#0@@0|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapDisjointUnion
              Maps._default.MapDisjointUnion$U@@0
              Maps._default.MapDisjointUnion$T@@0
              $ly@@257
              |mapa#0@@0|
              |mapb#0@@0|)
            (Maps.__default.MapDisjointUnion
              Maps._default.MapDisjointUnion$U@@0
              Maps._default.MapDisjointUnion$T@@0
              $LZ
              |mapa#0@@0|
              |mapb#0@@0|)))
     :pattern ((Maps.__default.MapDisjointUnion
                 Maps._default.MapDisjointUnion$U@@0
                 Maps._default.MapDisjointUnion$T@@0
                 (AsFuelBottom $ly@@257)
                 |mapa#0@@0|
                 |mapb#0@@0|))
     :skolemid |2651|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapDisjointUnion$U@@1 T@U)
                    (Maps._default.MapDisjointUnion$T@@1 T@U)
                    ($ly@@258 T@U)
                    (|mapa#0@@1| T@U)
                    (|mapb#0@@1| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapDisjointUnion#canCall|
                                 Maps._default.MapDisjointUnion$U@@1
                                 Maps._default.MapDisjointUnion$T@@1
                                 |mapa#0@@1|
                                 |mapb#0@@1|)
                               (and ($Is |mapa#0@@1|
                                         (TMap Maps._default.MapDisjointUnion$U@@1
                                               Maps._default.MapDisjointUnion$T@@1))
                                    ($Is |mapb#0@@1|
                                         (TMap Maps._default.MapDisjointUnion$U@@1
                                               Maps._default.MapDisjointUnion$T@@1))
                                    (|Set#Disjoint| (|Map#Domain| |mapa#0@@1|)
                                                    (|Map#Domain| |mapb#0@@1|)))))
                      (a!2 (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion
                                                             Maps._default.MapDisjointUnion$U@@1
                                                             Maps._default.MapDisjointUnion$T@@1
                                                             $ly@@258
                                                             |mapa#0@@1|
                                                             |mapb#0@@1|))
                                             (|Set#Union| (|Map#Domain| |mapa#0@@1|)
                                                          (|Map#Domain| |mapb#0@@1|)))
                                (forall ((|k#0@@60| T@U))
                                  (! (let ((a!1 (and (and (= (type |k#0@@60|)
                                                             BoxType)
                                                          ($IsBox |k#0@@60|
                                                                  Maps._default.MapDisjointUnion$U@@1))
                                                     (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@1|)
                                                                               |k#0@@60|))))
                                           (a!2 (= (MapType0Select (|Map#Elements| |mapa#0@@1|)
                                                                   |k#0@@60|)
                                                   (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion
                                                                                     Maps._default.MapDisjointUnion$U@@1
                                                                                     Maps._default.MapDisjointUnion$T@@1
                                                                                     $ly@@258
                                                                                     |mapa#0@@1|
                                                                                     |mapb#0@@1|))
                                                                   |k#0@@60|))))
                                       (=> a!1 a!2))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion
                                                                                 Maps._default.MapDisjointUnion$U@@1
                                                                                 Maps._default.MapDisjointUnion$T@@1
                                                                                 $ly@@258
                                                                                 |mapa#0@@1|
                                                                                 |mapb#0@@1|))
                                                               |k#0@@60|))
                                     :pattern ((MapType0Select (|Map#Elements| |mapa#0@@1|)
                                                               |k#0@@60|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapa#0@@1|)
                                                               |k#0@@60|))
                                     :skolemid |2652|
                                     :qid |Mapsidfy.131:18|))
                                (forall ((|k#1@@2| T@U))
                                  (! (let ((a!1 (and (and (= (type |k#1@@2|)
                                                             BoxType)
                                                          ($IsBox |k#1@@2|
                                                                  Maps._default.MapDisjointUnion$U@@1))
                                                     (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@1|)
                                                                               |k#1@@2|))))
                                           (a!2 (= (MapType0Select (|Map#Elements| |mapb#0@@1|)
                                                                   |k#1@@2|)
                                                   (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion
                                                                                     Maps._default.MapDisjointUnion$U@@1
                                                                                     Maps._default.MapDisjointUnion$T@@1
                                                                                     $ly@@258
                                                                                     |mapa#0@@1|
                                                                                     |mapb#0@@1|))
                                                                   |k#1@@2|))))
                                       (=> a!1 a!2))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion
                                                                                 Maps._default.MapDisjointUnion$U@@1
                                                                                 Maps._default.MapDisjointUnion$T@@1
                                                                                 $ly@@258
                                                                                 |mapa#0@@1|
                                                                                 |mapb#0@@1|))
                                                               |k#1@@2|))
                                     :pattern ((MapType0Select (|Map#Elements| |mapb#0@@1|)
                                                               |k#1@@2|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapb#0@@1|)
                                                               |k#1@@2|))
                                     :skolemid |2653|
                                     :qid |Mapsidfy.132:18|))
                                ($Is (Maps.__default.MapDisjointUnion
                                       Maps._default.MapDisjointUnion$U@@1
                                       Maps._default.MapDisjointUnion$T@@1
                                       $ly@@258
                                       |mapa#0@@1|
                                       |mapb#0@@1|)
                                     (TMap Maps._default.MapDisjointUnion$U@@1
                                           Maps._default.MapDisjointUnion$T@@1)))))
                  (=> (and (= (type Maps._default.MapDisjointUnion$U@@1) TyType)
                           (= (type Maps._default.MapDisjointUnion$T@@1) TyType)
                           (= (type $ly@@258) LayerTypeType)
                           (= (type |mapa#0@@1|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@1|) (MapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapDisjointUnion
                            Maps._default.MapDisjointUnion$U@@1
                            Maps._default.MapDisjointUnion$T@@1
                            $ly@@258
                            |mapa#0@@1|
                            |mapb#0@@1|))
                :skolemid |2654|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapDisjointUnion$U@@2 T@U)
         (Maps._default.MapDisjointUnion$T@@2 T@U)
         ($ly@@259 T@U)
         (|mapa#0@@2| T@U)
         (|mapb#0@@2| T@U))
  (! (=> (and (= (type Maps._default.MapDisjointUnion$U@@2) TyType)
              (= (type Maps._default.MapDisjointUnion$T@@2) TyType)
              (= (type $ly@@259) LayerTypeType)
              (= (type |mapa#0@@2|) (MapType BoxType BoxType))
              (= (type |mapb#0@@2|) (MapType BoxType BoxType))
              ($Is |mapa#0@@2|
                   (TMap Maps._default.MapDisjointUnion$U@@2
                         Maps._default.MapDisjointUnion$T@@2))
              ($Is |mapb#0@@2|
                   (TMap Maps._default.MapDisjointUnion$U@@2
                         Maps._default.MapDisjointUnion$T@@2)))
         (= (|Maps.__default.MapDisjointUnion#requires|
              Maps._default.MapDisjointUnion$U@@2
              Maps._default.MapDisjointUnion$T@@2
              $ly@@259
              |mapa#0@@2|
              |mapb#0@@2|)
            (|Set#Disjoint| (|Map#Domain| |mapa#0@@2|)
                            (|Map#Domain| |mapb#0@@2|))))
     :pattern ((|Maps.__default.MapDisjointUnion#requires|
                 Maps._default.MapDisjointUnion$U@@2
                 Maps._default.MapDisjointUnion$T@@2
                 $ly@@259
                 |mapa#0@@2|
                 |mapb#0@@2|))
     :skolemid |2655|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@513 T@U) (arg1@@249 T@U) (arg2@@143 T@U))
  (! (= (type (|lambda#184| arg0@@513 arg1@@249 arg2@@143))
        (MapType0Type BoxType BoxType))
     :pattern ((|lambda#184| arg0@@513 arg1@@249 arg2@@143))
     :qid |funType:lambda#184|)))
(assert (let ((a!1 (forall ((Maps._default.MapDisjointUnion$U@@3 T@U)
                    (Maps._default.MapDisjointUnion$T@@3 T@U)
                    ($ly@@260 T@U)
                    (|mapa#0@@3| T@U)
                    (|mapb#0@@3| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapDisjointUnion#canCall|
                                 Maps._default.MapDisjointUnion$U@@3
                                 Maps._default.MapDisjointUnion$T@@3
                                 |mapa#0@@3|
                                 |mapb#0@@3|)
                               (and ($Is |mapa#0@@3|
                                         (TMap Maps._default.MapDisjointUnion$U@@3
                                               Maps._default.MapDisjointUnion$T@@3))
                                    ($Is |mapb#0@@3|
                                         (TMap Maps._default.MapDisjointUnion$U@@3
                                               Maps._default.MapDisjointUnion$T@@3))
                                    (|Set#Disjoint| (|Map#Domain| |mapa#0@@3|)
                                                    (|Map#Domain| |mapb#0@@3|)))))
                      (a!2 (|Map#Glue| (|lambda#106| Maps._default.MapDisjointUnion$U@@3
                                                     (|Set#Union| (|Map#Domain| |mapa#0@@3|)
                                                                  (|Map#Domain| |mapb#0@@3|)))
                                       (|lambda#184| (|Map#Domain| |mapa#0@@3|)
                                                     (|Map#Elements| |mapa#0@@3|)
                                                     (|Map#Elements| |mapb#0@@3|))
                                       (TMap Maps._default.MapDisjointUnion$U@@3
                                             Maps._default.MapDisjointUnion$T@@3))))
                  (=> (and (= (type Maps._default.MapDisjointUnion$U@@3) TyType)
                           (= (type Maps._default.MapDisjointUnion$T@@3) TyType)
                           (= (type $ly@@260) LayerTypeType)
                           (= (type |mapa#0@@3|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@3|) (MapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.MapDisjointUnion
                           Maps._default.MapDisjointUnion$U@@3
                           Maps._default.MapDisjointUnion$T@@3
                           ($LS $ly@@260)
                           |mapa#0@@3|
                           |mapb#0@@3|)
                         a!2)))
                :pattern ((Maps.__default.MapDisjointUnion
                            Maps._default.MapDisjointUnion$U@@3
                            Maps._default.MapDisjointUnion$T@@3
                            ($LS $ly@@260)
                            |mapa#0@@3|
                            |mapb#0@@3|))
                :skolemid |2656|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapDisjointUnion$U@@4 T@U)
                    (Maps._default.MapDisjointUnion$T@@4 T@U)
                    ($ly@@261 T@U)
                    (|mapa#0@@4| T@U)
                    (|mapb#0@@4| T@U))
             (! (let ((a!1 (and ($Is |mapa#0@@4|
                                     (TMap Maps._default.MapDisjointUnion$U@@4
                                           Maps._default.MapDisjointUnion$T@@4))
                                ($Is |mapb#0@@4|
                                     (TMap Maps._default.MapDisjointUnion$U@@4
                                           Maps._default.MapDisjointUnion$T@@4))
                                (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@4|))
                                                (|Map#Domain| (Lit |mapb#0@@4|)))))
                      (a!3 (|lambda#106| Maps._default.MapDisjointUnion$U@@4
                                         (|Set#Union| (|Map#Domain| (Lit |mapa#0@@4|))
                                                      (|Map#Domain| (Lit |mapb#0@@4|))))))
                (let ((a!2 (and (= (type Maps._default.MapDisjointUnion$U@@4)
                                   TyType)
                                (= (type Maps._default.MapDisjointUnion$T@@4)
                                   TyType)
                                (= (type $ly@@261) LayerTypeType)
                                (= (type |mapa#0@@4|) (MapType BoxType BoxType))
                                (= (type |mapb#0@@4|) (MapType BoxType BoxType))
                                (or (|Maps.__default.MapDisjointUnion#canCall|
                                      Maps._default.MapDisjointUnion$U@@4
                                      Maps._default.MapDisjointUnion$T@@4
                                      (Lit |mapa#0@@4|)
                                      (Lit |mapb#0@@4|))
                                    a!1)))
                      (a!4 (|Map#Glue| a!3
                                       (|lambda#184| (|Map#Domain| |mapa#0@@4|)
                                                     (|Map#Elements| (Lit |mapa#0@@4|))
                                                     (|Map#Elements| (Lit |mapb#0@@4|)))
                                       (TMap Maps._default.MapDisjointUnion$U@@4
                                             Maps._default.MapDisjointUnion$T@@4))))
                  (=> a!2
                      (= (Maps.__default.MapDisjointUnion
                           Maps._default.MapDisjointUnion$U@@4
                           Maps._default.MapDisjointUnion$T@@4
                           ($LS $ly@@261)
                           (Lit |mapa#0@@4|)
                           (Lit |mapb#0@@4|))
                         a!4))))
                :pattern ((Maps.__default.MapDisjointUnion
                            Maps._default.MapDisjointUnion$U@@4
                            Maps._default.MapDisjointUnion$T@@4
                            ($LS $ly@@261)
                            (Lit |mapa#0@@4|)
                            (Lit |mapb#0@@4|)))
                :weight 3
                :skolemid |2657|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@514 T@U)
         (arg1@@250 T@U)
         (arg2@@144 T@U)
         (arg3@@85 T@U)
         (arg4@@50 T@U))
  (! (= (type (Maps.__default.MapUnionPreferA
                arg0@@514
                arg1@@250
                arg2@@144
                arg3@@85
                arg4@@50))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapUnionPreferA
                 arg0@@514
                 arg1@@250
                 arg2@@144
                 arg3@@85
                 arg4@@50))
     :qid |funType:Maps.__default.MapUnionPreferA|)))
(assert (forall ((Maps._default.MapUnionPreferA$U T@U)
         (Maps._default.MapUnionPreferA$T T@U)
         ($ly@@262 T@U)
         (|mapa#0@@5| T@U)
         (|mapb#0@@5| T@U))
  (! (=> (and (= (type Maps._default.MapUnionPreferA$U) TyType)
              (= (type Maps._default.MapUnionPreferA$T) TyType)
              (= (type $ly@@262) LayerTypeType)
              (= (type |mapa#0@@5|) (MapType BoxType BoxType))
              (= (type |mapb#0@@5|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapUnionPreferA
              Maps._default.MapUnionPreferA$U
              Maps._default.MapUnionPreferA$T
              ($LS $ly@@262)
              |mapa#0@@5|
              |mapb#0@@5|)
            (Maps.__default.MapUnionPreferA
              Maps._default.MapUnionPreferA$U
              Maps._default.MapUnionPreferA$T
              $ly@@262
              |mapa#0@@5|
              |mapb#0@@5|)))
     :pattern ((Maps.__default.MapUnionPreferA
                 Maps._default.MapUnionPreferA$U
                 Maps._default.MapUnionPreferA$T
                 ($LS $ly@@262)
                 |mapa#0@@5|
                 |mapb#0@@5|))
     :skolemid |2658|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapUnionPreferA$U@@0 T@U)
         (Maps._default.MapUnionPreferA$T@@0 T@U)
         ($ly@@263 T@U)
         (|mapa#0@@6| T@U)
         (|mapb#0@@6| T@U))
  (! (=> (and (= (type Maps._default.MapUnionPreferA$U@@0) TyType)
              (= (type Maps._default.MapUnionPreferA$T@@0) TyType)
              (= (type $ly@@263) LayerTypeType)
              (= (type |mapa#0@@6|) (MapType BoxType BoxType))
              (= (type |mapb#0@@6|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapUnionPreferA
              Maps._default.MapUnionPreferA$U@@0
              Maps._default.MapUnionPreferA$T@@0
              $ly@@263
              |mapa#0@@6|
              |mapb#0@@6|)
            (Maps.__default.MapUnionPreferA
              Maps._default.MapUnionPreferA$U@@0
              Maps._default.MapUnionPreferA$T@@0
              $LZ
              |mapa#0@@6|
              |mapb#0@@6|)))
     :pattern ((Maps.__default.MapUnionPreferA
                 Maps._default.MapUnionPreferA$U@@0
                 Maps._default.MapUnionPreferA$T@@0
                 (AsFuelBottom $ly@@263)
                 |mapa#0@@6|
                 |mapb#0@@6|))
     :skolemid |2659|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapUnionPreferA$U@@1 T@U)
                    (Maps._default.MapUnionPreferA$T@@1 T@U)
                    ($ly@@264 T@U)
                    (|mapa#0@@7| T@U)
                    (|mapb#0@@7| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnionPreferA#canCall|
                                 Maps._default.MapUnionPreferA$U@@1
                                 Maps._default.MapUnionPreferA$T@@1
                                 |mapa#0@@7|
                                 |mapb#0@@7|)
                               (and ($Is |mapa#0@@7|
                                         (TMap Maps._default.MapUnionPreferA$U@@1
                                               Maps._default.MapUnionPreferA$T@@1))
                                    ($Is |mapb#0@@7|
                                         (TMap Maps._default.MapUnionPreferA$U@@1
                                               Maps._default.MapUnionPreferA$T@@1)))))
                      (a!2 (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnionPreferA
                                                             Maps._default.MapUnionPreferA$U@@1
                                                             Maps._default.MapUnionPreferA$T@@1
                                                             $ly@@264
                                                             |mapa#0@@7|
                                                             |mapb#0@@7|))
                                             (|Set#Union| (|Map#Domain| |mapa#0@@7|)
                                                          (|Map#Domain| |mapb#0@@7|)))
                                (forall ((|k#0@@61| T@U))
                                  (! (let ((a!1 (and (and (= (type |k#0@@61|)
                                                             BoxType)
                                                          ($IsBox |k#0@@61|
                                                                  Maps._default.MapUnionPreferA$U@@1))
                                                     (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@7|)
                                                                               |k#0@@61|))))
                                           (a!2 (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA
                                                                                     Maps._default.MapUnionPreferA$U@@1
                                                                                     Maps._default.MapUnionPreferA$T@@1
                                                                                     $ly@@264
                                                                                     |mapa#0@@7|
                                                                                     |mapb#0@@7|))
                                                                   |k#0@@61|)
                                                   (MapType0Select (|Map#Elements| |mapa#0@@7|)
                                                                   |k#0@@61|))))
                                       (=> a!1 a!2))
                                     :pattern ((MapType0Select (|Map#Elements| |mapa#0@@7|)
                                                               |k#0@@61|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA
                                                                                 Maps._default.MapUnionPreferA$U@@1
                                                                                 Maps._default.MapUnionPreferA$T@@1
                                                                                 $ly@@264
                                                                                 |mapa#0@@7|
                                                                                 |mapb#0@@7|))
                                                               |k#0@@61|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapa#0@@7|)
                                                               |k#0@@61|))
                                     :skolemid |2660|
                                     :qid |Mapsidfy.141:20|))
                                (forall ((|k#1@@3| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@7|)
                                                                                            (|Map#Domain| |mapa#0@@7|))
                                                                          |k#1@@3|)))
                                           (a!3 (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA
                                                                                     Maps._default.MapUnionPreferA$U@@1
                                                                                     Maps._default.MapUnionPreferA$T@@1
                                                                                     $ly@@264
                                                                                     |mapa#0@@7|
                                                                                     |mapb#0@@7|))
                                                                   |k#1@@3|)
                                                   (MapType0Select (|Map#Elements| |mapb#0@@7|)
                                                                   |k#1@@3|))))
                                     (let ((a!2 (and (and (= (type |k#1@@3|)
                                                             BoxType)
                                                          ($IsBox |k#1@@3|
                                                                  Maps._default.MapUnionPreferA$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|Map#Elements| |mapb#0@@7|)
                                                               |k#1@@3|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA
                                                                                 Maps._default.MapUnionPreferA$U@@1
                                                                                 Maps._default.MapUnionPreferA$T@@1
                                                                                 $ly@@264
                                                                                 |mapa#0@@7|
                                                                                 |mapb#0@@7|))
                                                               |k#1@@3|))
                                     :pattern ((MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@7|)
                                                                                 (|Map#Domain| |mapa#0@@7|))
                                                               |k#1@@3|))
                                     :skolemid |2661|
                                     :qid |Mapsidfy.142:20|))
                                (forall ((|k#2| T@U))
                                  (! (let ((a!1 (not (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@7|)
                                                                               |k#2|))))
                                           (a!3 (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA
                                                                                     Maps._default.MapUnionPreferA$U@@1
                                                                                     Maps._default.MapUnionPreferA$T@@1
                                                                                     $ly@@264
                                                                                     |mapa#0@@7|
                                                                                     |mapb#0@@7|))
                                                                   |k#2|)
                                                   (MapType0Select (|Map#Elements| |mapa#0@@7|)
                                                                   |k#2|))))
                                     (let ((a!2 (and (and (= (type |k#2|)
                                                             BoxType)
                                                          ($IsBox |k#2|
                                                                  Maps._default.MapUnionPreferA$U@@1))
                                                     (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@7|)
                                                                               |k#2|))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|Map#Elements| |mapa#0@@7|)
                                                               |k#2|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA
                                                                                 Maps._default.MapUnionPreferA$U@@1
                                                                                 Maps._default.MapUnionPreferA$T@@1
                                                                                 $ly@@264
                                                                                 |mapa#0@@7|
                                                                                 |mapb#0@@7|))
                                                               |k#2|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapb#0@@7|)
                                                               |k#2|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapa#0@@7|)
                                                               |k#2|))
                                     :skolemid |2662|
                                     :qid |Mapsidfy.143:20|))
                                ($Is (Maps.__default.MapUnionPreferA
                                       Maps._default.MapUnionPreferA$U@@1
                                       Maps._default.MapUnionPreferA$T@@1
                                       $ly@@264
                                       |mapa#0@@7|
                                       |mapb#0@@7|)
                                     (TMap Maps._default.MapUnionPreferA$U@@1
                                           Maps._default.MapUnionPreferA$T@@1)))))
                  (=> (and (= (type Maps._default.MapUnionPreferA$U@@1) TyType)
                           (= (type Maps._default.MapUnionPreferA$T@@1) TyType)
                           (= (type $ly@@264) LayerTypeType)
                           (= (type |mapa#0@@7|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@7|) (MapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapUnionPreferA
                            Maps._default.MapUnionPreferA$U@@1
                            Maps._default.MapUnionPreferA$T@@1
                            $ly@@264
                            |mapa#0@@7|
                            |mapb#0@@7|))
                :skolemid |2663|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapUnionPreferA$U@@2 T@U)
         (Maps._default.MapUnionPreferA$T@@2 T@U)
         ($ly@@265 T@U)
         (|mapa#0@@8| T@U)
         (|mapb#0@@8| T@U))
  (! (=> (and (= (type Maps._default.MapUnionPreferA$U@@2) TyType)
              (= (type Maps._default.MapUnionPreferA$T@@2) TyType)
              (= (type $ly@@265) LayerTypeType)
              (= (type |mapa#0@@8|) (MapType BoxType BoxType))
              (= (type |mapb#0@@8|) (MapType BoxType BoxType))
              ($Is |mapa#0@@8|
                   (TMap Maps._default.MapUnionPreferA$U@@2
                         Maps._default.MapUnionPreferA$T@@2))
              ($Is |mapb#0@@8|
                   (TMap Maps._default.MapUnionPreferA$U@@2
                         Maps._default.MapUnionPreferA$T@@2)))
         (= (|Maps.__default.MapUnionPreferA#requires|
              Maps._default.MapUnionPreferA$U@@2
              Maps._default.MapUnionPreferA$T@@2
              $ly@@265
              |mapa#0@@8|
              |mapb#0@@8|)
            true))
     :pattern ((|Maps.__default.MapUnionPreferA#requires|
                 Maps._default.MapUnionPreferA$U@@2
                 Maps._default.MapUnionPreferA$T@@2
                 $ly@@265
                 |mapa#0@@8|
                 |mapb#0@@8|))
     :skolemid |2664|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapUnionPreferA$U@@3 T@U)
                    (Maps._default.MapUnionPreferA$T@@3 T@U)
                    ($ly@@266 T@U)
                    (|mapa#0@@9| T@U)
                    (|mapb#0@@9| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnionPreferA#canCall|
                                 Maps._default.MapUnionPreferA$U@@3
                                 Maps._default.MapUnionPreferA$T@@3
                                 |mapa#0@@9|
                                 |mapb#0@@9|)
                               (and ($Is |mapa#0@@9|
                                         (TMap Maps._default.MapUnionPreferA$U@@3
                                               Maps._default.MapUnionPreferA$T@@3))
                                    ($Is |mapb#0@@9|
                                         (TMap Maps._default.MapUnionPreferA$U@@3
                                               Maps._default.MapUnionPreferA$T@@3)))))
                      (a!2 (|Map#Glue| (|lambda#106| Maps._default.MapUnionPreferA$U@@3
                                                     (|Set#Union| (|Map#Domain| |mapa#0@@9|)
                                                                  (|Map#Domain| |mapb#0@@9|)))
                                       (|lambda#184| (|Map#Domain| |mapa#0@@9|)
                                                     (|Map#Elements| |mapa#0@@9|)
                                                     (|Map#Elements| |mapb#0@@9|))
                                       (TMap Maps._default.MapUnionPreferA$U@@3
                                             Maps._default.MapUnionPreferA$T@@3))))
                  (=> (and (= (type Maps._default.MapUnionPreferA$U@@3) TyType)
                           (= (type Maps._default.MapUnionPreferA$T@@3) TyType)
                           (= (type $ly@@266) LayerTypeType)
                           (= (type |mapa#0@@9|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@9|) (MapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.MapUnionPreferA
                           Maps._default.MapUnionPreferA$U@@3
                           Maps._default.MapUnionPreferA$T@@3
                           ($LS $ly@@266)
                           |mapa#0@@9|
                           |mapb#0@@9|)
                         a!2)))
                :pattern ((Maps.__default.MapUnionPreferA
                            Maps._default.MapUnionPreferA$U@@3
                            Maps._default.MapUnionPreferA$T@@3
                            ($LS $ly@@266)
                            |mapa#0@@9|
                            |mapb#0@@9|))
                :skolemid |2665|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapUnionPreferA$U@@4 T@U)
                    (Maps._default.MapUnionPreferA$T@@4 T@U)
                    ($ly@@267 T@U)
                    (|mapa#0@@10| T@U)
                    (|mapb#0@@10| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnionPreferA#canCall|
                                 Maps._default.MapUnionPreferA$U@@4
                                 Maps._default.MapUnionPreferA$T@@4
                                 (Lit |mapa#0@@10|)
                                 (Lit |mapb#0@@10|))
                               (and ($Is |mapa#0@@10|
                                         (TMap Maps._default.MapUnionPreferA$U@@4
                                               Maps._default.MapUnionPreferA$T@@4))
                                    ($Is |mapb#0@@10|
                                         (TMap Maps._default.MapUnionPreferA$U@@4
                                               Maps._default.MapUnionPreferA$T@@4)))))
                      (a!2 (|lambda#106| Maps._default.MapUnionPreferA$U@@4
                                         (|Set#Union| (|Map#Domain| (Lit |mapa#0@@10|))
                                                      (|Map#Domain| (Lit |mapb#0@@10|))))))
                (let ((a!3 (|Map#Glue| a!2
                                       (|lambda#184| (|Map#Domain| |mapa#0@@10|)
                                                     (|Map#Elements| (Lit |mapa#0@@10|))
                                                     (|Map#Elements| (Lit |mapb#0@@10|)))
                                       (TMap Maps._default.MapUnionPreferA$U@@4
                                             Maps._default.MapUnionPreferA$T@@4))))
                  (=> (and (= (type Maps._default.MapUnionPreferA$U@@4) TyType)
                           (= (type Maps._default.MapUnionPreferA$T@@4) TyType)
                           (= (type $ly@@267) LayerTypeType)
                           (= (type |mapa#0@@10|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@10|) (MapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.MapUnionPreferA
                           Maps._default.MapUnionPreferA$U@@4
                           Maps._default.MapUnionPreferA$T@@4
                           ($LS $ly@@267)
                           (Lit |mapa#0@@10|)
                           (Lit |mapb#0@@10|))
                         a!3))))
                :pattern ((Maps.__default.MapUnionPreferA
                            Maps._default.MapUnionPreferA$U@@4
                            Maps._default.MapUnionPreferA$T@@4
                            ($LS $ly@@267)
                            (Lit |mapa#0@@10|)
                            (Lit |mapb#0@@10|)))
                :weight 3
                :skolemid |2666|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@515 T@U)
         (arg1@@251 T@U)
         (arg2@@145 T@U)
         (arg3@@86 T@U)
         (arg4@@51 T@U))
  (! (= (type (Maps.__default.MapUnionPreferB
                arg0@@515
                arg1@@251
                arg2@@145
                arg3@@86
                arg4@@51))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapUnionPreferB
                 arg0@@515
                 arg1@@251
                 arg2@@145
                 arg3@@86
                 arg4@@51))
     :qid |funType:Maps.__default.MapUnionPreferB|)))
(assert (forall ((Maps._default.MapUnionPreferB$U T@U)
         (Maps._default.MapUnionPreferB$T T@U)
         ($ly@@268 T@U)
         (|mapa#0@@11| T@U)
         (|mapb#0@@11| T@U))
  (! (=> (and (= (type Maps._default.MapUnionPreferB$U) TyType)
              (= (type Maps._default.MapUnionPreferB$T) TyType)
              (= (type $ly@@268) LayerTypeType)
              (= (type |mapa#0@@11|) (MapType BoxType BoxType))
              (= (type |mapb#0@@11|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapUnionPreferB
              Maps._default.MapUnionPreferB$U
              Maps._default.MapUnionPreferB$T
              ($LS $ly@@268)
              |mapa#0@@11|
              |mapb#0@@11|)
            (Maps.__default.MapUnionPreferB
              Maps._default.MapUnionPreferB$U
              Maps._default.MapUnionPreferB$T
              $ly@@268
              |mapa#0@@11|
              |mapb#0@@11|)))
     :pattern ((Maps.__default.MapUnionPreferB
                 Maps._default.MapUnionPreferB$U
                 Maps._default.MapUnionPreferB$T
                 ($LS $ly@@268)
                 |mapa#0@@11|
                 |mapb#0@@11|))
     :skolemid |2667|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapUnionPreferB$U@@0 T@U)
         (Maps._default.MapUnionPreferB$T@@0 T@U)
         ($ly@@269 T@U)
         (|mapa#0@@12| T@U)
         (|mapb#0@@12| T@U))
  (! (=> (and (= (type Maps._default.MapUnionPreferB$U@@0) TyType)
              (= (type Maps._default.MapUnionPreferB$T@@0) TyType)
              (= (type $ly@@269) LayerTypeType)
              (= (type |mapa#0@@12|) (MapType BoxType BoxType))
              (= (type |mapb#0@@12|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapUnionPreferB
              Maps._default.MapUnionPreferB$U@@0
              Maps._default.MapUnionPreferB$T@@0
              $ly@@269
              |mapa#0@@12|
              |mapb#0@@12|)
            (Maps.__default.MapUnionPreferB
              Maps._default.MapUnionPreferB$U@@0
              Maps._default.MapUnionPreferB$T@@0
              $LZ
              |mapa#0@@12|
              |mapb#0@@12|)))
     :pattern ((Maps.__default.MapUnionPreferB
                 Maps._default.MapUnionPreferB$U@@0
                 Maps._default.MapUnionPreferB$T@@0
                 (AsFuelBottom $ly@@269)
                 |mapa#0@@12|
                 |mapb#0@@12|))
     :skolemid |2668|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapUnionPreferB$U@@1 T@U)
                    (Maps._default.MapUnionPreferB$T@@1 T@U)
                    ($ly@@270 T@U)
                    (|mapa#0@@13| T@U)
                    (|mapb#0@@13| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnionPreferB#canCall|
                                 Maps._default.MapUnionPreferB$U@@1
                                 Maps._default.MapUnionPreferB$T@@1
                                 |mapa#0@@13|
                                 |mapb#0@@13|)
                               (and ($Is |mapa#0@@13|
                                         (TMap Maps._default.MapUnionPreferB$U@@1
                                               Maps._default.MapUnionPreferB$T@@1))
                                    ($Is |mapb#0@@13|
                                         (TMap Maps._default.MapUnionPreferB$U@@1
                                               Maps._default.MapUnionPreferB$T@@1)))))
                      (a!2 (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnionPreferB
                                                             Maps._default.MapUnionPreferB$U@@1
                                                             Maps._default.MapUnionPreferB$T@@1
                                                             $ly@@270
                                                             |mapa#0@@13|
                                                             |mapb#0@@13|))
                                             (|Set#Union| (|Map#Domain| |mapa#0@@13|)
                                                          (|Map#Domain| |mapb#0@@13|)))
                                (forall ((|k#0@@62| T@U))
                                  (! (let ((a!1 (and (and (= (type |k#0@@62|)
                                                             BoxType)
                                                          ($IsBox |k#0@@62|
                                                                  Maps._default.MapUnionPreferB$U@@1))
                                                     (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@13|)
                                                                               |k#0@@62|))))
                                           (a!2 (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB
                                                                                     Maps._default.MapUnionPreferB$U@@1
                                                                                     Maps._default.MapUnionPreferB$T@@1
                                                                                     $ly@@270
                                                                                     |mapa#0@@13|
                                                                                     |mapb#0@@13|))
                                                                   |k#0@@62|)
                                                   (MapType0Select (|Map#Elements| |mapb#0@@13|)
                                                                   |k#0@@62|))))
                                       (=> a!1 a!2))
                                     :pattern ((MapType0Select (|Map#Elements| |mapb#0@@13|)
                                                               |k#0@@62|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB
                                                                                 Maps._default.MapUnionPreferB$U@@1
                                                                                 Maps._default.MapUnionPreferB$T@@1
                                                                                 $ly@@270
                                                                                 |mapa#0@@13|
                                                                                 |mapb#0@@13|))
                                                               |k#0@@62|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapb#0@@13|)
                                                               |k#0@@62|))
                                     :skolemid |2669|
                                     :qid |Mapsidfy.150:20|))
                                (forall ((|k#1@@4| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@13|)
                                                                                            (|Map#Domain| |mapb#0@@13|))
                                                                          |k#1@@4|)))
                                           (a!3 (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB
                                                                                     Maps._default.MapUnionPreferB$U@@1
                                                                                     Maps._default.MapUnionPreferB$T@@1
                                                                                     $ly@@270
                                                                                     |mapa#0@@13|
                                                                                     |mapb#0@@13|))
                                                                   |k#1@@4|)
                                                   (MapType0Select (|Map#Elements| |mapa#0@@13|)
                                                                   |k#1@@4|))))
                                     (let ((a!2 (and (and (= (type |k#1@@4|)
                                                             BoxType)
                                                          ($IsBox |k#1@@4|
                                                                  Maps._default.MapUnionPreferB$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|Map#Elements| |mapa#0@@13|)
                                                               |k#1@@4|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB
                                                                                 Maps._default.MapUnionPreferB$U@@1
                                                                                 Maps._default.MapUnionPreferB$T@@1
                                                                                 $ly@@270
                                                                                 |mapa#0@@13|
                                                                                 |mapb#0@@13|))
                                                               |k#1@@4|))
                                     :pattern ((MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@13|)
                                                                                 (|Map#Domain| |mapb#0@@13|))
                                                               |k#1@@4|))
                                     :skolemid |2670|
                                     :qid |Mapsidfy.151:20|))
                                (forall ((|k#2@@0| T@U))
                                  (! (let ((a!1 (not (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@13|)
                                                                               |k#2@@0|))))
                                           (a!3 (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB
                                                                                     Maps._default.MapUnionPreferB$U@@1
                                                                                     Maps._default.MapUnionPreferB$T@@1
                                                                                     $ly@@270
                                                                                     |mapa#0@@13|
                                                                                     |mapb#0@@13|))
                                                                   |k#2@@0|)
                                                   (MapType0Select (|Map#Elements| |mapa#0@@13|)
                                                                   |k#2@@0|))))
                                     (let ((a!2 (and (and (= (type |k#2@@0|)
                                                             BoxType)
                                                          ($IsBox |k#2@@0|
                                                                  Maps._default.MapUnionPreferB$U@@1))
                                                     (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@13|)
                                                                               |k#2@@0|))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|Map#Elements| |mapa#0@@13|)
                                                               |k#2@@0|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB
                                                                                 Maps._default.MapUnionPreferB$U@@1
                                                                                 Maps._default.MapUnionPreferB$T@@1
                                                                                 $ly@@270
                                                                                 |mapa#0@@13|
                                                                                 |mapb#0@@13|))
                                                               |k#2@@0|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapb#0@@13|)
                                                               |k#2@@0|))
                                     :pattern ((MapType0Select (|Map#Domain| |mapa#0@@13|)
                                                               |k#2@@0|))
                                     :skolemid |2671|
                                     :qid |Mapsidfy.152:20|))
                                ($Is (Maps.__default.MapUnionPreferB
                                       Maps._default.MapUnionPreferB$U@@1
                                       Maps._default.MapUnionPreferB$T@@1
                                       $ly@@270
                                       |mapa#0@@13|
                                       |mapb#0@@13|)
                                     (TMap Maps._default.MapUnionPreferB$U@@1
                                           Maps._default.MapUnionPreferB$T@@1)))))
                  (=> (and (= (type Maps._default.MapUnionPreferB$U@@1) TyType)
                           (= (type Maps._default.MapUnionPreferB$T@@1) TyType)
                           (= (type $ly@@270) LayerTypeType)
                           (= (type |mapa#0@@13|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@13|) (MapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapUnionPreferB
                            Maps._default.MapUnionPreferB$U@@1
                            Maps._default.MapUnionPreferB$T@@1
                            $ly@@270
                            |mapa#0@@13|
                            |mapb#0@@13|))
                :skolemid |2672|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapUnionPreferB$U@@2 T@U)
         (Maps._default.MapUnionPreferB$T@@2 T@U)
         ($ly@@271 T@U)
         (|mapa#0@@14| T@U)
         (|mapb#0@@14| T@U))
  (! (=> (and (= (type Maps._default.MapUnionPreferB$U@@2) TyType)
              (= (type Maps._default.MapUnionPreferB$T@@2) TyType)
              (= (type $ly@@271) LayerTypeType)
              (= (type |mapa#0@@14|) (MapType BoxType BoxType))
              (= (type |mapb#0@@14|) (MapType BoxType BoxType))
              ($Is |mapa#0@@14|
                   (TMap Maps._default.MapUnionPreferB$U@@2
                         Maps._default.MapUnionPreferB$T@@2))
              ($Is |mapb#0@@14|
                   (TMap Maps._default.MapUnionPreferB$U@@2
                         Maps._default.MapUnionPreferB$T@@2)))
         (= (|Maps.__default.MapUnionPreferB#requires|
              Maps._default.MapUnionPreferB$U@@2
              Maps._default.MapUnionPreferB$T@@2
              $ly@@271
              |mapa#0@@14|
              |mapb#0@@14|)
            true))
     :pattern ((|Maps.__default.MapUnionPreferB#requires|
                 Maps._default.MapUnionPreferB$U@@2
                 Maps._default.MapUnionPreferB$T@@2
                 $ly@@271
                 |mapa#0@@14|
                 |mapb#0@@14|))
     :skolemid |2673|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapUnionPreferB$U@@3 T@U)
                    (Maps._default.MapUnionPreferB$T@@3 T@U)
                    ($ly@@272 T@U)
                    (|mapa#0@@15| T@U)
                    (|mapb#0@@15| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnionPreferB#canCall|
                                 Maps._default.MapUnionPreferB$U@@3
                                 Maps._default.MapUnionPreferB$T@@3
                                 |mapa#0@@15|
                                 |mapb#0@@15|)
                               (and ($Is |mapa#0@@15|
                                         (TMap Maps._default.MapUnionPreferB$U@@3
                                               Maps._default.MapUnionPreferB$T@@3))
                                    ($Is |mapb#0@@15|
                                         (TMap Maps._default.MapUnionPreferB$U@@3
                                               Maps._default.MapUnionPreferB$T@@3)))))
                      (a!2 (|Map#Glue| (|lambda#106| Maps._default.MapUnionPreferB$U@@3
                                                     (|Set#Union| (|Map#Domain| |mapa#0@@15|)
                                                                  (|Map#Domain| |mapb#0@@15|)))
                                       (|lambda#184| (|Map#Domain| |mapb#0@@15|)
                                                     (|Map#Elements| |mapb#0@@15|)
                                                     (|Map#Elements| |mapa#0@@15|))
                                       (TMap Maps._default.MapUnionPreferB$U@@3
                                             Maps._default.MapUnionPreferB$T@@3))))
                  (=> (and (= (type Maps._default.MapUnionPreferB$U@@3) TyType)
                           (= (type Maps._default.MapUnionPreferB$T@@3) TyType)
                           (= (type $ly@@272) LayerTypeType)
                           (= (type |mapa#0@@15|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@15|) (MapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.MapUnionPreferB
                           Maps._default.MapUnionPreferB$U@@3
                           Maps._default.MapUnionPreferB$T@@3
                           ($LS $ly@@272)
                           |mapa#0@@15|
                           |mapb#0@@15|)
                         a!2)))
                :pattern ((Maps.__default.MapUnionPreferB
                            Maps._default.MapUnionPreferB$U@@3
                            Maps._default.MapUnionPreferB$T@@3
                            ($LS $ly@@272)
                            |mapa#0@@15|
                            |mapb#0@@15|))
                :skolemid |2674|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapUnionPreferB$U@@4 T@U)
                    (Maps._default.MapUnionPreferB$T@@4 T@U)
                    ($ly@@273 T@U)
                    (|mapa#0@@16| T@U)
                    (|mapb#0@@16| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnionPreferB#canCall|
                                 Maps._default.MapUnionPreferB$U@@4
                                 Maps._default.MapUnionPreferB$T@@4
                                 (Lit |mapa#0@@16|)
                                 (Lit |mapb#0@@16|))
                               (and ($Is |mapa#0@@16|
                                         (TMap Maps._default.MapUnionPreferB$U@@4
                                               Maps._default.MapUnionPreferB$T@@4))
                                    ($Is |mapb#0@@16|
                                         (TMap Maps._default.MapUnionPreferB$U@@4
                                               Maps._default.MapUnionPreferB$T@@4)))))
                      (a!2 (|lambda#106| Maps._default.MapUnionPreferB$U@@4
                                         (|Set#Union| (|Map#Domain| (Lit |mapa#0@@16|))
                                                      (|Map#Domain| (Lit |mapb#0@@16|))))))
                (let ((a!3 (|Map#Glue| a!2
                                       (|lambda#184| (|Map#Domain| |mapb#0@@16|)
                                                     (|Map#Elements| (Lit |mapb#0@@16|))
                                                     (|Map#Elements| (Lit |mapa#0@@16|)))
                                       (TMap Maps._default.MapUnionPreferB$U@@4
                                             Maps._default.MapUnionPreferB$T@@4))))
                  (=> (and (= (type Maps._default.MapUnionPreferB$U@@4) TyType)
                           (= (type Maps._default.MapUnionPreferB$T@@4) TyType)
                           (= (type $ly@@273) LayerTypeType)
                           (= (type |mapa#0@@16|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@16|) (MapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.MapUnionPreferB
                           Maps._default.MapUnionPreferB$U@@4
                           Maps._default.MapUnionPreferB$T@@4
                           ($LS $ly@@273)
                           (Lit |mapa#0@@16|)
                           (Lit |mapb#0@@16|))
                         a!3))))
                :pattern ((Maps.__default.MapUnionPreferB
                            Maps._default.MapUnionPreferB$U@@4
                            Maps._default.MapUnionPreferB$T@@4
                            ($LS $ly@@273)
                            (Lit |mapa#0@@16|)
                            (Lit |mapb#0@@16|)))
                :weight 3
                :skolemid |2675|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@516 T@U)
         (arg1@@252 T@U)
         (arg2@@146 T@U)
         (arg3@@87 T@U)
         (arg4@@52 T@U))
  (! (= (type (Maps.__default.MapUnion
                arg0@@516
                arg1@@252
                arg2@@146
                arg3@@87
                arg4@@52))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapUnion
                 arg0@@516
                 arg1@@252
                 arg2@@146
                 arg3@@87
                 arg4@@52))
     :qid |funType:Maps.__default.MapUnion|)))
(assert (forall ((Maps._default.MapUnion$U T@U)
         (Maps._default.MapUnion$T T@U)
         ($ly@@274 T@U)
         (|mapa#0@@17| T@U)
         (|mapb#0@@17| T@U))
  (! (=> (and (= (type Maps._default.MapUnion$U) TyType)
              (= (type Maps._default.MapUnion$T) TyType)
              (= (type $ly@@274) LayerTypeType)
              (= (type |mapa#0@@17|) (MapType BoxType BoxType))
              (= (type |mapb#0@@17|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapUnion
              Maps._default.MapUnion$U
              Maps._default.MapUnion$T
              ($LS $ly@@274)
              |mapa#0@@17|
              |mapb#0@@17|)
            (Maps.__default.MapUnion
              Maps._default.MapUnion$U
              Maps._default.MapUnion$T
              $ly@@274
              |mapa#0@@17|
              |mapb#0@@17|)))
     :pattern ((Maps.__default.MapUnion
                 Maps._default.MapUnion$U
                 Maps._default.MapUnion$T
                 ($LS $ly@@274)
                 |mapa#0@@17|
                 |mapb#0@@17|))
     :skolemid |2676|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapUnion$U@@0 T@U)
         (Maps._default.MapUnion$T@@0 T@U)
         ($ly@@275 T@U)
         (|mapa#0@@18| T@U)
         (|mapb#0@@18| T@U))
  (! (=> (and (= (type Maps._default.MapUnion$U@@0) TyType)
              (= (type Maps._default.MapUnion$T@@0) TyType)
              (= (type $ly@@275) LayerTypeType)
              (= (type |mapa#0@@18|) (MapType BoxType BoxType))
              (= (type |mapb#0@@18|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapUnion
              Maps._default.MapUnion$U@@0
              Maps._default.MapUnion$T@@0
              $ly@@275
              |mapa#0@@18|
              |mapb#0@@18|)
            (Maps.__default.MapUnion
              Maps._default.MapUnion$U@@0
              Maps._default.MapUnion$T@@0
              $LZ
              |mapa#0@@18|
              |mapb#0@@18|)))
     :pattern ((Maps.__default.MapUnion
                 Maps._default.MapUnion$U@@0
                 Maps._default.MapUnion$T@@0
                 (AsFuelBottom $ly@@275)
                 |mapa#0@@18|
                 |mapb#0@@18|))
     :skolemid |2677|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapUnion$U@@1 T@U)
                    (Maps._default.MapUnion$T@@1 T@U)
                    ($ly@@276 T@U)
                    (|mapa#0@@19| T@U)
                    (|mapb#0@@19| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnion#canCall|
                                 Maps._default.MapUnion$U@@1
                                 Maps._default.MapUnion$T@@1
                                 |mapa#0@@19|
                                 |mapb#0@@19|)
                               (and ($Is |mapa#0@@19|
                                         (TMap Maps._default.MapUnion$U@@1
                                               Maps._default.MapUnion$T@@1))
                                    ($Is |mapb#0@@19|
                                         (TMap Maps._default.MapUnion$U@@1
                                               Maps._default.MapUnion$T@@1)))))
                      (a!2 (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|)
                                               (|Map#Domain| |mapb#0@@19|))
                               (|Set#Equal| (|Map#Values| (Maps.__default.MapUnion
                                                            Maps._default.MapUnion$U@@1
                                                            Maps._default.MapUnion$T@@1
                                                            $ly@@276
                                                            |mapa#0@@19|
                                                            |mapb#0@@19|))
                                            (|Set#Union| (|Map#Values| |mapa#0@@19|)
                                                         (|Map#Values| |mapb#0@@19|))))))
                (let ((a!3 (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnion
                                                             Maps._default.MapUnion$U@@1
                                                             Maps._default.MapUnion$T@@1
                                                             $ly@@276
                                                             |mapa#0@@19|
                                                             |mapb#0@@19|))
                                             (|Set#Union| (|Map#Domain| |mapa#0@@19|)
                                                          (|Map#Domain| |mapb#0@@19|)))
                                (forall ((|k#0@@63| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@19|)
                                                                                            (|Map#Domain| |mapb#0@@19|))
                                                                          |k#0@@63|)))
                                           (a!3 (= (MapType0Select (|Map#Elements| |mapa#0@@19|)
                                                                   |k#0@@63|)
                                                   (MapType0Select (|Map#Elements| (Maps.__default.MapUnion
                                                                                     Maps._default.MapUnion$U@@1
                                                                                     Maps._default.MapUnion$T@@1
                                                                                     $ly@@276
                                                                                     |mapa#0@@19|
                                                                                     |mapb#0@@19|))
                                                                   |k#0@@63|))))
                                     (let ((a!2 (and (and (= (type |k#0@@63|)
                                                             BoxType)
                                                          ($IsBox |k#0@@63|
                                                                  Maps._default.MapUnion$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnion
                                                                                 Maps._default.MapUnion$U@@1
                                                                                 Maps._default.MapUnion$T@@1
                                                                                 $ly@@276
                                                                                 |mapa#0@@19|
                                                                                 |mapb#0@@19|))
                                                               |k#0@@63|))
                                     :pattern ((MapType0Select (|Map#Elements| |mapa#0@@19|)
                                                               |k#0@@63|))
                                     :pattern ((MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@19|)
                                                                                 (|Map#Domain| |mapb#0@@19|))
                                                               |k#0@@63|))
                                     :skolemid |2678|
                                     :qid |Mapsidfy.161:18|))
                                (forall ((|k#1@@5| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@19|)
                                                                                            (|Map#Domain| |mapa#0@@19|))
                                                                          |k#1@@5|)))
                                           (a!3 (= (MapType0Select (|Map#Elements| |mapb#0@@19|)
                                                                   |k#1@@5|)
                                                   (MapType0Select (|Map#Elements| (Maps.__default.MapUnion
                                                                                     Maps._default.MapUnion$U@@1
                                                                                     Maps._default.MapUnion$T@@1
                                                                                     $ly@@276
                                                                                     |mapa#0@@19|
                                                                                     |mapb#0@@19|))
                                                                   |k#1@@5|))))
                                     (let ((a!2 (and (and (= (type |k#1@@5|)
                                                             BoxType)
                                                          ($IsBox |k#1@@5|
                                                                  Maps._default.MapUnion$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnion
                                                                                 Maps._default.MapUnion$U@@1
                                                                                 Maps._default.MapUnion$T@@1
                                                                                 $ly@@276
                                                                                 |mapa#0@@19|
                                                                                 |mapb#0@@19|))
                                                               |k#1@@5|))
                                     :pattern ((MapType0Select (|Map#Elements| |mapb#0@@19|)
                                                               |k#1@@5|))
                                     :pattern ((MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@19|)
                                                                                 (|Map#Domain| |mapa#0@@19|))
                                                               |k#1@@5|))
                                     :skolemid |2679|
                                     :qid |Mapsidfy.162:18|))
                                (forall ((|k#2@@1| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|Set#Intersection|
                                                                            (|Map#Domain| |mapa#0@@19|)
                                                                            (|Map#Domain| |mapb#0@@19|))
                                                                          |k#2@@1|)))
                                           (a!3 (= (MapType0Select (|Map#Elements| |mapb#0@@19|)
                                                                   |k#2@@1|)
                                                   (MapType0Select (|Map#Elements| (Maps.__default.MapUnion
                                                                                     Maps._default.MapUnion$U@@1
                                                                                     Maps._default.MapUnion$T@@1
                                                                                     $ly@@276
                                                                                     |mapa#0@@19|
                                                                                     |mapb#0@@19|))
                                                                   |k#2@@1|)))
                                           (a!4 (= (MapType0Select (|Map#Elements| |mapa#0@@19|)
                                                                   |k#2@@1|)
                                                   (MapType0Select (|Map#Elements| (Maps.__default.MapUnion
                                                                                     Maps._default.MapUnion$U@@1
                                                                                     Maps._default.MapUnion$T@@1
                                                                                     $ly@@276
                                                                                     |mapa#0@@19|
                                                                                     |mapb#0@@19|))
                                                                   |k#2@@1|))))
                                     (let ((a!2 (and (and (= (type |k#2@@1|)
                                                             BoxType)
                                                          ($IsBox |k#2@@1|
                                                                  Maps._default.MapUnion$U@@1))
                                                     a!1)))
                                       (=> a!2 (or a!3 a!4))))
                                     :pattern ((MapType0Select (|Map#Elements| |mapa#0@@19|)
                                                               |k#2@@1|))
                                     :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapUnion
                                                                                 Maps._default.MapUnion$U@@1
                                                                                 Maps._default.MapUnion$T@@1
                                                                                 $ly@@276
                                                                                 |mapa#0@@19|
                                                                                 |mapb#0@@19|))
                                                               |k#2@@1|))
                                     :pattern ((MapType0Select (|Map#Elements| |mapb#0@@19|)
                                                               |k#2@@1|))
                                     :pattern ((MapType0Select (|Set#Intersection|
                                                                 (|Map#Domain| |mapa#0@@19|)
                                                                 (|Map#Domain| |mapb#0@@19|))
                                                               |k#2@@1|))
                                     :skolemid |2680|
                                     :qid |Mapsidfy.163:18|))
                                a!2
                                (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|)
                                                    (|Map#Domain| |mapb#0@@19|))
                                    (Maps.__default.IsSubMap
                                      Maps._default.MapUnion$U@@1
                                      Maps._default.MapUnion$T@@1
                                      |mapa#0@@19|
                                      (Maps.__default.MapUnion
                                        Maps._default.MapUnion$U@@1
                                        Maps._default.MapUnion$T@@1
                                        $ly@@276
                                        |mapa#0@@19|
                                        |mapb#0@@19|)))
                                (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|)
                                                    (|Map#Domain| |mapb#0@@19|))
                                    (Maps.__default.IsSubMap
                                      Maps._default.MapUnion$U@@1
                                      Maps._default.MapUnion$T@@1
                                      |mapb#0@@19|
                                      (Maps.__default.MapUnion
                                        Maps._default.MapUnion$U@@1
                                        Maps._default.MapUnion$T@@1
                                        $ly@@276
                                        |mapa#0@@19|
                                        |mapb#0@@19|)))
                                ($Is (Maps.__default.MapUnion
                                       Maps._default.MapUnion$U@@1
                                       Maps._default.MapUnion$T@@1
                                       $ly@@276
                                       |mapa#0@@19|
                                       |mapb#0@@19|)
                                     (TMap Maps._default.MapUnion$U@@1
                                           Maps._default.MapUnion$T@@1)))))
                  (=> (and (= (type Maps._default.MapUnion$U@@1) TyType)
                           (= (type Maps._default.MapUnion$T@@1) TyType)
                           (= (type $ly@@276) LayerTypeType)
                           (= (type |mapa#0@@19|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@19|) (MapType BoxType BoxType))
                           a!1)
                      a!3)))
                :pattern ((Maps.__default.MapUnion
                            Maps._default.MapUnion$U@@1
                            Maps._default.MapUnion$T@@1
                            $ly@@276
                            |mapa#0@@19|
                            |mapb#0@@19|))
                :skolemid |2681|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapUnion$U@@2 T@U)
         (Maps._default.MapUnion$T@@2 T@U)
         ($ly@@277 T@U)
         (|mapa#0@@20| T@U)
         (|mapb#0@@20| T@U))
  (! (=> (and (= (type Maps._default.MapUnion$U@@2) TyType)
              (= (type Maps._default.MapUnion$T@@2) TyType)
              (= (type $ly@@277) LayerTypeType)
              (= (type |mapa#0@@20|) (MapType BoxType BoxType))
              (= (type |mapb#0@@20|) (MapType BoxType BoxType))
              ($Is |mapa#0@@20|
                   (TMap Maps._default.MapUnion$U@@2
                         Maps._default.MapUnion$T@@2))
              ($Is |mapb#0@@20|
                   (TMap Maps._default.MapUnion$U@@2
                         Maps._default.MapUnion$T@@2)))
         (= (|Maps.__default.MapUnion#requires|
              Maps._default.MapUnion$U@@2
              Maps._default.MapUnion$T@@2
              $ly@@277
              |mapa#0@@20|
              |mapb#0@@20|)
            true))
     :pattern ((|Maps.__default.MapUnion#requires|
                 Maps._default.MapUnion$U@@2
                 Maps._default.MapUnion$T@@2
                 $ly@@277
                 |mapa#0@@20|
                 |mapb#0@@20|))
     :skolemid |2682|
     :qid |unknown.0:0|)))
(assert (= (type StartFuel_Maps._default.MapUnionPreferA) LayerTypeType))
(assert (let ((a!1 (forall ((Maps._default.MapUnion$U@@3 T@U)
                    (Maps._default.MapUnion$T@@3 T@U)
                    ($ly@@278 T@U)
                    (|mapa#0@@21| T@U)
                    (|mapb#0@@21| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnion#canCall|
                                 Maps._default.MapUnion$U@@3
                                 Maps._default.MapUnion$T@@3
                                 |mapa#0@@21|
                                 |mapb#0@@21|)
                               (and ($Is |mapa#0@@21|
                                         (TMap Maps._default.MapUnion$U@@3
                                               Maps._default.MapUnion$T@@3))
                                    ($Is |mapb#0@@21|
                                         (TMap Maps._default.MapUnion$U@@3
                                               Maps._default.MapUnion$T@@3)))))
                      (a!2 (and (|Maps.__default.MapUnionPreferA#canCall|
                                  Maps._default.MapUnion$U@@3
                                  Maps._default.MapUnion$T@@3
                                  |mapa#0@@21|
                                  |mapb#0@@21|)
                                (= (Maps.__default.MapUnion
                                     Maps._default.MapUnion$U@@3
                                     Maps._default.MapUnion$T@@3
                                     ($LS $ly@@278)
                                     |mapa#0@@21|
                                     |mapb#0@@21|)
                                   (Maps.__default.MapUnionPreferA
                                     Maps._default.MapUnion$U@@3
                                     Maps._default.MapUnion$T@@3
                                     StartFuel_Maps._default.MapUnionPreferA
                                     |mapa#0@@21|
                                     |mapb#0@@21|)))))
                  (=> (and (= (type Maps._default.MapUnion$U@@3) TyType)
                           (= (type Maps._default.MapUnion$T@@3) TyType)
                           (= (type $ly@@278) LayerTypeType)
                           (= (type |mapa#0@@21|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@21|) (MapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapUnion
                            Maps._default.MapUnion$U@@3
                            Maps._default.MapUnion$T@@3
                            ($LS $ly@@278)
                            |mapa#0@@21|
                            |mapb#0@@21|))
                :skolemid |2683|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapUnion$U@@4 T@U)
                    (Maps._default.MapUnion$T@@4 T@U)
                    ($ly@@279 T@U)
                    (|mapa#0@@22| T@U)
                    (|mapb#0@@22| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapUnion#canCall|
                                 Maps._default.MapUnion$U@@4
                                 Maps._default.MapUnion$T@@4
                                 (Lit |mapa#0@@22|)
                                 (Lit |mapb#0@@22|))
                               (and ($Is |mapa#0@@22|
                                         (TMap Maps._default.MapUnion$U@@4
                                               Maps._default.MapUnion$T@@4))
                                    ($Is |mapb#0@@22|
                                         (TMap Maps._default.MapUnion$U@@4
                                               Maps._default.MapUnion$T@@4)))))
                      (a!2 (and (|Maps.__default.MapUnionPreferA#canCall|
                                  Maps._default.MapUnion$U@@4
                                  Maps._default.MapUnion$T@@4
                                  (Lit |mapa#0@@22|)
                                  (Lit |mapb#0@@22|))
                                (= (Maps.__default.MapUnion
                                     Maps._default.MapUnion$U@@4
                                     Maps._default.MapUnion$T@@4
                                     ($LS $ly@@279)
                                     (Lit |mapa#0@@22|)
                                     (Lit |mapb#0@@22|))
                                   (Maps.__default.MapUnionPreferA
                                     Maps._default.MapUnion$U@@4
                                     Maps._default.MapUnion$T@@4
                                     StartFuel_Maps._default.MapUnionPreferA
                                     (Lit |mapa#0@@22|)
                                     (Lit |mapb#0@@22|))))))
                  (=> (and (= (type Maps._default.MapUnion$U@@4) TyType)
                           (= (type Maps._default.MapUnion$T@@4) TyType)
                           (= (type $ly@@279) LayerTypeType)
                           (= (type |mapa#0@@22|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@22|) (MapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.MapUnion
                            Maps._default.MapUnion$U@@4
                            Maps._default.MapUnion$T@@4
                            ($LS $ly@@279)
                            (Lit |mapa#0@@22|)
                            (Lit |mapb#0@@22|)))
                :weight 3
                :skolemid |2684|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@517 T@U)
         (arg1@@253 T@U)
         (arg2@@147 T@U)
         (arg3@@88 T@U)
         (arg4@@53 T@U))
  (! (= (type (Maps.__default.IMapUnionPreferA
                arg0@@517
                arg1@@253
                arg2@@147
                arg3@@88
                arg4@@53))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.IMapUnionPreferA
                 arg0@@517
                 arg1@@253
                 arg2@@147
                 arg3@@88
                 arg4@@53))
     :qid |funType:Maps.__default.IMapUnionPreferA|)))
(assert (forall ((Maps._default.IMapUnionPreferA$U T@U)
         (Maps._default.IMapUnionPreferA$T T@U)
         ($ly@@280 T@U)
         (|mapa#0@@23| T@U)
         (|mapb#0@@23| T@U))
  (! (=> (and (= (type Maps._default.IMapUnionPreferA$U) TyType)
              (= (type Maps._default.IMapUnionPreferA$T) TyType)
              (= (type $ly@@280) LayerTypeType)
              (= (type |mapa#0@@23|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@23|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapUnionPreferA
              Maps._default.IMapUnionPreferA$U
              Maps._default.IMapUnionPreferA$T
              ($LS $ly@@280)
              |mapa#0@@23|
              |mapb#0@@23|)
            (Maps.__default.IMapUnionPreferA
              Maps._default.IMapUnionPreferA$U
              Maps._default.IMapUnionPreferA$T
              $ly@@280
              |mapa#0@@23|
              |mapb#0@@23|)))
     :pattern ((Maps.__default.IMapUnionPreferA
                 Maps._default.IMapUnionPreferA$U
                 Maps._default.IMapUnionPreferA$T
                 ($LS $ly@@280)
                 |mapa#0@@23|
                 |mapb#0@@23|))
     :skolemid |2685|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.IMapUnionPreferA$U@@0 T@U)
         (Maps._default.IMapUnionPreferA$T@@0 T@U)
         ($ly@@281 T@U)
         (|mapa#0@@24| T@U)
         (|mapb#0@@24| T@U))
  (! (=> (and (= (type Maps._default.IMapUnionPreferA$U@@0) TyType)
              (= (type Maps._default.IMapUnionPreferA$T@@0) TyType)
              (= (type $ly@@281) LayerTypeType)
              (= (type |mapa#0@@24|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@24|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapUnionPreferA
              Maps._default.IMapUnionPreferA$U@@0
              Maps._default.IMapUnionPreferA$T@@0
              $ly@@281
              |mapa#0@@24|
              |mapb#0@@24|)
            (Maps.__default.IMapUnionPreferA
              Maps._default.IMapUnionPreferA$U@@0
              Maps._default.IMapUnionPreferA$T@@0
              $LZ
              |mapa#0@@24|
              |mapb#0@@24|)))
     :pattern ((Maps.__default.IMapUnionPreferA
                 Maps._default.IMapUnionPreferA$U@@0
                 Maps._default.IMapUnionPreferA$T@@0
                 (AsFuelBottom $ly@@281)
                 |mapa#0@@24|
                 |mapb#0@@24|))
     :skolemid |2686|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnionPreferA$U@@1 T@U)
                    (Maps._default.IMapUnionPreferA$T@@1 T@U)
                    ($ly@@282 T@U)
                    (|mapa#0@@25| T@U)
                    (|mapb#0@@25| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnionPreferA#canCall|
                                 Maps._default.IMapUnionPreferA$U@@1
                                 Maps._default.IMapUnionPreferA$T@@1
                                 |mapa#0@@25|
                                 |mapb#0@@25|)
                               (and ($Is |mapa#0@@25|
                                         (TIMap Maps._default.IMapUnionPreferA$U@@1
                                                Maps._default.IMapUnionPreferA$T@@1))
                                    ($Is |mapb#0@@25|
                                         (TIMap Maps._default.IMapUnionPreferA$U@@1
                                                Maps._default.IMapUnionPreferA$T@@1)))))
                      (a!2 (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnionPreferA
                                                               Maps._default.IMapUnionPreferA$U@@1
                                                               Maps._default.IMapUnionPreferA$T@@1
                                                               $ly@@282
                                                               |mapa#0@@25|
                                                               |mapb#0@@25|))
                                              (|ISet#Union| (|IMap#Domain| |mapa#0@@25|)
                                                            (|IMap#Domain| |mapb#0@@25|)))
                                (forall ((|k#0@@64| T@U))
                                  (! (let ((a!1 (and (and (= (type |k#0@@64|)
                                                             BoxType)
                                                          ($IsBox |k#0@@64|
                                                                  Maps._default.IMapUnionPreferA$U@@1))
                                                     (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@25|)
                                                                               |k#0@@64|))))
                                           (a!2 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA
                                                                                      Maps._default.IMapUnionPreferA$U@@1
                                                                                      Maps._default.IMapUnionPreferA$T@@1
                                                                                      $ly@@282
                                                                                      |mapa#0@@25|
                                                                                      |mapb#0@@25|))
                                                                   |k#0@@64|)
                                                   (MapType0Select (|IMap#Elements| |mapa#0@@25|)
                                                                   |k#0@@64|))))
                                       (=> a!1 a!2))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapa#0@@25|)
                                                               |k#0@@64|))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA
                                                                                  Maps._default.IMapUnionPreferA$U@@1
                                                                                  Maps._default.IMapUnionPreferA$T@@1
                                                                                  $ly@@282
                                                                                  |mapa#0@@25|
                                                                                  |mapb#0@@25|))
                                                               |k#0@@64|))
                                     :pattern ((MapType0Select (|IMap#Domain| |mapa#0@@25|)
                                                               |k#0@@64|))
                                     :skolemid |2687|
                                     :qid |Mapsidfy.173:20|))
                                (forall ((|k#1@@6| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|ISet#Difference|
                                                                            (|IMap#Domain| |mapb#0@@25|)
                                                                            (|IMap#Domain| |mapa#0@@25|))
                                                                          |k#1@@6|)))
                                           (a!3 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA
                                                                                      Maps._default.IMapUnionPreferA$U@@1
                                                                                      Maps._default.IMapUnionPreferA$T@@1
                                                                                      $ly@@282
                                                                                      |mapa#0@@25|
                                                                                      |mapb#0@@25|))
                                                                   |k#1@@6|)
                                                   (MapType0Select (|IMap#Elements| |mapb#0@@25|)
                                                                   |k#1@@6|))))
                                     (let ((a!2 (and (and (= (type |k#1@@6|)
                                                             BoxType)
                                                          ($IsBox |k#1@@6|
                                                                  Maps._default.IMapUnionPreferA$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapb#0@@25|)
                                                               |k#1@@6|))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA
                                                                                  Maps._default.IMapUnionPreferA$U@@1
                                                                                  Maps._default.IMapUnionPreferA$T@@1
                                                                                  $ly@@282
                                                                                  |mapa#0@@25|
                                                                                  |mapb#0@@25|))
                                                               |k#1@@6|))
                                     :pattern ((MapType0Select (|ISet#Difference|
                                                                 (|IMap#Domain| |mapb#0@@25|)
                                                                 (|IMap#Domain| |mapa#0@@25|))
                                                               |k#1@@6|))
                                     :skolemid |2688|
                                     :qid |Mapsidfy.174:20|))
                                (forall ((|k#2@@2| T@U))
                                  (! (let ((a!1 (not (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@25|)
                                                                               |k#2@@2|))))
                                           (a!3 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA
                                                                                      Maps._default.IMapUnionPreferA$U@@1
                                                                                      Maps._default.IMapUnionPreferA$T@@1
                                                                                      $ly@@282
                                                                                      |mapa#0@@25|
                                                                                      |mapb#0@@25|))
                                                                   |k#2@@2|)
                                                   (MapType0Select (|IMap#Elements| |mapb#0@@25|)
                                                                   |k#2@@2|))))
                                     (let ((a!2 (and (and (= (type |k#2@@2|)
                                                             BoxType)
                                                          ($IsBox |k#2@@2|
                                                                  Maps._default.IMapUnionPreferA$U@@1))
                                                     (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@25|)
                                                                               |k#2@@2|))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapb#0@@25|)
                                                               |k#2@@2|))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA
                                                                                  Maps._default.IMapUnionPreferA$U@@1
                                                                                  Maps._default.IMapUnionPreferA$T@@1
                                                                                  $ly@@282
                                                                                  |mapa#0@@25|
                                                                                  |mapb#0@@25|))
                                                               |k#2@@2|))
                                     :pattern ((MapType0Select (|IMap#Domain| |mapa#0@@25|)
                                                               |k#2@@2|))
                                     :pattern ((MapType0Select (|IMap#Domain| |mapb#0@@25|)
                                                               |k#2@@2|))
                                     :skolemid |2689|
                                     :qid |Mapsidfy.175:20|))
                                ($Is (Maps.__default.IMapUnionPreferA
                                       Maps._default.IMapUnionPreferA$U@@1
                                       Maps._default.IMapUnionPreferA$T@@1
                                       $ly@@282
                                       |mapa#0@@25|
                                       |mapb#0@@25|)
                                     (TIMap Maps._default.IMapUnionPreferA$U@@1
                                            Maps._default.IMapUnionPreferA$T@@1)))))
                  (=> (and (= (type Maps._default.IMapUnionPreferA$U@@1) TyType)
                           (= (type Maps._default.IMapUnionPreferA$T@@1) TyType)
                           (= (type $ly@@282) LayerTypeType)
                           (= (type |mapa#0@@25|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@25|) (IMapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapUnionPreferA
                            Maps._default.IMapUnionPreferA$U@@1
                            Maps._default.IMapUnionPreferA$T@@1
                            $ly@@282
                            |mapa#0@@25|
                            |mapb#0@@25|))
                :skolemid |2690|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapUnionPreferA$U@@2 T@U)
         (Maps._default.IMapUnionPreferA$T@@2 T@U)
         ($ly@@283 T@U)
         (|mapa#0@@26| T@U)
         (|mapb#0@@26| T@U))
  (! (=> (and (= (type Maps._default.IMapUnionPreferA$U@@2) TyType)
              (= (type Maps._default.IMapUnionPreferA$T@@2) TyType)
              (= (type $ly@@283) LayerTypeType)
              (= (type |mapa#0@@26|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@26|) (IMapType BoxType BoxType))
              ($Is |mapa#0@@26|
                   (TIMap Maps._default.IMapUnionPreferA$U@@2
                          Maps._default.IMapUnionPreferA$T@@2))
              ($Is |mapb#0@@26|
                   (TIMap Maps._default.IMapUnionPreferA$U@@2
                          Maps._default.IMapUnionPreferA$T@@2)))
         (= (|Maps.__default.IMapUnionPreferA#requires|
              Maps._default.IMapUnionPreferA$U@@2
              Maps._default.IMapUnionPreferA$T@@2
              $ly@@283
              |mapa#0@@26|
              |mapb#0@@26|)
            true))
     :pattern ((|Maps.__default.IMapUnionPreferA#requires|
                 Maps._default.IMapUnionPreferA$U@@2
                 Maps._default.IMapUnionPreferA$T@@2
                 $ly@@283
                 |mapa#0@@26|
                 |mapb#0@@26|))
     :skolemid |2691|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnionPreferA$U@@3 T@U)
                    (Maps._default.IMapUnionPreferA$T@@3 T@U)
                    ($ly@@284 T@U)
                    (|mapa#0@@27| T@U)
                    (|mapb#0@@27| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnionPreferA#canCall|
                                 Maps._default.IMapUnionPreferA$U@@3
                                 Maps._default.IMapUnionPreferA$T@@3
                                 |mapa#0@@27|
                                 |mapb#0@@27|)
                               (and ($Is |mapa#0@@27|
                                         (TIMap Maps._default.IMapUnionPreferA$U@@3
                                                Maps._default.IMapUnionPreferA$T@@3))
                                    ($Is |mapb#0@@27|
                                         (TIMap Maps._default.IMapUnionPreferA$U@@3
                                                Maps._default.IMapUnionPreferA$T@@3)))))
                      (a!2 (|IMap#Glue| (|lambda#106| Maps._default.IMapUnionPreferA$U@@3
                                                      (|ISet#Union| (|IMap#Domain| |mapa#0@@27|)
                                                                    (|IMap#Domain| |mapb#0@@27|)))
                                        (|lambda#184| (|IMap#Domain| |mapa#0@@27|)
                                                      (|IMap#Elements| |mapa#0@@27|)
                                                      (|IMap#Elements| |mapb#0@@27|))
                                        (TIMap Maps._default.IMapUnionPreferA$U@@3
                                               Maps._default.IMapUnionPreferA$T@@3))))
                  (=> (and (= (type Maps._default.IMapUnionPreferA$U@@3) TyType)
                           (= (type Maps._default.IMapUnionPreferA$T@@3) TyType)
                           (= (type $ly@@284) LayerTypeType)
                           (= (type |mapa#0@@27|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@27|) (IMapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.IMapUnionPreferA
                           Maps._default.IMapUnionPreferA$U@@3
                           Maps._default.IMapUnionPreferA$T@@3
                           ($LS $ly@@284)
                           |mapa#0@@27|
                           |mapb#0@@27|)
                         a!2)))
                :pattern ((Maps.__default.IMapUnionPreferA
                            Maps._default.IMapUnionPreferA$U@@3
                            Maps._default.IMapUnionPreferA$T@@3
                            ($LS $ly@@284)
                            |mapa#0@@27|
                            |mapb#0@@27|))
                :skolemid |2692|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnionPreferA$U@@4 T@U)
                    (Maps._default.IMapUnionPreferA$T@@4 T@U)
                    ($ly@@285 T@U)
                    (|mapa#0@@28| T@U)
                    (|mapb#0@@28| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnionPreferA#canCall|
                                 Maps._default.IMapUnionPreferA$U@@4
                                 Maps._default.IMapUnionPreferA$T@@4
                                 (Lit |mapa#0@@28|)
                                 (Lit |mapb#0@@28|))
                               (and ($Is |mapa#0@@28|
                                         (TIMap Maps._default.IMapUnionPreferA$U@@4
                                                Maps._default.IMapUnionPreferA$T@@4))
                                    ($Is |mapb#0@@28|
                                         (TIMap Maps._default.IMapUnionPreferA$U@@4
                                                Maps._default.IMapUnionPreferA$T@@4)))))
                      (a!2 (|lambda#106| Maps._default.IMapUnionPreferA$U@@4
                                         (|ISet#Union| (|IMap#Domain| (Lit |mapa#0@@28|))
                                                       (|IMap#Domain| (Lit |mapb#0@@28|))))))
                (let ((a!3 (|IMap#Glue| a!2
                                        (|lambda#184| (|IMap#Domain| |mapa#0@@28|)
                                                      (|IMap#Elements| (Lit |mapa#0@@28|))
                                                      (|IMap#Elements| (Lit |mapb#0@@28|)))
                                        (TIMap Maps._default.IMapUnionPreferA$U@@4
                                               Maps._default.IMapUnionPreferA$T@@4))))
                  (=> (and (= (type Maps._default.IMapUnionPreferA$U@@4) TyType)
                           (= (type Maps._default.IMapUnionPreferA$T@@4) TyType)
                           (= (type $ly@@285) LayerTypeType)
                           (= (type |mapa#0@@28|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@28|) (IMapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.IMapUnionPreferA
                           Maps._default.IMapUnionPreferA$U@@4
                           Maps._default.IMapUnionPreferA$T@@4
                           ($LS $ly@@285)
                           (Lit |mapa#0@@28|)
                           (Lit |mapb#0@@28|))
                         a!3))))
                :pattern ((Maps.__default.IMapUnionPreferA
                            Maps._default.IMapUnionPreferA$U@@4
                            Maps._default.IMapUnionPreferA$T@@4
                            ($LS $ly@@285)
                            (Lit |mapa#0@@28|)
                            (Lit |mapb#0@@28|)))
                :weight 3
                :skolemid |2693|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@518 T@U)
         (arg1@@254 T@U)
         (arg2@@148 T@U)
         (arg3@@89 T@U)
         (arg4@@54 T@U))
  (! (= (type (Maps.__default.IMapUnionPreferB
                arg0@@518
                arg1@@254
                arg2@@148
                arg3@@89
                arg4@@54))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.IMapUnionPreferB
                 arg0@@518
                 arg1@@254
                 arg2@@148
                 arg3@@89
                 arg4@@54))
     :qid |funType:Maps.__default.IMapUnionPreferB|)))
(assert (forall ((Maps._default.IMapUnionPreferB$U T@U)
         (Maps._default.IMapUnionPreferB$T T@U)
         ($ly@@286 T@U)
         (|mapa#0@@29| T@U)
         (|mapb#0@@29| T@U))
  (! (=> (and (= (type Maps._default.IMapUnionPreferB$U) TyType)
              (= (type Maps._default.IMapUnionPreferB$T) TyType)
              (= (type $ly@@286) LayerTypeType)
              (= (type |mapa#0@@29|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@29|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapUnionPreferB
              Maps._default.IMapUnionPreferB$U
              Maps._default.IMapUnionPreferB$T
              ($LS $ly@@286)
              |mapa#0@@29|
              |mapb#0@@29|)
            (Maps.__default.IMapUnionPreferB
              Maps._default.IMapUnionPreferB$U
              Maps._default.IMapUnionPreferB$T
              $ly@@286
              |mapa#0@@29|
              |mapb#0@@29|)))
     :pattern ((Maps.__default.IMapUnionPreferB
                 Maps._default.IMapUnionPreferB$U
                 Maps._default.IMapUnionPreferB$T
                 ($LS $ly@@286)
                 |mapa#0@@29|
                 |mapb#0@@29|))
     :skolemid |2694|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.IMapUnionPreferB$U@@0 T@U)
         (Maps._default.IMapUnionPreferB$T@@0 T@U)
         ($ly@@287 T@U)
         (|mapa#0@@30| T@U)
         (|mapb#0@@30| T@U))
  (! (=> (and (= (type Maps._default.IMapUnionPreferB$U@@0) TyType)
              (= (type Maps._default.IMapUnionPreferB$T@@0) TyType)
              (= (type $ly@@287) LayerTypeType)
              (= (type |mapa#0@@30|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@30|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapUnionPreferB
              Maps._default.IMapUnionPreferB$U@@0
              Maps._default.IMapUnionPreferB$T@@0
              $ly@@287
              |mapa#0@@30|
              |mapb#0@@30|)
            (Maps.__default.IMapUnionPreferB
              Maps._default.IMapUnionPreferB$U@@0
              Maps._default.IMapUnionPreferB$T@@0
              $LZ
              |mapa#0@@30|
              |mapb#0@@30|)))
     :pattern ((Maps.__default.IMapUnionPreferB
                 Maps._default.IMapUnionPreferB$U@@0
                 Maps._default.IMapUnionPreferB$T@@0
                 (AsFuelBottom $ly@@287)
                 |mapa#0@@30|
                 |mapb#0@@30|))
     :skolemid |2695|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnionPreferB$U@@1 T@U)
                    (Maps._default.IMapUnionPreferB$T@@1 T@U)
                    ($ly@@288 T@U)
                    (|mapa#0@@31| T@U)
                    (|mapb#0@@31| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnionPreferB#canCall|
                                 Maps._default.IMapUnionPreferB$U@@1
                                 Maps._default.IMapUnionPreferB$T@@1
                                 |mapa#0@@31|
                                 |mapb#0@@31|)
                               (and ($Is |mapa#0@@31|
                                         (TIMap Maps._default.IMapUnionPreferB$U@@1
                                                Maps._default.IMapUnionPreferB$T@@1))
                                    ($Is |mapb#0@@31|
                                         (TIMap Maps._default.IMapUnionPreferB$U@@1
                                                Maps._default.IMapUnionPreferB$T@@1)))))
                      (a!2 (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnionPreferB
                                                               Maps._default.IMapUnionPreferB$U@@1
                                                               Maps._default.IMapUnionPreferB$T@@1
                                                               $ly@@288
                                                               |mapa#0@@31|
                                                               |mapb#0@@31|))
                                              (|ISet#Union| (|IMap#Domain| |mapa#0@@31|)
                                                            (|IMap#Domain| |mapb#0@@31|)))
                                (forall ((|k#0@@65| T@U))
                                  (! (let ((a!1 (and (and (= (type |k#0@@65|)
                                                             BoxType)
                                                          ($IsBox |k#0@@65|
                                                                  Maps._default.IMapUnionPreferB$U@@1))
                                                     (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@31|)
                                                                               |k#0@@65|))))
                                           (a!2 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB
                                                                                      Maps._default.IMapUnionPreferB$U@@1
                                                                                      Maps._default.IMapUnionPreferB$T@@1
                                                                                      $ly@@288
                                                                                      |mapa#0@@31|
                                                                                      |mapb#0@@31|))
                                                                   |k#0@@65|)
                                                   (MapType0Select (|IMap#Elements| |mapb#0@@31|)
                                                                   |k#0@@65|))))
                                       (=> a!1 a!2))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapb#0@@31|)
                                                               |k#0@@65|))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB
                                                                                  Maps._default.IMapUnionPreferB$U@@1
                                                                                  Maps._default.IMapUnionPreferB$T@@1
                                                                                  $ly@@288
                                                                                  |mapa#0@@31|
                                                                                  |mapb#0@@31|))
                                                               |k#0@@65|))
                                     :pattern ((MapType0Select (|IMap#Domain| |mapb#0@@31|)
                                                               |k#0@@65|))
                                     :skolemid |2696|
                                     :qid |Mapsidfy.182:20|))
                                (forall ((|k#1@@7| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|ISet#Difference|
                                                                            (|IMap#Domain| |mapa#0@@31|)
                                                                            (|IMap#Domain| |mapb#0@@31|))
                                                                          |k#1@@7|)))
                                           (a!3 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB
                                                                                      Maps._default.IMapUnionPreferB$U@@1
                                                                                      Maps._default.IMapUnionPreferB$T@@1
                                                                                      $ly@@288
                                                                                      |mapa#0@@31|
                                                                                      |mapb#0@@31|))
                                                                   |k#1@@7|)
                                                   (MapType0Select (|IMap#Elements| |mapa#0@@31|)
                                                                   |k#1@@7|))))
                                     (let ((a!2 (and (and (= (type |k#1@@7|)
                                                             BoxType)
                                                          ($IsBox |k#1@@7|
                                                                  Maps._default.IMapUnionPreferB$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapa#0@@31|)
                                                               |k#1@@7|))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB
                                                                                  Maps._default.IMapUnionPreferB$U@@1
                                                                                  Maps._default.IMapUnionPreferB$T@@1
                                                                                  $ly@@288
                                                                                  |mapa#0@@31|
                                                                                  |mapb#0@@31|))
                                                               |k#1@@7|))
                                     :pattern ((MapType0Select (|ISet#Difference|
                                                                 (|IMap#Domain| |mapa#0@@31|)
                                                                 (|IMap#Domain| |mapb#0@@31|))
                                                               |k#1@@7|))
                                     :skolemid |2697|
                                     :qid |Mapsidfy.183:20|))
                                (forall ((|k#2@@3| T@U))
                                  (! (let ((a!1 (not (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@31|)
                                                                               |k#2@@3|))))
                                           (a!3 (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB
                                                                                      Maps._default.IMapUnionPreferB$U@@1
                                                                                      Maps._default.IMapUnionPreferB$T@@1
                                                                                      $ly@@288
                                                                                      |mapa#0@@31|
                                                                                      |mapb#0@@31|))
                                                                   |k#2@@3|)
                                                   (MapType0Select (|IMap#Elements| |mapa#0@@31|)
                                                                   |k#2@@3|))))
                                     (let ((a!2 (and (and (= (type |k#2@@3|)
                                                             BoxType)
                                                          ($IsBox |k#2@@3|
                                                                  Maps._default.IMapUnionPreferB$U@@1))
                                                     (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@31|)
                                                                               |k#2@@3|))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapa#0@@31|)
                                                               |k#2@@3|))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB
                                                                                  Maps._default.IMapUnionPreferB$U@@1
                                                                                  Maps._default.IMapUnionPreferB$T@@1
                                                                                  $ly@@288
                                                                                  |mapa#0@@31|
                                                                                  |mapb#0@@31|))
                                                               |k#2@@3|))
                                     :pattern ((MapType0Select (|IMap#Domain| |mapb#0@@31|)
                                                               |k#2@@3|))
                                     :pattern ((MapType0Select (|IMap#Domain| |mapa#0@@31|)
                                                               |k#2@@3|))
                                     :skolemid |2698|
                                     :qid |Mapsidfy.184:20|))
                                ($Is (Maps.__default.IMapUnionPreferB
                                       Maps._default.IMapUnionPreferB$U@@1
                                       Maps._default.IMapUnionPreferB$T@@1
                                       $ly@@288
                                       |mapa#0@@31|
                                       |mapb#0@@31|)
                                     (TIMap Maps._default.IMapUnionPreferB$U@@1
                                            Maps._default.IMapUnionPreferB$T@@1)))))
                  (=> (and (= (type Maps._default.IMapUnionPreferB$U@@1) TyType)
                           (= (type Maps._default.IMapUnionPreferB$T@@1) TyType)
                           (= (type $ly@@288) LayerTypeType)
                           (= (type |mapa#0@@31|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@31|) (IMapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapUnionPreferB
                            Maps._default.IMapUnionPreferB$U@@1
                            Maps._default.IMapUnionPreferB$T@@1
                            $ly@@288
                            |mapa#0@@31|
                            |mapb#0@@31|))
                :skolemid |2699|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapUnionPreferB$U@@2 T@U)
         (Maps._default.IMapUnionPreferB$T@@2 T@U)
         ($ly@@289 T@U)
         (|mapa#0@@32| T@U)
         (|mapb#0@@32| T@U))
  (! (=> (and (= (type Maps._default.IMapUnionPreferB$U@@2) TyType)
              (= (type Maps._default.IMapUnionPreferB$T@@2) TyType)
              (= (type $ly@@289) LayerTypeType)
              (= (type |mapa#0@@32|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@32|) (IMapType BoxType BoxType))
              ($Is |mapa#0@@32|
                   (TIMap Maps._default.IMapUnionPreferB$U@@2
                          Maps._default.IMapUnionPreferB$T@@2))
              ($Is |mapb#0@@32|
                   (TIMap Maps._default.IMapUnionPreferB$U@@2
                          Maps._default.IMapUnionPreferB$T@@2)))
         (= (|Maps.__default.IMapUnionPreferB#requires|
              Maps._default.IMapUnionPreferB$U@@2
              Maps._default.IMapUnionPreferB$T@@2
              $ly@@289
              |mapa#0@@32|
              |mapb#0@@32|)
            true))
     :pattern ((|Maps.__default.IMapUnionPreferB#requires|
                 Maps._default.IMapUnionPreferB$U@@2
                 Maps._default.IMapUnionPreferB$T@@2
                 $ly@@289
                 |mapa#0@@32|
                 |mapb#0@@32|))
     :skolemid |2700|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnionPreferB$U@@3 T@U)
                    (Maps._default.IMapUnionPreferB$T@@3 T@U)
                    ($ly@@290 T@U)
                    (|mapa#0@@33| T@U)
                    (|mapb#0@@33| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnionPreferB#canCall|
                                 Maps._default.IMapUnionPreferB$U@@3
                                 Maps._default.IMapUnionPreferB$T@@3
                                 |mapa#0@@33|
                                 |mapb#0@@33|)
                               (and ($Is |mapa#0@@33|
                                         (TIMap Maps._default.IMapUnionPreferB$U@@3
                                                Maps._default.IMapUnionPreferB$T@@3))
                                    ($Is |mapb#0@@33|
                                         (TIMap Maps._default.IMapUnionPreferB$U@@3
                                                Maps._default.IMapUnionPreferB$T@@3)))))
                      (a!2 (|IMap#Glue| (|lambda#106| Maps._default.IMapUnionPreferB$U@@3
                                                      (|ISet#Union| (|IMap#Domain| |mapa#0@@33|)
                                                                    (|IMap#Domain| |mapb#0@@33|)))
                                        (|lambda#184| (|IMap#Domain| |mapb#0@@33|)
                                                      (|IMap#Elements| |mapb#0@@33|)
                                                      (|IMap#Elements| |mapa#0@@33|))
                                        (TIMap Maps._default.IMapUnionPreferB$U@@3
                                               Maps._default.IMapUnionPreferB$T@@3))))
                  (=> (and (= (type Maps._default.IMapUnionPreferB$U@@3) TyType)
                           (= (type Maps._default.IMapUnionPreferB$T@@3) TyType)
                           (= (type $ly@@290) LayerTypeType)
                           (= (type |mapa#0@@33|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@33|) (IMapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.IMapUnionPreferB
                           Maps._default.IMapUnionPreferB$U@@3
                           Maps._default.IMapUnionPreferB$T@@3
                           ($LS $ly@@290)
                           |mapa#0@@33|
                           |mapb#0@@33|)
                         a!2)))
                :pattern ((Maps.__default.IMapUnionPreferB
                            Maps._default.IMapUnionPreferB$U@@3
                            Maps._default.IMapUnionPreferB$T@@3
                            ($LS $ly@@290)
                            |mapa#0@@33|
                            |mapb#0@@33|))
                :skolemid |2701|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnionPreferB$U@@4 T@U)
                    (Maps._default.IMapUnionPreferB$T@@4 T@U)
                    ($ly@@291 T@U)
                    (|mapa#0@@34| T@U)
                    (|mapb#0@@34| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnionPreferB#canCall|
                                 Maps._default.IMapUnionPreferB$U@@4
                                 Maps._default.IMapUnionPreferB$T@@4
                                 (Lit |mapa#0@@34|)
                                 (Lit |mapb#0@@34|))
                               (and ($Is |mapa#0@@34|
                                         (TIMap Maps._default.IMapUnionPreferB$U@@4
                                                Maps._default.IMapUnionPreferB$T@@4))
                                    ($Is |mapb#0@@34|
                                         (TIMap Maps._default.IMapUnionPreferB$U@@4
                                                Maps._default.IMapUnionPreferB$T@@4)))))
                      (a!2 (|lambda#106| Maps._default.IMapUnionPreferB$U@@4
                                         (|ISet#Union| (|IMap#Domain| (Lit |mapa#0@@34|))
                                                       (|IMap#Domain| (Lit |mapb#0@@34|))))))
                (let ((a!3 (|IMap#Glue| a!2
                                        (|lambda#184| (|IMap#Domain| |mapb#0@@34|)
                                                      (|IMap#Elements| (Lit |mapb#0@@34|))
                                                      (|IMap#Elements| (Lit |mapa#0@@34|)))
                                        (TIMap Maps._default.IMapUnionPreferB$U@@4
                                               Maps._default.IMapUnionPreferB$T@@4))))
                  (=> (and (= (type Maps._default.IMapUnionPreferB$U@@4) TyType)
                           (= (type Maps._default.IMapUnionPreferB$T@@4) TyType)
                           (= (type $ly@@291) LayerTypeType)
                           (= (type |mapa#0@@34|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@34|) (IMapType BoxType BoxType))
                           a!1)
                      (= (Maps.__default.IMapUnionPreferB
                           Maps._default.IMapUnionPreferB$U@@4
                           Maps._default.IMapUnionPreferB$T@@4
                           ($LS $ly@@291)
                           (Lit |mapa#0@@34|)
                           (Lit |mapb#0@@34|))
                         a!3))))
                :pattern ((Maps.__default.IMapUnionPreferB
                            Maps._default.IMapUnionPreferB$U@@4
                            Maps._default.IMapUnionPreferB$T@@4
                            ($LS $ly@@291)
                            (Lit |mapa#0@@34|)
                            (Lit |mapb#0@@34|)))
                :weight 3
                :skolemid |2702|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@519 T@U)
         (arg1@@255 T@U)
         (arg2@@149 T@U)
         (arg3@@90 T@U)
         (arg4@@55 T@U))
  (! (= (type (Maps.__default.IMapUnion
                arg0@@519
                arg1@@255
                arg2@@149
                arg3@@90
                arg4@@55))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.IMapUnion
                 arg0@@519
                 arg1@@255
                 arg2@@149
                 arg3@@90
                 arg4@@55))
     :qid |funType:Maps.__default.IMapUnion|)))
(assert (forall ((Maps._default.IMapUnion$U T@U)
         (Maps._default.IMapUnion$T T@U)
         ($ly@@292 T@U)
         (|mapa#0@@35| T@U)
         (|mapb#0@@35| T@U))
  (! (=> (and (= (type Maps._default.IMapUnion$U) TyType)
              (= (type Maps._default.IMapUnion$T) TyType)
              (= (type $ly@@292) LayerTypeType)
              (= (type |mapa#0@@35|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@35|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapUnion
              Maps._default.IMapUnion$U
              Maps._default.IMapUnion$T
              ($LS $ly@@292)
              |mapa#0@@35|
              |mapb#0@@35|)
            (Maps.__default.IMapUnion
              Maps._default.IMapUnion$U
              Maps._default.IMapUnion$T
              $ly@@292
              |mapa#0@@35|
              |mapb#0@@35|)))
     :pattern ((Maps.__default.IMapUnion
                 Maps._default.IMapUnion$U
                 Maps._default.IMapUnion$T
                 ($LS $ly@@292)
                 |mapa#0@@35|
                 |mapb#0@@35|))
     :skolemid |2703|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.IMapUnion$U@@0 T@U)
         (Maps._default.IMapUnion$T@@0 T@U)
         ($ly@@293 T@U)
         (|mapa#0@@36| T@U)
         (|mapb#0@@36| T@U))
  (! (=> (and (= (type Maps._default.IMapUnion$U@@0) TyType)
              (= (type Maps._default.IMapUnion$T@@0) TyType)
              (= (type $ly@@293) LayerTypeType)
              (= (type |mapa#0@@36|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@36|) (IMapType BoxType BoxType)))
         (= (Maps.__default.IMapUnion
              Maps._default.IMapUnion$U@@0
              Maps._default.IMapUnion$T@@0
              $ly@@293
              |mapa#0@@36|
              |mapb#0@@36|)
            (Maps.__default.IMapUnion
              Maps._default.IMapUnion$U@@0
              Maps._default.IMapUnion$T@@0
              $LZ
              |mapa#0@@36|
              |mapb#0@@36|)))
     :pattern ((Maps.__default.IMapUnion
                 Maps._default.IMapUnion$U@@0
                 Maps._default.IMapUnion$T@@0
                 (AsFuelBottom $ly@@293)
                 |mapa#0@@36|
                 |mapb#0@@36|))
     :skolemid |2704|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnion$U@@1 T@U)
                    (Maps._default.IMapUnion$T@@1 T@U)
                    ($ly@@294 T@U)
                    (|mapa#0@@37| T@U)
                    (|mapb#0@@37| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnion#canCall|
                                 Maps._default.IMapUnion$U@@1
                                 Maps._default.IMapUnion$T@@1
                                 |mapa#0@@37|
                                 |mapb#0@@37|)
                               (and ($Is |mapa#0@@37|
                                         (TIMap Maps._default.IMapUnion$U@@1
                                                Maps._default.IMapUnion$T@@1))
                                    ($Is |mapb#0@@37|
                                         (TIMap Maps._default.IMapUnion$U@@1
                                                Maps._default.IMapUnion$T@@1)))))
                      (a!2 (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnion
                                                               Maps._default.IMapUnion$U@@1
                                                               Maps._default.IMapUnion$T@@1
                                                               $ly@@294
                                                               |mapa#0@@37|
                                                               |mapb#0@@37|))
                                              (|ISet#Union| (|IMap#Domain| |mapa#0@@37|)
                                                            (|IMap#Domain| |mapb#0@@37|)))
                                (forall ((|k#0@@66| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|ISet#Difference|
                                                                            (|IMap#Domain| |mapa#0@@37|)
                                                                            (|IMap#Domain| |mapb#0@@37|))
                                                                          |k#0@@66|)))
                                           (a!3 (= (MapType0Select (|IMap#Elements| |mapa#0@@37|)
                                                                   |k#0@@66|)
                                                   (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion
                                                                                      Maps._default.IMapUnion$U@@1
                                                                                      Maps._default.IMapUnion$T@@1
                                                                                      $ly@@294
                                                                                      |mapa#0@@37|
                                                                                      |mapb#0@@37|))
                                                                   |k#0@@66|))))
                                     (let ((a!2 (and (and (= (type |k#0@@66|)
                                                             BoxType)
                                                          ($IsBox |k#0@@66|
                                                                  Maps._default.IMapUnion$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion
                                                                                  Maps._default.IMapUnion$U@@1
                                                                                  Maps._default.IMapUnion$T@@1
                                                                                  $ly@@294
                                                                                  |mapa#0@@37|
                                                                                  |mapb#0@@37|))
                                                               |k#0@@66|))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapa#0@@37|)
                                                               |k#0@@66|))
                                     :pattern ((MapType0Select (|ISet#Difference|
                                                                 (|IMap#Domain| |mapa#0@@37|)
                                                                 (|IMap#Domain| |mapb#0@@37|))
                                                               |k#0@@66|))
                                     :skolemid |2705|
                                     :qid |Mapsidfy.193:18|))
                                (forall ((|k#1@@8| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|ISet#Difference|
                                                                            (|IMap#Domain| |mapb#0@@37|)
                                                                            (|IMap#Domain| |mapa#0@@37|))
                                                                          |k#1@@8|)))
                                           (a!3 (= (MapType0Select (|IMap#Elements| |mapb#0@@37|)
                                                                   |k#1@@8|)
                                                   (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion
                                                                                      Maps._default.IMapUnion$U@@1
                                                                                      Maps._default.IMapUnion$T@@1
                                                                                      $ly@@294
                                                                                      |mapa#0@@37|
                                                                                      |mapb#0@@37|))
                                                                   |k#1@@8|))))
                                     (let ((a!2 (and (and (= (type |k#1@@8|)
                                                             BoxType)
                                                          ($IsBox |k#1@@8|
                                                                  Maps._default.IMapUnion$U@@1))
                                                     a!1)))
                                       (=> a!2 a!3)))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion
                                                                                  Maps._default.IMapUnion$U@@1
                                                                                  Maps._default.IMapUnion$T@@1
                                                                                  $ly@@294
                                                                                  |mapa#0@@37|
                                                                                  |mapb#0@@37|))
                                                               |k#1@@8|))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapb#0@@37|)
                                                               |k#1@@8|))
                                     :pattern ((MapType0Select (|ISet#Difference|
                                                                 (|IMap#Domain| |mapb#0@@37|)
                                                                 (|IMap#Domain| |mapa#0@@37|))
                                                               |k#1@@8|))
                                     :skolemid |2706|
                                     :qid |Mapsidfy.194:18|))
                                (forall ((|k#2@@4| T@U))
                                  (! (let ((a!1 (U_2_bool (MapType0Select (|ISet#Intersection|
                                                                            (|IMap#Domain| |mapa#0@@37|)
                                                                            (|IMap#Domain| |mapb#0@@37|))
                                                                          |k#2@@4|)))
                                           (a!3 (= (MapType0Select (|IMap#Elements| |mapb#0@@37|)
                                                                   |k#2@@4|)
                                                   (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion
                                                                                      Maps._default.IMapUnion$U@@1
                                                                                      Maps._default.IMapUnion$T@@1
                                                                                      $ly@@294
                                                                                      |mapa#0@@37|
                                                                                      |mapb#0@@37|))
                                                                   |k#2@@4|)))
                                           (a!4 (= (MapType0Select (|IMap#Elements| |mapa#0@@37|)
                                                                   |k#2@@4|)
                                                   (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion
                                                                                      Maps._default.IMapUnion$U@@1
                                                                                      Maps._default.IMapUnion$T@@1
                                                                                      $ly@@294
                                                                                      |mapa#0@@37|
                                                                                      |mapb#0@@37|))
                                                                   |k#2@@4|))))
                                     (let ((a!2 (and (and (= (type |k#2@@4|)
                                                             BoxType)
                                                          ($IsBox |k#2@@4|
                                                                  Maps._default.IMapUnion$U@@1))
                                                     a!1)))
                                       (=> a!2 (or a!3 a!4))))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapa#0@@37|)
                                                               |k#2@@4|))
                                     :pattern ((MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion
                                                                                  Maps._default.IMapUnion$U@@1
                                                                                  Maps._default.IMapUnion$T@@1
                                                                                  $ly@@294
                                                                                  |mapa#0@@37|
                                                                                  |mapb#0@@37|))
                                                               |k#2@@4|))
                                     :pattern ((MapType0Select (|IMap#Elements| |mapb#0@@37|)
                                                               |k#2@@4|))
                                     :pattern ((MapType0Select (|ISet#Intersection|
                                                                 (|IMap#Domain| |mapa#0@@37|)
                                                                 (|IMap#Domain| |mapb#0@@37|))
                                                               |k#2@@4|))
                                     :skolemid |2707|
                                     :qid |Mapsidfy.195:18|))
                                ($Is (Maps.__default.IMapUnion
                                       Maps._default.IMapUnion$U@@1
                                       Maps._default.IMapUnion$T@@1
                                       $ly@@294
                                       |mapa#0@@37|
                                       |mapb#0@@37|)
                                     (TIMap Maps._default.IMapUnion$U@@1
                                            Maps._default.IMapUnion$T@@1)))))
                  (=> (and (= (type Maps._default.IMapUnion$U@@1) TyType)
                           (= (type Maps._default.IMapUnion$T@@1) TyType)
                           (= (type $ly@@294) LayerTypeType)
                           (= (type |mapa#0@@37|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@37|) (IMapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapUnion
                            Maps._default.IMapUnion$U@@1
                            Maps._default.IMapUnion$T@@1
                            $ly@@294
                            |mapa#0@@37|
                            |mapb#0@@37|))
                :skolemid |2708|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.IMapUnion$U@@2 T@U)
         (Maps._default.IMapUnion$T@@2 T@U)
         ($ly@@295 T@U)
         (|mapa#0@@38| T@U)
         (|mapb#0@@38| T@U))
  (! (=> (and (= (type Maps._default.IMapUnion$U@@2) TyType)
              (= (type Maps._default.IMapUnion$T@@2) TyType)
              (= (type $ly@@295) LayerTypeType)
              (= (type |mapa#0@@38|) (IMapType BoxType BoxType))
              (= (type |mapb#0@@38|) (IMapType BoxType BoxType))
              ($Is |mapa#0@@38|
                   (TIMap Maps._default.IMapUnion$U@@2
                          Maps._default.IMapUnion$T@@2))
              ($Is |mapb#0@@38|
                   (TIMap Maps._default.IMapUnion$U@@2
                          Maps._default.IMapUnion$T@@2)))
         (= (|Maps.__default.IMapUnion#requires|
              Maps._default.IMapUnion$U@@2
              Maps._default.IMapUnion$T@@2
              $ly@@295
              |mapa#0@@38|
              |mapb#0@@38|)
            true))
     :pattern ((|Maps.__default.IMapUnion#requires|
                 Maps._default.IMapUnion$U@@2
                 Maps._default.IMapUnion$T@@2
                 $ly@@295
                 |mapa#0@@38|
                 |mapb#0@@38|))
     :skolemid |2709|
     :qid |unknown.0:0|)))
(assert (= (type StartFuel_Maps._default.IMapUnionPreferA) LayerTypeType))
(assert (let ((a!1 (forall ((Maps._default.IMapUnion$U@@3 T@U)
                    (Maps._default.IMapUnion$T@@3 T@U)
                    ($ly@@296 T@U)
                    (|mapa#0@@39| T@U)
                    (|mapb#0@@39| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnion#canCall|
                                 Maps._default.IMapUnion$U@@3
                                 Maps._default.IMapUnion$T@@3
                                 |mapa#0@@39|
                                 |mapb#0@@39|)
                               (and ($Is |mapa#0@@39|
                                         (TIMap Maps._default.IMapUnion$U@@3
                                                Maps._default.IMapUnion$T@@3))
                                    ($Is |mapb#0@@39|
                                         (TIMap Maps._default.IMapUnion$U@@3
                                                Maps._default.IMapUnion$T@@3)))))
                      (a!2 (and (|Maps.__default.IMapUnionPreferA#canCall|
                                  Maps._default.IMapUnion$U@@3
                                  Maps._default.IMapUnion$T@@3
                                  |mapa#0@@39|
                                  |mapb#0@@39|)
                                (= (Maps.__default.IMapUnion
                                     Maps._default.IMapUnion$U@@3
                                     Maps._default.IMapUnion$T@@3
                                     ($LS $ly@@296)
                                     |mapa#0@@39|
                                     |mapb#0@@39|)
                                   (Maps.__default.IMapUnionPreferA
                                     Maps._default.IMapUnion$U@@3
                                     Maps._default.IMapUnion$T@@3
                                     StartFuel_Maps._default.IMapUnionPreferA
                                     |mapa#0@@39|
                                     |mapb#0@@39|)))))
                  (=> (and (= (type Maps._default.IMapUnion$U@@3) TyType)
                           (= (type Maps._default.IMapUnion$T@@3) TyType)
                           (= (type $ly@@296) LayerTypeType)
                           (= (type |mapa#0@@39|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@39|) (IMapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapUnion
                            Maps._default.IMapUnion$U@@3
                            Maps._default.IMapUnion$T@@3
                            ($LS $ly@@296)
                            |mapa#0@@39|
                            |mapb#0@@39|))
                :skolemid |2710|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.IMapUnion$U@@4 T@U)
                    (Maps._default.IMapUnion$T@@4 T@U)
                    ($ly@@297 T@U)
                    (|mapa#0@@40| T@U)
                    (|mapb#0@@40| T@U))
             (! (let ((a!1 (or (|Maps.__default.IMapUnion#canCall|
                                 Maps._default.IMapUnion$U@@4
                                 Maps._default.IMapUnion$T@@4
                                 (Lit |mapa#0@@40|)
                                 (Lit |mapb#0@@40|))
                               (and ($Is |mapa#0@@40|
                                         (TIMap Maps._default.IMapUnion$U@@4
                                                Maps._default.IMapUnion$T@@4))
                                    ($Is |mapb#0@@40|
                                         (TIMap Maps._default.IMapUnion$U@@4
                                                Maps._default.IMapUnion$T@@4)))))
                      (a!2 (and (|Maps.__default.IMapUnionPreferA#canCall|
                                  Maps._default.IMapUnion$U@@4
                                  Maps._default.IMapUnion$T@@4
                                  (Lit |mapa#0@@40|)
                                  (Lit |mapb#0@@40|))
                                (= (Maps.__default.IMapUnion
                                     Maps._default.IMapUnion$U@@4
                                     Maps._default.IMapUnion$T@@4
                                     ($LS $ly@@297)
                                     (Lit |mapa#0@@40|)
                                     (Lit |mapb#0@@40|))
                                   (Maps.__default.IMapUnionPreferA
                                     Maps._default.IMapUnion$U@@4
                                     Maps._default.IMapUnion$T@@4
                                     StartFuel_Maps._default.IMapUnionPreferA
                                     (Lit |mapa#0@@40|)
                                     (Lit |mapb#0@@40|))))))
                  (=> (and (= (type Maps._default.IMapUnion$U@@4) TyType)
                           (= (type Maps._default.IMapUnion$T@@4) TyType)
                           (= (type $ly@@297) LayerTypeType)
                           (= (type |mapa#0@@40|) (IMapType BoxType BoxType))
                           (= (type |mapb#0@@40|) (IMapType BoxType BoxType))
                           a!1)
                      a!2))
                :pattern ((Maps.__default.IMapUnion
                            Maps._default.IMapUnion$U@@4
                            Maps._default.IMapUnion$T@@4
                            ($LS $ly@@297)
                            (Lit |mapa#0@@40|)
                            (Lit |mapb#0@@40|)))
                :weight 3
                :skolemid |2711|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@520 T@U)
         (arg1@@256 T@U)
         (arg2@@150 T@U)
         (arg3@@91 T@U)
         (arg4@@56 T@U)
         (arg5@@21 T@U))
  (! (= (type (Maps.__default.MapDisjointUnion3
                arg0@@520
                arg1@@256
                arg2@@150
                arg3@@91
                arg4@@56
                arg5@@21))
        (MapType BoxType BoxType))
     :pattern ((Maps.__default.MapDisjointUnion3
                 arg0@@520
                 arg1@@256
                 arg2@@150
                 arg3@@91
                 arg4@@56
                 arg5@@21))
     :qid |funType:Maps.__default.MapDisjointUnion3|)))
(assert (forall ((Maps._default.MapDisjointUnion3$U T@U)
         (Maps._default.MapDisjointUnion3$T T@U)
         ($ly@@298 T@U)
         (|mapa#0@@41| T@U)
         (|mapb#0@@41| T@U)
         (|mapc#0| T@U))
  (! (=> (and (= (type Maps._default.MapDisjointUnion3$U) TyType)
              (= (type Maps._default.MapDisjointUnion3$T) TyType)
              (= (type $ly@@298) LayerTypeType)
              (= (type |mapa#0@@41|) (MapType BoxType BoxType))
              (= (type |mapb#0@@41|) (MapType BoxType BoxType))
              (= (type |mapc#0|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapDisjointUnion3
              Maps._default.MapDisjointUnion3$U
              Maps._default.MapDisjointUnion3$T
              ($LS $ly@@298)
              |mapa#0@@41|
              |mapb#0@@41|
              |mapc#0|)
            (Maps.__default.MapDisjointUnion3
              Maps._default.MapDisjointUnion3$U
              Maps._default.MapDisjointUnion3$T
              $ly@@298
              |mapa#0@@41|
              |mapb#0@@41|
              |mapc#0|)))
     :pattern ((Maps.__default.MapDisjointUnion3
                 Maps._default.MapDisjointUnion3$U
                 Maps._default.MapDisjointUnion3$T
                 ($LS $ly@@298)
                 |mapa#0@@41|
                 |mapb#0@@41|
                 |mapc#0|))
     :skolemid |2712|
     :qid |unknown.0:0|)))
(assert (forall ((Maps._default.MapDisjointUnion3$U@@0 T@U)
         (Maps._default.MapDisjointUnion3$T@@0 T@U)
         ($ly@@299 T@U)
         (|mapa#0@@42| T@U)
         (|mapb#0@@42| T@U)
         (|mapc#0@@0| T@U))
  (! (=> (and (= (type Maps._default.MapDisjointUnion3$U@@0) TyType)
              (= (type Maps._default.MapDisjointUnion3$T@@0) TyType)
              (= (type $ly@@299) LayerTypeType)
              (= (type |mapa#0@@42|) (MapType BoxType BoxType))
              (= (type |mapb#0@@42|) (MapType BoxType BoxType))
              (= (type |mapc#0@@0|) (MapType BoxType BoxType)))
         (= (Maps.__default.MapDisjointUnion3
              Maps._default.MapDisjointUnion3$U@@0
              Maps._default.MapDisjointUnion3$T@@0
              $ly@@299
              |mapa#0@@42|
              |mapb#0@@42|
              |mapc#0@@0|)
            (Maps.__default.MapDisjointUnion3
              Maps._default.MapDisjointUnion3$U@@0
              Maps._default.MapDisjointUnion3$T@@0
              $LZ
              |mapa#0@@42|
              |mapb#0@@42|
              |mapc#0@@0|)))
     :pattern ((Maps.__default.MapDisjointUnion3
                 Maps._default.MapDisjointUnion3$U@@0
                 Maps._default.MapDisjointUnion3$T@@0
                 (AsFuelBottom $ly@@299)
                 |mapa#0@@42|
                 |mapb#0@@42|
                 |mapc#0@@0|))
     :skolemid |2713|
     :qid |unknown.0:0|)))
(assert (= (type StartFuel_Maps._default.MapDisjointUnion) LayerTypeType))
(assert (let ((a!1 (forall ((Maps._default.MapDisjointUnion3$U@@1 T@U)
                    (Maps._default.MapDisjointUnion3$T@@1 T@U)
                    ($ly@@300 T@U)
                    (|mapa#0@@43| T@U)
                    (|mapb#0@@43| T@U)
                    (|mapc#0@@1| T@U))
             (! (let ((a!1 (and ($Is |mapa#0@@43|
                                     (TMap Maps._default.MapDisjointUnion3$U@@1
                                           Maps._default.MapDisjointUnion3$T@@1))
                                ($Is |mapb#0@@43|
                                     (TMap Maps._default.MapDisjointUnion3$U@@1
                                           Maps._default.MapDisjointUnion3$T@@1))
                                ($Is |mapc#0@@1|
                                     (TMap Maps._default.MapDisjointUnion3$U@@1
                                           Maps._default.MapDisjointUnion3$T@@1))
                                (|Set#Disjoint| (|Map#Domain| |mapa#0@@43|)
                                                (|Map#Domain| |mapb#0@@43|))
                                (|Set#Disjoint| (|Map#Domain| |mapa#0@@43|)
                                                (|Map#Domain| |mapb#0@@43|))
                                (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@43|)
                                                             (|Map#Domain| |mapb#0@@43|))
                                                (|Map#Domain| |mapc#0@@1|))))
                      (a!2 (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion3
                                                        Maps._default.MapDisjointUnion3$U@@1
                                                        Maps._default.MapDisjointUnion3$T@@1
                                                        $ly@@300
                                                        |mapa#0@@43|
                                                        |mapb#0@@43|
                                                        |mapc#0@@1|))
                                        (|Set#Union| (|Set#Union| (|Map#Domain| |mapa#0@@43|)
                                                                  (|Map#Domain| |mapb#0@@43|))
                                                     (|Map#Domain| |mapc#0@@1|))))
                      (a!3 (or (not (|Set#Equal| (|Map#Domain| |mapa#0@@43|)
                                                 (|Set#Empty| BoxType)))
                               (not (|Set#Equal| (|Map#Domain| |mapb#0@@43|)
                                                 (|Set#Empty| BoxType)))
                               (not (|Set#Equal| (|Map#Domain| |mapc#0@@1|)
                                                 (|Set#Empty| BoxType)))))
                      (a!4 (not (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion3
                                                             Maps._default.MapDisjointUnion3$U@@1
                                                             Maps._default.MapDisjointUnion3$T@@1
                                                             $ly@@300
                                                             |mapa#0@@43|
                                                             |mapb#0@@43|
                                                             |mapc#0@@1|))
                                             (|Set#Empty| BoxType))))
                      (a!5 (forall ((|k#0@@67| T@U))
                             (! (let ((a!1 (and (and (= (type |k#0@@67|)
                                                        BoxType)
                                                     ($IsBox |k#0@@67|
                                                             Maps._default.MapDisjointUnion3$U@@1))
                                                (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@43|)
                                                                          |k#0@@67|))))
                                      (a!2 (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3
                                                                             Maps._default.MapDisjointUnion3$U@@1
                                                                             Maps._default.MapDisjointUnion3$T@@1
                                                                             $ly@@300
                                                                             |mapa#0@@43|
                                                                             |mapb#0@@43|
                                                                             |mapc#0@@1|))
                                                           |k#0@@67|)))
                                  (=> a!1
                                      (= (MapType0Select (|Map#Elements| |mapa#0@@43|)
                                                         |k#0@@67|)
                                         a!2)))
                                :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3
                                                                            Maps._default.MapDisjointUnion3$U@@1
                                                                            Maps._default.MapDisjointUnion3$T@@1
                                                                            $ly@@300
                                                                            |mapa#0@@43|
                                                                            |mapb#0@@43|
                                                                            |mapc#0@@1|))
                                                          |k#0@@67|))
                                :pattern ((MapType0Select (|Map#Elements| |mapa#0@@43|)
                                                          |k#0@@67|))
                                :pattern ((MapType0Select (|Map#Domain| |mapa#0@@43|)
                                                          |k#0@@67|))
                                :skolemid |2714|
                                :qid |Mapsidfy.205:18|)))
                      (a!6 (forall ((|k#1@@9| T@U))
                             (! (let ((a!1 (and (and (= (type |k#1@@9|) BoxType)
                                                     ($IsBox |k#1@@9|
                                                             Maps._default.MapDisjointUnion3$U@@1))
                                                (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@43|)
                                                                          |k#1@@9|))))
                                      (a!2 (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3
                                                                             Maps._default.MapDisjointUnion3$U@@1
                                                                             Maps._default.MapDisjointUnion3$T@@1
                                                                             $ly@@300
                                                                             |mapa#0@@43|
                                                                             |mapb#0@@43|
                                                                             |mapc#0@@1|))
                                                           |k#1@@9|)))
                                  (=> a!1
                                      (= (MapType0Select (|Map#Elements| |mapb#0@@43|)
                                                         |k#1@@9|)
                                         a!2)))
                                :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3
                                                                            Maps._default.MapDisjointUnion3$U@@1
                                                                            Maps._default.MapDisjointUnion3$T@@1
                                                                            $ly@@300
                                                                            |mapa#0@@43|
                                                                            |mapb#0@@43|
                                                                            |mapc#0@@1|))
                                                          |k#1@@9|))
                                :pattern ((MapType0Select (|Map#Elements| |mapb#0@@43|)
                                                          |k#1@@9|))
                                :pattern ((MapType0Select (|Map#Domain| |mapb#0@@43|)
                                                          |k#1@@9|))
                                :skolemid |2715|
                                :qid |Mapsidfy.206:18|)))
                      (a!7 (forall ((|k#2@@5| T@U))
                             (! (let ((a!1 (and (and (= (type |k#2@@5|) BoxType)
                                                     ($IsBox |k#2@@5|
                                                             Maps._default.MapDisjointUnion3$U@@1))
                                                (U_2_bool (MapType0Select (|Map#Domain| |mapc#0@@1|)
                                                                          |k#2@@5|))))
                                      (a!2 (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3
                                                                             Maps._default.MapDisjointUnion3$U@@1
                                                                             Maps._default.MapDisjointUnion3$T@@1
                                                                             $ly@@300
                                                                             |mapa#0@@43|
                                                                             |mapb#0@@43|
                                                                             |mapc#0@@1|))
                                                           |k#2@@5|)))
                                  (=> a!1
                                      (= (MapType0Select (|Map#Elements| |mapc#0@@1|)
                                                         |k#2@@5|)
                                         a!2)))
                                :pattern ((MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3
                                                                            Maps._default.MapDisjointUnion3$U@@1
                                                                            Maps._default.MapDisjointUnion3$T@@1
                                                                            $ly@@300
                                                                            |mapa#0@@43|
                                                                            |mapb#0@@43|
                                                                            |mapc#0@@1|))
                                                          |k#2@@5|))
                                :pattern ((MapType0Select (|Map#Elements| |mapc#0@@1|)
                                                          |k#2@@5|))
                                :pattern ((MapType0Select (|Map#Domain| |mapc#0@@1|)
                                                          |k#2@@5|))
                                :skolemid |2716|
                                :qid |Mapsidfy.207:18|)))
                      (a!8 (Maps.__default.MapDisjointUnion
                             Maps._default.MapDisjointUnion3$U@@1
                             Maps._default.MapDisjointUnion3$T@@1
                             StartFuel_Maps._default.MapDisjointUnion
                             |mapa#0@@43|
                             (Maps.__default.MapDisjointUnion
                               Maps._default.MapDisjointUnion3$U@@1
                               Maps._default.MapDisjointUnion3$T@@1
                               StartFuel_Maps._default.MapDisjointUnion
                               |mapb#0@@43|
                               |mapc#0@@1|))))
                (let ((a!9 (and a!2
                                (=> a!3 a!4)
                                a!5
                                a!6
                                a!7
                                (|Map#Equal| (Maps.__default.MapDisjointUnion3
                                               Maps._default.MapDisjointUnion3$U@@1
                                               Maps._default.MapDisjointUnion3$T@@1
                                               $ly@@300
                                               |mapa#0@@43|
                                               |mapb#0@@43|
                                               |mapc#0@@1|)
                                             a!8)
                                (|Map#Equal| a!8
                                             (Maps.__default.MapDisjointUnion
                                               Maps._default.MapDisjointUnion3$U@@1
                                               Maps._default.MapDisjointUnion3$T@@1
                                               StartFuel_Maps._default.MapDisjointUnion
                                               (Maps.__default.MapDisjointUnion
                                                 Maps._default.MapDisjointUnion3$U@@1
                                                 Maps._default.MapDisjointUnion3$T@@1
                                                 StartFuel_Maps._default.MapDisjointUnion
                                                 |mapa#0@@43|
                                                 |mapb#0@@43|)
                                               |mapc#0@@1|))
                                ($Is (Maps.__default.MapDisjointUnion3
                                       Maps._default.MapDisjointUnion3$U@@1
                                       Maps._default.MapDisjointUnion3$T@@1
                                       $ly@@300
                                       |mapa#0@@43|
                                       |mapb#0@@43|
                                       |mapc#0@@1|)
                                     (TMap Maps._default.MapDisjointUnion3$U@@1
                                           Maps._default.MapDisjointUnion3$T@@1)))))
                  (=> (and (= (type Maps._default.MapDisjointUnion3$U@@1)
                              TyType)
                           (= (type Maps._default.MapDisjointUnion3$T@@1)
                              TyType)
                           (= (type $ly@@300) LayerTypeType)
                           (= (type |mapa#0@@43|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@43|) (MapType BoxType BoxType))
                           (= (type |mapc#0@@1|) (MapType BoxType BoxType))
                           (or (|Maps.__default.MapDisjointUnion3#canCall|
                                 Maps._default.MapDisjointUnion3$U@@1
                                 Maps._default.MapDisjointUnion3$T@@1
                                 |mapa#0@@43|
                                 |mapb#0@@43|
                                 |mapc#0@@1|)
                               a!1))
                      a!9)))
                :pattern ((Maps.__default.MapDisjointUnion3
                            Maps._default.MapDisjointUnion3$U@@1
                            Maps._default.MapDisjointUnion3$T@@1
                            $ly@@300
                            |mapa#0@@43|
                            |mapb#0@@43|
                            |mapc#0@@1|))
                :skolemid |2717|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapDisjointUnion3$U@@2 T@U)
         (Maps._default.MapDisjointUnion3$T@@2 T@U)
         ($ly@@301 T@U)
         (|mapa#0@@44| T@U)
         (|mapb#0@@44| T@U)
         (|mapc#0@@2| T@U))
  (! (let ((a!1 (and (|Set#Disjoint| (|Map#Domain| |mapa#0@@44|)
                                     (|Map#Domain| |mapb#0@@44|))
                     (|Set#Disjoint| (|Map#Domain| |mapa#0@@44|)
                                     (|Map#Domain| |mapb#0@@44|))
                     (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@44|)
                                                  (|Map#Domain| |mapb#0@@44|))
                                     (|Map#Domain| |mapc#0@@2|)))))
       (=> (and (= (type Maps._default.MapDisjointUnion3$U@@2) TyType)
                (= (type Maps._default.MapDisjointUnion3$T@@2) TyType)
                (= (type $ly@@301) LayerTypeType)
                (= (type |mapa#0@@44|) (MapType BoxType BoxType))
                (= (type |mapb#0@@44|) (MapType BoxType BoxType))
                (= (type |mapc#0@@2|) (MapType BoxType BoxType))
                ($Is |mapa#0@@44|
                     (TMap Maps._default.MapDisjointUnion3$U@@2
                           Maps._default.MapDisjointUnion3$T@@2))
                ($Is |mapb#0@@44|
                     (TMap Maps._default.MapDisjointUnion3$U@@2
                           Maps._default.MapDisjointUnion3$T@@2))
                ($Is |mapc#0@@2|
                     (TMap Maps._default.MapDisjointUnion3$U@@2
                           Maps._default.MapDisjointUnion3$T@@2)))
           (= (|Maps.__default.MapDisjointUnion3#requires|
                Maps._default.MapDisjointUnion3$U@@2
                Maps._default.MapDisjointUnion3$T@@2
                $ly@@301
                |mapa#0@@44|
                |mapb#0@@44|
                |mapc#0@@2|)
              a!1)))
     :pattern ((|Maps.__default.MapDisjointUnion3#requires|
                 Maps._default.MapDisjointUnion3$U@@2
                 Maps._default.MapDisjointUnion3$T@@2
                 $ly@@301
                 |mapa#0@@44|
                 |mapb#0@@44|
                 |mapc#0@@2|))
     :skolemid |2718|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@521 T@U)
         (arg1@@257 T@U)
         (arg2@@151 T@U)
         (arg3@@92 T@U)
         (arg4@@57 T@U))
  (! (= (type (|lambda#204| arg0@@521 arg1@@257 arg2@@151 arg3@@92 arg4@@57))
        (MapType0Type BoxType BoxType))
     :pattern ((|lambda#204| arg0@@521 arg1@@257 arg2@@151 arg3@@92 arg4@@57))
     :qid |funType:lambda#204|)))
(assert (let ((a!1 (forall ((Maps._default.MapDisjointUnion3$U@@3 T@U)
                    (Maps._default.MapDisjointUnion3$T@@3 T@U)
                    ($ly@@302 T@U)
                    (|mapa#0@@45| T@U)
                    (|mapb#0@@45| T@U)
                    (|mapc#0@@3| T@U))
             (! (let ((a!1 (and ($Is |mapa#0@@45|
                                     (TMap Maps._default.MapDisjointUnion3$U@@3
                                           Maps._default.MapDisjointUnion3$T@@3))
                                ($Is |mapb#0@@45|
                                     (TMap Maps._default.MapDisjointUnion3$U@@3
                                           Maps._default.MapDisjointUnion3$T@@3))
                                ($Is |mapc#0@@3|
                                     (TMap Maps._default.MapDisjointUnion3$U@@3
                                           Maps._default.MapDisjointUnion3$T@@3))
                                (|Set#Disjoint| (|Map#Domain| |mapa#0@@45|)
                                                (|Map#Domain| |mapb#0@@45|))
                                (|Set#Disjoint| (|Map#Domain| |mapa#0@@45|)
                                                (|Map#Domain| |mapb#0@@45|))
                                (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@45|)
                                                             (|Map#Domain| |mapb#0@@45|))
                                                (|Map#Domain| |mapc#0@@3|))))
                      (a!2 (|lambda#106| Maps._default.MapDisjointUnion3$U@@3
                                         (|Set#Union| (|Set#Union| (|Map#Domain| |mapa#0@@45|)
                                                                   (|Map#Domain| |mapb#0@@45|))
                                                      (|Map#Domain| |mapc#0@@3|)))))
                (let ((a!3 (= (Maps.__default.MapDisjointUnion3
                                Maps._default.MapDisjointUnion3$U@@3
                                Maps._default.MapDisjointUnion3$T@@3
                                ($LS $ly@@302)
                                |mapa#0@@45|
                                |mapb#0@@45|
                                |mapc#0@@3|)
                              (|Map#Glue| a!2
                                          (|lambda#204| (|Map#Domain| |mapa#0@@45|)
                                                        (|Map#Elements| |mapa#0@@45|)
                                                        (|Map#Domain| |mapb#0@@45|)
                                                        (|Map#Elements| |mapb#0@@45|)
                                                        (|Map#Elements| |mapc#0@@3|))
                                          (TMap Maps._default.MapDisjointUnion3$U@@3
                                                Maps._default.MapDisjointUnion3$T@@3)))))
                  (=> (and (= (type Maps._default.MapDisjointUnion3$U@@3)
                              TyType)
                           (= (type Maps._default.MapDisjointUnion3$T@@3)
                              TyType)
                           (= (type $ly@@302) LayerTypeType)
                           (= (type |mapa#0@@45|) (MapType BoxType BoxType))
                           (= (type |mapb#0@@45|) (MapType BoxType BoxType))
                           (= (type |mapc#0@@3|) (MapType BoxType BoxType))
                           (or (|Maps.__default.MapDisjointUnion3#canCall|
                                 Maps._default.MapDisjointUnion3$U@@3
                                 Maps._default.MapDisjointUnion3$T@@3
                                 |mapa#0@@45|
                                 |mapb#0@@45|
                                 |mapc#0@@3|)
                               a!1))
                      a!3)))
                :pattern ((Maps.__default.MapDisjointUnion3
                            Maps._default.MapDisjointUnion3$U@@3
                            Maps._default.MapDisjointUnion3$T@@3
                            ($LS $ly@@302)
                            |mapa#0@@45|
                            |mapb#0@@45|
                            |mapc#0@@3|))
                :skolemid |2719|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapDisjointUnion3$U@@4 T@U)
                    (Maps._default.MapDisjointUnion3$T@@4 T@U)
                    ($ly@@303 T@U)
                    (|mapa#0@@46| T@U)
                    (|mapb#0@@46| T@U)
                    (|mapc#0@@4| T@U))
             (! (let ((a!1 (|Set#Disjoint| (|Set#Union| (|Map#Domain| (Lit |mapa#0@@46|))
                                                        (|Map#Domain| (Lit |mapb#0@@46|)))
                                           (|Map#Domain| (Lit |mapc#0@@4|))))
                      (a!4 (|Set#Union| (|Set#Union| (|Map#Domain| (Lit |mapa#0@@46|))
                                                     (|Map#Domain| (Lit |mapb#0@@46|)))
                                        (|Map#Domain| (Lit |mapc#0@@4|)))))
                (let ((a!2 (and ($Is |mapa#0@@46|
                                     (TMap Maps._default.MapDisjointUnion3$U@@4
                                           Maps._default.MapDisjointUnion3$T@@4))
                                ($Is |mapb#0@@46|
                                     (TMap Maps._default.MapDisjointUnion3$U@@4
                                           Maps._default.MapDisjointUnion3$T@@4))
                                ($Is |mapc#0@@4|
                                     (TMap Maps._default.MapDisjointUnion3$U@@4
                                           Maps._default.MapDisjointUnion3$T@@4))
                                (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@46|))
                                                (|Map#Domain| (Lit |mapb#0@@46|)))
                                (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@46|))
                                                (|Map#Domain| (Lit |mapb#0@@46|)))
                                a!1))
                      (a!5 (|Map#Glue| (|lambda#106| Maps._default.MapDisjointUnion3$U@@4
                                                     a!4)
                                       (|lambda#204| (|Map#Domain| |mapa#0@@46|)
                                                     (|Map#Elements| (Lit |mapa#0@@46|))
                                                     (|Map#Domain| |mapb#0@@46|)
                                                     (|Map#Elements| (Lit |mapb#0@@46|))
                                                     (|Map#Elements| (Lit |mapc#0@@4|)))
                                       (TMap Maps._default.MapDisjointUnion3$U@@4
                                             Maps._default.MapDisjointUnion3$T@@4))))
                (let ((a!3 (and (= (type Maps._default.MapDisjointUnion3$U@@4)
                                   TyType)
                                (= (type Maps._default.MapDisjointUnion3$T@@4)
                                   TyType)
                                (= (type $ly@@303) LayerTypeType)
                                (= (type |mapa#0@@46|)
                                   (MapType BoxType BoxType))
                                (= (type |mapb#0@@46|)
                                   (MapType BoxType BoxType))
                                (= (type |mapc#0@@4|) (MapType BoxType BoxType))
                                (or (|Maps.__default.MapDisjointUnion3#canCall|
                                      Maps._default.MapDisjointUnion3$U@@4
                                      Maps._default.MapDisjointUnion3$T@@4
                                      (Lit |mapa#0@@46|)
                                      (Lit |mapb#0@@46|)
                                      (Lit |mapc#0@@4|))
                                    a!2))))
                  (=> a!3
                      (= (Maps.__default.MapDisjointUnion3
                           Maps._default.MapDisjointUnion3$U@@4
                           Maps._default.MapDisjointUnion3$T@@4
                           ($LS $ly@@303)
                           (Lit |mapa#0@@46|)
                           (Lit |mapb#0@@46|)
                           (Lit |mapc#0@@4|))
                         a!5)))))
                :pattern ((Maps.__default.MapDisjointUnion3
                            Maps._default.MapDisjointUnion3$U@@4
                            Maps._default.MapDisjointUnion3$T@@4
                            ($LS $ly@@303)
                            (Lit |mapa#0@@46|)
                            (Lit |mapb#0@@46|)
                            (Lit |mapc#0@@4|)))
                :weight 3
                :skolemid |2720|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@522 T@U) (arg1@@258 T@U) (arg2@@152 T@U))
  (! (= (type (Maps.__default.MapToImap arg0@@522 arg1@@258 arg2@@152))
        (IMapType BoxType BoxType))
     :pattern ((Maps.__default.MapToImap arg0@@522 arg1@@258 arg2@@152))
     :qid |funType:Maps.__default.MapToImap|)))
(assert (let ((a!1 (forall ((Maps._default.MapToImap$K T@U)
                    (Maps._default.MapToImap$V T@U)
                    (|m#0@@97| T@U))
             (! (let ((a!1 (and (= (type Maps._default.MapToImap$K) TyType)
                                (= (type Maps._default.MapToImap$V) TyType)
                                (= (type |m#0@@97|) (MapType BoxType BoxType))
                                (or (|Maps.__default.MapToImap#canCall|
                                      Maps._default.MapToImap$K
                                      Maps._default.MapToImap$V
                                      |m#0@@97|)
                                    ($Is |m#0@@97|
                                         (TMap Maps._default.MapToImap$K
                                               Maps._default.MapToImap$V))))))
                  (=> a!1
                      ($Is (Maps.__default.MapToImap
                             Maps._default.MapToImap$K
                             Maps._default.MapToImap$V
                             |m#0@@97|)
                           (TIMap Maps._default.MapToImap$K
                                  Maps._default.MapToImap$V))))
                :pattern ((Maps.__default.MapToImap
                            Maps._default.MapToImap$K
                            Maps._default.MapToImap$V
                            |m#0@@97|))
                :skolemid |2721|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapToImap$K@@0 T@U)
         (Maps._default.MapToImap$V@@0 T@U)
         (|m#0@@98| T@U))
  (! (=> (and (= (type Maps._default.MapToImap$K@@0) TyType)
              (= (type Maps._default.MapToImap$V@@0) TyType)
              (= (type |m#0@@98|) (MapType BoxType BoxType))
              ($Is |m#0@@98|
                   (TMap Maps._default.MapToImap$K@@0
                         Maps._default.MapToImap$V@@0)))
         (= (|Maps.__default.MapToImap#requires|
              Maps._default.MapToImap$K@@0
              Maps._default.MapToImap$V@@0
              |m#0@@98|)
            true))
     :pattern ((|Maps.__default.MapToImap#requires|
                 Maps._default.MapToImap$K@@0
                 Maps._default.MapToImap$V@@0
                 |m#0@@98|))
     :skolemid |2722|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((Maps._default.MapToImap$K@@1 T@U)
             (Maps._default.MapToImap$V@@1 T@U)
             (|m#0@@99| T@U))
      (! (let ((a!1 (and (= (type Maps._default.MapToImap$K@@1) TyType)
                         (= (type Maps._default.MapToImap$V@@1) TyType)
                         (= (type |m#0@@99|) (MapType BoxType BoxType))
                         (or (|Maps.__default.MapToImap#canCall|
                               Maps._default.MapToImap$K@@1
                               Maps._default.MapToImap$V@@1
                               |m#0@@99|)
                             ($Is |m#0@@99|
                                  (TMap Maps._default.MapToImap$K@@1
                                        Maps._default.MapToImap$V@@1)))))
               (a!2 (= (Maps.__default.MapToImap
                         Maps._default.MapToImap$K@@1
                         Maps._default.MapToImap$V@@1
                         |m#0@@99|)
                       (|IMap#Glue| (|lambda#106| Maps._default.MapToImap$K@@1
                                                  (|Map#Domain| |m#0@@99|))
                                    (|lambda#148| (|Map#Elements| |m#0@@99|))
                                    (TIMap Maps._default.MapToImap$K@@1
                                           Maps._default.MapToImap$V@@1)))))
           (=> a!1 a!2))
         :pattern ((Maps.__default.MapToImap
                     Maps._default.MapToImap$K@@1
                     Maps._default.MapToImap$V@@1
                     |m#0@@99|))
         :skolemid |2723|
         :qid |unknown.0:0|))))
(assert (let ((a!1 (forall ((Maps._default.MapToImap$K@@2 T@U)
                    (Maps._default.MapToImap$V@@2 T@U)
                    (|m#0@@100| T@U))
             (! (let ((a!1 (and (= (type Maps._default.MapToImap$K@@2) TyType)
                                (= (type Maps._default.MapToImap$V@@2) TyType)
                                (= (type |m#0@@100|) (MapType BoxType BoxType))
                                (or (|Maps.__default.MapToImap#canCall|
                                      Maps._default.MapToImap$K@@2
                                      Maps._default.MapToImap$V@@2
                                      (Lit |m#0@@100|))
                                    ($Is |m#0@@100|
                                         (TMap Maps._default.MapToImap$K@@2
                                               Maps._default.MapToImap$V@@2)))))
                      (a!2 (|IMap#Glue| (|lambda#106| Maps._default.MapToImap$K@@2
                                                      (|Map#Domain| |m#0@@100|))
                                        (|lambda#148| (|Map#Elements| (Lit |m#0@@100|)))
                                        (TIMap Maps._default.MapToImap$K@@2
                                               Maps._default.MapToImap$V@@2))))
                  (=> a!1
                      (= (Maps.__default.MapToImap
                           Maps._default.MapToImap$K@@2
                           Maps._default.MapToImap$V@@2
                           (Lit |m#0@@100|))
                         a!2)))
                :pattern ((Maps.__default.MapToImap
                            Maps._default.MapToImap$K@@2
                            Maps._default.MapToImap$V@@2
                            (Lit |m#0@@100|)))
                :weight 3
                :skolemid |2724|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@523 T@U) (arg1@@259 T@U) (arg2@@153 T@U) (arg3@@93 T@U))
  (! (= (type (Maps.__default.MapLookupOption
                arg0@@523
                arg1@@259
                arg2@@153
                arg3@@93))
        DatatypeTypeType)
     :pattern ((Maps.__default.MapLookupOption
                 arg0@@523
                 arg1@@259
                 arg2@@153
                 arg3@@93))
     :qid |funType:Maps.__default.MapLookupOption|)))
(assert (let ((a!1 (forall ((Maps._default.MapLookupOption$K T@U)
                    (Maps._default.MapLookupOption$V T@U)
                    (|m#0@@101| T@U)
                    (|key#0@@19| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapLookupOption#canCall|
                                 Maps._default.MapLookupOption$K
                                 Maps._default.MapLookupOption$V
                                 |m#0@@101|
                                 |key#0@@19|)
                               (and ($Is |m#0@@101|
                                         (TMap Maps._default.MapLookupOption$K
                                               Maps._default.MapLookupOption$V))
                                    ($IsBox |key#0@@19|
                                            Maps._default.MapLookupOption$K)))))
                  (=> (and (= (type Maps._default.MapLookupOption$K) TyType)
                           (= (type Maps._default.MapLookupOption$V) TyType)
                           (= (type |m#0@@101|) (MapType BoxType BoxType))
                           (= (type |key#0@@19|) BoxType)
                           a!1)
                      ($Is (Maps.__default.MapLookupOption
                             Maps._default.MapLookupOption$K
                             Maps._default.MapLookupOption$V
                             |m#0@@101|
                             |key#0@@19|)
                           (Tclass.Options.Option
                             Maps._default.MapLookupOption$V))))
                :pattern ((Maps.__default.MapLookupOption
                            Maps._default.MapLookupOption$K
                            Maps._default.MapLookupOption$V
                            |m#0@@101|
                            |key#0@@19|))
                :skolemid |2725|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.MapLookupOption$K@@0 T@U)
         (Maps._default.MapLookupOption$V@@0 T@U)
         (|m#0@@102| T@U)
         (|key#0@@20| T@U))
  (! (=> (and (= (type Maps._default.MapLookupOption$K@@0) TyType)
              (= (type Maps._default.MapLookupOption$V@@0) TyType)
              (= (type |m#0@@102|) (MapType BoxType BoxType))
              (= (type |key#0@@20|) BoxType)
              ($Is |m#0@@102|
                   (TMap Maps._default.MapLookupOption$K@@0
                         Maps._default.MapLookupOption$V@@0))
              ($IsBox |key#0@@20| Maps._default.MapLookupOption$K@@0))
         (= (|Maps.__default.MapLookupOption#requires|
              Maps._default.MapLookupOption$K@@0
              Maps._default.MapLookupOption$V@@0
              |m#0@@102|
              |key#0@@20|)
            true))
     :pattern ((|Maps.__default.MapLookupOption#requires|
                 Maps._default.MapLookupOption$K@@0
                 Maps._default.MapLookupOption$V@@0
                 |m#0@@102|
                 |key#0@@20|))
     :skolemid |2726|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.MapLookupOption$K@@1 T@U)
                    (Maps._default.MapLookupOption$V@@1 T@U)
                    (|m#0@@103| T@U)
                    (|key#0@@21| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapLookupOption#canCall|
                                 Maps._default.MapLookupOption$K@@1
                                 Maps._default.MapLookupOption$V@@1
                                 |m#0@@103|
                                 |key#0@@21|)
                               (and ($Is |m#0@@103|
                                         (TMap Maps._default.MapLookupOption$K@@1
                                               Maps._default.MapLookupOption$V@@1))
                                    ($IsBox |key#0@@21|
                                            Maps._default.MapLookupOption$K@@1))))
                      (a!2 (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@103|)
                                                          |key#0@@21|))
                                (|#Options.Option.Some|
                                  (MapType0Select (|Map#Elements| |m#0@@103|)
                                                  |key#0@@21|))
                                |#Options.Option.None|)))
                  (=> (and (= (type Maps._default.MapLookupOption$K@@1) TyType)
                           (= (type Maps._default.MapLookupOption$V@@1) TyType)
                           (= (type |m#0@@103|) (MapType BoxType BoxType))
                           (= (type |key#0@@21|) BoxType)
                           a!1)
                      (= (Maps.__default.MapLookupOption
                           Maps._default.MapLookupOption$K@@1
                           Maps._default.MapLookupOption$V@@1
                           |m#0@@103|
                           |key#0@@21|)
                         a!2)))
                :pattern ((Maps.__default.MapLookupOption
                            Maps._default.MapLookupOption$K@@1
                            Maps._default.MapLookupOption$V@@1
                            |m#0@@103|
                            |key#0@@21|))
                :skolemid |2727|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapLookupOption$K@@2 T@U)
                    (Maps._default.MapLookupOption$V@@2 T@U)
                    (|m#0@@104| T@U)
                    (|key#0@@22| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapLookupOption#canCall|
                                 Maps._default.MapLookupOption$K@@2
                                 Maps._default.MapLookupOption$V@@2
                                 (Lit |m#0@@104|)
                                 |key#0@@22|)
                               (and ($Is |m#0@@104|
                                         (TMap Maps._default.MapLookupOption$K@@2
                                               Maps._default.MapLookupOption$V@@2))
                                    ($IsBox |key#0@@22|
                                            Maps._default.MapLookupOption$K@@2))))
                      (a!2 (|#Options.Option.Some|
                             (MapType0Select (|Map#Elements| (Lit |m#0@@104|))
                                             |key#0@@22|))))
                (let ((a!3 (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@104|)
                                                          |key#0@@22|))
                                a!2
                                |#Options.Option.None|)))
                  (=> (and (= (type Maps._default.MapLookupOption$K@@2) TyType)
                           (= (type Maps._default.MapLookupOption$V@@2) TyType)
                           (= (type |m#0@@104|) (MapType BoxType BoxType))
                           (= (type |key#0@@22|) BoxType)
                           a!1)
                      (= (Maps.__default.MapLookupOption
                           Maps._default.MapLookupOption$K@@2
                           Maps._default.MapLookupOption$V@@2
                           (Lit |m#0@@104|)
                           |key#0@@22|)
                         a!3))))
                :pattern ((Maps.__default.MapLookupOption
                            Maps._default.MapLookupOption$K@@2
                            Maps._default.MapLookupOption$V@@2
                            (Lit |m#0@@104|)
                            |key#0@@22|))
                :weight 3
                :skolemid |2728|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.MapLookupOption$K@@3 T@U)
                    (Maps._default.MapLookupOption$V@@3 T@U)
                    (|m#0@@105| T@U)
                    (|key#0@@23| T@U))
             (! (let ((a!1 (or (|Maps.__default.MapLookupOption#canCall|
                                 Maps._default.MapLookupOption$K@@3
                                 Maps._default.MapLookupOption$V@@3
                                 (Lit |m#0@@105|)
                                 (Lit |key#0@@23|))
                               (and ($Is |m#0@@105|
                                         (TMap Maps._default.MapLookupOption$K@@3
                                               Maps._default.MapLookupOption$V@@3))
                                    ($IsBox |key#0@@23|
                                            Maps._default.MapLookupOption$K@@3))))
                      (a!2 (|#Options.Option.Some|
                             (MapType0Select (|Map#Elements| (Lit |m#0@@105|))
                                             (Lit |key#0@@23|)))))
                (let ((a!3 (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@105|)
                                                          |key#0@@23|))
                                a!2
                                |#Options.Option.None|)))
                  (=> (and (= (type Maps._default.MapLookupOption$K@@3) TyType)
                           (= (type Maps._default.MapLookupOption$V@@3) TyType)
                           (= (type |m#0@@105|) (MapType BoxType BoxType))
                           (= (type |key#0@@23|) BoxType)
                           a!1)
                      (= (Maps.__default.MapLookupOption
                           Maps._default.MapLookupOption$K@@3
                           Maps._default.MapLookupOption$V@@3
                           (Lit |m#0@@105|)
                           (Lit |key#0@@23|))
                         a!3))))
                :pattern ((Maps.__default.MapLookupOption
                            Maps._default.MapLookupOption$K@@3
                            Maps._default.MapLookupOption$V@@3
                            (Lit |m#0@@105|)
                            (Lit |key#0@@23|)))
                :weight 3
                :skolemid |2729|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@524 T@U) (arg1@@260 T@U) (arg2@@154 T@U) (arg3@@94 T@U))
  (! (= (type (Maps.__default.ImapLookupOption
                arg0@@524
                arg1@@260
                arg2@@154
                arg3@@94))
        DatatypeTypeType)
     :pattern ((Maps.__default.ImapLookupOption
                 arg0@@524
                 arg1@@260
                 arg2@@154
                 arg3@@94))
     :qid |funType:Maps.__default.ImapLookupOption|)))
(assert (let ((a!1 (forall ((Maps._default.ImapLookupOption$K T@U)
                    (Maps._default.ImapLookupOption$V T@U)
                    (|m#0@@106| T@U)
                    (|key#0@@24| T@U))
             (! (let ((a!1 (or (|Maps.__default.ImapLookupOption#canCall|
                                 Maps._default.ImapLookupOption$K
                                 Maps._default.ImapLookupOption$V
                                 |m#0@@106|
                                 |key#0@@24|)
                               (and ($Is |m#0@@106|
                                         (TIMap Maps._default.ImapLookupOption$K
                                                Maps._default.ImapLookupOption$V))
                                    ($IsBox |key#0@@24|
                                            Maps._default.ImapLookupOption$K)))))
                  (=> (and (= (type Maps._default.ImapLookupOption$K) TyType)
                           (= (type Maps._default.ImapLookupOption$V) TyType)
                           (= (type |m#0@@106|) (IMapType BoxType BoxType))
                           (= (type |key#0@@24|) BoxType)
                           a!1)
                      ($Is (Maps.__default.ImapLookupOption
                             Maps._default.ImapLookupOption$K
                             Maps._default.ImapLookupOption$V
                             |m#0@@106|
                             |key#0@@24|)
                           (Tclass.Options.Option
                             Maps._default.ImapLookupOption$V))))
                :pattern ((Maps.__default.ImapLookupOption
                            Maps._default.ImapLookupOption$K
                            Maps._default.ImapLookupOption$V
                            |m#0@@106|
                            |key#0@@24|))
                :skolemid |2730|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((Maps._default.ImapLookupOption$K@@0 T@U)
         (Maps._default.ImapLookupOption$V@@0 T@U)
         (|m#0@@107| T@U)
         (|key#0@@25| T@U))
  (! (=> (and (= (type Maps._default.ImapLookupOption$K@@0) TyType)
              (= (type Maps._default.ImapLookupOption$V@@0) TyType)
              (= (type |m#0@@107|) (IMapType BoxType BoxType))
              (= (type |key#0@@25|) BoxType)
              ($Is |m#0@@107|
                   (TIMap Maps._default.ImapLookupOption$K@@0
                          Maps._default.ImapLookupOption$V@@0))
              ($IsBox |key#0@@25| Maps._default.ImapLookupOption$K@@0))
         (= (|Maps.__default.ImapLookupOption#requires|
              Maps._default.ImapLookupOption$K@@0
              Maps._default.ImapLookupOption$V@@0
              |m#0@@107|
              |key#0@@25|)
            true))
     :pattern ((|Maps.__default.ImapLookupOption#requires|
                 Maps._default.ImapLookupOption$K@@0
                 Maps._default.ImapLookupOption$V@@0
                 |m#0@@107|
                 |key#0@@25|))
     :skolemid |2731|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((Maps._default.ImapLookupOption$K@@1 T@U)
                    (Maps._default.ImapLookupOption$V@@1 T@U)
                    (|m#0@@108| T@U)
                    (|key#0@@26| T@U))
             (! (let ((a!1 (or (|Maps.__default.ImapLookupOption#canCall|
                                 Maps._default.ImapLookupOption$K@@1
                                 Maps._default.ImapLookupOption$V@@1
                                 |m#0@@108|
                                 |key#0@@26|)
                               (and ($Is |m#0@@108|
                                         (TIMap Maps._default.ImapLookupOption$K@@1
                                                Maps._default.ImapLookupOption$V@@1))
                                    ($IsBox |key#0@@26|
                                            Maps._default.ImapLookupOption$K@@1))))
                      (a!2 (ite (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@108|)
                                                          |key#0@@26|))
                                (|#Options.Option.Some|
                                  (MapType0Select (|IMap#Elements| |m#0@@108|)
                                                  |key#0@@26|))
                                |#Options.Option.None|)))
                  (=> (and (= (type Maps._default.ImapLookupOption$K@@1) TyType)
                           (= (type Maps._default.ImapLookupOption$V@@1) TyType)
                           (= (type |m#0@@108|) (IMapType BoxType BoxType))
                           (= (type |key#0@@26|) BoxType)
                           a!1)
                      (= (Maps.__default.ImapLookupOption
                           Maps._default.ImapLookupOption$K@@1
                           Maps._default.ImapLookupOption$V@@1
                           |m#0@@108|
                           |key#0@@26|)
                         a!2)))
                :pattern ((Maps.__default.ImapLookupOption
                            Maps._default.ImapLookupOption$K@@1
                            Maps._default.ImapLookupOption$V@@1
                            |m#0@@108|
                            |key#0@@26|))
                :skolemid |2732|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((Maps._default.ImapLookupOption$K@@2 T@U)
                    (Maps._default.ImapLookupOption$V@@2 T@U)
                    (|m#0@@109| T@U)
                    (|key#0@@27| T@U))
             (! (let ((a!1 (or (|Maps.__default.ImapLookupOption#canCall|
                                 Maps._default.ImapLookupOption$K@@2
                                 Maps._default.ImapLookupOption$V@@2
                                 (Lit |m#0@@109|)
                                 (Lit |key#0@@27|))
                               (and ($Is |m#0@@109|
                                         (TIMap Maps._default.ImapLookupOption$K@@2
                                                Maps._default.ImapLookupOption$V@@2))
                                    ($IsBox |key#0@@27|
                                            Maps._default.ImapLookupOption$K@@2))))
                      (a!2 (|#Options.Option.Some|
                             (MapType0Select (|IMap#Elements| (Lit |m#0@@109|))
                                             (Lit |key#0@@27|)))))
                (let ((a!3 (ite (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@109|)
                                                          |key#0@@27|))
                                a!2
                                |#Options.Option.None|)))
                  (=> (and (= (type Maps._default.ImapLookupOption$K@@2) TyType)
                           (= (type Maps._default.ImapLookupOption$V@@2) TyType)
                           (= (type |m#0@@109|) (IMapType BoxType BoxType))
                           (= (type |key#0@@27|) BoxType)
                           a!1)
                      (= (Maps.__default.ImapLookupOption
                           Maps._default.ImapLookupOption$K@@2
                           Maps._default.ImapLookupOption$V@@2
                           (Lit |m#0@@109|)
                           (Lit |key#0@@27|))
                         a!3))))
                :pattern ((Maps.__default.ImapLookupOption
                            Maps._default.ImapLookupOption$K@@2
                            Maps._default.ImapLookupOption$V@@2
                            (Lit |m#0@@109|)
                            (Lit |key#0@@27|)))
                :weight 3
                :skolemid |2733|
                :qid |unknown.0:0|))))
  (=> true a!1)))
(assert (forall ((arg0@@525 T@U) (arg1@@261 T@U))
  (! (= (type (|#MsgHistoryMod.KeyedMessage.KeyedMessage| arg0@@525 arg1@@261))
        DatatypeTypeType)
     :pattern ((|#MsgHistoryMod.KeyedMessage.KeyedMessage| arg0@@525 arg1@@261))
     :qid |funType:#MsgHistoryMod.KeyedMessage.KeyedMessage|)))
(assert (forall ((|a#0#0#0@@2| T@U) (|a#0#1#0@@1| T@U))
  (! (=> (and (= (type |a#0#0#0@@2|) (SeqType BoxType))
              (= (type |a#0#1#0@@1|) DatatypeTypeType))
         (= (DatatypeCtorId (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                              |a#0#0#0@@2|
                              |a#0#1#0@@1|))
            |##MsgHistoryMod.KeyedMessage.KeyedMessage|))
     :pattern ((|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                 |a#0#0#0@@2|
                 |a#0#1#0@@1|))
     :skolemid |2734|
     :qid |MsgHistoryidfy.25:40|)))
(assert (forall ((d@@41 T@U))
  (! (=> (= (type d@@41) DatatypeTypeType)
         (= (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@41)
            (= (DatatypeCtorId d@@41)
               |##MsgHistoryMod.KeyedMessage.KeyedMessage|)))
     :pattern ((MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@41))
     :skolemid |2735|
     :qid |unknown.0:0|)))
(assert (forall ((d@@42 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@2| T@U) (|a#1#1#0@@1| T@U))
                  (! (and (= (type |a#1#0#0@@2|) (SeqType BoxType))
                          (= (type |a#1#1#0@@1|) DatatypeTypeType)
                          (= d@@42
                             (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                               |a#1#0#0@@2|
                               |a#1#1#0@@1|)))
                     :no-pattern (type |a#1#0#0@@2|)
                     :no-pattern (type |a#1#1#0@@1|)
                     :no-pattern (U_2_int |a#1#0#0@@2|)
                     :no-pattern (U_2_bool |a#1#0#0@@2|)
                     :no-pattern (U_2_int |a#1#1#0@@1|)
                     :no-pattern (U_2_bool |a#1#1#0@@1|)
                     :skolemid |2736|
                     :qid |MsgHistoryidfy.25:40|))))
       (=> (and (= (type d@@42) DatatypeTypeType)
                (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@42))
           a!1))
     :pattern ((MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@42))
     :skolemid |2737|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@2| T@U) (|a#2#1#0@@1| T@U))
  (! (=> (and (= (type |a#2#0#0@@2|) (SeqType BoxType))
              (= (type |a#2#1#0@@1|) DatatypeTypeType))
         (= ($Is (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                   |a#2#0#0@@2|
                   |a#2#1#0@@1|)
                 Tclass.MsgHistoryMod.KeyedMessage)
            (and ($Is |a#2#0#0@@2| Tclass.KeyType.Key)
                 ($Is |a#2#1#0@@1| Tclass.ValueMessage.Message))))
     :pattern (($Is (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                      |a#2#0#0@@2|
                      |a#2#1#0@@1|)
                    Tclass.MsgHistoryMod.KeyedMessage))
     :skolemid |2738|
     :qid |MsgHistoryidfy.25:40|)))
(assert (forall ((|a#3#0#0@@2| T@U) (|a#3#1#0@@1| T@U) ($h@@93 T@U))
  (! (=> (and (= (type |a#3#0#0@@2|) (SeqType BoxType))
              (= (type |a#3#1#0@@1|) DatatypeTypeType)
              (= (type $h@@93) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@93))
         (= ($IsAlloc (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                        |a#3#0#0@@2|
                        |a#3#1#0@@1|)
                      Tclass.MsgHistoryMod.KeyedMessage
                      $h@@93)
            (and ($IsAlloc |a#3#0#0@@2| Tclass.KeyType.Key $h@@93)
                 ($IsAlloc |a#3#1#0@@1| Tclass.ValueMessage.Message $h@@93))))
     :pattern (($IsAlloc (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                           |a#3#0#0@@2|
                           |a#3#1#0@@1|)
                         Tclass.MsgHistoryMod.KeyedMessage
                         $h@@93))
     :skolemid |2739|
     :qid |MsgHistoryidfy.25:40|)))
(assert (forall ((arg0@@526 T@U))
  (! (= (type (MsgHistoryMod.KeyedMessage.key arg0@@526)) (SeqType BoxType))
     :pattern ((MsgHistoryMod.KeyedMessage.key arg0@@526))
     :qid |funType:MsgHistoryMod.KeyedMessage.key|)))
(assert (forall ((d@@43 T@U) ($h@@94 T@U))
  (! (=> (and (= (type d@@43) DatatypeTypeType)
              (= (type $h@@94) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@94)
              (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@43)
              ($IsAlloc d@@43 Tclass.MsgHistoryMod.KeyedMessage $h@@94))
         ($IsAlloc (MsgHistoryMod.KeyedMessage.key d@@43)
                   Tclass.KeyType.Key
                   $h@@94))
     :pattern (($IsAlloc (MsgHistoryMod.KeyedMessage.key d@@43)
                         Tclass.KeyType.Key
                         $h@@94))
     :skolemid |2740|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@527 T@U))
  (! (= (type (MsgHistoryMod.KeyedMessage.message arg0@@527)) DatatypeTypeType)
     :pattern ((MsgHistoryMod.KeyedMessage.message arg0@@527))
     :qid |funType:MsgHistoryMod.KeyedMessage.message|)))
(assert (forall ((d@@44 T@U) ($h@@95 T@U))
  (! (=> (and (= (type d@@44) DatatypeTypeType)
              (= (type $h@@95) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@95)
              (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@44)
              ($IsAlloc d@@44 Tclass.MsgHistoryMod.KeyedMessage $h@@95))
         ($IsAlloc (MsgHistoryMod.KeyedMessage.message d@@44)
                   Tclass.ValueMessage.Message
                   $h@@95))
     :pattern (($IsAlloc (MsgHistoryMod.KeyedMessage.message d@@44)
                         Tclass.ValueMessage.Message
                         $h@@95))
     :skolemid |2741|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@2| T@U) (|a#4#1#0@@1| T@U))
  (! (=> (and (= (type |a#4#0#0@@2|) (SeqType BoxType))
              (= (type |a#4#1#0@@1|) DatatypeTypeType))
         (= (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
              (Lit |a#4#0#0@@2|)
              (Lit |a#4#1#0@@1|))
            (Lit (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                   |a#4#0#0@@2|
                   |a#4#1#0@@1|))))
     :pattern ((|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                 (Lit |a#4#0#0@@2|)
                 (Lit |a#4#1#0@@1|)))
     :skolemid |2742|
     :qid |MsgHistoryidfy.25:40|)))
(assert (forall ((|a#5#0#0@@3| T@U) (|a#5#1#0@@1| T@U))
  (! (=> (and (= (type |a#5#0#0@@3|) (SeqType BoxType))
              (= (type |a#5#1#0@@1|) DatatypeTypeType))
         (= (MsgHistoryMod.KeyedMessage.key
              (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                |a#5#0#0@@3|
                |a#5#1#0@@1|))
            |a#5#0#0@@3|))
     :pattern ((|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                 |a#5#0#0@@3|
                 |a#5#1#0@@1|))
     :skolemid |2743|
     :qid |MsgHistoryidfy.25:40|)))
(assert (forall ((|a#6#0#0@@3| T@U) (|a#6#1#0@@1| T@U))
  (! (=> (and (= (type |a#6#0#0@@3|) (SeqType BoxType))
              (= (type |a#6#1#0@@1|) DatatypeTypeType))
         (= (MsgHistoryMod.KeyedMessage.message
              (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                |a#6#0#0@@3|
                |a#6#1#0@@1|))
            |a#6#1#0@@1|))
     :pattern ((|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                 |a#6#0#0@@3|
                 |a#6#1#0@@1|))
     :skolemid |2744|
     :qid |MsgHistoryidfy.25:40|)))
(assert (forall ((|a#7#0#0@@3| T@U) (|a#7#1#0@@1| T@U))
  (! (=> (and (= (type |a#7#0#0@@3|) (SeqType BoxType))
              (= (type |a#7#1#0@@1|) DatatypeTypeType))
         (< (DtRank |a#7#1#0@@1|)
            (DtRank (|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                      |a#7#0#0@@3|
                      |a#7#1#0@@1|))))
     :pattern ((|#MsgHistoryMod.KeyedMessage.KeyedMessage|
                 |a#7#0#0@@3|
                 |a#7#1#0@@1|))
     :skolemid |2745|
     :qid |MsgHistoryidfy.25:40|)))
(assert (forall ((d@@45 T@U))
  (! (=> (and (= (type d@@45) DatatypeTypeType)
              (|$IsA#MsgHistoryMod.KeyedMessage| d@@45))
         (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@45))
     :pattern ((|$IsA#MsgHistoryMod.KeyedMessage| d@@45))
     :skolemid |2746|
     :qid |unknown.0:0|)))
(assert (forall ((d@@46 T@U))
  (! (=> (and (= (type d@@46) DatatypeTypeType)
              ($Is d@@46 Tclass.MsgHistoryMod.KeyedMessage))
         (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@46))
     :pattern ((MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@46)
               ($Is d@@46 Tclass.MsgHistoryMod.KeyedMessage))
     :skolemid |2747|
     :qid |unknown.0:0|)))
(assert (forall ((a@@128 T@U) (b@@78 T@U))
  (! (let ((a!1 (= (|MsgHistoryMod.KeyedMessage#Equal| a@@128 b@@78)
                   (and (|Seq#Equal| (MsgHistoryMod.KeyedMessage.key a@@128)
                                     (MsgHistoryMod.KeyedMessage.key b@@78))
                        (|ValueMessage.Message#Equal|
                          (MsgHistoryMod.KeyedMessage.message a@@128)
                          (MsgHistoryMod.KeyedMessage.message b@@78))))))
       (=> (and (= (type a@@128) DatatypeTypeType)
                (= (type b@@78) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|MsgHistoryMod.KeyedMessage#Equal| a@@128 b@@78))
     :skolemid |2748|
     :qid |unknown.0:0|)))
(assert (forall ((a@@129 T@U) (b@@79 T@U))
  (! (=> (and (= (type a@@129) DatatypeTypeType)
              (= (type b@@79) DatatypeTypeType))
         (= (|MsgHistoryMod.KeyedMessage#Equal| a@@129 b@@79) (= a@@129 b@@79)))
     :pattern ((|MsgHistoryMod.KeyedMessage#Equal| a@@129 b@@79))
     :skolemid |2749|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@528 T@U) (arg1@@262 Int) (arg2@@155 Int))
  (! (= (type (|#MsgHistoryMod.MsgHistory.MsgHistory|
                arg0@@528
                arg1@@262
                arg2@@155))
        DatatypeTypeType)
     :pattern ((|#MsgHistoryMod.MsgHistory.MsgHistory|
                 arg0@@528
                 arg1@@262
                 arg2@@155))
     :qid |funType:#MsgHistoryMod.MsgHistory.MsgHistory|)))
(assert (forall ((|a#8#0#0@@2| T@U) (|a#8#1#0@@0| Int) (|a#8#2#0| Int))
  (! (=> (= (type |a#8#0#0@@2|) (MapType BoxType BoxType))
         (= (DatatypeCtorId (|#MsgHistoryMod.MsgHistory.MsgHistory|
                              |a#8#0#0@@2|
                              |a#8#1#0@@0|
                              |a#8#2#0|))
            |##MsgHistoryMod.MsgHistory.MsgHistory|))
     :pattern ((|#MsgHistoryMod.MsgHistory.MsgHistory|
                 |a#8#0#0@@2|
                 |a#8#1#0@@0|
                 |a#8#2#0|))
     :skolemid |2750|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((d@@47 T@U))
  (! (=> (= (type d@@47) DatatypeTypeType)
         (= (MsgHistoryMod.MsgHistory.MsgHistory_q d@@47)
            (= (DatatypeCtorId d@@47) |##MsgHistoryMod.MsgHistory.MsgHistory|)))
     :pattern ((MsgHistoryMod.MsgHistory.MsgHistory_q d@@47))
     :skolemid |2751|
     :qid |unknown.0:0|)))
(assert (forall ((d@@48 T@U))
  (! (let ((a!1 (exists ((|a#9#0#0@@1| T@U) (|a#9#1#0| Int) (|a#9#2#0| Int))
                  (! (and (= (type |a#9#0#0@@1|) (MapType BoxType BoxType))
                          (= d@@48
                             (|#MsgHistoryMod.MsgHistory.MsgHistory|
                               |a#9#0#0@@1|
                               |a#9#1#0|
                               |a#9#2#0|)))
                     :no-pattern (type |a#9#0#0@@1|)
                     :no-pattern (U_2_int |a#9#0#0@@1|)
                     :no-pattern (U_2_bool |a#9#0#0@@1|)
                     :skolemid |2752|
                     :qid |MsgHistoryidfy.28:36|))))
       (=> (and (= (type d@@48) DatatypeTypeType)
                (MsgHistoryMod.MsgHistory.MsgHistory_q d@@48))
           a!1))
     :pattern ((MsgHistoryMod.MsgHistory.MsgHistory_q d@@48))
     :skolemid |2753|
     :qid |unknown.0:0|)))
(assert (forall ((|a#10#0#0@@1| T@U) (|a#10#1#0| Int) (|a#10#2#0| Int))
  (! (let ((a!1 (= ($Is (|#MsgHistoryMod.MsgHistory.MsgHistory|
                          |a#10#0#0@@1|
                          |a#10#1#0|
                          |a#10#2#0|)
                        Tclass.MsgHistoryMod.MsgHistory)
                   (and ($Is |a#10#0#0@@1|
                             (TMap Tclass._System.nat
                                   Tclass.MsgHistoryMod.KeyedMessage))
                        ($Is (int_2_U |a#10#1#0|) Tclass._System.nat)
                        ($Is (int_2_U |a#10#2#0|) Tclass._System.nat)))))
       (=> (= (type |a#10#0#0@@1|) (MapType BoxType BoxType)) a!1))
     :pattern (($Is (|#MsgHistoryMod.MsgHistory.MsgHistory|
                      |a#10#0#0@@1|
                      |a#10#1#0|
                      |a#10#2#0|)
                    Tclass.MsgHistoryMod.MsgHistory))
     :skolemid |2754|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((|a#11#0#0@@1| T@U) (|a#11#1#0| Int) (|a#11#2#0| Int) ($h@@96 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#MsgHistoryMod.MsgHistory.MsgHistory|
                               |a#11#0#0@@1|
                               |a#11#1#0|
                               |a#11#2#0|)
                             Tclass.MsgHistoryMod.MsgHistory
                             $h@@96)
                   (and ($IsAlloc |a#11#0#0@@1|
                                  (TMap Tclass._System.nat
                                        Tclass.MsgHistoryMod.KeyedMessage)
                                  $h@@96)
                        ($IsAlloc (int_2_U |a#11#1#0|)
                                  Tclass._System.nat
                                  $h@@96)
                        ($IsAlloc (int_2_U |a#11#2#0|)
                                  Tclass._System.nat
                                  $h@@96)))))
       (=> (and (= (type |a#11#0#0@@1|) (MapType BoxType BoxType))
                (= (type $h@@96) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@96))
           a!1))
     :pattern (($IsAlloc (|#MsgHistoryMod.MsgHistory.MsgHistory|
                           |a#11#0#0@@1|
                           |a#11#1#0|
                           |a#11#2#0|)
                         Tclass.MsgHistoryMod.MsgHistory
                         $h@@96))
     :skolemid |2755|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((arg0@@529 T@U))
  (! (= (type (MsgHistoryMod.MsgHistory.msgs arg0@@529))
        (MapType BoxType BoxType))
     :pattern ((MsgHistoryMod.MsgHistory.msgs arg0@@529))
     :qid |funType:MsgHistoryMod.MsgHistory.msgs|)))
(assert (forall ((d@@49 T@U) ($h@@97 T@U))
  (! (=> (and (= (type d@@49) DatatypeTypeType)
              (= (type $h@@97) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@97)
              (MsgHistoryMod.MsgHistory.MsgHistory_q d@@49)
              ($IsAlloc d@@49 Tclass.MsgHistoryMod.MsgHistory $h@@97))
         ($IsAlloc (MsgHistoryMod.MsgHistory.msgs d@@49)
                   (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage)
                   $h@@97))
     :pattern (($IsAlloc (MsgHistoryMod.MsgHistory.msgs d@@49)
                         (TMap Tclass._System.nat
                               Tclass.MsgHistoryMod.KeyedMessage)
                         $h@@97))
     :skolemid |2756|
     :qid |unknown.0:0|)))
(assert (forall ((d@@50 T@U) ($h@@98 T@U))
  (! (=> (and (= (type d@@50) DatatypeTypeType)
              (= (type $h@@98) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@98)
              (MsgHistoryMod.MsgHistory.MsgHistory_q d@@50)
              ($IsAlloc d@@50 Tclass.MsgHistoryMod.MsgHistory $h@@98))
         ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqStart d@@50))
                   Tclass._System.nat
                   $h@@98))
     :pattern (($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqStart d@@50))
                         Tclass._System.nat
                         $h@@98))
     :skolemid |2757|
     :qid |unknown.0:0|)))
(assert (forall ((d@@51 T@U) ($h@@99 T@U))
  (! (=> (and (= (type d@@51) DatatypeTypeType)
              (= (type $h@@99) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@99)
              (MsgHistoryMod.MsgHistory.MsgHistory_q d@@51)
              ($IsAlloc d@@51 Tclass.MsgHistoryMod.MsgHistory $h@@99))
         ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqEnd d@@51))
                   Tclass._System.nat
                   $h@@99))
     :pattern (($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqEnd d@@51))
                         Tclass._System.nat
                         $h@@99))
     :skolemid |2758|
     :qid |unknown.0:0|)))
(assert (forall ((|a#12#0#0@@0| T@U) (|a#12#1#0| Int) (|a#12#2#0| Int))
  (! (=> (= (type |a#12#0#0@@0|) (MapType BoxType BoxType))
         (= (|#MsgHistoryMod.MsgHistory.MsgHistory|
              (Lit |a#12#0#0@@0|)
              (LitInt |a#12#1#0|)
              (LitInt |a#12#2#0|))
            (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory|
                   |a#12#0#0@@0|
                   |a#12#1#0|
                   |a#12#2#0|))))
     :pattern ((|#MsgHistoryMod.MsgHistory.MsgHistory|
                 (Lit |a#12#0#0@@0|)
                 (LitInt |a#12#1#0|)
                 (LitInt |a#12#2#0|)))
     :skolemid |2759|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((|a#13#0#0| T@U) (|a#13#1#0| Int) (|a#13#2#0| Int))
  (! (=> (= (type |a#13#0#0|) (MapType BoxType BoxType))
         (= (MsgHistoryMod.MsgHistory.msgs
              (|#MsgHistoryMod.MsgHistory.MsgHistory|
                |a#13#0#0|
                |a#13#1#0|
                |a#13#2#0|))
            |a#13#0#0|))
     :pattern ((|#MsgHistoryMod.MsgHistory.MsgHistory|
                 |a#13#0#0|
                 |a#13#1#0|
                 |a#13#2#0|))
     :skolemid |2760|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((|a#14#0#0@@0| T@U) (|a#14#1#0@@0| Int) (|a#14#2#0| Int) (d@@52 T@U))
  (! (let ((a!1 (and (= (type |a#14#0#0@@0|) (MapType BoxType BoxType))
                     (= (type d@@52) DatatypeTypeType)
                     (U_2_bool (MapType0Select (|Map#Domain| |a#14#0#0@@0|)
                                               ($Box d@@52))))))
       (=> a!1
           (< (DtRank d@@52)
              (DtRank (|#MsgHistoryMod.MsgHistory.MsgHistory|
                        |a#14#0#0@@0|
                        |a#14#1#0@@0|
                        |a#14#2#0|)))))
     :pattern ((MapType0Select (|Map#Domain| |a#14#0#0@@0|) ($Box d@@52))
               (|#MsgHistoryMod.MsgHistory.MsgHistory|
                 |a#14#0#0@@0|
                 |a#14#1#0@@0|
                 |a#14#2#0|))
     :skolemid |2761|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((|a#15#0#0@@0| T@U) (|a#15#1#0@@0| Int) (|a#15#2#0| Int) (bx@@156 T@U))
  (! (let ((a!1 (and (= (type |a#15#0#0@@0|) (MapType BoxType BoxType))
                     (= (type bx@@156) BoxType)
                     (U_2_bool (MapType0Select (|Map#Domain| |a#15#0#0@@0|)
                                               bx@@156))))
           (a!2 (DtRank ($Unbox DatatypeTypeType
                                (MapType0Select (|Map#Elements| |a#15#0#0@@0|)
                                                bx@@156)))))
       (=> a!1
           (< a!2
              (DtRank (|#MsgHistoryMod.MsgHistory.MsgHistory|
                        |a#15#0#0@@0|
                        |a#15#1#0@@0|
                        |a#15#2#0|)))))
     :pattern ((MapType0Select (|Map#Domain| |a#15#0#0@@0|) bx@@156)
               (|#MsgHistoryMod.MsgHistory.MsgHistory|
                 |a#15#0#0@@0|
                 |a#15#1#0@@0|
                 |a#15#2#0|))
     :skolemid |2762|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((|a#16#0#0@@0| T@U) (|a#16#1#0@@0| Int) (|a#16#2#0| Int))
  (! (=> (= (type |a#16#0#0@@0|) (MapType BoxType BoxType))
         (= (MsgHistoryMod.MsgHistory.seqStart
              (|#MsgHistoryMod.MsgHistory.MsgHistory|
                |a#16#0#0@@0|
                |a#16#1#0@@0|
                |a#16#2#0|))
            |a#16#1#0@@0|))
     :pattern ((|#MsgHistoryMod.MsgHistory.MsgHistory|
                 |a#16#0#0@@0|
                 |a#16#1#0@@0|
                 |a#16#2#0|))
     :skolemid |2763|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((|a#17#0#0@@0| T@U) (|a#17#1#0@@0| Int) (|a#17#2#0| Int))
  (! (=> (= (type |a#17#0#0@@0|) (MapType BoxType BoxType))
         (= (MsgHistoryMod.MsgHistory.seqEnd
              (|#MsgHistoryMod.MsgHistory.MsgHistory|
                |a#17#0#0@@0|
                |a#17#1#0@@0|
                |a#17#2#0|))
            |a#17#2#0|))
     :pattern ((|#MsgHistoryMod.MsgHistory.MsgHistory|
                 |a#17#0#0@@0|
                 |a#17#1#0@@0|
                 |a#17#2#0|))
     :skolemid |2764|
     :qid |MsgHistoryidfy.28:36|)))
(assert (forall ((d@@53 T@U))
  (! (=> (and (= (type d@@53) DatatypeTypeType)
              (|$IsA#MsgHistoryMod.MsgHistory| d@@53))
         (MsgHistoryMod.MsgHistory.MsgHistory_q d@@53))
     :pattern ((|$IsA#MsgHistoryMod.MsgHistory| d@@53))
     :skolemid |2765|
     :qid |unknown.0:0|)))
(assert (forall ((d@@54 T@U))
  (! (=> (and (= (type d@@54) DatatypeTypeType)
              ($Is d@@54 Tclass.MsgHistoryMod.MsgHistory))
         (MsgHistoryMod.MsgHistory.MsgHistory_q d@@54))
     :pattern ((MsgHistoryMod.MsgHistory.MsgHistory_q d@@54)
               ($Is d@@54 Tclass.MsgHistoryMod.MsgHistory))
     :skolemid |2766|
     :qid |unknown.0:0|)))
(assert (forall ((a@@130 T@U) (b@@80 T@U))
  (! (let ((a!1 (= (|MsgHistoryMod.MsgHistory#Equal| a@@130 b@@80)
                   (and (|Map#Equal| (MsgHistoryMod.MsgHistory.msgs a@@130)
                                     (MsgHistoryMod.MsgHistory.msgs b@@80))
                        (= (MsgHistoryMod.MsgHistory.seqStart a@@130)
                           (MsgHistoryMod.MsgHistory.seqStart b@@80))
                        (= (MsgHistoryMod.MsgHistory.seqEnd a@@130)
                           (MsgHistoryMod.MsgHistory.seqEnd b@@80))))))
       (=> (and (= (type a@@130) DatatypeTypeType)
                (= (type b@@80) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|MsgHistoryMod.MsgHistory#Equal| a@@130 b@@80))
     :skolemid |2767|
     :qid |unknown.0:0|)))
(assert (forall ((a@@131 T@U) (b@@81 T@U))
  (! (=> (and (= (type a@@131) DatatypeTypeType)
              (= (type b@@81) DatatypeTypeType))
         (= (|MsgHistoryMod.MsgHistory#Equal| a@@131 b@@81) (= a@@131 b@@81)))
     :pattern ((|MsgHistoryMod.MsgHistory#Equal| a@@131 b@@81))
     :skolemid |2768|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((this T@U))
             (! (=> (and (= (type this) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.WF#canCall| this)
                             ($Is this Tclass.MsgHistoryMod.MsgHistory)))
                    true)
                :pattern ((MsgHistoryMod.MsgHistory.WF this))
                :skolemid |2769|
                :qid |MsgHistoryidfy.34:15|))))
  (=> true a!1)))
(assert (forall ((this@@0 T@U))
  (! (=> (and (= (type this@@0) DatatypeTypeType)
              ($Is this@@0 Tclass.MsgHistoryMod.MsgHistory))
         (= (|MsgHistoryMod.MsgHistory.WF#requires| this@@0) true))
     :pattern ((|MsgHistoryMod.MsgHistory.WF#requires| this@@0))
     :skolemid |2770|
     :qid |MsgHistoryidfy.34:15|)))
(assert (let ((a!1 (forall ((this@@1 T@U))
             (! (let ((a!1 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@1)
                                (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall|
                                  this@@1
                                  (|Map#Domain| (MsgHistoryMod.MsgHistory.msgs
                                                  this@@1)))))
                      (a!2 (and (INTERNAL_le_boogie
                                  (MsgHistoryMod.MsgHistory.seqStart this@@1)
                                  (MsgHistoryMod.MsgHistory.seqEnd this@@1))
                                (MsgHistoryMod.MsgHistory.ContainsExactly
                                  this@@1
                                  (|Map#Domain| (MsgHistoryMod.MsgHistory.msgs
                                                  this@@1))))))
                (let ((a!3 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@1)
                                (MsgHistoryMod.MsgHistory.MsgHistory_q this@@1)
                                (=> (INTERNAL_le_boogie
                                      (MsgHistoryMod.MsgHistory.seqStart
                                        this@@1)
                                      (MsgHistoryMod.MsgHistory.seqEnd this@@1))
                                    a!1)
                                (= (MsgHistoryMod.MsgHistory.WF this@@1) a!2))))
                  (=> (and (= (type this@@1) DatatypeTypeType)
                           (or (|MsgHistoryMod.MsgHistory.WF#canCall| this@@1)
                               ($Is this@@1 Tclass.MsgHistoryMod.MsgHistory)))
                      a!3)))
                :pattern ((MsgHistoryMod.MsgHistory.WF this@@1))
                :skolemid |2771|
                :qid |MsgHistoryidfy.34:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@2 T@U))
      (! (let ((a!1 (and (= (type this@@2) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.WF#canCall|
                               (Lit this@@2))
                             ($Is this@@2 Tclass.MsgHistoryMod.MsgHistory))))
               (a!2 (|Map#Domain| (Lit (MsgHistoryMod.MsgHistory.msgs
                                         (Lit this@@2))))))
         (let ((a!3 (=> (INTERNAL_le_boogie
                          (MsgHistoryMod.MsgHistory.seqStart (Lit this@@2))
                          (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@2)))
                        (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                               (Lit this@@2))
                             (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall|
                               (Lit this@@2)
                               (Lit a!2)))))
               (a!4 (and (INTERNAL_le_boogie
                           (MsgHistoryMod.MsgHistory.seqStart (Lit this@@2))
                           (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@2)))
                         (MsgHistoryMod.MsgHistory.ContainsExactly
                           (Lit this@@2)
                           (Lit a!2)))))
         (let ((a!5 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@2))
                         (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@2))
                         a!3
                         (= (MsgHistoryMod.MsgHistory.WF (Lit this@@2)) a!4))))
           (=> a!1 a!5))))
         :pattern ((MsgHistoryMod.MsgHistory.WF (Lit this@@2)))
         :weight 3
         :skolemid |2772|
         :qid |MsgHistoryidfy.34:15|))))
(assert (let ((a!1 (forall ((this@@3 T@U) (|lsns#0| T@U))
             (! (let ((a!1 (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall|
                                 this@@3
                                 |lsns#0|)
                               (and ($Is this@@3
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    ($Is |lsns#0| (TSet Tclass._System.nat))))))
                  (=> (and (= (type this@@3) DatatypeTypeType)
                           (= (type |lsns#0|) (MapType0Type BoxType boolType))
                           a!1)
                      true))
                :pattern ((MsgHistoryMod.MsgHistory.ContainsExactly
                            this@@3
                            |lsns#0|))
                :skolemid |2773|
                :qid |MsgHistoryidfy.40:15|))))
  (=> true a!1)))
(assert (forall ((this@@4 T@U) (|lsns#0@@0| T@U))
  (! (=> (and (= (type this@@4) DatatypeTypeType)
              (= (type |lsns#0@@0|) (MapType0Type BoxType boolType))
              ($Is this@@4 Tclass.MsgHistoryMod.MsgHistory)
              ($Is |lsns#0@@0| (TSet Tclass._System.nat)))
         (= (|MsgHistoryMod.MsgHistory.ContainsExactly#requires|
              this@@4
              |lsns#0@@0|)
            true))
     :pattern ((|MsgHistoryMod.MsgHistory.ContainsExactly#requires|
                 this@@4
                 |lsns#0@@0|))
     :skolemid |2774|
     :qid |MsgHistoryidfy.40:15|)))
(assert (let ((a!1 (forall ((this@@5 T@U) (|lsns#0@@1| T@U))
             (! (let ((a!1 (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall|
                                 this@@5
                                 |lsns#0@@1|)
                               (and ($Is this@@5
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    ($Is |lsns#0@@1| (TSet Tclass._System.nat)))))
                      (a!2 (forall ((|lsn#0@@0| Int))
                             (! (let ((a!1 (U_2_bool (MapType0Select |lsns#0@@1|
                                                                     ($Box (int_2_U |lsn#0@@0|))))))
                                  (=> (INTERNAL_le_boogie 0 |lsn#0@@0|)
                                      (= a!1
                                         (MsgHistoryMod.MsgHistory.Contains
                                           this@@5
                                           |lsn#0@@0|))))
                                :pattern ((MsgHistoryMod.MsgHistory.Contains
                                            this@@5
                                            |lsn#0@@0|))
                                :pattern ((MapType0Select |lsns#0@@1|
                                                          ($Box (int_2_U |lsn#0@@0|))))
                                :skolemid |2775|
                                :qid |MsgHistoryidfy.42:14|))))
                (let ((a!3 (and (forall ((|lsn#0| Int))
                                  (! (=> (INTERNAL_le_boogie 0 |lsn#0|)
                                         (|MsgHistoryMod.MsgHistory.Contains#canCall|
                                           this@@5
                                           |lsn#0|))
                                     :pattern ((MsgHistoryMod.MsgHistory.Contains
                                                 this@@5
                                                 |lsn#0|))
                                     :pattern ((MapType0Select |lsns#0@@1|
                                                               ($Box (int_2_U |lsn#0|))))
                                     :skolemid |2776|
                                     :qid |MsgHistoryidfy.42:14|))
                                (= (MsgHistoryMod.MsgHistory.ContainsExactly
                                     this@@5
                                     |lsns#0@@1|)
                                   a!2))))
                  (=> (and (= (type this@@5) DatatypeTypeType)
                           (= (type |lsns#0@@1|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      a!3)))
                :pattern ((MsgHistoryMod.MsgHistory.ContainsExactly
                            this@@5
                            |lsns#0@@1|))
                :skolemid |2777|
                :qid |MsgHistoryidfy.40:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@6 T@U) (|lsns#0@@2| T@U))
             (! (let ((a!1 (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall|
                                 (Lit this@@6)
                                 (Lit |lsns#0@@2|))
                               (and ($Is this@@6
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    ($Is |lsns#0@@2| (TSet Tclass._System.nat)))))
                      (a!2 (forall ((|lsn#1| Int))
                             (! (=> (INTERNAL_le_boogie 0 |lsn#1|)
                                    (|MsgHistoryMod.MsgHistory.Contains#canCall|
                                      (Lit this@@6)
                                      |lsn#1|))
                                :pattern ((MsgHistoryMod.MsgHistory.Contains
                                            this@@6
                                            |lsn#1|))
                                :pattern ((MapType0Select |lsns#0@@2|
                                                          ($Box (int_2_U |lsn#1|))))
                                :skolemid |2779|
                                :qid |MsgHistoryidfy.42:14|)))
                      (a!3 (forall ((|lsn#1@@0| Int))
                             (! (let ((a!1 (U_2_bool (MapType0Select (Lit |lsns#0@@2|)
                                                                     ($Box (int_2_U |lsn#1@@0|))))))
                                  (=> (INTERNAL_le_boogie 0 |lsn#1@@0|)
                                      (= a!1
                                         (MsgHistoryMod.MsgHistory.Contains
                                           (Lit this@@6)
                                           |lsn#1@@0|))))
                                :pattern ((MsgHistoryMod.MsgHistory.Contains
                                            this@@6
                                            |lsn#1@@0|))
                                :pattern ((MapType0Select |lsns#0@@2|
                                                          ($Box (int_2_U |lsn#1@@0|))))
                                :skolemid |2778|
                                :qid |MsgHistoryidfy.42:14|))))
                (let ((a!4 (and a!2
                                (= (MsgHistoryMod.MsgHistory.ContainsExactly
                                     (Lit this@@6)
                                     (Lit |lsns#0@@2|))
                                   a!3))))
                  (=> (and (= (type this@@6) DatatypeTypeType)
                           (= (type |lsns#0@@2|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      a!4)))
                :pattern ((MsgHistoryMod.MsgHistory.ContainsExactly
                            (Lit this@@6)
                            (Lit |lsns#0@@2|)))
                :weight 3
                :skolemid |2780|
                :qid |MsgHistoryidfy.40:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@7 T@U) (|lsn#0@@1| Int))
      (! (let ((a!1 (and (= (type this@@7) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.Contains#canCall|
                               this@@7
                               |lsn#0@@1|)
                             (and ($Is this@@7 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@1|))))))
           (=> a!1 true))
         :pattern ((MsgHistoryMod.MsgHistory.Contains this@@7 |lsn#0@@1|))
         :skolemid |2781|
         :qid |MsgHistoryidfy.45:15|))))
(assert (forall ((this@@8 T@U) (|lsn#0@@2| Int))
  (! (=> (= (type this@@8) DatatypeTypeType)
         (=> (and ($Is this@@8 Tclass.MsgHistoryMod.MsgHistory)
                  (INTERNAL_le_boogie 0 |lsn#0@@2|))
             (= (|MsgHistoryMod.MsgHistory.Contains#requires|
                  this@@8
                  |lsn#0@@2|)
                true)))
     :pattern ((|MsgHistoryMod.MsgHistory.Contains#requires| this@@8 |lsn#0@@2|))
     :skolemid |2782|
     :qid |MsgHistoryidfy.45:15|)))
(assert (=> true
    (forall ((this@@9 T@U) (|lsn#0@@3| Int))
      (! (let ((a!1 (and (= (type this@@9) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.Contains#canCall|
                               this@@9
                               |lsn#0@@3|)
                             (and ($Is this@@9 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@3|)))))
               (a!2 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@9)
                         (=> (INTERNAL_le_boogie
                               (MsgHistoryMod.MsgHistory.seqStart this@@9)
                               |lsn#0@@3|)
                             (MsgHistoryMod.MsgHistory.MsgHistory_q this@@9))))
               (a!4 (= (MsgHistoryMod.MsgHistory.Contains this@@9 |lsn#0@@3|)
                       (and true
                            (INTERNAL_le_boogie
                              (MsgHistoryMod.MsgHistory.seqStart this@@9)
                              |lsn#0@@3|)
                            (INTERNAL_lt_boogie
                              |lsn#0@@3|
                              (MsgHistoryMod.MsgHistory.seqEnd this@@9))))))
         (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true))) a!2)))
           (=> a!1 (and a!3 a!4))))
         :pattern ((MsgHistoryMod.MsgHistory.Contains this@@9 |lsn#0@@3|))
         :skolemid |2783|
         :qid |MsgHistoryidfy.45:15|))))
(assert (=> true
    (forall ((this@@10 T@U) (|lsn#0@@4| Int))
      (! (let ((a!1 (and (= (type this@@10) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.Contains#canCall|
                               (Lit this@@10)
                               (LitInt |lsn#0@@4|))
                             (and ($Is this@@10 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@4|)))))
               (a!2 (=> (INTERNAL_le_boogie
                          (MsgHistoryMod.MsgHistory.seqStart (Lit this@@10))
                          |lsn#0@@4|)
                        (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@10))))
               (a!4 (and true
                         (INTERNAL_le_boogie
                           (MsgHistoryMod.MsgHistory.seqStart (Lit this@@10))
                           |lsn#0@@4|)
                         (INTERNAL_lt_boogie
                           |lsn#0@@4|
                           (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@10))))))
         (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true)))
                        (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                               (Lit this@@10))
                             a!2))))
         (let ((a!5 (and a!3
                         (= (MsgHistoryMod.MsgHistory.Contains
                              (Lit this@@10)
                              (LitInt |lsn#0@@4|))
                            a!4))))
           (=> a!1 a!5))))
         :pattern ((MsgHistoryMod.MsgHistory.Contains
                     (Lit this@@10)
                     (LitInt |lsn#0@@4|)))
         :weight 3
         :skolemid |2784|
         :qid |MsgHistoryidfy.45:15|))))
(assert (forall ((arg0@@530 T@U) (arg1@@263 T@U))
  (! (= (type (MsgHistoryMod.MsgHistory.LSNSet arg0@@530 arg1@@263))
        (MapType0Type BoxType boolType))
     :pattern ((MsgHistoryMod.MsgHistory.LSNSet arg0@@530 arg1@@263))
     :qid |funType:MsgHistoryMod.MsgHistory.LSNSet|)))
(assert (forall (($ly@@304 T@U) (this@@11 T@U))
  (! (=> (and (= (type $ly@@304) LayerTypeType)
              (= (type this@@11) DatatypeTypeType))
         (= (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@304) this@@11)
            (MsgHistoryMod.MsgHistory.LSNSet $ly@@304 this@@11)))
     :pattern ((MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@304) this@@11))
     :skolemid |2785|
     :qid |MsgHistoryidfy.52:24|)))
(assert (forall (($ly@@305 T@U) (this@@12 T@U))
  (! (=> (and (= (type $ly@@305) LayerTypeType)
              (= (type this@@12) DatatypeTypeType))
         (= (MsgHistoryMod.MsgHistory.LSNSet $ly@@305 this@@12)
            (MsgHistoryMod.MsgHistory.LSNSet $LZ this@@12)))
     :pattern ((MsgHistoryMod.MsgHistory.LSNSet
                 (AsFuelBottom $ly@@305)
                 this@@12))
     :skolemid |2786|
     :qid |MsgHistoryidfy.52:24|)))
(assert (let ((a!1 (forall (($ly@@306 T@U) (this@@13 T@U))
             (! (=> (and (= (type $ly@@306) LayerTypeType)
                         (= (type this@@13) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall|
                               this@@13)
                             ($Is this@@13 Tclass.MsgHistoryMod.MsgHistory)))
                    (and (MsgHistoryMod.MsgHistory.ContainsExactly
                           this@@13
                           (MsgHistoryMod.MsgHistory.LSNSet $ly@@306 this@@13))
                         ($Is (MsgHistoryMod.MsgHistory.LSNSet
                                $ly@@306
                                this@@13)
                              (TSet Tclass._System.nat))))
                :pattern ((MsgHistoryMod.MsgHistory.LSNSet $ly@@306 this@@13))
                :skolemid |2787|
                :qid |MsgHistoryidfy.52:24|))))
  (=> true a!1)))
(assert (forall (($ly@@307 T@U) (this@@14 T@U))
  (! (=> (and (= (type $ly@@307) LayerTypeType)
              (= (type this@@14) DatatypeTypeType)
              ($Is this@@14 Tclass.MsgHistoryMod.MsgHistory))
         (= (|MsgHistoryMod.MsgHistory.LSNSet#requires| $ly@@307 this@@14) true))
     :pattern ((|MsgHistoryMod.MsgHistory.LSNSet#requires| $ly@@307 this@@14))
     :skolemid |2788|
     :qid |MsgHistoryidfy.52:24|)))
(assert (forall ((arg0@@531 T@U) (arg1@@264 Int) (arg2@@156 Int))
  (! (= (type (|lambda#211| arg0@@531 arg1@@264 arg2@@156))
        (MapType0Type BoxType boolType))
     :pattern ((|lambda#211| arg0@@531 arg1@@264 arg2@@156))
     :qid |funType:lambda#211|)))
(assert (let ((a!1 (forall (($ly@@308 T@U) (this@@15 T@U))
             (! (let ((a!1 (forall ((|lsn#0@@5| Int))
                             (! (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       this@@15)
                                     (=> (INTERNAL_le_boogie
                                           (MsgHistoryMod.MsgHistory.seqStart
                                             this@@15)
                                           |lsn#0@@5|)
                                         (MsgHistoryMod.MsgHistory.MsgHistory_q
                                           this@@15)))
                                :pattern ((INTERNAL_lt_boogie
                                            |lsn#0@@5|
                                            (MsgHistoryMod.MsgHistory.seqEnd
                                              this@@15)))
                                :pattern ((INTERNAL_le_boogie
                                            (MsgHistoryMod.MsgHistory.seqStart
                                              this@@15)
                                            |lsn#0@@5|))
                                :skolemid |2789|
                                :qid |MsgHistoryidfy.55:11|))))
                (let ((a!2 (and a!1
                                (= (MsgHistoryMod.MsgHistory.LSNSet
                                     ($LS $ly@@308)
                                     this@@15)
                                   (|lambda#211| TInt
                                                 (MsgHistoryMod.MsgHistory.seqStart
                                                   this@@15)
                                                 (MsgHistoryMod.MsgHistory.seqEnd
                                                   this@@15))))))
                  (=> (and (= (type $ly@@308) LayerTypeType)
                           (= (type this@@15) DatatypeTypeType)
                           (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall|
                                 this@@15)
                               ($Is this@@15 Tclass.MsgHistoryMod.MsgHistory)))
                      a!2)))
                :pattern ((MsgHistoryMod.MsgHistory.LSNSet
                            ($LS $ly@@308)
                            this@@15))
                :skolemid |2790|
                :qid |MsgHistoryidfy.52:24|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@309 T@U) (this@@16 T@U))
      (! (let ((a!1 (and (= (type $ly@@309) LayerTypeType)
                         (= (type this@@16) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall|
                               (Lit this@@16))
                             ($Is this@@16 Tclass.MsgHistoryMod.MsgHistory))))
               (a!2 (forall ((|lsn#1@@1| Int))
                      (! (let ((a!1 (=> (INTERNAL_le_boogie
                                          (MsgHistoryMod.MsgHistory.seqStart
                                            (Lit this@@16))
                                          |lsn#1@@1|)
                                        (MsgHistoryMod.MsgHistory.MsgHistory_q
                                          (Lit this@@16)))))
                           (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                  (Lit this@@16))
                                a!1))
                         :pattern ((INTERNAL_lt_boogie
                                     |lsn#1@@1|
                                     (MsgHistoryMod.MsgHistory.seqEnd this@@16)))
                         :pattern ((INTERNAL_le_boogie
                                     (MsgHistoryMod.MsgHistory.seqStart
                                       this@@16)
                                     |lsn#1@@1|))
                         :skolemid |2791|
                         :qid |MsgHistoryidfy.55:11|)))
               (a!3 (= (MsgHistoryMod.MsgHistory.LSNSet
                         ($LS $ly@@309)
                         (Lit this@@16))
                       (|lambda#211| TInt
                                     (MsgHistoryMod.MsgHistory.seqStart
                                       (Lit this@@16))
                                     (MsgHistoryMod.MsgHistory.seqEnd
                                       (Lit this@@16))))))
           (=> a!1 (and a!2 a!3)))
         :pattern ((MsgHistoryMod.MsgHistory.LSNSet
                     ($LS $ly@@309)
                     (Lit this@@16)))
         :weight 3
         :skolemid |2792|
         :qid |MsgHistoryidfy.52:24|))))
(assert (=> true
    (forall ((this@@17 T@U))
      (! (let ((a!1 (and (= (type this@@17) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                               this@@17)
                             (and ($Is this@@17 Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@17))))))
           (=> a!1 true))
         :pattern ((MsgHistoryMod.MsgHistory.IsEmpty this@@17))
         :skolemid |2793|
         :qid |MsgHistoryidfy.58:15|))))
(assert (forall ((this@@18 T@U))
  (! (=> (and (= (type this@@18) DatatypeTypeType)
              ($Is this@@18 Tclass.MsgHistoryMod.MsgHistory))
         (= (|MsgHistoryMod.MsgHistory.IsEmpty#requires| this@@18)
            (MsgHistoryMod.MsgHistory.WF this@@18)))
     :pattern ((|MsgHistoryMod.MsgHistory.IsEmpty#requires| this@@18))
     :skolemid |2794|
     :qid |MsgHistoryidfy.58:15|)))
(assert (=> true
    (forall ((this@@19 T@U))
      (! (let ((a!1 (and (= (type this@@19) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                               this@@19)
                             (and ($Is this@@19 Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@19)))))
               (a!2 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@19)
                         (MsgHistoryMod.MsgHistory.MsgHistory_q this@@19)
                         (= (MsgHistoryMod.MsgHistory.IsEmpty this@@19)
                            (= (MsgHistoryMod.MsgHistory.seqEnd this@@19)
                               (MsgHistoryMod.MsgHistory.seqStart this@@19))))))
           (=> a!1 a!2))
         :pattern ((MsgHistoryMod.MsgHistory.IsEmpty this@@19))
         :skolemid |2795|
         :qid |MsgHistoryidfy.58:15|))))
(assert (=> true
    (forall ((this@@20 T@U))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@20)))))
               (a!3 (= (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@20)))
                       (LitInt (MsgHistoryMod.MsgHistory.seqStart
                                 (Lit this@@20))))))
         (let ((a!2 (and (= (type this@@20) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                               (Lit this@@20))
                             (and ($Is this@@20 Tclass.MsgHistoryMod.MsgHistory)
                                  (U_2_bool a!1)))))
               (a!4 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@20))
                         (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@20))
                         (= (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@20))
                            a!3))))
           (=> a!2 a!4)))
         :pattern ((MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@20)))
         :weight 3
         :skolemid |2796|
         :qid |MsgHistoryidfy.58:15|))))
(assert (let ((a!1 (forall ((this@@21 T@U))
             (! (let ((a!1 (and (= (type this@@21) DatatypeTypeType)
                                (or (|MsgHistoryMod.MsgHistory.Len#canCall|
                                      this@@21)
                                    (and ($Is this@@21
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         (MsgHistoryMod.MsgHistory.WF this@@21))))))
                  (=> a!1
                      (INTERNAL_le_boogie
                        0
                        (MsgHistoryMod.MsgHistory.Len this@@21))))
                :pattern ((MsgHistoryMod.MsgHistory.Len this@@21))
                :skolemid |2797|
                :qid |MsgHistoryidfy.64:14|))))
  (=> true a!1)))
(assert (forall ((this@@22 T@U))
  (! (=> (and (= (type this@@22) DatatypeTypeType)
              ($Is this@@22 Tclass.MsgHistoryMod.MsgHistory))
         (= (|MsgHistoryMod.MsgHistory.Len#requires| this@@22)
            (MsgHistoryMod.MsgHistory.WF this@@22)))
     :pattern ((|MsgHistoryMod.MsgHistory.Len#requires| this@@22))
     :skolemid |2798|
     :qid |MsgHistoryidfy.64:14|)))
(assert (=> true
    (forall ((this@@23 T@U))
      (! (let ((a!1 (and (= (type this@@23) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.Len#canCall| this@@23)
                             (and ($Is this@@23 Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@23)))))
               (a!2 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@23)
                         (MsgHistoryMod.MsgHistory.MsgHistory_q this@@23)
                         (= (MsgHistoryMod.MsgHistory.Len this@@23)
                            (INTERNAL_sub_boogie
                              (MsgHistoryMod.MsgHistory.seqEnd this@@23)
                              (MsgHistoryMod.MsgHistory.seqStart this@@23))))))
           (=> a!1 a!2))
         :pattern ((MsgHistoryMod.MsgHistory.Len this@@23))
         :skolemid |2799|
         :qid |MsgHistoryidfy.64:14|))))
(assert (=> true
    (forall ((this@@24 T@U))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@24)))))
               (a!3 (LitInt (INTERNAL_sub_boogie
                              (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@24))
                              (MsgHistoryMod.MsgHistory.seqStart (Lit this@@24))))))
         (let ((a!2 (and (= (type this@@24) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.Len#canCall|
                               (Lit this@@24))
                             (and ($Is this@@24 Tclass.MsgHistoryMod.MsgHistory)
                                  (U_2_bool a!1)))))
               (a!4 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@24))
                         (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@24))
                         (= (MsgHistoryMod.MsgHistory.Len (Lit this@@24)) a!3))))
           (=> a!2 a!4)))
         :pattern ((MsgHistoryMod.MsgHistory.Len (Lit this@@24)))
         :weight 3
         :skolemid |2800|
         :qid |MsgHistoryidfy.64:14|))))
(assert (=> true
    (forall ((this@@25 T@U) (|other#0@@3| T@U))
      (! (let ((a!1 (and (= (type this@@25) DatatypeTypeType)
                         (= (type |other#0@@3|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall|
                               this@@25
                               |other#0@@3|)
                             (and ($Is this@@25 Tclass.MsgHistoryMod.MsgHistory)
                                  ($Is |other#0@@3|
                                       Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@25)
                                  (MsgHistoryMod.MsgHistory.WF |other#0@@3|))))))
           (=> a!1 true))
         :pattern ((MsgHistoryMod.MsgHistory.CanConcat this@@25 |other#0@@3|))
         :skolemid |2801|
         :qid |MsgHistoryidfy.70:15|))))
(assert (forall ((this@@26 T@U) (|other#0@@4| T@U))
  (! (=> (and (= (type this@@26) DatatypeTypeType)
              (= (type |other#0@@4|) DatatypeTypeType)
              ($Is this@@26 Tclass.MsgHistoryMod.MsgHistory)
              ($Is |other#0@@4| Tclass.MsgHistoryMod.MsgHistory))
         (= (|MsgHistoryMod.MsgHistory.CanConcat#requires|
              this@@26
              |other#0@@4|)
            (and (MsgHistoryMod.MsgHistory.WF this@@26)
                 (MsgHistoryMod.MsgHistory.WF |other#0@@4|))))
     :pattern ((|MsgHistoryMod.MsgHistory.CanConcat#requires|
                 this@@26
                 |other#0@@4|))
     :skolemid |2802|
     :qid |MsgHistoryidfy.70:15|)))
(assert (=> true
    (forall ((this@@27 T@U) (|other#0@@5| T@U))
      (! (let ((a!1 (and (= (type this@@27) DatatypeTypeType)
                         (= (type |other#0@@5|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall|
                               this@@27
                               |other#0@@5|)
                             (and ($Is this@@27 Tclass.MsgHistoryMod.MsgHistory)
                                  ($Is |other#0@@5|
                                       Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@27)
                                  (MsgHistoryMod.MsgHistory.WF |other#0@@5|)))))
               (a!2 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@27)
                         (|MsgHistoryMod.MsgHistory.CanFollow#canCall|
                           |other#0@@5|
                           (MsgHistoryMod.MsgHistory.seqEnd this@@27))
                         (= (MsgHistoryMod.MsgHistory.CanConcat
                              this@@27
                              |other#0@@5|)
                            (MsgHistoryMod.MsgHistory.CanFollow
                              |other#0@@5|
                              (MsgHistoryMod.MsgHistory.seqEnd this@@27))))))
           (=> a!1 a!2))
         :pattern ((MsgHistoryMod.MsgHistory.CanConcat this@@27 |other#0@@5|))
         :skolemid |2803|
         :qid |MsgHistoryidfy.70:15|))))
(assert (let ((a!1 (forall ((this@@28 T@U) (|other#0@@6| T@U))
             (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                            (Lit this@@28)))))
                      (a!2 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                            (Lit |other#0@@6|)))))
                      (a!4 (|MsgHistoryMod.MsgHistory.CanFollow#canCall|
                             (Lit |other#0@@6|)
                             (LitInt (MsgHistoryMod.MsgHistory.seqEnd
                                       (Lit this@@28)))))
                      (a!5 (MsgHistoryMod.MsgHistory.CanFollow
                             (Lit |other#0@@6|)
                             (LitInt (MsgHistoryMod.MsgHistory.seqEnd
                                       (Lit this@@28))))))
                (let ((a!3 (and (= (type this@@28) DatatypeTypeType)
                                (= (type |other#0@@6|) DatatypeTypeType)
                                (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall|
                                      (Lit this@@28)
                                      (Lit |other#0@@6|))
                                    (and ($Is this@@28
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         ($Is |other#0@@6|
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         (U_2_bool a!1)
                                         (U_2_bool a!2)))))
                      (a!6 (= (MsgHistoryMod.MsgHistory.CanConcat
                                (Lit this@@28)
                                (Lit |other#0@@6|))
                              (U_2_bool (Lit (bool_2_U a!5))))))
                  (=> a!3
                      (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                             (Lit this@@28))
                           a!4
                           a!6))))
                :pattern ((MsgHistoryMod.MsgHistory.CanConcat
                            (Lit this@@28)
                            (Lit |other#0@@6|)))
                :weight 3
                :skolemid |2804|
                :qid |MsgHistoryidfy.70:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((arg0@@532 T@U) (arg1@@265 T@U))
             (! (= (type (MsgHistoryMod.MsgHistory.Concat arg0@@532 arg1@@265))
                   DatatypeTypeType)
                :pattern ((MsgHistoryMod.MsgHistory.Concat arg0@@532 arg1@@265))
                :qid |funType:MsgHistoryMod.MsgHistory.Concat|))))
  (and a!1 (= (type StartFuel_MsgHistoryMod.MsgHistory.LSNSet) LayerTypeType))))
(assert (=> true
    (forall ((this@@29 T@U) (|other#0@@7| T@U))
      (! (let ((a!1 (and (= (type this@@29) DatatypeTypeType)
                         (= (type |other#0@@7|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.Concat#canCall|
                               this@@29
                               |other#0@@7|)
                             (and ($Is this@@29 Tclass.MsgHistoryMod.MsgHistory)
                                  ($Is |other#0@@7|
                                       Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@29)
                                  (MsgHistoryMod.MsgHistory.WF |other#0@@7|)
                                  (MsgHistoryMod.MsgHistory.CanConcat
                                    this@@29
                                    |other#0@@7|)))))
               (a!2 (and (MsgHistoryMod.MsgHistory.WF
                           (MsgHistoryMod.MsgHistory.Concat
                             this@@29
                             |other#0@@7|))
                         (|Set#Equal| (MsgHistoryMod.MsgHistory.LSNSet
                                        StartFuel_MsgHistoryMod.MsgHistory.LSNSet
                                        (MsgHistoryMod.MsgHistory.Concat
                                          this@@29
                                          |other#0@@7|))
                                      (|Set#Union| (MsgHistoryMod.MsgHistory.LSNSet
                                                     StartFuel_MsgHistoryMod.MsgHistory.LSNSet
                                                     this@@29)
                                                   (MsgHistoryMod.MsgHistory.LSNSet
                                                     StartFuel_MsgHistoryMod.MsgHistory.LSNSet
                                                     |other#0@@7|)))
                         (=> (MsgHistoryMod.MsgHistory.IsEmpty |other#0@@7|)
                             (|MsgHistoryMod.MsgHistory#Equal|
                               (MsgHistoryMod.MsgHistory.Concat
                                 this@@29
                                 |other#0@@7|)
                               this@@29))
                         ($Is (MsgHistoryMod.MsgHistory.Concat
                                this@@29
                                |other#0@@7|)
                              Tclass.MsgHistoryMod.MsgHistory))))
           (=> a!1 a!2))
         :pattern ((MsgHistoryMod.MsgHistory.Concat this@@29 |other#0@@7|))
         :skolemid |2805|
         :qid |MsgHistoryidfy.77:14|))))
(assert (forall ((this@@30 T@U) (|other#0@@8| T@U))
  (! (=> (and (= (type this@@30) DatatypeTypeType)
              (= (type |other#0@@8|) DatatypeTypeType)
              ($Is this@@30 Tclass.MsgHistoryMod.MsgHistory)
              ($Is |other#0@@8| Tclass.MsgHistoryMod.MsgHistory))
         (= (|MsgHistoryMod.MsgHistory.Concat#requires| this@@30 |other#0@@8|)
            (and (MsgHistoryMod.MsgHistory.WF this@@30)
                 (MsgHistoryMod.MsgHistory.WF |other#0@@8|)
                 (MsgHistoryMod.MsgHistory.CanConcat this@@30 |other#0@@8|))))
     :pattern ((|MsgHistoryMod.MsgHistory.Concat#requires|
                 this@@30
                 |other#0@@8|))
     :skolemid |2806|
     :qid |MsgHistoryidfy.77:14|)))
(assert (let ((a!1 (forall ((this@@31 T@U) (|other#0@@9| T@U))
             (! (let ((a!1 (and (= (type this@@31) DatatypeTypeType)
                                (= (type |other#0@@9|) DatatypeTypeType)
                                (or (|MsgHistoryMod.MsgHistory.Concat#canCall|
                                      this@@31
                                      |other#0@@9|)
                                    (and ($Is this@@31
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         ($Is |other#0@@9|
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         (MsgHistoryMod.MsgHistory.WF this@@31)
                                         (MsgHistoryMod.MsgHistory.WF
                                           |other#0@@9|)
                                         (MsgHistoryMod.MsgHistory.CanConcat
                                           this@@31
                                           |other#0@@9|)))))
                      (a!2 (= (MsgHistoryMod.MsgHistory.Concat
                                this@@31
                                |other#0@@9|)
                              (|#MsgHistoryMod.MsgHistory.MsgHistory|
                                (Maps.__default.MapDisjointUnion
                                  Tclass._System.nat
                                  Tclass.MsgHistoryMod.KeyedMessage
                                  StartFuel_Maps._default.MapDisjointUnion
                                  (MsgHistoryMod.MsgHistory.msgs this@@31)
                                  (MsgHistoryMod.MsgHistory.msgs |other#0@@9|))
                                (MsgHistoryMod.MsgHistory.seqStart this@@31)
                                (MsgHistoryMod.MsgHistory.seqEnd |other#0@@9|)))))
                  (=> a!1
                      (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@31)
                           (MsgHistoryMod.MsgHistory.MsgHistory_q |other#0@@9|)
                           (|Maps.__default.MapDisjointUnion#canCall|
                             Tclass._System.nat
                             Tclass.MsgHistoryMod.KeyedMessage
                             (MsgHistoryMod.MsgHistory.msgs this@@31)
                             (MsgHistoryMod.MsgHistory.msgs |other#0@@9|))
                           (MsgHistoryMod.MsgHistory.MsgHistory_q this@@31)
                           (MsgHistoryMod.MsgHistory.MsgHistory_q |other#0@@9|)
                           a!2)))
                :pattern ((MsgHistoryMod.MsgHistory.Concat
                            this@@31
                            |other#0@@9|))
                :skolemid |2807|
                :qid |MsgHistoryidfy.77:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@32 T@U) (|other#0@@10| T@U))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@32)))))
               (a!2 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                     (Lit |other#0@@10|)))))
               (a!3 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanConcat
                                     (Lit this@@32)
                                     (Lit |other#0@@10|)))))
               (a!5 (|Maps.__default.MapDisjointUnion#canCall|
                      Tclass._System.nat
                      Tclass.MsgHistoryMod.KeyedMessage
                      (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@32)))
                      (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |other#0@@10|)))))
               (a!6 (Maps.__default.MapDisjointUnion
                      Tclass._System.nat
                      Tclass.MsgHistoryMod.KeyedMessage
                      StartFuel_Maps._default.MapDisjointUnion
                      (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@32)))
                      (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |other#0@@10|))))))
         (let ((a!4 (and (= (type this@@32) DatatypeTypeType)
                         (= (type |other#0@@10|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.Concat#canCall|
                               (Lit this@@32)
                               (Lit |other#0@@10|))
                             (and ($Is this@@32 Tclass.MsgHistoryMod.MsgHistory)
                                  ($Is |other#0@@10|
                                       Tclass.MsgHistoryMod.MsgHistory)
                                  (U_2_bool a!1)
                                  (U_2_bool a!2)
                                  (U_2_bool a!3)))))
               (a!7 (|#MsgHistoryMod.MsgHistory.MsgHistory|
                      a!6
                      (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@32)))
                      (LitInt (MsgHistoryMod.MsgHistory.seqEnd
                                (Lit |other#0@@10|))))))
         (let ((a!8 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@32))
                         (MsgHistoryMod.MsgHistory.MsgHistory_q
                           (Lit |other#0@@10|))
                         a!5
                         (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@32))
                         (MsgHistoryMod.MsgHistory.MsgHistory_q
                           (Lit |other#0@@10|))
                         (= (MsgHistoryMod.MsgHistory.Concat
                              (Lit this@@32)
                              (Lit |other#0@@10|))
                            a!7))))
           (=> a!4 a!8))))
         :pattern ((MsgHistoryMod.MsgHistory.Concat
                     (Lit this@@32)
                     (Lit |other#0@@10|)))
         :weight 3
         :skolemid |2808|
         :qid |MsgHistoryidfy.77:14|))))
(assert (=> true
    (forall ((this@@33 T@U) (|lsn#0@@6| Int))
      (! (let ((a!1 (and (= (type this@@33) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall|
                               this@@33
                               |lsn#0@@6|)
                             (and ($Is this@@33 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@6|))))))
           (=> a!1 true))
         :pattern ((MsgHistoryMod.MsgHistory.CanFollow this@@33 |lsn#0@@6|))
         :skolemid |2809|
         :qid |MsgHistoryidfy.89:15|))))
(assert (forall ((this@@34 T@U) (|lsn#0@@7| Int))
  (! (=> (= (type this@@34) DatatypeTypeType)
         (=> (and ($Is this@@34 Tclass.MsgHistoryMod.MsgHistory)
                  (INTERNAL_le_boogie 0 |lsn#0@@7|))
             (= (|MsgHistoryMod.MsgHistory.CanFollow#requires|
                  this@@34
                  |lsn#0@@7|)
                true)))
     :pattern ((|MsgHistoryMod.MsgHistory.CanFollow#requires|
                 this@@34
                 |lsn#0@@7|))
     :skolemid |2810|
     :qid |MsgHistoryidfy.89:15|)))
(assert (=> true
    (forall ((this@@35 T@U) (|lsn#0@@8| Int))
      (! (let ((a!1 (and (= (type this@@35) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall|
                               this@@35
                               |lsn#0@@8|)
                             (and ($Is this@@35 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@8|)))))
               (a!2 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@35)
                         (= (MsgHistoryMod.MsgHistory.CanFollow
                              this@@35
                              |lsn#0@@8|)
                            (= (MsgHistoryMod.MsgHistory.seqStart this@@35)
                               |lsn#0@@8|)))))
           (=> a!1 a!2))
         :pattern ((MsgHistoryMod.MsgHistory.CanFollow this@@35 |lsn#0@@8|))
         :skolemid |2811|
         :qid |MsgHistoryidfy.89:15|))))
(assert (=> true
    (forall ((this@@36 T@U) (|lsn#0@@9| Int))
      (! (let ((a!1 (and (= (type this@@36) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall|
                               (Lit this@@36)
                               (LitInt |lsn#0@@9|))
                             (and ($Is this@@36 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@9|)))))
               (a!2 (= (LitInt (MsgHistoryMod.MsgHistory.seqStart
                                 (Lit this@@36)))
                       (LitInt |lsn#0@@9|))))
         (let ((a!3 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@36))
                         (= (MsgHistoryMod.MsgHistory.CanFollow
                              (Lit this@@36)
                              (LitInt |lsn#0@@9|))
                            a!2))))
           (=> a!1 a!3)))
         :pattern ((MsgHistoryMod.MsgHistory.CanFollow
                     (Lit this@@36)
                     (LitInt |lsn#0@@9|)))
         :weight 3
         :skolemid |2812|
         :qid |MsgHistoryidfy.89:15|))))
(assert (forall ((arg0@@533 T@U) (arg1@@266 T@U) (arg2@@157 T@U))
  (! (= (type (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                arg0@@533
                arg1@@266
                arg2@@157))
        DatatypeTypeType)
     :pattern ((MsgHistoryMod.MsgHistory.ApplyToStampedMap
                 arg0@@533
                 arg1@@266
                 arg2@@157))
     :qid |funType:MsgHistoryMod.MsgHistory.ApplyToStampedMap|)))
(assert (forall (($ly@@310 T@U) (this@@37 T@U) (|orig#0| T@U))
  (! (=> (and (= (type $ly@@310) LayerTypeType)
              (= (type this@@37) DatatypeTypeType)
              (= (type |orig#0|) DatatypeTypeType))
         (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap
              ($LS $ly@@310)
              this@@37
              |orig#0|)
            (MsgHistoryMod.MsgHistory.ApplyToStampedMap
              $ly@@310
              this@@37
              |orig#0|)))
     :pattern ((MsgHistoryMod.MsgHistory.ApplyToStampedMap
                 ($LS $ly@@310)
                 this@@37
                 |orig#0|))
     :skolemid |2813|
     :qid |MsgHistoryidfy.94:14|)))
(assert (forall (($ly@@311 T@U) (this@@38 T@U) (|orig#0@@0| T@U))
  (! (=> (and (= (type $ly@@311) LayerTypeType)
              (= (type this@@38) DatatypeTypeType)
              (= (type |orig#0@@0|) DatatypeTypeType))
         (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap
              $ly@@311
              this@@38
              |orig#0@@0|)
            (MsgHistoryMod.MsgHistory.ApplyToStampedMap
              $LZ
              this@@38
              |orig#0@@0|)))
     :pattern ((MsgHistoryMod.MsgHistory.ApplyToStampedMap
                 (AsFuelBottom $ly@@311)
                 this@@38
                 |orig#0@@0|))
     :skolemid |2814|
     :qid |MsgHistoryidfy.94:14|)))
(assert (let ((a!1 (forall (($ly@@312 T@U) (this@@39 T@U) (|orig#0@@1| T@U))
             (! (let ((a!1 (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                                 this@@39
                                 |orig#0@@1|)
                               (and ($Is this@@39
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    ($Is |orig#0@@1|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap))
                                    (MsgHistoryMod.MsgHistory.WF this@@39)
                                    (MsgHistoryMod.MsgHistory.CanFollow
                                      this@@39
                                      (StampedMod.Stamped.seqEnd |orig#0@@1|)))))
                      (a!2 (and (= (StampedMod.Stamped.seqEnd
                                     (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                                       $ly@@312
                                       this@@39
                                       |orig#0@@1|))
                                   (INTERNAL_add_boogie
                                     (StampedMod.Stamped.seqEnd |orig#0@@1|)
                                     (MsgHistoryMod.MsgHistory.Len this@@39)))
                                ($Is (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                                       $ly@@312
                                       this@@39
                                       |orig#0@@1|)
                                     (Tclass.StampedMod.Stamped
                                       Tclass.TotalKMMapMod.TotalMap)))))
                  (=> (and (= (type $ly@@312) LayerTypeType)
                           (= (type this@@39) DatatypeTypeType)
                           (= (type |orig#0@@1|) DatatypeTypeType)
                           a!1)
                      a!2))
                :pattern ((MsgHistoryMod.MsgHistory.ApplyToStampedMap
                            $ly@@312
                            this@@39
                            |orig#0@@1|))
                :skolemid |2815|
                :qid |MsgHistoryidfy.94:14|))))
  (=> true a!1)))
(assert (forall (($ly@@313 T@U) (this@@40 T@U) (|orig#0@@2| T@U))
  (! (let ((a!1 (= (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires|
                     $ly@@313
                     this@@40
                     |orig#0@@2|)
                   (and (MsgHistoryMod.MsgHistory.WF this@@40)
                        (MsgHistoryMod.MsgHistory.CanFollow
                          this@@40
                          (StampedMod.Stamped.seqEnd |orig#0@@2|))))))
       (=> (and (= (type $ly@@313) LayerTypeType)
                (= (type this@@40) DatatypeTypeType)
                (= (type |orig#0@@2|) DatatypeTypeType)
                ($Is this@@40 Tclass.MsgHistoryMod.MsgHistory)
                ($Is |orig#0@@2|
                     (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))
           a!1))
     :pattern ((|MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires|
                 $ly@@313
                 this@@40
                 |orig#0@@2|))
     :skolemid |2816|
     :qid |MsgHistoryidfy.94:14|)))
(assert (forall ((arg0@@534 T@U) (arg1@@267 Int))
  (! (= (type (MsgHistoryMod.MsgHistory.DiscardRecent arg0@@534 arg1@@267))
        DatatypeTypeType)
     :pattern ((MsgHistoryMod.MsgHistory.DiscardRecent arg0@@534 arg1@@267))
     :qid |funType:MsgHistoryMod.MsgHistory.DiscardRecent|)))
(assert (let ((a!1 (forall (($ly@@314 T@U) (this@@41 T@U) (|orig#0@@3| T@U))
             (! (let ((a!1 (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                                 this@@41
                                 |orig#0@@3|)
                               (and ($Is this@@41
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    ($Is |orig#0@@3|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap))
                                    (MsgHistoryMod.MsgHistory.WF this@@41)
                                    (MsgHistoryMod.MsgHistory.CanFollow
                                      this@@41
                                      (StampedMod.Stamped.seqEnd |orig#0@@3|)))))
                      (a!2 (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                             (MsgHistoryMod.MsgHistory.DiscardRecent
                               this@@41
                               (INTERNAL_sub_boogie
                                 (MsgHistoryMod.MsgHistory.seqEnd this@@41)
                                 1))
                             |orig#0@@3|))
                      (a!3 ($Box (int_2_U (INTERNAL_sub_boogie
                                            (MsgHistoryMod.MsgHistory.seqEnd
                                              this@@41)
                                            1))))
                      (a!5 (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                             $ly@@314
                             (MsgHistoryMod.MsgHistory.DiscardRecent
                               this@@41
                               (INTERNAL_sub_boogie
                                 (MsgHistoryMod.MsgHistory.seqEnd this@@41)
                                 1))
                             |orig#0@@3|)))
                (let ((a!4 ($Unbox DatatypeTypeType
                                   (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                     this@@41))
                                                   a!3))))
                (let ((a!6 (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType
                                                                              BoxType)
                                                                    (StampedMod.Stamped.value
                                                                      a!5)))
                                           ($Box (MsgHistoryMod.KeyedMessage.key
                                                   a!4)))))
                (let ((a!7 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@41)
                                (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                                  this@@41
                                  (INTERNAL_sub_boogie
                                    (MsgHistoryMod.MsgHistory.seqEnd this@@41)
                                    1))
                                a!2
                                (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       this@@41)
                                     (MsgHistoryMod.KeyedMessage.KeyedMessage_q
                                       a!4))
                                (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       this@@41)
                                     (MsgHistoryMod.KeyedMessage.KeyedMessage_q
                                       a!4))
                                (StampedMod.Stamped.Stamped_q a!5)
                                (StampedMod.Stamped.Stamped_q a!5)
                                (|ValueMessage.__default.Merge#canCall|
                                  (MsgHistoryMod.KeyedMessage.message a!4)
                                  ($Unbox DatatypeTypeType a!6))
                                (StampedMod.Stamped.Stamped_q a!5)))
                      (a!8 (|IMap#Build| ($Unbox (IMapType BoxType BoxType)
                                                 (StampedMod.Stamped.value a!5))
                                         ($Box (MsgHistoryMod.KeyedMessage.key
                                                 a!4))
                                         ($Box (ValueMessage.__default.Merge
                                                 (MsgHistoryMod.KeyedMessage.message
                                                   a!4)
                                                 ($Unbox DatatypeTypeType a!6))))))
                (let ((a!9 (ite (MsgHistoryMod.MsgHistory.IsEmpty this@@41)
                                |orig#0@@3|
                                (|#StampedMod.Stamped.Stamped|
                                  ($Box a!8)
                                  (INTERNAL_add_boogie
                                    (StampedMod.Stamped.seqEnd a!5)
                                    1)))))
                (let ((a!10 (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                                   this@@41)
                                 (=> (not (MsgHistoryMod.MsgHistory.IsEmpty
                                            this@@41))
                                     a!7)
                                 (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                                      ($LS $ly@@314)
                                      this@@41
                                      |orig#0@@3|)
                                    a!9))))
                  (=> (and (= (type $ly@@314) LayerTypeType)
                           (= (type this@@41) DatatypeTypeType)
                           (= (type |orig#0@@3|) DatatypeTypeType)
                           a!1)
                      a!10)))))))
                :pattern ((MsgHistoryMod.MsgHistory.ApplyToStampedMap
                            ($LS $ly@@314)
                            this@@41
                            |orig#0@@3|))
                :skolemid |2817|
                :qid |MsgHistoryidfy.94:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($ly@@315 T@U) (this@@42 T@U) (|orig#0@@4| T@U))
             (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                            (Lit this@@42)))))
                      (a!3 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty
                                            (Lit this@@42)))))
                      (a!4 (LitInt (INTERNAL_sub_boogie
                                     (MsgHistoryMod.MsgHistory.seqEnd
                                       (Lit this@@42))
                                     1)))
                      (a!5 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                                  (Lit this@@42))))))
                (let ((a!2 (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                                 (Lit this@@42)
                                 |orig#0@@4|)
                               (and ($Is this@@42
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    ($Is |orig#0@@4|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap))
                                    (U_2_bool a!1)
                                    (MsgHistoryMod.MsgHistory.CanFollow
                                      (Lit this@@42)
                                      (StampedMod.Stamped.seqEnd |orig#0@@4|)))))
                      (a!6 ($Unbox DatatypeTypeType
                                   (MapType0Select a!5 ($Box (int_2_U a!4)))))
                      (a!7 (StampedMod.Stamped.Stamped_q
                             (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                               ($LS $ly@@315)
                               (MsgHistoryMod.MsgHistory.DiscardRecent
                                 (Lit this@@42)
                                 a!4)
                               |orig#0@@4|)))
                      (a!8 (StampedMod.Stamped.value
                             (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                               ($LS $ly@@315)
                               (MsgHistoryMod.MsgHistory.DiscardRecent
                                 (Lit this@@42)
                                 a!4)
                               |orig#0@@4|)))
                      (a!11 (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                              ($LS $ly@@315)
                              (Lit (MsgHistoryMod.MsgHistory.DiscardRecent
                                     (Lit this@@42)
                                     a!4))
                              |orig#0@@4|)))
                (let ((a!9 (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType
                                                                              BoxType)
                                                                    a!8))
                                           ($Box (MsgHistoryMod.KeyedMessage.key
                                                   a!6))))
                      (a!12 (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType
                                                                               BoxType)
                                                                     (StampedMod.Stamped.value
                                                                       a!11)))
                                            ($Box (MsgHistoryMod.KeyedMessage.key
                                                    a!6)))))
                (let ((a!10 (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                   (Lit this@@42))
                                 (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                                   (Lit this@@42)
                                   a!4)
                                 (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                                   (MsgHistoryMod.MsgHistory.DiscardRecent
                                     (Lit this@@42)
                                     a!4)
                                   |orig#0@@4|)
                                 (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                        (Lit this@@42))
                                      (MsgHistoryMod.KeyedMessage.KeyedMessage_q
                                        a!6))
                                 (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                        (Lit this@@42))
                                      (MsgHistoryMod.KeyedMessage.KeyedMessage_q
                                        a!6))
                                 a!7
                                 a!7
                                 (|ValueMessage.__default.Merge#canCall|
                                   (MsgHistoryMod.KeyedMessage.message a!6)
                                   ($Unbox DatatypeTypeType a!9))
                                 a!7))
                      (a!13 (|IMap#Build| ($Unbox (IMapType BoxType BoxType)
                                                  (StampedMod.Stamped.value
                                                    a!11))
                                          ($Box (MsgHistoryMod.KeyedMessage.key
                                                  a!6))
                                          ($Box (ValueMessage.__default.Merge
                                                  (MsgHistoryMod.KeyedMessage.message
                                                    a!6)
                                                  ($Unbox DatatypeTypeType a!12))))))
                (let ((a!14 (ite (MsgHistoryMod.MsgHistory.IsEmpty
                                   (Lit this@@42))
                                 |orig#0@@4|
                                 (|#StampedMod.Stamped.Stamped|
                                   ($Box a!13)
                                   (INTERNAL_add_boogie
                                     (StampedMod.Stamped.seqEnd a!11)
                                     1)))))
                (let ((a!15 (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                                   (Lit this@@42))
                                 (=> (not (U_2_bool a!3)) a!10)
                                 (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                                      ($LS $ly@@315)
                                      (Lit this@@42)
                                      |orig#0@@4|)
                                    a!14))))
                  (=> (and (= (type $ly@@315) LayerTypeType)
                           (= (type this@@42) DatatypeTypeType)
                           (= (type |orig#0@@4|) DatatypeTypeType)
                           a!2)
                      a!15)))))))
                :pattern ((MsgHistoryMod.MsgHistory.ApplyToStampedMap
                            ($LS $ly@@315)
                            (Lit this@@42)
                            |orig#0@@4|))
                :weight 3
                :skolemid |2818|
                :qid |MsgHistoryidfy.94:14|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@316 T@U) (this@@43 T@U) (|orig#0@@5| T@U))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@43)))))
               (a!2 (MsgHistoryMod.MsgHistory.CanFollow
                      (Lit this@@43)
                      (LitInt (StampedMod.Stamped.seqEnd (Lit |orig#0@@5|)))))
               (a!5 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty
                                     (Lit this@@43)))))
               (a!6 (LitInt (INTERNAL_sub_boogie
                              (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@43))
                              1)))
               (a!7 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                           (Lit this@@43))))))
         (let ((a!3 (and ($Is this@@43 Tclass.MsgHistoryMod.MsgHistory)
                         ($Is |orig#0@@5|
                              (Tclass.StampedMod.Stamped
                                Tclass.TotalKMMapMod.TotalMap))
                         (U_2_bool a!1)
                         (U_2_bool (Lit (bool_2_U a!2)))))
               (a!8 ($Unbox DatatypeTypeType
                            (MapType0Select a!7 ($Box (int_2_U a!6)))))
               (a!9 (StampedMod.Stamped.Stamped_q
                      (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                        ($LS $ly@@316)
                        (MsgHistoryMod.MsgHistory.DiscardRecent
                          (Lit this@@43)
                          a!6)
                        (Lit |orig#0@@5|))))
               (a!10 (StampedMod.Stamped.value
                       (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                         ($LS $ly@@316)
                         (MsgHistoryMod.MsgHistory.DiscardRecent
                           (Lit this@@43)
                           a!6)
                         (Lit |orig#0@@5|))))
               (a!13 (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                       ($LS $ly@@316)
                       (Lit (MsgHistoryMod.MsgHistory.DiscardRecent
                              (Lit this@@43)
                              a!6))
                       (Lit |orig#0@@5|))))
         (let ((a!4 (and (= (type $ly@@316) LayerTypeType)
                         (= (type this@@43) DatatypeTypeType)
                         (= (type |orig#0@@5|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                               (Lit this@@43)
                               (Lit |orig#0@@5|))
                             a!3)))
               (a!11 (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType
                                                                        BoxType)
                                                              a!10))
                                     ($Box (MsgHistoryMod.KeyedMessage.key a!8))))
               (a!14 (Lit ($Unbox (IMapType BoxType BoxType)
                                  (StampedMod.Stamped.value (Lit a!13)))))
               (a!17 (LitInt (INTERNAL_add_boogie
                               (StampedMod.Stamped.seqEnd (Lit a!13))
                               1))))
         (let ((a!12 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@43))
                          (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                            (Lit this@@43)
                            a!6)
                          (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                            (MsgHistoryMod.MsgHistory.DiscardRecent
                              (Lit this@@43)
                              a!6)
                            (Lit |orig#0@@5|))
                          (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                 (Lit this@@43))
                               (MsgHistoryMod.KeyedMessage.KeyedMessage_q a!8))
                          (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                 (Lit this@@43))
                               (MsgHistoryMod.KeyedMessage.KeyedMessage_q a!8))
                          a!9
                          a!9
                          (|ValueMessage.__default.Merge#canCall|
                            (MsgHistoryMod.KeyedMessage.message a!8)
                            ($Unbox DatatypeTypeType a!11))
                          a!9))
               (a!15 ($Unbox DatatypeTypeType
                             (MapType0Select (|IMap#Elements| a!14)
                                             ($Box (MsgHistoryMod.KeyedMessage.key
                                                     a!8))))))
         (let ((a!16 (|IMap#Build| a!14
                                   ($Box (MsgHistoryMod.KeyedMessage.key a!8))
                                   ($Box (ValueMessage.__default.Merge
                                           (MsgHistoryMod.KeyedMessage.message
                                             a!8)
                                           a!15)))))
         (let ((a!18 (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                          ($LS $ly@@316)
                          (Lit this@@43)
                          (Lit |orig#0@@5|))
                        (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@43))
                             |orig#0@@5|
                             (|#StampedMod.Stamped.Stamped| ($Box a!16) a!17)))))
         (let ((a!19 (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                            (Lit this@@43))
                          (=> (not (U_2_bool a!5)) a!12)
                          a!18)))
           (=> a!4 a!19))))))))
         :pattern ((MsgHistoryMod.MsgHistory.ApplyToStampedMap
                     ($LS $ly@@316)
                     (Lit this@@43)
                     (Lit |orig#0@@5|)))
         :weight 3
         :skolemid |2819|
         :qid |MsgHistoryidfy.94:14|))))
(assert (=> true
    (forall ((this@@44 T@U) (|lsn#0@@10| Int))
      (! (let ((a!1 (and (= (type this@@44) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall|
                               this@@44
                               |lsn#0@@10|)
                             (and ($Is this@@44 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@10|))))))
           (=> a!1 true))
         :pattern ((MsgHistoryMod.MsgHistory.CanDiscardTo this@@44 |lsn#0@@10|))
         :skolemid |2820|
         :qid |MsgHistoryidfy.112:15|))))
(assert (forall ((this@@45 T@U) (|lsn#0@@11| Int))
  (! (=> (= (type this@@45) DatatypeTypeType)
         (=> (and ($Is this@@45 Tclass.MsgHistoryMod.MsgHistory)
                  (INTERNAL_le_boogie 0 |lsn#0@@11|))
             (= (|MsgHistoryMod.MsgHistory.CanDiscardTo#requires|
                  this@@45
                  |lsn#0@@11|)
                true)))
     :pattern ((|MsgHistoryMod.MsgHistory.CanDiscardTo#requires|
                 this@@45
                 |lsn#0@@11|))
     :skolemid |2821|
     :qid |MsgHistoryidfy.112:15|)))
(assert (=> true
    (forall ((this@@46 T@U) (|lsn#0@@12| Int))
      (! (let ((a!1 (and (= (type this@@46) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall|
                               this@@46
                               |lsn#0@@12|)
                             (and ($Is this@@46 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@12|)))))
               (a!2 (= (MsgHistoryMod.MsgHistory.CanDiscardTo
                         this@@46
                         |lsn#0@@12|)
                       (and (INTERNAL_le_boogie
                              (MsgHistoryMod.MsgHistory.seqStart this@@46)
                              |lsn#0@@12|)
                            (INTERNAL_le_boogie
                              |lsn#0@@12|
                              (MsgHistoryMod.MsgHistory.seqEnd this@@46))))))
         (let ((a!3 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@46)
                         (=> (INTERNAL_le_boogie
                               (MsgHistoryMod.MsgHistory.seqStart this@@46)
                               |lsn#0@@12|)
                             (MsgHistoryMod.MsgHistory.MsgHistory_q this@@46))
                         a!2)))
           (=> a!1 a!3)))
         :pattern ((MsgHistoryMod.MsgHistory.CanDiscardTo this@@46 |lsn#0@@12|))
         :skolemid |2822|
         :qid |MsgHistoryidfy.112:15|))))
(assert (=> true
    (forall ((this@@47 T@U) (|lsn#0@@13| Int))
      (! (let ((a!1 (and (= (type this@@47) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall|
                               (Lit this@@47)
                               (LitInt |lsn#0@@13|))
                             (and ($Is this@@47 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@13|)))))
               (a!2 (=> (INTERNAL_le_boogie
                          (MsgHistoryMod.MsgHistory.seqStart (Lit this@@47))
                          |lsn#0@@13|)
                        (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@47))))
               (a!3 (and (INTERNAL_le_boogie
                           (MsgHistoryMod.MsgHistory.seqStart (Lit this@@47))
                           |lsn#0@@13|)
                         (INTERNAL_le_boogie
                           |lsn#0@@13|
                           (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@47))))))
         (let ((a!4 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@47))
                         a!2
                         (= (MsgHistoryMod.MsgHistory.CanDiscardTo
                              (Lit this@@47)
                              (LitInt |lsn#0@@13|))
                            a!3))))
           (=> a!1 a!4)))
         :pattern ((MsgHistoryMod.MsgHistory.CanDiscardTo
                     (Lit this@@47)
                     (LitInt |lsn#0@@13|)))
         :weight 3
         :skolemid |2823|
         :qid |MsgHistoryidfy.112:15|))))
(assert (forall ((arg0@@535 T@U) (arg1@@268 Int))
  (! (= (type (MsgHistoryMod.MsgHistory.DiscardOld arg0@@535 arg1@@268))
        DatatypeTypeType)
     :pattern ((MsgHistoryMod.MsgHistory.DiscardOld arg0@@535 arg1@@268))
     :qid |funType:MsgHistoryMod.MsgHistory.DiscardOld|)))
(assert (let ((a!1 (forall ((this@@48 T@U) (|lsn#0@@14| Int))
             (! (let ((a!1 (and (= (type this@@48) DatatypeTypeType)
                                (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall|
                                      this@@48
                                      |lsn#0@@14|)
                                    (and ($Is this@@48
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         (INTERNAL_le_boogie 0 |lsn#0@@14|)
                                         (MsgHistoryMod.MsgHistory.WF this@@48)
                                         (MsgHistoryMod.MsgHistory.CanDiscardTo
                                           this@@48
                                           |lsn#0@@14|))))))
                  (=> a!1
                      (and (MsgHistoryMod.MsgHistory.WF
                             (MsgHistoryMod.MsgHistory.DiscardOld
                               this@@48
                               |lsn#0@@14|))
                           ($Is (MsgHistoryMod.MsgHistory.DiscardOld
                                  this@@48
                                  |lsn#0@@14|)
                                Tclass.MsgHistoryMod.MsgHistory))))
                :pattern ((MsgHistoryMod.MsgHistory.DiscardOld
                            this@@48
                            |lsn#0@@14|))
                :skolemid |2824|
                :qid |MsgHistoryidfy.121:14|))))
  (=> true a!1)))
(assert (forall ((this@@49 T@U) (|lsn#0@@15| Int))
  (! (let ((a!1 (=> (and ($Is this@@49 Tclass.MsgHistoryMod.MsgHistory)
                         (INTERNAL_le_boogie 0 |lsn#0@@15|))
                    (= (|MsgHistoryMod.MsgHistory.DiscardOld#requires|
                         this@@49
                         |lsn#0@@15|)
                       (and (MsgHistoryMod.MsgHistory.WF this@@49)
                            (MsgHistoryMod.MsgHistory.CanDiscardTo
                              this@@49
                              |lsn#0@@15|))))))
       (=> (= (type this@@49) DatatypeTypeType) a!1))
     :pattern ((|MsgHistoryMod.MsgHistory.DiscardOld#requires|
                 this@@49
                 |lsn#0@@15|))
     :skolemid |2825|
     :qid |MsgHistoryidfy.121:14|)))
(assert (=> true
    (forall ((this@@50 T@U) (|lsn#0@@16| Int))
      (! (let ((a!1 (and (= (type this@@50) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall|
                               this@@50
                               |lsn#0@@16|)
                             (and ($Is this@@50 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@16|)
                                  (MsgHistoryMod.MsgHistory.WF this@@50)
                                  (MsgHistoryMod.MsgHistory.CanDiscardTo
                                    this@@50
                                    |lsn#0@@16|)))))
               (a!2 (forall ((|k#0@@68| T@U))
                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                               |lsn#0@@16|
                                               (U_2_int |k#0@@68|))
                                             (INTERNAL_lt_boogie
                                               (U_2_int |k#0@@68|)
                                               (MsgHistoryMod.MsgHistory.seqEnd
                                                 this@@50)))
                                        (MsgHistoryMod.MsgHistory.MsgHistory_q
                                          this@@50))))
                         (let ((a!2 (and (=> (INTERNAL_le_boogie
                                               |lsn#0@@16|
                                               (U_2_int |k#0@@68|))
                                             (MsgHistoryMod.MsgHistory.MsgHistory_q
                                               this@@50))
                                         a!1)))
                           (=> (= (type |k#0@@68|) intType) a!2)))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@50))
                                                           ($Box |k#0@@68|))))
                         :skolemid |2826|
                         :qid |MsgHistoryidfy.126:26|)))
               (a!3 (|Map#Glue| (|lambda#211| TInt
                                              |lsn#0@@16|
                                              (MsgHistoryMod.MsgHistory.seqEnd
                                                this@@50))
                                (|lambda#148| (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                this@@50)))
                                (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
         (let ((a!4 (and a!2
                         (MsgHistoryMod.MsgHistory.MsgHistory_q this@@50)
                         (= (MsgHistoryMod.MsgHistory.DiscardOld
                              this@@50
                              |lsn#0@@16|)
                            (|#MsgHistoryMod.MsgHistory.MsgHistory|
                              a!3
                              |lsn#0@@16|
                              (MsgHistoryMod.MsgHistory.seqEnd this@@50))))))
           (=> a!1 a!4)))
         :pattern ((MsgHistoryMod.MsgHistory.DiscardOld this@@50 |lsn#0@@16|))
         :skolemid |2827|
         :qid |MsgHistoryidfy.121:14|))))
(assert (=> true
    (forall ((this@@51 T@U) (|lsn#0@@17| Int))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@51)))))
               (a!2 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanDiscardTo
                                     (Lit this@@51)
                                     (LitInt |lsn#0@@17|)))))
               (a!4 (forall ((|k#0@@69| T@U))
                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                           |lsn#0@@17|
                                           (U_2_int |k#0@@69|))
                                         (INTERNAL_lt_boogie
                                           (U_2_int |k#0@@69|)
                                           (MsgHistoryMod.MsgHistory.seqEnd
                                             (Lit this@@51))))))
                         (let ((a!2 (and (=> (INTERNAL_le_boogie
                                               |lsn#0@@17|
                                               (U_2_int |k#0@@69|))
                                             (MsgHistoryMod.MsgHistory.MsgHistory_q
                                               (Lit this@@51)))
                                         (=> a!1
                                             (MsgHistoryMod.MsgHistory.MsgHistory_q
                                               (Lit this@@51))))))
                           (=> (= (type |k#0@@69|) intType) a!2)))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@51))
                                                           ($Box |k#0@@69|))))
                         :skolemid |2828|
                         :qid |MsgHistoryidfy.126:26|)))
               (a!5 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                           (Lit this@@51))))))
         (let ((a!3 (and (= (type this@@51) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall|
                               (Lit this@@51)
                               (LitInt |lsn#0@@17|))
                             (and ($Is this@@51 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@17|)
                                  (U_2_bool a!1)
                                  (U_2_bool a!2)))))
               (a!6 (|Map#Glue| (|lambda#211| TInt
                                              |lsn#0@@17|
                                              (MsgHistoryMod.MsgHistory.seqEnd
                                                (Lit this@@51)))
                                (|lambda#148| a!5)
                                (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
         (let ((a!7 (|#MsgHistoryMod.MsgHistory.MsgHistory|
                      a!6
                      (LitInt |lsn#0@@17|)
                      (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@51))))))
         (let ((a!8 (and a!4
                         (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@51))
                         (= (MsgHistoryMod.MsgHistory.DiscardOld
                              (Lit this@@51)
                              (LitInt |lsn#0@@17|))
                            a!7))))
           (=> a!3 a!8)))))
         :pattern ((MsgHistoryMod.MsgHistory.DiscardOld
                     (Lit this@@51)
                     (LitInt |lsn#0@@17|)))
         :weight 3
         :skolemid |2829|
         :qid |MsgHistoryidfy.121:14|))))
(assert (forall ((arg0@@536 T@U) (arg1@@269 Int))
  (! (= (type (MsgHistoryMod.MsgHistory.MaybeDiscardOld arg0@@536 arg1@@269))
        DatatypeTypeType)
     :pattern ((MsgHistoryMod.MsgHistory.MaybeDiscardOld arg0@@536 arg1@@269))
     :qid |funType:MsgHistoryMod.MsgHistory.MaybeDiscardOld|)))
(assert (let ((a!1 (forall ((this@@52 T@U) (|lsn#0@@18| Int))
             (! (let ((a!1 (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall|
                                 this@@52
                                 |lsn#0@@18|)
                               (and ($Is this@@52
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    (INTERNAL_le_boogie 0 |lsn#0@@18|)
                                    (MsgHistoryMod.MsgHistory.WF this@@52)
                                    (INTERNAL_le_boogie
                                      |lsn#0@@18|
                                      (MsgHistoryMod.MsgHistory.seqEnd this@@52))))))
                  (=> (and (= (type this@@52) DatatypeTypeType) a!1)
                      (and (MsgHistoryMod.MsgHistory.WF
                             (MsgHistoryMod.MsgHistory.MaybeDiscardOld
                               this@@52
                               |lsn#0@@18|))
                           ($Is (MsgHistoryMod.MsgHistory.MaybeDiscardOld
                                  this@@52
                                  |lsn#0@@18|)
                                Tclass.MsgHistoryMod.MsgHistory))))
                :pattern ((MsgHistoryMod.MsgHistory.MaybeDiscardOld
                            this@@52
                            |lsn#0@@18|))
                :skolemid |2830|
                :qid |MsgHistoryidfy.130:14|))))
  (=> true a!1)))
(assert (forall ((this@@53 T@U) (|lsn#0@@19| Int))
  (! (let ((a!1 (= (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires|
                     this@@53
                     |lsn#0@@19|)
                   (and (MsgHistoryMod.MsgHistory.WF this@@53)
                        (INTERNAL_le_boogie
                          |lsn#0@@19|
                          (MsgHistoryMod.MsgHistory.seqEnd this@@53))))))
       (=> (= (type this@@53) DatatypeTypeType)
           (=> (and ($Is this@@53 Tclass.MsgHistoryMod.MsgHistory)
                    (INTERNAL_le_boogie 0 |lsn#0@@19|))
               a!1)))
     :pattern ((|MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires|
                 this@@53
                 |lsn#0@@19|))
     :skolemid |2831|
     :qid |MsgHistoryidfy.130:14|)))
(assert (let ((a!1 (forall ((this@@54 T@U) (|lsn#0@@20| Int))
             (! (let ((a!1 (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall|
                                 this@@54
                                 |lsn#0@@20|)
                               (and ($Is this@@54
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    (INTERNAL_le_boogie 0 |lsn#0@@20|)
                                    (MsgHistoryMod.MsgHistory.WF this@@54)
                                    (INTERNAL_le_boogie
                                      |lsn#0@@20|
                                      (MsgHistoryMod.MsgHistory.seqEnd this@@54)))))
                      (a!2 (= (MsgHistoryMod.MsgHistory.MaybeDiscardOld
                                this@@54
                                |lsn#0@@20|)
                              (ite (INTERNAL_le_boogie
                                     (MsgHistoryMod.MsgHistory.seqStart
                                       this@@54)
                                     |lsn#0@@20|)
                                   (MsgHistoryMod.MsgHistory.DiscardOld
                                     this@@54
                                     |lsn#0@@20|)
                                   this@@54))))
                (let ((a!3 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@54)
                                (=> (INTERNAL_le_boogie
                                      (MsgHistoryMod.MsgHistory.seqStart
                                        this@@54)
                                      |lsn#0@@20|)
                                    (|MsgHistoryMod.MsgHistory.DiscardOld#canCall|
                                      this@@54
                                      |lsn#0@@20|))
                                a!2)))
                  (=> (and (= (type this@@54) DatatypeTypeType) a!1) a!3)))
                :pattern ((MsgHistoryMod.MsgHistory.MaybeDiscardOld
                            this@@54
                            |lsn#0@@20|))
                :skolemid |2832|
                :qid |MsgHistoryidfy.130:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@55 T@U) (|lsn#0@@21| Int))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@55)))))
               (a!4 (=> (INTERNAL_le_boogie
                          (MsgHistoryMod.MsgHistory.seqStart (Lit this@@55))
                          |lsn#0@@21|)
                        (|MsgHistoryMod.MsgHistory.DiscardOld#canCall|
                          (Lit this@@55)
                          (LitInt |lsn#0@@21|))))
               (a!5 (ite (INTERNAL_le_boogie
                           (MsgHistoryMod.MsgHistory.seqStart (Lit this@@55))
                           |lsn#0@@21|)
                         (MsgHistoryMod.MsgHistory.DiscardOld
                           (Lit this@@55)
                           (LitInt |lsn#0@@21|))
                         this@@55)))
         (let ((a!2 (and ($Is this@@55 Tclass.MsgHistoryMod.MsgHistory)
                         (INTERNAL_le_boogie 0 |lsn#0@@21|)
                         (U_2_bool a!1)
                         (INTERNAL_le_boogie
                           |lsn#0@@21|
                           (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@55)))))
               (a!6 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@55))
                         a!4
                         (= (MsgHistoryMod.MsgHistory.MaybeDiscardOld
                              (Lit this@@55)
                              (LitInt |lsn#0@@21|))
                            a!5))))
         (let ((a!3 (and (= (type this@@55) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall|
                               (Lit this@@55)
                               (LitInt |lsn#0@@21|))
                             a!2))))
           (=> a!3 a!6))))
         :pattern ((MsgHistoryMod.MsgHistory.MaybeDiscardOld
                     (Lit this@@55)
                     (LitInt |lsn#0@@21|)))
         :weight 3
         :skolemid |2833|
         :qid |MsgHistoryidfy.130:14|))))
(assert (let ((a!1 (forall ((this@@56 T@U) (|lsn#0@@22| Int))
             (! (let ((a!1 (and (= (type this@@56) DatatypeTypeType)
                                (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                                      this@@56
                                      |lsn#0@@22|)
                                    (and ($Is this@@56
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         (INTERNAL_le_boogie 0 |lsn#0@@22|)
                                         (MsgHistoryMod.MsgHistory.CanDiscardTo
                                           this@@56
                                           |lsn#0@@22|)
                                         (MsgHistoryMod.MsgHistory.WF this@@56))))))
                  (=> a!1
                      (and (MsgHistoryMod.MsgHistory.WF
                             (MsgHistoryMod.MsgHistory.DiscardRecent
                               this@@56
                               |lsn#0@@22|))
                           ($Is (MsgHistoryMod.MsgHistory.DiscardRecent
                                  this@@56
                                  |lsn#0@@22|)
                                Tclass.MsgHistoryMod.MsgHistory))))
                :pattern ((MsgHistoryMod.MsgHistory.DiscardRecent
                            this@@56
                            |lsn#0@@22|))
                :skolemid |2834|
                :qid |MsgHistoryidfy.140:14|))))
  (=> true a!1)))
(assert (forall ((this@@57 T@U) (|lsn#0@@23| Int))
  (! (let ((a!1 (=> (and ($Is this@@57 Tclass.MsgHistoryMod.MsgHistory)
                         (INTERNAL_le_boogie 0 |lsn#0@@23|))
                    (= (|MsgHistoryMod.MsgHistory.DiscardRecent#requires|
                         this@@57
                         |lsn#0@@23|)
                       (and (MsgHistoryMod.MsgHistory.CanDiscardTo
                              this@@57
                              |lsn#0@@23|)
                            (MsgHistoryMod.MsgHistory.WF this@@57))))))
       (=> (= (type this@@57) DatatypeTypeType) a!1))
     :pattern ((|MsgHistoryMod.MsgHistory.DiscardRecent#requires|
                 this@@57
                 |lsn#0@@23|))
     :skolemid |2835|
     :qid |MsgHistoryidfy.140:14|)))
(assert (=> true
    (forall ((this@@58 T@U) (|lsn#0@@24| Int))
      (! (let ((a!1 (and (= (type this@@58) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                               this@@58
                               |lsn#0@@24|)
                             (and ($Is this@@58 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@24|)
                                  (MsgHistoryMod.MsgHistory.CanDiscardTo
                                    this@@58
                                    |lsn#0@@24|)
                                  (MsgHistoryMod.MsgHistory.WF this@@58)))))
               (a!2 (forall ((|k#0@@70| T@U))
                      (! (let ((a!1 (=> (and (INTERNAL_le_boogie
                                               (MsgHistoryMod.MsgHistory.seqStart
                                                 this@@58)
                                               (U_2_int |k#0@@70|))
                                             (INTERNAL_lt_boogie
                                               (U_2_int |k#0@@70|)
                                               |lsn#0@@24|))
                                        (MsgHistoryMod.MsgHistory.MsgHistory_q
                                          this@@58))))
                           (=> (= (type |k#0@@70|) intType)
                               (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                      this@@58)
                                    a!1)))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@58))
                                                           ($Box |k#0@@70|))))
                         :skolemid |2836|
                         :qid |MsgHistoryidfy.145:26|)))
               (a!3 (|Map#Glue| (|lambda#211| TInt
                                              (MsgHistoryMod.MsgHistory.seqStart
                                                this@@58)
                                              |lsn#0@@24|)
                                (|lambda#148| (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                this@@58)))
                                (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
         (let ((a!4 (and a!2
                         (MsgHistoryMod.MsgHistory.MsgHistory_q this@@58)
                         (= (MsgHistoryMod.MsgHistory.DiscardRecent
                              this@@58
                              |lsn#0@@24|)
                            (|#MsgHistoryMod.MsgHistory.MsgHistory|
                              a!3
                              (MsgHistoryMod.MsgHistory.seqStart this@@58)
                              |lsn#0@@24|)))))
           (=> a!1 a!4)))
         :pattern ((MsgHistoryMod.MsgHistory.DiscardRecent this@@58 |lsn#0@@24|))
         :skolemid |2837|
         :qid |MsgHistoryidfy.140:14|))))
(assert (=> true
    (forall ((this@@59 T@U) (|lsn#0@@25| Int))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanDiscardTo
                                     (Lit this@@59)
                                     (LitInt |lsn#0@@25|)))))
               (a!2 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@59)))))
               (a!4 (forall ((|k#0@@71| T@U))
                      (! (let ((a!1 (and (INTERNAL_le_boogie
                                           (MsgHistoryMod.MsgHistory.seqStart
                                             (Lit this@@59))
                                           (U_2_int |k#0@@71|))
                                         (INTERNAL_lt_boogie
                                           (U_2_int |k#0@@71|)
                                           |lsn#0@@25|))))
                         (let ((a!2 (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                           (Lit this@@59))
                                         (=> a!1
                                             (MsgHistoryMod.MsgHistory.MsgHistory_q
                                               (Lit this@@59))))))
                           (=> (= (type |k#0@@71|) intType) a!2)))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@59))
                                                           ($Box |k#0@@71|))))
                         :skolemid |2838|
                         :qid |MsgHistoryidfy.145:26|)))
               (a!5 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                           (Lit this@@59))))))
         (let ((a!3 (and (= (type this@@59) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                               (Lit this@@59)
                               (LitInt |lsn#0@@25|))
                             (and ($Is this@@59 Tclass.MsgHistoryMod.MsgHistory)
                                  (INTERNAL_le_boogie 0 |lsn#0@@25|)
                                  (U_2_bool a!1)
                                  (U_2_bool a!2)))))
               (a!6 (|Map#Glue| (|lambda#211| TInt
                                              (MsgHistoryMod.MsgHistory.seqStart
                                                (Lit this@@59))
                                              |lsn#0@@25|)
                                (|lambda#148| a!5)
                                (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
         (let ((a!7 (|#MsgHistoryMod.MsgHistory.MsgHistory|
                      a!6
                      (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@59)))
                      (LitInt |lsn#0@@25|))))
         (let ((a!8 (and a!4
                         (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@59))
                         (= (MsgHistoryMod.MsgHistory.DiscardRecent
                              (Lit this@@59)
                              (LitInt |lsn#0@@25|))
                            a!7))))
           (=> a!3 a!8)))))
         :pattern ((MsgHistoryMod.MsgHistory.DiscardRecent
                     (Lit this@@59)
                     (LitInt |lsn#0@@25|)))
         :weight 3
         :skolemid |2839|
         :qid |MsgHistoryidfy.140:14|))))
(assert (=> true
    (forall ((this@@60 T@U) (|subseq#0| T@U))
      (! (let ((a!1 (and (= (type this@@60) DatatypeTypeType)
                         (= (type |subseq#0|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall|
                               this@@60
                               |subseq#0|)
                             (and ($Is this@@60 Tclass.MsgHistoryMod.MsgHistory)
                                  ($Is |subseq#0|
                                       Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@60)
                                  (MsgHistoryMod.MsgHistory.WF |subseq#0|)))
                         (MsgHistoryMod.MsgHistory.IncludesSubseq
                           this@@60
                           |subseq#0|)
                         (MsgHistoryMod.MsgHistory.IsEmpty this@@60))))
           (=> a!1 (MsgHistoryMod.MsgHistory.IsEmpty |subseq#0|)))
         :pattern ((MsgHistoryMod.MsgHistory.IncludesSubseq this@@60 |subseq#0|))
         :skolemid |2840|
         :qid |MsgHistoryidfy.149:15|))))
(assert (forall ((this@@61 T@U) (|subseq#0@@0| T@U))
  (! (=> (and (= (type this@@61) DatatypeTypeType)
              (= (type |subseq#0@@0|) DatatypeTypeType)
              ($Is this@@61 Tclass.MsgHistoryMod.MsgHistory)
              ($Is |subseq#0@@0| Tclass.MsgHistoryMod.MsgHistory))
         (= (|MsgHistoryMod.MsgHistory.IncludesSubseq#requires|
              this@@61
              |subseq#0@@0|)
            (and (MsgHistoryMod.MsgHistory.WF this@@61)
                 (MsgHistoryMod.MsgHistory.WF |subseq#0@@0|))))
     :pattern ((|MsgHistoryMod.MsgHistory.IncludesSubseq#requires|
                 this@@61
                 |subseq#0@@0|))
     :skolemid |2841|
     :qid |MsgHistoryidfy.149:15|)))
(assert (=> true
    (forall ((this@@62 T@U) (|subseq#0@@1| T@U))
      (! (let ((a!1 (and (= (type this@@62) DatatypeTypeType)
                         (= (type |subseq#0@@1|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall|
                               this@@62
                               |subseq#0@@1|)
                             (and ($Is this@@62 Tclass.MsgHistoryMod.MsgHistory)
                                  ($Is |subseq#0@@1|
                                       Tclass.MsgHistoryMod.MsgHistory)
                                  (MsgHistoryMod.MsgHistory.WF this@@62)
                                  (MsgHistoryMod.MsgHistory.WF |subseq#0@@1|)))))
               (a!2 (forall ((|lsn#0@@26| Int))
                      (! (let ((a!1 ($Unbox DatatypeTypeType
                                            (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                              this@@62))
                                                            ($Box (int_2_U |lsn#0@@26|)))))
                               (a!2 ($Unbox DatatypeTypeType
                                            (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                              |subseq#0@@1|))
                                                            ($Box (int_2_U |lsn#0@@26|))))))
                         (let ((a!3 (and (|MsgHistoryMod.MsgHistory.Contains#canCall|
                                           this@@62
                                           |lsn#0@@26|)
                                         (=> (MsgHistoryMod.MsgHistory.Contains
                                               this@@62
                                               |lsn#0@@26|)
                                             (and (|$IsA#MsgHistoryMod.KeyedMessage|
                                                    a!1)
                                                  (|$IsA#MsgHistoryMod.KeyedMessage|
                                                    a!2)
                                                  (MsgHistoryMod.MsgHistory.MsgHistory_q
                                                    this@@62)
                                                  (MsgHistoryMod.MsgHistory.MsgHistory_q
                                                    |subseq#0@@1|))))))
                           (=> (INTERNAL_le_boogie 0 |lsn#0@@26|)
                               (and (|MsgHistoryMod.MsgHistory.Contains#canCall|
                                      |subseq#0@@1|
                                      |lsn#0@@26|)
                                    (=> (MsgHistoryMod.MsgHistory.Contains
                                          |subseq#0@@1|
                                          |lsn#0@@26|)
                                        a!3)))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             |subseq#0@@1|))
                                                           ($Box (int_2_U |lsn#0@@26|)))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@62))
                                                           ($Box (int_2_U |lsn#0@@26|)))))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     this@@62
                                     |lsn#0@@26|))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     |subseq#0@@1|
                                     |lsn#0@@26|))
                         :skolemid |2843|
                         :qid |MsgHistoryidfy.156:31|)))
               (a!4 (forall ((|lsn#0@@27| Int))
                      (! (let ((a!1 ($Unbox DatatypeTypeType
                                            (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                              this@@62))
                                                            ($Box (int_2_U |lsn#0@@27|)))))
                               (a!2 ($Unbox DatatypeTypeType
                                            (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                              |subseq#0@@1|))
                                                            ($Box (int_2_U |lsn#0@@27|))))))
                           (=> (and (INTERNAL_le_boogie 0 |lsn#0@@27|)
                                    (MsgHistoryMod.MsgHistory.Contains
                                      |subseq#0@@1|
                                      |lsn#0@@27|))
                               (and (MsgHistoryMod.MsgHistory.Contains
                                      this@@62
                                      |lsn#0@@27|)
                                    (|MsgHistoryMod.KeyedMessage#Equal| a!1 a!2))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             |subseq#0@@1|))
                                                           ($Box (int_2_U |lsn#0@@27|)))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@62))
                                                           ($Box (int_2_U |lsn#0@@27|)))))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     this@@62
                                     |lsn#0@@27|))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     |subseq#0@@1|
                                     |lsn#0@@27|))
                         :skolemid |2842|
                         :qid |MsgHistoryidfy.156:31|))))
         (let ((a!3 (and (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|)
                         (MsgHistoryMod.MsgHistory.MsgHistory_q this@@62)
                         (=> (INTERNAL_le_boogie
                               (MsgHistoryMod.MsgHistory.seqEnd |subseq#0@@1|)
                               (MsgHistoryMod.MsgHistory.seqEnd this@@62))
                             a!2)))
               (a!5 (= (MsgHistoryMod.MsgHistory.IncludesSubseq
                         this@@62
                         |subseq#0@@1|)
                       (and (INTERNAL_le_boogie
                              (MsgHistoryMod.MsgHistory.seqStart this@@62)
                              (MsgHistoryMod.MsgHistory.seqStart |subseq#0@@1|))
                            (INTERNAL_le_boogie
                              (MsgHistoryMod.MsgHistory.seqEnd |subseq#0@@1|)
                              (MsgHistoryMod.MsgHistory.seqEnd this@@62))
                            a!4))))
         (let ((a!6 (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@62)
                         (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|)
                         (=> (INTERNAL_le_boogie
                               (MsgHistoryMod.MsgHistory.seqStart this@@62)
                               (MsgHistoryMod.MsgHistory.seqStart |subseq#0@@1|))
                             a!3)
                         a!5)))
           (=> a!1 a!6))))
         :pattern ((MsgHistoryMod.MsgHistory.IncludesSubseq
                     this@@62
                     |subseq#0@@1|))
         :skolemid |2845|
         :qid |MsgHistoryidfy.149:15|))))
(assert (=> true
    (forall ((this@@63 T@U) (|subseq#0@@2| T@U))
      (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@63)))))
               (a!2 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                     (Lit |subseq#0@@2|)))))
               (a!4 (forall ((|lsn#1@@2| Int))
                      (! (let ((a!1 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                                           (Lit this@@63)))))
                               (a!3 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                                           (Lit |subseq#0@@2|))))))
                         (let ((a!2 ($Unbox DatatypeTypeType
                                            (MapType0Select a!1
                                                            ($Box (int_2_U |lsn#1@@2|)))))
                               (a!4 ($Unbox DatatypeTypeType
                                            (MapType0Select a!3
                                                            ($Box (int_2_U |lsn#1@@2|))))))
                         (let ((a!5 (=> (MsgHistoryMod.MsgHistory.Contains
                                          (Lit this@@63)
                                          |lsn#1@@2|)
                                        (and (|$IsA#MsgHistoryMod.KeyedMessage|
                                               a!2)
                                             (|$IsA#MsgHistoryMod.KeyedMessage|
                                               a!4)
                                             (MsgHistoryMod.MsgHistory.MsgHistory_q
                                               (Lit this@@63))
                                             (MsgHistoryMod.MsgHistory.MsgHistory_q
                                               (Lit |subseq#0@@2|))))))
                         (let ((a!6 (=> (MsgHistoryMod.MsgHistory.Contains
                                          (Lit |subseq#0@@2|)
                                          |lsn#1@@2|)
                                        (and (|MsgHistoryMod.MsgHistory.Contains#canCall|
                                               (Lit this@@63)
                                               |lsn#1@@2|)
                                             a!5))))
                           (=> (INTERNAL_le_boogie 0 |lsn#1@@2|)
                               (and (|MsgHistoryMod.MsgHistory.Contains#canCall|
                                      (Lit |subseq#0@@2|)
                                      |lsn#1@@2|)
                                    a!6))))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             |subseq#0@@2|))
                                                           ($Box (int_2_U |lsn#1@@2|)))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@63))
                                                           ($Box (int_2_U |lsn#1@@2|)))))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     this@@63
                                     |lsn#1@@2|))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     |subseq#0@@2|
                                     |lsn#1@@2|))
                         :skolemid |2847|
                         :qid |MsgHistoryidfy.156:31|)))
               (a!7 (forall ((|lsn#1@@3| Int))
                      (! (let ((a!1 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                                           (Lit this@@63)))))
                               (a!3 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                                           (Lit |subseq#0@@2|))))))
                         (let ((a!2 ($Unbox DatatypeTypeType
                                            (MapType0Select a!1
                                                            ($Box (int_2_U |lsn#1@@3|)))))
                               (a!4 ($Unbox DatatypeTypeType
                                            (MapType0Select a!3
                                                            ($Box (int_2_U |lsn#1@@3|))))))
                           (=> (and (INTERNAL_le_boogie 0 |lsn#1@@3|)
                                    (MsgHistoryMod.MsgHistory.Contains
                                      (Lit |subseq#0@@2|)
                                      |lsn#1@@3|))
                               (and (MsgHistoryMod.MsgHistory.Contains
                                      (Lit this@@63)
                                      |lsn#1@@3|)
                                    (|MsgHistoryMod.KeyedMessage#Equal| a!2 a!4)))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             |subseq#0@@2|))
                                                           ($Box (int_2_U |lsn#1@@3|)))))
                         :pattern (($Unbox DatatypeTypeType
                                           (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                             this@@63))
                                                           ($Box (int_2_U |lsn#1@@3|)))))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     this@@63
                                     |lsn#1@@3|))
                         :pattern ((MsgHistoryMod.MsgHistory.Contains
                                     |subseq#0@@2|
                                     |lsn#1@@3|))
                         :skolemid |2846|
                         :qid |MsgHistoryidfy.156:31|))))
         (let ((a!3 (and (= (type this@@63) DatatypeTypeType)
                         (= (type |subseq#0@@2|) DatatypeTypeType)
                         (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall|
                               (Lit this@@63)
                               (Lit |subseq#0@@2|))
                             (and ($Is this@@63 Tclass.MsgHistoryMod.MsgHistory)
                                  ($Is |subseq#0@@2|
                                       Tclass.MsgHistoryMod.MsgHistory)
                                  (U_2_bool a!1)
                                  (U_2_bool a!2)))))
               (a!5 (=> (INTERNAL_le_boogie
                          (MsgHistoryMod.MsgHistory.seqEnd (Lit |subseq#0@@2|))
                          (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@63)))
                        a!4))
               (a!8 (and (INTERNAL_le_boogie
                           (MsgHistoryMod.MsgHistory.seqStart (Lit this@@63))
                           (MsgHistoryMod.MsgHistory.seqStart
                             (Lit |subseq#0@@2|)))
                         (INTERNAL_le_boogie
                           (MsgHistoryMod.MsgHistory.seqEnd (Lit |subseq#0@@2|))
                           (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@63)))
                         a!7)))
         (let ((a!6 (=> (INTERNAL_le_boogie
                          (MsgHistoryMod.MsgHistory.seqStart (Lit this@@63))
                          (MsgHistoryMod.MsgHistory.seqStart
                            (Lit |subseq#0@@2|)))
                        (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                               (Lit |subseq#0@@2|))
                             (MsgHistoryMod.MsgHistory.MsgHistory_q
                               (Lit this@@63))
                             a!5))))
         (let ((a!9 (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@63))
                         (MsgHistoryMod.MsgHistory.MsgHistory_q
                           (Lit |subseq#0@@2|))
                         a!6
                         (= (MsgHistoryMod.MsgHistory.IncludesSubseq
                              (Lit this@@63)
                              (Lit |subseq#0@@2|))
                            a!8))))
           (=> a!3 a!9)))))
         :pattern ((MsgHistoryMod.MsgHistory.IncludesSubseq
                     (Lit this@@63)
                     (Lit |subseq#0@@2|)))
         :weight 3
         :skolemid |2849|
         :qid |MsgHistoryidfy.149:15|))))
(assert (= (type Tclass.MsgHistoryMod.__default) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.__default) Tagclass.MsgHistoryMod.__default))
(assert (= (TagFamily Tclass.MsgHistoryMod.__default) tytagFamily$_default))
(assert (forall ((bx@@157 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@157)) bx@@157)
                     ($Is ($Unbox refType bx@@157)
                          Tclass.MsgHistoryMod.__default))))
       (=> (and (= (type bx@@157) BoxType)
                ($IsBox bx@@157 Tclass.MsgHistoryMod.__default))
           a!1))
     :pattern (($IsBox bx@@157 Tclass.MsgHistoryMod.__default))
     :skolemid |2850|
     :qid |unknown.0:0|)))
(assert (forall (($o@@45 T@U))
  (! (let ((a!1 (= ($Is $o@@45 Tclass.MsgHistoryMod.__default)
                   (or (= $o@@45 null)
                       (= (dtype $o@@45) Tclass.MsgHistoryMod.__default)))))
       (=> (= (type $o@@45) refType) a!1))
     :pattern (($Is $o@@45 Tclass.MsgHistoryMod.__default))
     :skolemid |2851|
     :qid |unknown.0:0|)))
(assert (forall (($o@@46 T@U) ($h@@100 T@U))
  (! (let ((a!1 (or (= $o@@46 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@100 $o@@46)
                                              alloc)))))
       (=> (and (= (type $o@@46) refType)
                (= (type $h@@100) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@46 Tclass.MsgHistoryMod.__default $h@@100) a!1)))
     :pattern (($IsAlloc $o@@46 Tclass.MsgHistoryMod.__default $h@@100))
     :skolemid |2852|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@537 Int))
  (! (= (type (MsgHistoryMod.__default.EmptyHistoryAt arg0@@537))
        DatatypeTypeType)
     :pattern ((MsgHistoryMod.__default.EmptyHistoryAt arg0@@537))
     :qid |funType:MsgHistoryMod.__default.EmptyHistoryAt|)))
(assert (let ((a!1 (forall ((|lsn#0@@28| Int))
             (! (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall|
                          |lsn#0@@28|)
                        (INTERNAL_le_boogie 0 |lsn#0@@28|))
                    (and (MsgHistoryMod.MsgHistory.WF
                           (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|))
                         ($Is (MsgHistoryMod.__default.EmptyHistoryAt
                                |lsn#0@@28|)
                              Tclass.MsgHistoryMod.MsgHistory)))
                :pattern ((MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|))
                :skolemid |2853|
                :qid |MsgHistoryidfy.162:27|))))
  (=> true a!1)))
(assert (forall ((|lsn#0@@29| Int))
  (! (=> (INTERNAL_le_boogie 0 |lsn#0@@29|)
         (= (|MsgHistoryMod.__default.EmptyHistoryAt#requires| |lsn#0@@29|)
            true))
     :pattern ((|MsgHistoryMod.__default.EmptyHistoryAt#requires| |lsn#0@@29|))
     :skolemid |2854|
     :qid |MsgHistoryidfy.162:27|)))
(assert (let ((a!1 (forall ((|lsn#0@@30| Int))
             (! (let ((a!1 (= (MsgHistoryMod.__default.EmptyHistoryAt
                                |lsn#0@@30|)
                              (|#MsgHistoryMod.MsgHistory.MsgHistory|
                                (Lit (|Map#Empty| BoxType BoxType))
                                |lsn#0@@30|
                                |lsn#0@@30|))))
                  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall|
                            |lsn#0@@30|)
                          (INTERNAL_le_boogie 0 |lsn#0@@30|))
                      a!1))
                :pattern ((MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@30|))
                :skolemid |2855|
                :qid |MsgHistoryidfy.162:27|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|lsn#0@@31| Int))
             (! (let ((a!1 (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory|
                                  (Lit (|Map#Empty| BoxType BoxType))
                                  (LitInt |lsn#0@@31|)
                                  (LitInt |lsn#0@@31|)))))
                  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall|
                            (LitInt |lsn#0@@31|))
                          (INTERNAL_le_boogie 0 |lsn#0@@31|))
                      (= (MsgHistoryMod.__default.EmptyHistoryAt
                           (LitInt |lsn#0@@31|))
                         a!1)))
                :pattern ((MsgHistoryMod.__default.EmptyHistoryAt
                            (LitInt |lsn#0@@31|)))
                :weight 3
                :skolemid |2856|
                :qid |MsgHistoryidfy.162:27|))))
  (=> true a!1)))
(assert (forall ((arg0@@538 Int) (arg1@@270 T@U))
  (! (= (type (MsgHistoryMod.__default.SingletonAt arg0@@538 arg1@@270))
        DatatypeTypeType)
     :pattern ((MsgHistoryMod.__default.SingletonAt arg0@@538 arg1@@270))
     :qid |funType:MsgHistoryMod.__default.SingletonAt|)))
(assert (let ((a!1 (forall ((|lsn#0@@32| Int) (|msg#0@@3| T@U))
             (! (let ((a!1 (and (= (type |msg#0@@3|) DatatypeTypeType)
                                (or (|MsgHistoryMod.__default.SingletonAt#canCall|
                                      |lsn#0@@32|
                                      |msg#0@@3|)
                                    (and (INTERNAL_le_boogie 0 |lsn#0@@32|)
                                         ($Is |msg#0@@3|
                                              Tclass.MsgHistoryMod.KeyedMessage))))))
                  (=> a!1
                      ($Is (MsgHistoryMod.__default.SingletonAt
                             |lsn#0@@32|
                             |msg#0@@3|)
                           Tclass.MsgHistoryMod.MsgHistory)))
                :pattern ((MsgHistoryMod.__default.SingletonAt
                            |lsn#0@@32|
                            |msg#0@@3|))
                :skolemid |2857|
                :qid |MsgHistoryidfy.168:24|))))
  (=> true a!1)))
(assert (forall ((|lsn#0@@33| Int) (|msg#0@@4| T@U))
  (! (=> (= (type |msg#0@@4|) DatatypeTypeType)
         (=> (and (INTERNAL_le_boogie 0 |lsn#0@@33|)
                  ($Is |msg#0@@4| Tclass.MsgHistoryMod.KeyedMessage))
             (= (|MsgHistoryMod.__default.SingletonAt#requires|
                  |lsn#0@@33|
                  |msg#0@@4|)
                true)))
     :pattern ((|MsgHistoryMod.__default.SingletonAt#requires|
                 |lsn#0@@33|
                 |msg#0@@4|))
     :skolemid |2858|
     :qid |MsgHistoryidfy.168:24|)))
(assert (let ((a!1 (forall ((|lsn#0@@34| Int) (|msg#0@@5| T@U))
             (! (let ((a!1 (and (= (type |msg#0@@5|) DatatypeTypeType)
                                (or (|MsgHistoryMod.__default.SingletonAt#canCall|
                                      |lsn#0@@34|
                                      |msg#0@@5|)
                                    (and (INTERNAL_le_boogie 0 |lsn#0@@34|)
                                         ($Is |msg#0@@5|
                                              Tclass.MsgHistoryMod.KeyedMessage)))))
                      (a!2 (|#MsgHistoryMod.MsgHistory.MsgHistory|
                             (|Map#Build| (|Map#Empty| BoxType BoxType)
                                          ($Box (int_2_U |lsn#0@@34|))
                                          ($Box |msg#0@@5|))
                             |lsn#0@@34|
                             (INTERNAL_add_boogie |lsn#0@@34| 1))))
                  (=> a!1
                      (= (MsgHistoryMod.__default.SingletonAt
                           |lsn#0@@34|
                           |msg#0@@5|)
                         a!2)))
                :pattern ((MsgHistoryMod.__default.SingletonAt
                            |lsn#0@@34|
                            |msg#0@@5|))
                :skolemid |2859|
                :qid |MsgHistoryidfy.168:24|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|lsn#0@@35| Int) (|msg#0@@6| T@U))
             (! (let ((a!1 (and (= (type |msg#0@@6|) DatatypeTypeType)
                                (or (|MsgHistoryMod.__default.SingletonAt#canCall|
                                      (LitInt |lsn#0@@35|)
                                      (Lit |msg#0@@6|))
                                    (and (INTERNAL_le_boogie 0 |lsn#0@@35|)
                                         ($Is |msg#0@@6|
                                              Tclass.MsgHistoryMod.KeyedMessage)))))
                      (a!2 (|Map#Build| (|Map#Empty| BoxType BoxType)
                                        ($Box (int_2_U (LitInt |lsn#0@@35|)))
                                        ($Box (Lit |msg#0@@6|)))))
                (let ((a!3 (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory|
                                  (Lit a!2)
                                  (LitInt |lsn#0@@35|)
                                  (LitInt (INTERNAL_add_boogie |lsn#0@@35| 1))))))
                  (=> a!1
                      (= (MsgHistoryMod.__default.SingletonAt
                           (LitInt |lsn#0@@35|)
                           (Lit |msg#0@@6|))
                         a!3))))
                :pattern ((MsgHistoryMod.__default.SingletonAt
                            (LitInt |lsn#0@@35|)
                            (Lit |msg#0@@6|)))
                :weight 3
                :skolemid |2860|
                :qid |MsgHistoryidfy.168:24|))))
  (=> true a!1)))
(assert (forall ((arg0@@539 T@U) (arg1@@271 T@U))
  (! (= (type (MsgHistoryMod.__default.MapPlusHistory arg0@@539 arg1@@271))
        DatatypeTypeType)
     :pattern ((MsgHistoryMod.__default.MapPlusHistory arg0@@539 arg1@@271))
     :qid |funType:MsgHistoryMod.__default.MapPlusHistory|)))
(assert (let ((a!1 (forall ((|stampedMap#0| T@U) (|history#0| T@U))
             (! (let ((a!1 (or (|MsgHistoryMod.__default.MapPlusHistory#canCall|
                                 |stampedMap#0|
                                 |history#0|)
                               (and ($Is |stampedMap#0|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap))
                                    ($Is |history#0|
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    (MsgHistoryMod.MsgHistory.WF |history#0|)
                                    (MsgHistoryMod.MsgHistory.CanFollow
                                      |history#0|
                                      (StampedMod.Stamped.seqEnd |stampedMap#0|))))))
                  (=> (and (= (type |stampedMap#0|) DatatypeTypeType)
                           (= (type |history#0|) DatatypeTypeType)
                           a!1)
                      ($Is (MsgHistoryMod.__default.MapPlusHistory
                             |stampedMap#0|
                             |history#0|)
                           (Tclass.StampedMod.Stamped
                             Tclass.TotalKMMapMod.TotalMap))))
                :pattern ((MsgHistoryMod.__default.MapPlusHistory
                            |stampedMap#0|
                            |history#0|))
                :skolemid |2861|
                :qid |MsgHistoryidfy.178:27|))))
  (=> true a!1)))
(assert (forall ((|stampedMap#0@@0| T@U) (|history#0@@0| T@U))
  (! (let ((a!1 (= (|MsgHistoryMod.__default.MapPlusHistory#requires|
                     |stampedMap#0@@0|
                     |history#0@@0|)
                   (and (MsgHistoryMod.MsgHistory.WF |history#0@@0|)
                        (MsgHistoryMod.MsgHistory.CanFollow
                          |history#0@@0|
                          (StampedMod.Stamped.seqEnd |stampedMap#0@@0|))))))
       (=> (and (= (type |stampedMap#0@@0|) DatatypeTypeType)
                (= (type |history#0@@0|) DatatypeTypeType)
                ($Is |stampedMap#0@@0|
                     (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))
                ($Is |history#0@@0| Tclass.MsgHistoryMod.MsgHistory))
           a!1))
     :pattern ((|MsgHistoryMod.__default.MapPlusHistory#requires|
                 |stampedMap#0@@0|
                 |history#0@@0|))
     :skolemid |2862|
     :qid |MsgHistoryidfy.178:27|)))
(assert (let ((a!1 (forall ((|stampedMap#0@@1| T@U) (|history#0@@1| T@U))
             (! (let ((a!1 (or (|MsgHistoryMod.__default.MapPlusHistory#canCall|
                                 |stampedMap#0@@1|
                                 |history#0@@1|)
                               (and ($Is |stampedMap#0@@1|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap))
                                    ($Is |history#0@@1|
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    (MsgHistoryMod.MsgHistory.WF |history#0@@1|)
                                    (MsgHistoryMod.MsgHistory.CanFollow
                                      |history#0@@1|
                                      (StampedMod.Stamped.seqEnd
                                        |stampedMap#0@@1|)))))
                      (a!2 (and (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                                  |history#0@@1|
                                  |stampedMap#0@@1|)
                                (= (MsgHistoryMod.__default.MapPlusHistory
                                     |stampedMap#0@@1|
                                     |history#0@@1|)
                                   (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                                     ($LS $LZ)
                                     |history#0@@1|
                                     |stampedMap#0@@1|)))))
                  (=> (and (= (type |stampedMap#0@@1|) DatatypeTypeType)
                           (= (type |history#0@@1|) DatatypeTypeType)
                           a!1)
                      a!2))
                :pattern ((MsgHistoryMod.__default.MapPlusHistory
                            |stampedMap#0@@1|
                            |history#0@@1|))
                :skolemid |2863|
                :qid |MsgHistoryidfy.178:27|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|stampedMap#0@@2| T@U) (|history#0@@2| T@U))
             (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                            (Lit |history#0@@2|)))))
                      (a!2 (MsgHistoryMod.MsgHistory.CanFollow
                             (Lit |history#0@@2|)
                             (LitInt (StampedMod.Stamped.seqEnd
                                       (Lit |stampedMap#0@@2|)))))
                      (a!5 (= (MsgHistoryMod.__default.MapPlusHistory
                                (Lit |stampedMap#0@@2|)
                                (Lit |history#0@@2|))
                              (Lit (MsgHistoryMod.MsgHistory.ApplyToStampedMap
                                     ($LS $LZ)
                                     (Lit |history#0@@2|)
                                     (Lit |stampedMap#0@@2|))))))
                (let ((a!3 (and ($Is |stampedMap#0@@2|
                                     (Tclass.StampedMod.Stamped
                                       Tclass.TotalKMMapMod.TotalMap))
                                ($Is |history#0@@2|
                                     Tclass.MsgHistoryMod.MsgHistory)
                                (U_2_bool a!1)
                                (U_2_bool (Lit (bool_2_U a!2))))))
                (let ((a!4 (and (= (type |stampedMap#0@@2|) DatatypeTypeType)
                                (= (type |history#0@@2|) DatatypeTypeType)
                                (or (|MsgHistoryMod.__default.MapPlusHistory#canCall|
                                      (Lit |stampedMap#0@@2|)
                                      (Lit |history#0@@2|))
                                    a!3))))
                  (=> a!4
                      (and (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall|
                             (Lit |history#0@@2|)
                             (Lit |stampedMap#0@@2|))
                           a!5)))))
                :pattern ((MsgHistoryMod.__default.MapPlusHistory
                            (Lit |stampedMap#0@@2|)
                            (Lit |history#0@@2|)))
                :weight 3
                :skolemid |2864|
                :qid |MsgHistoryidfy.178:27|))))
  (=> true a!1)))
(assert (forall ((arg0@@540 T@U))
  (! (= (type (|#Buffers.Buffer.Buffer| arg0@@540)) DatatypeTypeType)
     :pattern ((|#Buffers.Buffer.Buffer| arg0@@540))
     :qid |funType:#Buffers.Buffer.Buffer|)))
(assert (forall ((|a#0#0#0@@3| T@U))
  (! (=> (= (type |a#0#0#0@@3|) (MapType BoxType BoxType))
         (= (DatatypeCtorId (|#Buffers.Buffer.Buffer| |a#0#0#0@@3|))
            |##Buffers.Buffer.Buffer|))
     :pattern ((|#Buffers.Buffer.Buffer| |a#0#0#0@@3|))
     :skolemid |2865|
     :qid |Buffersidfy.25:28|)))
(assert (forall ((d@@55 T@U))
  (! (=> (= (type d@@55) DatatypeTypeType)
         (= (Buffers.Buffer.Buffer_q d@@55)
            (= (DatatypeCtorId d@@55) |##Buffers.Buffer.Buffer|)))
     :pattern ((Buffers.Buffer.Buffer_q d@@55))
     :skolemid |2866|
     :qid |unknown.0:0|)))
(assert (forall ((d@@56 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@3| T@U))
                  (! (and (= (type |a#1#0#0@@3|) (MapType BoxType BoxType))
                          (= d@@56 (|#Buffers.Buffer.Buffer| |a#1#0#0@@3|)))
                     :no-pattern (type |a#1#0#0@@3|)
                     :no-pattern (U_2_int |a#1#0#0@@3|)
                     :no-pattern (U_2_bool |a#1#0#0@@3|)
                     :skolemid |2867|
                     :qid |Buffersidfy.25:28|))))
       (=> (and (= (type d@@56) DatatypeTypeType)
                (Buffers.Buffer.Buffer_q d@@56))
           a!1))
     :pattern ((Buffers.Buffer.Buffer_q d@@56))
     :skolemid |2868|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@3| T@U))
  (! (=> (= (type |a#2#0#0@@3|) (MapType BoxType BoxType))
         (= ($Is (|#Buffers.Buffer.Buffer| |a#2#0#0@@3|) Tclass.Buffers.Buffer)
            ($Is |a#2#0#0@@3|
                 (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))
     :pattern (($Is (|#Buffers.Buffer.Buffer| |a#2#0#0@@3|)
                    Tclass.Buffers.Buffer))
     :skolemid |2869|
     :qid |Buffersidfy.25:28|)))
(assert (forall ((|a#3#0#0@@3| T@U) ($h@@101 T@U))
  (! (=> (and (= (type |a#3#0#0@@3|) (MapType BoxType BoxType))
              (= (type $h@@101) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@101))
         (= ($IsAlloc (|#Buffers.Buffer.Buffer| |a#3#0#0@@3|)
                      Tclass.Buffers.Buffer
                      $h@@101)
            ($IsAlloc |a#3#0#0@@3|
                      (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message)
                      $h@@101)))
     :pattern (($IsAlloc (|#Buffers.Buffer.Buffer| |a#3#0#0@@3|)
                         Tclass.Buffers.Buffer
                         $h@@101))
     :skolemid |2870|
     :qid |Buffersidfy.25:28|)))
(assert (forall ((arg0@@541 T@U))
  (! (= (type (Buffers.Buffer.mapp arg0@@541)) (MapType BoxType BoxType))
     :pattern ((Buffers.Buffer.mapp arg0@@541))
     :qid |funType:Buffers.Buffer.mapp|)))
(assert (forall ((d@@57 T@U) ($h@@102 T@U))
  (! (=> (and (= (type d@@57) DatatypeTypeType)
              (= (type $h@@102) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@102)
              (Buffers.Buffer.Buffer_q d@@57)
              ($IsAlloc d@@57 Tclass.Buffers.Buffer $h@@102))
         ($IsAlloc (Buffers.Buffer.mapp d@@57)
                   (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message)
                   $h@@102))
     :pattern (($IsAlloc (Buffers.Buffer.mapp d@@57)
                         (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message)
                         $h@@102))
     :skolemid |2871|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@3| T@U))
  (! (=> (= (type |a#4#0#0@@3|) (MapType BoxType BoxType))
         (= (|#Buffers.Buffer.Buffer| (Lit |a#4#0#0@@3|))
            (Lit (|#Buffers.Buffer.Buffer| |a#4#0#0@@3|))))
     :pattern ((|#Buffers.Buffer.Buffer| (Lit |a#4#0#0@@3|)))
     :skolemid |2872|
     :qid |Buffersidfy.25:28|)))
(assert (forall ((|a#5#0#0@@4| T@U))
  (! (=> (= (type |a#5#0#0@@4|) (MapType BoxType BoxType))
         (= (Buffers.Buffer.mapp (|#Buffers.Buffer.Buffer| |a#5#0#0@@4|))
            |a#5#0#0@@4|))
     :pattern ((|#Buffers.Buffer.Buffer| |a#5#0#0@@4|))
     :skolemid |2873|
     :qid |Buffersidfy.25:28|)))
(assert (forall ((|a#6#0#0@@4| T@U) (d@@58 T@U))
  (! (let ((a!1 (and (= (type |a#6#0#0@@4|) (MapType BoxType BoxType))
                     (= (type d@@58) DatatypeTypeType)
                     (U_2_bool (MapType0Select (|Map#Domain| |a#6#0#0@@4|)
                                               ($Box d@@58))))))
       (=> a!1
           (< (DtRank d@@58) (DtRank (|#Buffers.Buffer.Buffer| |a#6#0#0@@4|)))))
     :pattern ((MapType0Select (|Map#Domain| |a#6#0#0@@4|) ($Box d@@58))
               (|#Buffers.Buffer.Buffer| |a#6#0#0@@4|))
     :skolemid |2874|
     :qid |Buffersidfy.25:28|)))
(assert (forall ((|a#7#0#0@@4| T@U) (bx@@158 T@U))
  (! (let ((a!1 (and (= (type |a#7#0#0@@4|) (MapType BoxType BoxType))
                     (= (type bx@@158) BoxType)
                     (U_2_bool (MapType0Select (|Map#Domain| |a#7#0#0@@4|)
                                               bx@@158))))
           (a!2 (DtRank ($Unbox DatatypeTypeType
                                (MapType0Select (|Map#Elements| |a#7#0#0@@4|)
                                                bx@@158)))))
       (=> a!1 (< a!2 (DtRank (|#Buffers.Buffer.Buffer| |a#7#0#0@@4|)))))
     :pattern ((MapType0Select (|Map#Domain| |a#7#0#0@@4|) bx@@158)
               (|#Buffers.Buffer.Buffer| |a#7#0#0@@4|))
     :skolemid |2875|
     :qid |Buffersidfy.25:28|)))
(assert (forall ((d@@59 T@U))
  (! (=> (and (= (type d@@59) DatatypeTypeType) (|$IsA#Buffers.Buffer| d@@59))
         (Buffers.Buffer.Buffer_q d@@59))
     :pattern ((|$IsA#Buffers.Buffer| d@@59))
     :skolemid |2876|
     :qid |unknown.0:0|)))
(assert (forall ((d@@60 T@U))
  (! (=> (and (= (type d@@60) DatatypeTypeType)
              ($Is d@@60 Tclass.Buffers.Buffer))
         (Buffers.Buffer.Buffer_q d@@60))
     :pattern ((Buffers.Buffer.Buffer_q d@@60)
               ($Is d@@60 Tclass.Buffers.Buffer))
     :skolemid |2877|
     :qid |unknown.0:0|)))
(assert (forall ((a@@132 T@U) (b@@82 T@U))
  (! (=> (and (= (type a@@132) DatatypeTypeType)
              (= (type b@@82) DatatypeTypeType)
              true)
         (= (|Buffers.Buffer#Equal| a@@132 b@@82)
            (|Map#Equal| (Buffers.Buffer.mapp a@@132)
                         (Buffers.Buffer.mapp b@@82))))
     :pattern ((|Buffers.Buffer#Equal| a@@132 b@@82))
     :skolemid |2878|
     :qid |unknown.0:0|)))
(assert (forall ((a@@133 T@U) (b@@83 T@U))
  (! (=> (and (= (type a@@133) DatatypeTypeType)
              (= (type b@@83) DatatypeTypeType))
         (= (|Buffers.Buffer#Equal| a@@133 b@@83) (= a@@133 b@@83)))
     :pattern ((|Buffers.Buffer#Equal| a@@133 b@@83))
     :skolemid |2879|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@542 T@U) (arg1@@272 T@U))
  (! (= (type (Buffers.Buffer.Query arg0@@542 arg1@@272)) DatatypeTypeType)
     :pattern ((Buffers.Buffer.Query arg0@@542 arg1@@272))
     :qid |funType:Buffers.Buffer.Query|)))
(assert (let ((a!1 (forall ((this@@64 T@U) (|key#0@@30| T@U))
             (! (let ((a!1 (and (= (type this@@64) DatatypeTypeType)
                                (= (type |key#0@@30|) (SeqType BoxType))
                                (or (|Buffers.Buffer.Query#canCall|
                                      this@@64
                                      |key#0@@30|)
                                    (and ($Is this@@64 Tclass.Buffers.Buffer)
                                         ($Is |key#0@@30| Tclass.KeyType.Key))))))
                  (=> a!1
                      ($Is (Buffers.Buffer.Query this@@64 |key#0@@30|)
                           Tclass.ValueMessage.Message)))
                :pattern ((Buffers.Buffer.Query this@@64 |key#0@@30|))
                :skolemid |2880|
                :qid |Buffersidfy.27:14|))))
  (=> true a!1)))
(assert (forall ((this@@65 T@U) (|key#0@@31| T@U))
  (! (=> (and (= (type this@@65) DatatypeTypeType)
              (= (type |key#0@@31|) (SeqType BoxType))
              ($Is this@@65 Tclass.Buffers.Buffer)
              ($Is |key#0@@31| Tclass.KeyType.Key))
         (= (|Buffers.Buffer.Query#requires| this@@65 |key#0@@31|) true))
     :pattern ((|Buffers.Buffer.Query#requires| this@@65 |key#0@@31|))
     :skolemid |2881|
     :qid |Buffersidfy.27:14|)))
(assert (let ((a!1 (forall ((this@@66 T@U) (|key#0@@32| T@U))
             (! (let ((a!1 (and (= (type this@@66) DatatypeTypeType)
                                (= (type |key#0@@32|) (SeqType BoxType))
                                (or (|Buffers.Buffer.Query#canCall|
                                      this@@66
                                      |key#0@@32|)
                                    (and ($Is this@@66 Tclass.Buffers.Buffer)
                                         ($Is |key#0@@32| Tclass.KeyType.Key)))))
                      (a!2 (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                                     this@@66))
                                                     ($Box |key#0@@32|))))
                      (a!3 ($Unbox DatatypeTypeType
                                   (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp
                                                                     this@@66))
                                                   ($Box |key#0@@32|)))))
                (let ((a!4 (= (Buffers.Buffer.Query this@@66 |key#0@@32|)
                              (ite a!2
                                   a!3
                                   (|#ValueMessage.Message.Update|
                                     (Lit ValueMessage.__default.NopDelta))))))
                  (=> a!1
                      (and (Buffers.Buffer.Buffer_q this@@66)
                           (=> a!2 (Buffers.Buffer.Buffer_q this@@66))
                           (=> (not a!2)
                               |ValueMessage.__default.NopDelta#canCall|)
                           a!4))))
                :pattern ((Buffers.Buffer.Query this@@66 |key#0@@32|))
                :skolemid |2882|
                :qid |Buffersidfy.27:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@67 T@U) (|key#0@@33| T@U))
      (! (let ((a!1 (and (= (type this@@67) DatatypeTypeType)
                         (= (type |key#0@@33|) (SeqType BoxType))
                         (or (|Buffers.Buffer.Query#canCall|
                               (Lit this@@67)
                               (Lit |key#0@@33|))
                             (and ($Is this@@67 Tclass.Buffers.Buffer)
                                  ($Is |key#0@@33| Tclass.KeyType.Key)))))
               (a!2 (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                    (Lit this@@67)))
                                    ($Box |key#0@@33|)))
               (a!3 (|Map#Elements| (Lit (Buffers.Buffer.mapp (Lit this@@67))))))
         (let ((a!4 ($Unbox DatatypeTypeType
                            (MapType0Select a!3 ($Box (Lit |key#0@@33|))))))
         (let ((a!5 (= (Buffers.Buffer.Query (Lit this@@67) (Lit |key#0@@33|))
                       (ite (U_2_bool a!2)
                            a!4
                            (|#ValueMessage.Message.Update|
                              (Lit ValueMessage.__default.NopDelta))))))
         (let ((a!6 (and (Buffers.Buffer.Buffer_q (Lit this@@67))
                         (=> (U_2_bool a!2)
                             (Buffers.Buffer.Buffer_q (Lit this@@67)))
                         (=> (not (U_2_bool a!2))
                             |ValueMessage.__default.NopDelta#canCall|)
                         a!5)))
           (=> a!1 a!6)))))
         :pattern ((Buffers.Buffer.Query (Lit this@@67) (Lit |key#0@@33|)))
         :weight 3
         :skolemid |2883|
         :qid |Buffersidfy.27:14|))))
(assert (forall ((arg0@@543 T@U) (arg1@@273 T@U))
  (! (= (type (Buffers.Buffer.ApplyFilter arg0@@543 arg1@@273))
        DatatypeTypeType)
     :pattern ((Buffers.Buffer.ApplyFilter arg0@@543 arg1@@273))
     :qid |funType:Buffers.Buffer.ApplyFilter|)))
(assert (let ((a!1 (forall ((this@@68 T@U) (|accept#0| T@U))
             (! (let ((a!1 (or (|Buffers.Buffer.ApplyFilter#canCall|
                                 this@@68
                                 |accept#0|)
                               (and ($Is this@@68 Tclass.Buffers.Buffer)
                                    ($Is |accept#0| (TISet Tclass.KeyType.Key))))))
                  (=> (and (= (type this@@68) DatatypeTypeType)
                           (= (type |accept#0|) (MapType0Type BoxType boolType))
                           a!1)
                      ($Is (Buffers.Buffer.ApplyFilter this@@68 |accept#0|)
                           Tclass.Buffers.Buffer)))
                :pattern ((Buffers.Buffer.ApplyFilter this@@68 |accept#0|))
                :skolemid |2884|
                :qid |Buffersidfy.32:14|))))
  (=> true a!1)))
(assert (forall ((this@@69 T@U) (|accept#0@@0| T@U))
  (! (=> (and (= (type this@@69) DatatypeTypeType)
              (= (type |accept#0@@0|) (MapType0Type BoxType boolType))
              ($Is this@@69 Tclass.Buffers.Buffer)
              ($Is |accept#0@@0| (TISet Tclass.KeyType.Key)))
         (= (|Buffers.Buffer.ApplyFilter#requires| this@@69 |accept#0@@0|) true))
     :pattern ((|Buffers.Buffer.ApplyFilter#requires| this@@69 |accept#0@@0|))
     :skolemid |2885|
     :qid |Buffersidfy.32:14|)))
(assert (let ((a!1 (forall ((this@@70 T@U) (|accept#0@@1| T@U))
             (! (let ((a!1 (or (|Buffers.Buffer.ApplyFilter#canCall|
                                 this@@70
                                 |accept#0@@1|)
                               (and ($Is this@@70 Tclass.Buffers.Buffer)
                                    ($Is |accept#0@@1|
                                         (TISet Tclass.KeyType.Key)))))
                      (a!2 (forall ((|k#0@@72| T@U))
                             (! (let ((a!1 (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                                                     this@@70))
                                                                     ($Box |k#0@@72|)))))
                                (let ((a!2 (and a!1
                                                (U_2_bool (MapType0Select |accept#0@@1|
                                                                          ($Box |k#0@@72|))))))
                                  (=> (and (= (type |k#0@@72|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@72| Tclass.KeyType.Key))
                                      (and (Buffers.Buffer.Buffer_q this@@70)
                                           (=> a!2
                                               (Buffers.Buffer.Buffer_q
                                                 this@@70))))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp
                                                                                    this@@70))
                                                                  ($Box |k#0@@72|))))
                                :pattern ((MapType0Select |accept#0@@1|
                                                          ($Box |k#0@@72|)))
                                :pattern ((MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                                          this@@70))
                                                          ($Box |k#0@@72|)))
                                :skolemid |2886|
                                :qid |Buffersidfy.34:18|)))
                      (a!3 (|Map#Glue| (|lambda#169| Tclass.KeyType.Key
                                                     (|Map#Domain| (Buffers.Buffer.mapp
                                                                     this@@70))
                                                     |accept#0@@1|)
                                       (|lambda#148| (|Map#Elements| (Buffers.Buffer.mapp
                                                                       this@@70)))
                                       (TMap Tclass.KeyType.Key
                                             Tclass.ValueMessage.Message))))
                  (=> (and (= (type this@@70) DatatypeTypeType)
                           (= (type |accept#0@@1|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and a!2
                           (= (Buffers.Buffer.ApplyFilter
                                this@@70
                                |accept#0@@1|)
                              (|#Buffers.Buffer.Buffer| a!3)))))
                :pattern ((Buffers.Buffer.ApplyFilter this@@70 |accept#0@@1|))
                :skolemid |2887|
                :qid |Buffersidfy.32:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@71 T@U) (|accept#0@@2| T@U))
             (! (let ((a!1 (or (|Buffers.Buffer.ApplyFilter#canCall|
                                 (Lit this@@71)
                                 |accept#0@@2|)
                               (and ($Is this@@71 Tclass.Buffers.Buffer)
                                    ($Is |accept#0@@2|
                                         (TISet Tclass.KeyType.Key)))))
                      (a!2 (forall ((|k#0@@73| T@U))
                             (! (let ((a!1 (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                                           (Lit this@@71)))
                                                           ($Box |k#0@@73|))))
                                (let ((a!2 (and (U_2_bool a!1)
                                                (U_2_bool (MapType0Select |accept#0@@2|
                                                                          ($Box |k#0@@73|))))))
                                (let ((a!3 (and (Buffers.Buffer.Buffer_q
                                                  (Lit this@@71))
                                                (=> a!2
                                                    (Buffers.Buffer.Buffer_q
                                                      (Lit this@@71))))))
                                  (=> (and (= (type |k#0@@73|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@73| Tclass.KeyType.Key))
                                      a!3))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp
                                                                                    this@@71))
                                                                  ($Box |k#0@@73|))))
                                :pattern ((MapType0Select |accept#0@@2|
                                                          ($Box |k#0@@73|)))
                                :pattern ((MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                                          this@@71))
                                                          ($Box |k#0@@73|)))
                                :skolemid |2888|
                                :qid |Buffersidfy.34:18|)))
                      (a!3 (|lambda#169| Tclass.KeyType.Key
                                         (|Map#Domain| (Buffers.Buffer.mapp
                                                         (Lit this@@71)))
                                         |accept#0@@2|))
                      (a!4 (|Map#Elements| (Lit (Buffers.Buffer.mapp
                                                  (Lit this@@71))))))
                (let ((a!5 (= (Buffers.Buffer.ApplyFilter
                                (Lit this@@71)
                                |accept#0@@2|)
                              (|#Buffers.Buffer.Buffer|
                                (|Map#Glue| a!3
                                            (|lambda#148| a!4)
                                            (TMap Tclass.KeyType.Key
                                                  Tclass.ValueMessage.Message))))))
                  (=> (and (= (type this@@71) DatatypeTypeType)
                           (= (type |accept#0@@2|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and a!2 a!5))))
                :pattern ((Buffers.Buffer.ApplyFilter
                            (Lit this@@71)
                            |accept#0@@2|))
                :weight 3
                :skolemid |2889|
                :qid |Buffersidfy.32:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@72 T@U) (|accept#0@@3| T@U))
             (! (let ((a!1 (or (|Buffers.Buffer.ApplyFilter#canCall|
                                 (Lit this@@72)
                                 (Lit |accept#0@@3|))
                               (and ($Is this@@72 Tclass.Buffers.Buffer)
                                    ($Is |accept#0@@3|
                                         (TISet Tclass.KeyType.Key)))))
                      (a!2 (forall ((|k#0@@74| T@U))
                             (! (let ((a!1 (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                                           (Lit this@@72)))
                                                           ($Box |k#0@@74|))))
                                (let ((a!2 (and (U_2_bool a!1)
                                                (U_2_bool (MapType0Select (Lit |accept#0@@3|)
                                                                          ($Box |k#0@@74|))))))
                                (let ((a!3 (and (Buffers.Buffer.Buffer_q
                                                  (Lit this@@72))
                                                (=> a!2
                                                    (Buffers.Buffer.Buffer_q
                                                      (Lit this@@72))))))
                                  (=> (and (= (type |k#0@@74|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@74| Tclass.KeyType.Key))
                                      a!3))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp
                                                                                    this@@72))
                                                                  ($Box |k#0@@74|))))
                                :pattern ((MapType0Select |accept#0@@3|
                                                          ($Box |k#0@@74|)))
                                :pattern ((MapType0Select (|Map#Domain| (Buffers.Buffer.mapp
                                                                          this@@72))
                                                          ($Box |k#0@@74|)))
                                :skolemid |2890|
                                :qid |Buffersidfy.34:18|)))
                      (a!3 (|lambda#169| Tclass.KeyType.Key
                                         (|Map#Domain| (Buffers.Buffer.mapp
                                                         (Lit this@@72)))
                                         (Lit |accept#0@@3|)))
                      (a!4 (|Map#Elements| (Lit (Buffers.Buffer.mapp
                                                  (Lit this@@72))))))
                (let ((a!5 (= (Buffers.Buffer.ApplyFilter
                                (Lit this@@72)
                                (Lit |accept#0@@3|))
                              (|#Buffers.Buffer.Buffer|
                                (|Map#Glue| a!3
                                            (|lambda#148| a!4)
                                            (TMap Tclass.KeyType.Key
                                                  Tclass.ValueMessage.Message))))))
                  (=> (and (= (type this@@72) DatatypeTypeType)
                           (= (type |accept#0@@3|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and a!2 a!5))))
                :pattern ((Buffers.Buffer.ApplyFilter
                            (Lit this@@72)
                            (Lit |accept#0@@3|)))
                :weight 3
                :skolemid |2891|
                :qid |Buffersidfy.32:14|))))
  (=> true a!1)))
(assert (forall ((arg0@@544 T@U))
  (! (= (type (|#Buffers.BufferStack.BufferStack| arg0@@544)) DatatypeTypeType)
     :pattern ((|#Buffers.BufferStack.BufferStack| arg0@@544))
     :qid |funType:#Buffers.BufferStack.BufferStack|)))
(assert (forall ((|a#0#0#0@@4| T@U))
  (! (=> (= (type |a#0#0#0@@4|) (SeqType BoxType))
         (= (DatatypeCtorId (|#Buffers.BufferStack.BufferStack| |a#0#0#0@@4|))
            |##Buffers.BufferStack.BufferStack|))
     :pattern ((|#Buffers.BufferStack.BufferStack| |a#0#0#0@@4|))
     :skolemid |2892|
     :qid |Buffersidfy.39:38|)))
(assert (forall ((d@@61 T@U))
  (! (=> (= (type d@@61) DatatypeTypeType)
         (= (Buffers.BufferStack.BufferStack_q d@@61)
            (= (DatatypeCtorId d@@61) |##Buffers.BufferStack.BufferStack|)))
     :pattern ((Buffers.BufferStack.BufferStack_q d@@61))
     :skolemid |2893|
     :qid |unknown.0:0|)))
(assert (forall ((d@@62 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@4| T@U))
                  (! (and (= (type |a#1#0#0@@4|) (SeqType BoxType))
                          (= d@@62
                             (|#Buffers.BufferStack.BufferStack| |a#1#0#0@@4|)))
                     :no-pattern (type |a#1#0#0@@4|)
                     :no-pattern (U_2_int |a#1#0#0@@4|)
                     :no-pattern (U_2_bool |a#1#0#0@@4|)
                     :skolemid |2894|
                     :qid |Buffersidfy.39:38|))))
       (=> (and (= (type d@@62) DatatypeTypeType)
                (Buffers.BufferStack.BufferStack_q d@@62))
           a!1))
     :pattern ((Buffers.BufferStack.BufferStack_q d@@62))
     :skolemid |2895|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@4| T@U))
  (! (=> (= (type |a#2#0#0@@4|) (SeqType BoxType))
         (= ($Is (|#Buffers.BufferStack.BufferStack| |a#2#0#0@@4|)
                 Tclass.Buffers.BufferStack)
            ($Is |a#2#0#0@@4| (TSeq Tclass.Buffers.Buffer))))
     :pattern (($Is (|#Buffers.BufferStack.BufferStack| |a#2#0#0@@4|)
                    Tclass.Buffers.BufferStack))
     :skolemid |2896|
     :qid |Buffersidfy.39:38|)))
(assert (forall ((|a#3#0#0@@4| T@U) ($h@@103 T@U))
  (! (=> (and (= (type |a#3#0#0@@4|) (SeqType BoxType))
              (= (type $h@@103) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@103))
         (= ($IsAlloc (|#Buffers.BufferStack.BufferStack| |a#3#0#0@@4|)
                      Tclass.Buffers.BufferStack
                      $h@@103)
            ($IsAlloc |a#3#0#0@@4| (TSeq Tclass.Buffers.Buffer) $h@@103)))
     :pattern (($IsAlloc (|#Buffers.BufferStack.BufferStack| |a#3#0#0@@4|)
                         Tclass.Buffers.BufferStack
                         $h@@103))
     :skolemid |2897|
     :qid |Buffersidfy.39:38|)))
(assert (forall ((arg0@@545 T@U))
  (! (= (type (Buffers.BufferStack.buffers arg0@@545)) (SeqType BoxType))
     :pattern ((Buffers.BufferStack.buffers arg0@@545))
     :qid |funType:Buffers.BufferStack.buffers|)))
(assert (forall ((d@@63 T@U) ($h@@104 T@U))
  (! (=> (and (= (type d@@63) DatatypeTypeType)
              (= (type $h@@104) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@104)
              (Buffers.BufferStack.BufferStack_q d@@63)
              ($IsAlloc d@@63 Tclass.Buffers.BufferStack $h@@104))
         ($IsAlloc (Buffers.BufferStack.buffers d@@63)
                   (TSeq Tclass.Buffers.Buffer)
                   $h@@104))
     :pattern (($IsAlloc (Buffers.BufferStack.buffers d@@63)
                         (TSeq Tclass.Buffers.Buffer)
                         $h@@104))
     :skolemid |2898|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@4| T@U))
  (! (=> (= (type |a#4#0#0@@4|) (SeqType BoxType))
         (= (|#Buffers.BufferStack.BufferStack| (Lit |a#4#0#0@@4|))
            (Lit (|#Buffers.BufferStack.BufferStack| |a#4#0#0@@4|))))
     :pattern ((|#Buffers.BufferStack.BufferStack| (Lit |a#4#0#0@@4|)))
     :skolemid |2899|
     :qid |Buffersidfy.39:38|)))
(assert (forall ((|a#5#0#0@@5| T@U))
  (! (=> (= (type |a#5#0#0@@5|) (SeqType BoxType))
         (= (Buffers.BufferStack.buffers
              (|#Buffers.BufferStack.BufferStack| |a#5#0#0@@5|))
            |a#5#0#0@@5|))
     :pattern ((|#Buffers.BufferStack.BufferStack| |a#5#0#0@@5|))
     :skolemid |2900|
     :qid |Buffersidfy.39:38|)))
(assert (forall ((|a#6#0#0@@5| T@U) (i@@25 Int))
  (! (let ((a!1 (< (DtRank ($Unbox DatatypeTypeType
                                   (|Seq#Index| |a#6#0#0@@5| i@@25)))
                   (DtRank (|#Buffers.BufferStack.BufferStack| |a#6#0#0@@5|)))))
     (let ((a!2 (=> (and (<= 0 i@@25) (< i@@25 (|Seq#Length| |a#6#0#0@@5|)))
                    a!1)))
       (=> (= (type |a#6#0#0@@5|) (SeqType BoxType)) a!2)))
     :pattern ((|Seq#Index| |a#6#0#0@@5| i@@25)
               (|#Buffers.BufferStack.BufferStack| |a#6#0#0@@5|))
     :skolemid |2901|
     :qid |Buffersidfy.39:38|)))
(assert (forall ((|a#7#0#0@@5| T@U))
  (! (=> (= (type |a#7#0#0@@5|) (SeqType BoxType))
         (< (|Seq#Rank| |a#7#0#0@@5|)
            (DtRank (|#Buffers.BufferStack.BufferStack| |a#7#0#0@@5|))))
     :pattern ((|#Buffers.BufferStack.BufferStack| |a#7#0#0@@5|))
     :skolemid |2902|
     :qid |Buffersidfy.39:38|)))
(assert (forall ((d@@64 T@U))
  (! (=> (and (= (type d@@64) DatatypeTypeType)
              (|$IsA#Buffers.BufferStack| d@@64))
         (Buffers.BufferStack.BufferStack_q d@@64))
     :pattern ((|$IsA#Buffers.BufferStack| d@@64))
     :skolemid |2903|
     :qid |unknown.0:0|)))
(assert (forall ((d@@65 T@U))
  (! (=> (and (= (type d@@65) DatatypeTypeType)
              ($Is d@@65 Tclass.Buffers.BufferStack))
         (Buffers.BufferStack.BufferStack_q d@@65))
     :pattern ((Buffers.BufferStack.BufferStack_q d@@65)
               ($Is d@@65 Tclass.Buffers.BufferStack))
     :skolemid |2904|
     :qid |unknown.0:0|)))
(assert (forall ((a@@134 T@U) (b@@84 T@U))
  (! (=> (and (= (type a@@134) DatatypeTypeType)
              (= (type b@@84) DatatypeTypeType)
              true)
         (= (|Buffers.BufferStack#Equal| a@@134 b@@84)
            (|Seq#Equal| (Buffers.BufferStack.buffers a@@134)
                         (Buffers.BufferStack.buffers b@@84))))
     :pattern ((|Buffers.BufferStack#Equal| a@@134 b@@84))
     :skolemid |2905|
     :qid |unknown.0:0|)))
(assert (forall ((a@@135 T@U) (b@@85 T@U))
  (! (=> (and (= (type a@@135) DatatypeTypeType)
              (= (type b@@85) DatatypeTypeType))
         (= (|Buffers.BufferStack#Equal| a@@135 b@@85) (= a@@135 b@@85)))
     :pattern ((|Buffers.BufferStack#Equal| a@@135 b@@85))
     :skolemid |2906|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@546 T@U) (arg1@@274 T@U) (arg2@@158 T@U) (arg3@@95 Int))
  (! (= (type (Buffers.BufferStack.QueryUpTo
                arg0@@546
                arg1@@274
                arg2@@158
                arg3@@95))
        DatatypeTypeType)
     :pattern ((Buffers.BufferStack.QueryUpTo
                 arg0@@546
                 arg1@@274
                 arg2@@158
                 arg3@@95))
     :qid |funType:Buffers.BufferStack.QueryUpTo|)))
(assert (forall (($ly@@317 T@U) (this@@73 T@U) (|key#0@@34| T@U) (|count#0| Int))
  (! (=> (and (= (type $ly@@317) LayerTypeType)
              (= (type this@@73) DatatypeTypeType)
              (= (type |key#0@@34|) (SeqType BoxType)))
         (= (Buffers.BufferStack.QueryUpTo
              ($LS $ly@@317)
              this@@73
              |key#0@@34|
              |count#0|)
            (Buffers.BufferStack.QueryUpTo
              $ly@@317
              this@@73
              |key#0@@34|
              |count#0|)))
     :pattern ((Buffers.BufferStack.QueryUpTo
                 ($LS $ly@@317)
                 this@@73
                 |key#0@@34|
                 |count#0|))
     :skolemid |2907|
     :qid |Buffersidfy.41:14|)))
(assert (forall (($ly@@318 T@U) (this@@74 T@U) (|key#0@@35| T@U) (|count#0@@0| Int))
  (! (=> (and (= (type $ly@@318) LayerTypeType)
              (= (type this@@74) DatatypeTypeType)
              (= (type |key#0@@35|) (SeqType BoxType)))
         (= (Buffers.BufferStack.QueryUpTo
              $ly@@318
              this@@74
              |key#0@@35|
              |count#0@@0|)
            (Buffers.BufferStack.QueryUpTo
              $LZ
              this@@74
              |key#0@@35|
              |count#0@@0|)))
     :pattern ((Buffers.BufferStack.QueryUpTo
                 (AsFuelBottom $ly@@318)
                 this@@74
                 |key#0@@35|
                 |count#0@@0|))
     :skolemid |2908|
     :qid |Buffersidfy.41:14|)))
(assert (let ((a!1 (forall (($ly@@319 T@U)
                    (this@@75 T@U)
                    (|key#0@@36| T@U)
                    (|count#0@@1| Int))
             (! (let ((a!1 (and ($Is this@@75 Tclass.Buffers.BufferStack)
                                ($Is |key#0@@36| Tclass.KeyType.Key)
                                (INTERNAL_le_boogie 0 |count#0@@1|)
                                (INTERNAL_le_boogie
                                  |count#0@@1|
                                  (|Seq#Length| (Buffers.BufferStack.buffers
                                                  this@@75))))))
                  (=> (and (= (type $ly@@319) LayerTypeType)
                           (= (type this@@75) DatatypeTypeType)
                           (= (type |key#0@@36|) (SeqType BoxType))
                           (or (|Buffers.BufferStack.QueryUpTo#canCall|
                                 this@@75
                                 |key#0@@36|
                                 |count#0@@1|)
                               a!1))
                      ($Is (Buffers.BufferStack.QueryUpTo
                             $ly@@319
                             this@@75
                             |key#0@@36|
                             |count#0@@1|)
                           Tclass.ValueMessage.Message)))
                :pattern ((Buffers.BufferStack.QueryUpTo
                            $ly@@319
                            this@@75
                            |key#0@@36|
                            |count#0@@1|))
                :skolemid |2909|
                :qid |Buffersidfy.41:14|))))
  (=> true a!1)))
(assert (forall (($ly@@320 T@U) (this@@76 T@U) (|key#0@@37| T@U) (|count#0@@2| Int))
  (! (let ((a!1 (= (|Buffers.BufferStack.QueryUpTo#requires|
                     $ly@@320
                     this@@76
                     |key#0@@37|
                     |count#0@@2|)
                   (INTERNAL_le_boogie
                     |count#0@@2|
                     (|Seq#Length| (Buffers.BufferStack.buffers this@@76))))))
       (=> (and (= (type $ly@@320) LayerTypeType)
                (= (type this@@76) DatatypeTypeType)
                (= (type |key#0@@37|) (SeqType BoxType))
                ($Is this@@76 Tclass.Buffers.BufferStack)
                ($Is |key#0@@37| Tclass.KeyType.Key)
                (INTERNAL_le_boogie 0 |count#0@@2|))
           a!1))
     :pattern ((|Buffers.BufferStack.QueryUpTo#requires|
                 $ly@@320
                 this@@76
                 |key#0@@37|
                 |count#0@@2|))
     :skolemid |2910|
     :qid |Buffersidfy.41:14|)))
(assert (let ((a!1 (forall (($ly@@321 T@U)
                    (this@@77 T@U)
                    (|key#0@@38| T@U)
                    (|count#0@@3| Int))
             (! (let ((a!1 (and ($Is this@@77 Tclass.Buffers.BufferStack)
                                ($Is |key#0@@38| Tclass.KeyType.Key)
                                (INTERNAL_le_boogie 0 |count#0@@3|)
                                (INTERNAL_le_boogie
                                  |count#0@@3|
                                  (|Seq#Length| (Buffers.BufferStack.buffers
                                                  this@@77)))))
                      (a!2 (|Buffers.Buffer.Query#canCall|
                             ($Unbox DatatypeTypeType
                                     (|Seq#Index| (Buffers.BufferStack.buffers
                                                    this@@77)
                                                  (INTERNAL_sub_boogie
                                                    |count#0@@3|
                                                    1)))
                             |key#0@@38|))
                      (a!3 (Buffers.Buffer.Query
                             ($Unbox DatatypeTypeType
                                     (|Seq#Index| (Buffers.BufferStack.buffers
                                                    this@@77)
                                                  (INTERNAL_sub_boogie
                                                    |count#0@@3|
                                                    1)))
                             |key#0@@38|)))
                (let ((a!4 (and (|Buffers.BufferStack.QueryUpTo#canCall|
                                  this@@77
                                  |key#0@@38|
                                  (INTERNAL_sub_boogie |count#0@@3| 1))
                                (Buffers.BufferStack.BufferStack_q this@@77)
                                a!2
                                (|ValueMessage.__default.Merge#canCall|
                                  (Buffers.BufferStack.QueryUpTo
                                    $ly@@321
                                    this@@77
                                    |key#0@@38|
                                    (INTERNAL_sub_boogie |count#0@@3| 1))
                                  a!3)))
                      (a!6 (ite (= |count#0@@3| (LitInt 0))
                                (|#ValueMessage.Message.Update|
                                  (Lit ValueMessage.__default.NopDelta))
                                (ValueMessage.__default.Merge
                                  (Buffers.BufferStack.QueryUpTo
                                    $ly@@321
                                    this@@77
                                    |key#0@@38|
                                    (INTERNAL_sub_boogie |count#0@@3| 1))
                                  a!3))))
                (let ((a!5 (=> (not (= |count#0@@3| (LitInt 0))) a!4)))
                (let ((a!7 (and (=> (= |count#0@@3| (LitInt 0))
                                    |ValueMessage.__default.NopDelta#canCall|)
                                a!5
                                (= (Buffers.BufferStack.QueryUpTo
                                     ($LS $ly@@321)
                                     this@@77
                                     |key#0@@38|
                                     |count#0@@3|)
                                   a!6))))
                  (=> (and (= (type $ly@@321) LayerTypeType)
                           (= (type this@@77) DatatypeTypeType)
                           (= (type |key#0@@38|) (SeqType BoxType))
                           (or (|Buffers.BufferStack.QueryUpTo#canCall|
                                 this@@77
                                 |key#0@@38|
                                 |count#0@@3|)
                               a!1))
                      a!7)))))
                :pattern ((Buffers.BufferStack.QueryUpTo
                            ($LS $ly@@321)
                            this@@77
                            |key#0@@38|
                            |count#0@@3|))
                :skolemid |2911|
                :qid |Buffersidfy.41:14|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@322 T@U) (this@@78 T@U) (|key#0@@39| T@U) (|count#0@@4| Int))
      (! (let ((a!1 (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                         (Lit this@@78)))))
               (a!3 (|Seq#Index| (Lit (Buffers.BufferStack.buffers
                                        (Lit this@@78)))
                                 (LitInt (INTERNAL_sub_boogie |count#0@@4| 1))))
               (a!4 (Lit (Buffers.BufferStack.QueryUpTo
                           ($LS $ly@@322)
                           (Lit this@@78)
                           (Lit |key#0@@39|)
                           (LitInt (INTERNAL_sub_boogie |count#0@@4| 1))))))
         (let ((a!2 (and (= (type $ly@@322) LayerTypeType)
                         (= (type this@@78) DatatypeTypeType)
                         (= (type |key#0@@39|) (SeqType BoxType))
                         (or (|Buffers.BufferStack.QueryUpTo#canCall|
                               (Lit this@@78)
                               (Lit |key#0@@39|)
                               (LitInt |count#0@@4|))
                             (and ($Is this@@78 Tclass.Buffers.BufferStack)
                                  ($Is |key#0@@39| Tclass.KeyType.Key)
                                  (INTERNAL_le_boogie 0 |count#0@@4|)
                                  (INTERNAL_le_boogie |count#0@@4| a!1)))))
               (a!5 (and (|Buffers.BufferStack.QueryUpTo#canCall|
                           (Lit this@@78)
                           (Lit |key#0@@39|)
                           (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))
                         (Buffers.BufferStack.BufferStack_q (Lit this@@78))
                         (|Buffers.Buffer.Query#canCall|
                           ($Unbox DatatypeTypeType a!3)
                           (Lit |key#0@@39|))
                         (|ValueMessage.__default.Merge#canCall|
                           a!4
                           (Buffers.Buffer.Query
                             ($Unbox DatatypeTypeType a!3)
                             (Lit |key#0@@39|)))))
               (a!7 (ite (= (LitInt |count#0@@4|) (LitInt 0))
                         (|#ValueMessage.Message.Update|
                           (Lit ValueMessage.__default.NopDelta))
                         (ValueMessage.__default.Merge
                           a!4
                           (Buffers.Buffer.Query
                             ($Unbox DatatypeTypeType a!3)
                             (Lit |key#0@@39|))))))
         (let ((a!6 (=> (not (= (LitInt |count#0@@4|) (LitInt 0))) a!5)))
         (let ((a!8 (and (=> (= (LitInt |count#0@@4|) (LitInt 0))
                             |ValueMessage.__default.NopDelta#canCall|)
                         a!6
                         (= (Buffers.BufferStack.QueryUpTo
                              ($LS $ly@@322)
                              (Lit this@@78)
                              (Lit |key#0@@39|)
                              (LitInt |count#0@@4|))
                            a!7))))
           (=> a!2 a!8)))))
         :pattern ((Buffers.BufferStack.QueryUpTo
                     ($LS $ly@@322)
                     (Lit this@@78)
                     (Lit |key#0@@39|)
                     (LitInt |count#0@@4|)))
         :weight 3
         :skolemid |2912|
         :qid |Buffersidfy.41:14|))))
(assert (let ((a!1 (forall ((this@@79 T@U) (|key#0@@40| T@U))
             (! (let ((a!1 (and (= (type this@@79) DatatypeTypeType)
                                (= (type |key#0@@40|) (SeqType BoxType))
                                (or (|Buffers.BufferStack.Query#canCall|
                                      this@@79
                                      |key#0@@40|)
                                    (and ($Is this@@79
                                              Tclass.Buffers.BufferStack)
                                         ($Is |key#0@@40| Tclass.KeyType.Key))))))
                  (=> a!1
                      ($Is (Buffers.BufferStack.Query this@@79 |key#0@@40|)
                           Tclass.ValueMessage.Message)))
                :pattern ((Buffers.BufferStack.Query this@@79 |key#0@@40|))
                :skolemid |2913|
                :qid |Buffersidfy.48:14|))))
  (=> true a!1)))
(assert (forall ((this@@80 T@U) (|key#0@@41| T@U))
  (! (=> (and (= (type this@@80) DatatypeTypeType)
              (= (type |key#0@@41|) (SeqType BoxType))
              ($Is this@@80 Tclass.Buffers.BufferStack)
              ($Is |key#0@@41| Tclass.KeyType.Key))
         (= (|Buffers.BufferStack.Query#requires| this@@80 |key#0@@41|) true))
     :pattern ((|Buffers.BufferStack.Query#requires| this@@80 |key#0@@41|))
     :skolemid |2914|
     :qid |Buffersidfy.48:14|)))
(assert (=> true
    (forall ((this@@81 T@U) (|key#0@@42| T@U))
      (! (let ((a!1 (and (= (type this@@81) DatatypeTypeType)
                         (= (type |key#0@@42|) (SeqType BoxType))
                         (or (|Buffers.BufferStack.Query#canCall|
                               this@@81
                               |key#0@@42|)
                             (and ($Is this@@81 Tclass.Buffers.BufferStack)
                                  ($Is |key#0@@42| Tclass.KeyType.Key)))))
               (a!2 (= (Buffers.BufferStack.Query this@@81 |key#0@@42|)
                       (Buffers.BufferStack.QueryUpTo
                         ($LS $LZ)
                         this@@81
                         |key#0@@42|
                         (|Seq#Length| (Buffers.BufferStack.buffers this@@81))))))
         (let ((a!3 (and (Buffers.BufferStack.BufferStack_q this@@81)
                         (|Buffers.BufferStack.QueryUpTo#canCall|
                           this@@81
                           |key#0@@42|
                           (|Seq#Length| (Buffers.BufferStack.buffers this@@81)))
                         a!2)))
           (=> a!1 a!3)))
         :pattern ((Buffers.BufferStack.Query this@@81 |key#0@@42|))
         :skolemid |2915|
         :qid |Buffersidfy.48:14|))))
(assert (=> true
    (forall ((this@@82 T@U) (|key#0@@43| T@U))
      (! (let ((a!1 (and (= (type this@@82) DatatypeTypeType)
                         (= (type |key#0@@43|) (SeqType BoxType))
                         (or (|Buffers.BufferStack.Query#canCall|
                               (Lit this@@82)
                               (Lit |key#0@@43|))
                             (and ($Is this@@82 Tclass.Buffers.BufferStack)
                                  ($Is |key#0@@43| Tclass.KeyType.Key)))))
               (a!2 (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                         (Lit this@@82))))))
         (let ((a!3 (and (Buffers.BufferStack.BufferStack_q (Lit this@@82))
                         (|Buffers.BufferStack.QueryUpTo#canCall|
                           (Lit this@@82)
                           (Lit |key#0@@43|)
                           a!2)
                         (= (Buffers.BufferStack.Query
                              (Lit this@@82)
                              (Lit |key#0@@43|))
                            (Buffers.BufferStack.QueryUpTo
                              ($LS $LZ)
                              (Lit this@@82)
                              (Lit |key#0@@43|)
                              a!2)))))
           (=> a!1 a!3)))
         :pattern ((Buffers.BufferStack.Query (Lit this@@82) (Lit |key#0@@43|)))
         :weight 3
         :skolemid |2916|
         :qid |Buffersidfy.48:14|))))
(assert (forall ((arg0@@547 T@U) (arg1@@275 T@U))
  (! (= (type (Buffers.BufferStack.ApplyFilter arg0@@547 arg1@@275))
        DatatypeTypeType)
     :pattern ((Buffers.BufferStack.ApplyFilter arg0@@547 arg1@@275))
     :qid |funType:Buffers.BufferStack.ApplyFilter|)))
(assert (let ((a!1 (forall ((this@@83 T@U) (|accept#0@@4| T@U))
             (! (let ((a!1 (or (|Buffers.BufferStack.ApplyFilter#canCall|
                                 this@@83
                                 |accept#0@@4|)
                               (and ($Is this@@83 Tclass.Buffers.BufferStack)
                                    ($Is |accept#0@@4|
                                         (TISet Tclass.KeyType.Key))))))
                  (=> (and (= (type this@@83) DatatypeTypeType)
                           (= (type |accept#0@@4|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      ($Is (Buffers.BufferStack.ApplyFilter
                             this@@83
                             |accept#0@@4|)
                           Tclass.Buffers.BufferStack)))
                :pattern ((Buffers.BufferStack.ApplyFilter
                            this@@83
                            |accept#0@@4|))
                :skolemid |2917|
                :qid |Buffersidfy.53:14|))))
  (=> true a!1)))
(assert (forall (($Heap@@46 T@U) (this@@84 T@U) (|accept#0@@5| T@U))
  (! (=> (and (= (type $Heap@@46) (MapType0Type refType MapType1Type))
              (= (type this@@84) DatatypeTypeType)
              (= (type |accept#0@@5|) (MapType0Type BoxType boolType))
              ($IsGoodHeap $Heap@@46)
              ($Is this@@84 Tclass.Buffers.BufferStack)
              ($IsAlloc this@@84 Tclass.Buffers.BufferStack $Heap@@46)
              ($Is |accept#0@@5| (TISet Tclass.KeyType.Key)))
         (= (|Buffers.BufferStack.ApplyFilter#requires| this@@84 |accept#0@@5|)
            true))
     :pattern ((|Buffers.BufferStack.ApplyFilter#requires|
                 this@@84
                 |accept#0@@5|)
               ($IsGoodHeap $Heap@@46))
     :skolemid |2918|
     :qid |Buffersidfy.53:14|)))
(assert (forall ((arg0@@548 T@U) (arg1@@276 T@U))
  (! (= (type (|lambda#227| arg0@@548 arg1@@276))
        (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
     :pattern ((|lambda#227| arg0@@548 arg1@@276))
     :qid |funType:lambda#227|)))
(assert (let ((a!1 (forall (($Heap@@47 T@U) (this@@85 T@U) (|accept#0@@6| T@U))
             (! (let ((a!1 (or (|Buffers.BufferStack.ApplyFilter#canCall|
                                 this@@85
                                 |accept#0@@6|)
                               (and ($IsGoodHeap $Heap@@47)
                                    ($Is this@@85 Tclass.Buffers.BufferStack)
                                    ($IsAlloc this@@85
                                              Tclass.Buffers.BufferStack
                                              $Heap@@47)
                                    ($Is |accept#0@@6|
                                         (TISet Tclass.KeyType.Key)))))
                      (a!2 (forall ((|$l#1#i#0@@1| Int))
                             (! (let ((a!1 (and (INTERNAL_le_boogie
                                                  0
                                                  |$l#1#i#0@@1|)
                                                (INTERNAL_lt_boogie
                                                  |$l#1#i#0@@1|
                                                  (|Seq#Length| (Buffers.BufferStack.buffers
                                                                  this@@85)))))
                                      (a!2 (|Buffers.Buffer.ApplyFilter#canCall|
                                             ($Unbox DatatypeTypeType
                                                     (|Seq#Index| (Buffers.BufferStack.buffers
                                                                    this@@85)
                                                                  |$l#1#i#0@@1|))
                                             |accept#0@@6|)))
                                  (and (=> (INTERNAL_le_boogie 0 |$l#1#i#0@@1|)
                                           (Buffers.BufferStack.BufferStack_q
                                             this@@85))
                                       (=> a!1
                                           (and (Buffers.BufferStack.BufferStack_q
                                                  this@@85)
                                                a!2))))
                                :no-pattern (INTERNAL_lt_boogie
                                              |$l#1#i#0@@1|
                                              (|Seq#Length| (Buffers.BufferStack.buffers
                                                              this@@85)))
                                :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@1|)
                                :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@1|)
                                :skolemid |2919|
                                :qid |unknown.0:0|)))
                      (a!3 (Handle1 (|lambda#227| (Buffers.BufferStack.buffers
                                                    this@@85)
                                                  |accept#0@@6|)
                                    (|lambda#91| TInt
                                                 0
                                                 (|Seq#Length| (Buffers.BufferStack.buffers
                                                                 this@@85)))
                                    (|lambda#93| (SetRef_to_SetBox (|lambda#92| false))))))
                (let ((a!4 (|Seq#Create| Tclass.Buffers.Buffer
                                         $Heap@@47
                                         (|Seq#Length| (Buffers.BufferStack.buffers
                                                         this@@85))
                                         (Lit (AtLayer (|lambda#94| a!3)
                                                       ($LS $LZ))))))
                  (=> (and (= (type $Heap@@47)
                              (MapType0Type refType MapType1Type))
                           (= (type this@@85) DatatypeTypeType)
                           (= (type |accept#0@@6|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and (Buffers.BufferStack.BufferStack_q this@@85)
                           a!2
                           (= (Buffers.BufferStack.ApplyFilter
                                this@@85
                                |accept#0@@6|)
                              (|#Buffers.BufferStack.BufferStack| a!4))))))
                :pattern ((Buffers.BufferStack.ApplyFilter
                            this@@85
                            |accept#0@@6|)
                          ($IsGoodHeap $Heap@@47))
                :skolemid |2920|
                :qid |Buffersidfy.53:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($Heap@@48 T@U) (this@@86 T@U) (|accept#0@@7| T@U))
             (! (let ((a!1 (or (|Buffers.BufferStack.ApplyFilter#canCall|
                                 (Lit this@@86)
                                 |accept#0@@7|)
                               (and ($IsGoodHeap $Heap@@48)
                                    ($Is this@@86 Tclass.Buffers.BufferStack)
                                    ($IsAlloc this@@86
                                              Tclass.Buffers.BufferStack
                                              $Heap@@48)
                                    ($Is |accept#0@@7|
                                         (TISet Tclass.KeyType.Key)))))
                      (a!2 (forall ((|$l#3#i#0@@1| Int))
                             (! (let ((a!1 (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                                                (Lit this@@86)))))
                                      (a!2 (|Seq#Index| (Lit (Buffers.BufferStack.buffers
                                                               (Lit this@@86)))
                                                        |$l#3#i#0@@1|)))
                                (let ((a!3 (=> (and (INTERNAL_le_boogie
                                                      0
                                                      |$l#3#i#0@@1|)
                                                    (INTERNAL_lt_boogie
                                                      |$l#3#i#0@@1|
                                                      a!1))
                                               (and (Buffers.BufferStack.BufferStack_q
                                                      (Lit this@@86))
                                                    (|Buffers.Buffer.ApplyFilter#canCall|
                                                      ($Unbox DatatypeTypeType
                                                              a!2)
                                                      |accept#0@@7|)))))
                                  (and (=> (INTERNAL_le_boogie 0 |$l#3#i#0@@1|)
                                           (Buffers.BufferStack.BufferStack_q
                                             (Lit this@@86)))
                                       a!3)))
                                :no-pattern (INTERNAL_lt_boogie
                                              |$l#3#i#0@@1|
                                              (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                                                   (Lit this@@86)))))
                                :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@1|)
                                :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@1|)
                                :skolemid |2921|
                                :qid |unknown.0:0|)))
                      (a!3 (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                                (Lit this@@86)))))
                      (a!4 (|lambda#227| (Lit (Buffers.BufferStack.buffers
                                                (Lit this@@86)))
                                         |accept#0@@7|)))
                (let ((a!5 (Handle1 a!4
                                    (|lambda#91| TInt 0 a!3)
                                    (|lambda#93| (SetRef_to_SetBox (|lambda#92| false))))))
                (let ((a!6 (|Seq#Create| Tclass.Buffers.Buffer
                                         $Heap@@48
                                         a!3
                                         (Lit (AtLayer (|lambda#94| a!5)
                                                       ($LS $LZ))))))
                (let ((a!7 (and (Buffers.BufferStack.BufferStack_q
                                  (Lit this@@86))
                                a!2
                                (= (Buffers.BufferStack.ApplyFilter
                                     (Lit this@@86)
                                     |accept#0@@7|)
                                   (|#Buffers.BufferStack.BufferStack| a!6)))))
                  (=> (and (= (type $Heap@@48)
                              (MapType0Type refType MapType1Type))
                           (= (type this@@86) DatatypeTypeType)
                           (= (type |accept#0@@7|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      a!7)))))
                :pattern ((Buffers.BufferStack.ApplyFilter
                            (Lit this@@86)
                            |accept#0@@7|)
                          ($IsGoodHeap $Heap@@48))
                :weight 3
                :skolemid |2922|
                :qid |Buffersidfy.53:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($Heap@@49 T@U) (this@@87 T@U) (|accept#0@@8| T@U))
             (! (let ((a!1 (or (|Buffers.BufferStack.ApplyFilter#canCall|
                                 (Lit this@@87)
                                 (Lit |accept#0@@8|))
                               (and ($IsGoodHeap $Heap@@49)
                                    ($Is this@@87 Tclass.Buffers.BufferStack)
                                    ($IsAlloc this@@87
                                              Tclass.Buffers.BufferStack
                                              $Heap@@49)
                                    ($Is |accept#0@@8|
                                         (TISet Tclass.KeyType.Key)))))
                      (a!2 (forall ((|$l#5#i#0@@0| Int))
                             (! (let ((a!1 (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                                                (Lit this@@87)))))
                                      (a!2 (|Seq#Index| (Lit (Buffers.BufferStack.buffers
                                                               (Lit this@@87)))
                                                        |$l#5#i#0@@0|)))
                                (let ((a!3 (=> (and (INTERNAL_le_boogie
                                                      0
                                                      |$l#5#i#0@@0|)
                                                    (INTERNAL_lt_boogie
                                                      |$l#5#i#0@@0|
                                                      a!1))
                                               (and (Buffers.BufferStack.BufferStack_q
                                                      (Lit this@@87))
                                                    (|Buffers.Buffer.ApplyFilter#canCall|
                                                      ($Unbox DatatypeTypeType
                                                              a!2)
                                                      (Lit |accept#0@@8|))))))
                                  (and (=> (INTERNAL_le_boogie 0 |$l#5#i#0@@0|)
                                           (Buffers.BufferStack.BufferStack_q
                                             (Lit this@@87)))
                                       a!3)))
                                :no-pattern (INTERNAL_lt_boogie
                                              |$l#5#i#0@@0|
                                              (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                                                   (Lit this@@87)))))
                                :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0@@0|)
                                :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0@@0|)
                                :skolemid |2923|
                                :qid |unknown.0:0|)))
                      (a!3 (|Seq#Length| (Lit (Buffers.BufferStack.buffers
                                                (Lit this@@87)))))
                      (a!4 (|lambda#227| (Lit (Buffers.BufferStack.buffers
                                                (Lit this@@87)))
                                         (Lit |accept#0@@8|))))
                (let ((a!5 (Handle1 a!4
                                    (|lambda#91| TInt 0 a!3)
                                    (|lambda#93| (SetRef_to_SetBox (|lambda#92| false))))))
                (let ((a!6 (|Seq#Create| Tclass.Buffers.Buffer
                                         $Heap@@49
                                         a!3
                                         (Lit (AtLayer (|lambda#94| a!5)
                                                       ($LS $LZ))))))
                (let ((a!7 (and (Buffers.BufferStack.BufferStack_q
                                  (Lit this@@87))
                                a!2
                                (= (Buffers.BufferStack.ApplyFilter
                                     (Lit this@@87)
                                     (Lit |accept#0@@8|))
                                   (|#Buffers.BufferStack.BufferStack| a!6)))))
                  (=> (and (= (type $Heap@@49)
                              (MapType0Type refType MapType1Type))
                           (= (type this@@87) DatatypeTypeType)
                           (= (type |accept#0@@8|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      a!7)))))
                :pattern ((Buffers.BufferStack.ApplyFilter
                            (Lit this@@87)
                            (Lit |accept#0@@8|))
                          ($IsGoodHeap $Heap@@49))
                :weight 3
                :skolemid |2924|
                :qid |Buffersidfy.53:14|))))
  (=> true a!1)))
(assert (forall ((arg0@@549 T@U) (arg1@@277 T@U))
  (! (= (type (Buffers.BufferStack.PushBufferStack arg0@@549 arg1@@277))
        DatatypeTypeType)
     :pattern ((Buffers.BufferStack.PushBufferStack arg0@@549 arg1@@277))
     :qid |funType:Buffers.BufferStack.PushBufferStack|)))
(assert (let ((a!1 (forall ((this@@88 T@U) (|newBuffers#0| T@U))
             (! (let ((a!1 (and (= (type this@@88) DatatypeTypeType)
                                (= (type |newBuffers#0|) DatatypeTypeType)
                                (or (|Buffers.BufferStack.PushBufferStack#canCall|
                                      this@@88
                                      |newBuffers#0|)
                                    (and ($Is this@@88
                                              Tclass.Buffers.BufferStack)
                                         ($Is |newBuffers#0|
                                              Tclass.Buffers.BufferStack))))))
                  (=> a!1
                      ($Is (Buffers.BufferStack.PushBufferStack
                             this@@88
                             |newBuffers#0|)
                           Tclass.Buffers.BufferStack)))
                :pattern ((Buffers.BufferStack.PushBufferStack
                            this@@88
                            |newBuffers#0|))
                :skolemid |2925|
                :qid |Buffersidfy.58:14|))))
  (=> true a!1)))
(assert (forall ((this@@89 T@U) (|newBuffers#0@@0| T@U))
  (! (=> (and (= (type this@@89) DatatypeTypeType)
              (= (type |newBuffers#0@@0|) DatatypeTypeType)
              ($Is this@@89 Tclass.Buffers.BufferStack)
              ($Is |newBuffers#0@@0| Tclass.Buffers.BufferStack))
         (= (|Buffers.BufferStack.PushBufferStack#requires|
              this@@89
              |newBuffers#0@@0|)
            true))
     :pattern ((|Buffers.BufferStack.PushBufferStack#requires|
                 this@@89
                 |newBuffers#0@@0|))
     :skolemid |2926|
     :qid |Buffersidfy.58:14|)))
(assert (let ((a!1 (forall ((this@@90 T@U) (|newBuffers#0@@1| T@U))
             (! (let ((a!1 (and (= (type this@@90) DatatypeTypeType)
                                (= (type |newBuffers#0@@1|) DatatypeTypeType)
                                (or (|Buffers.BufferStack.PushBufferStack#canCall|
                                      this@@90
                                      |newBuffers#0@@1|)
                                    (and ($Is this@@90
                                              Tclass.Buffers.BufferStack)
                                         ($Is |newBuffers#0@@1|
                                              Tclass.Buffers.BufferStack)))))
                      (a!2 (= (Buffers.BufferStack.PushBufferStack
                                this@@90
                                |newBuffers#0@@1|)
                              (|#Buffers.BufferStack.BufferStack|
                                (|Seq#Append| (Buffers.BufferStack.buffers
                                                |newBuffers#0@@1|)
                                              (Buffers.BufferStack.buffers
                                                this@@90))))))
                  (=> a!1
                      (and (Buffers.BufferStack.BufferStack_q |newBuffers#0@@1|)
                           (Buffers.BufferStack.BufferStack_q this@@90)
                           a!2)))
                :pattern ((Buffers.BufferStack.PushBufferStack
                            this@@90
                            |newBuffers#0@@1|))
                :skolemid |2927|
                :qid |Buffersidfy.58:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@91 T@U) (|newBuffers#0@@2| T@U))
      (! (let ((a!1 (and (= (type this@@91) DatatypeTypeType)
                         (= (type |newBuffers#0@@2|) DatatypeTypeType)
                         (or (|Buffers.BufferStack.PushBufferStack#canCall|
                               (Lit this@@91)
                               (Lit |newBuffers#0@@2|))
                             (and ($Is this@@91 Tclass.Buffers.BufferStack)
                                  ($Is |newBuffers#0@@2|
                                       Tclass.Buffers.BufferStack)))))
               (a!2 (|#Buffers.BufferStack.BufferStack|
                      (|Seq#Append| (Buffers.BufferStack.buffers
                                      (Lit |newBuffers#0@@2|))
                                    (Buffers.BufferStack.buffers (Lit this@@91))))))
         (let ((a!3 (and (Buffers.BufferStack.BufferStack_q
                           (Lit |newBuffers#0@@2|))
                         (Buffers.BufferStack.BufferStack_q (Lit this@@91))
                         (= (Buffers.BufferStack.PushBufferStack
                              (Lit this@@91)
                              (Lit |newBuffers#0@@2|))
                            a!2))))
           (=> a!1 a!3)))
         :pattern ((Buffers.BufferStack.PushBufferStack
                     (Lit this@@91)
                     (Lit |newBuffers#0@@2|)))
         :weight 3
         :skolemid |2928|
         :qid |Buffersidfy.58:14|))))
(assert (=> true
    (forall ((this@@92 T@U) (|other#0@@11| T@U))
      (! (let ((a!1 (and (= (type this@@92) DatatypeTypeType)
                         (= (type |other#0@@11|) DatatypeTypeType)
                         (or (|Buffers.BufferStack.Equivalent#canCall|
                               this@@92
                               |other#0@@11|)
                             (and ($Is this@@92 Tclass.Buffers.BufferStack)
                                  ($Is |other#0@@11| Tclass.Buffers.BufferStack))))))
           (=> a!1 true))
         :pattern ((Buffers.BufferStack.Equivalent this@@92 |other#0@@11|))
         :skolemid |2929|
         :qid |Buffersidfy.63:15|))))
(assert (forall ((this@@93 T@U) (|other#0@@12| T@U))
  (! (=> (and (= (type this@@93) DatatypeTypeType)
              (= (type |other#0@@12|) DatatypeTypeType)
              ($Is this@@93 Tclass.Buffers.BufferStack)
              ($Is |other#0@@12| Tclass.Buffers.BufferStack))
         (= (|Buffers.BufferStack.Equivalent#requires| this@@93 |other#0@@12|)
            true))
     :pattern ((|Buffers.BufferStack.Equivalent#requires|
                 this@@93
                 |other#0@@12|))
     :skolemid |2930|
     :qid |Buffersidfy.63:15|)))
(assert (let ((a!1 (forall ((this@@94 T@U) (|other#0@@13| T@U))
             (! (let ((a!1 (and (= (type this@@94) DatatypeTypeType)
                                (= (type |other#0@@13|) DatatypeTypeType)
                                (or (|Buffers.BufferStack.Equivalent#canCall|
                                      this@@94
                                      |other#0@@13|)
                                    (and ($Is this@@94
                                              Tclass.Buffers.BufferStack)
                                         ($Is |other#0@@13|
                                              Tclass.Buffers.BufferStack)))))
                      (a!2 (forall ((|k#0@@75| T@U))
                             (! (let ((a!1 (=> (Buffers.__default.AnyKey
                                                 |k#0@@75|)
                                               (and (|$IsA#ValueMessage.Message|
                                                      (Buffers.BufferStack.Query
                                                        this@@94
                                                        |k#0@@75|))
                                                    (|$IsA#ValueMessage.Message|
                                                      (Buffers.BufferStack.Query
                                                        |other#0@@13|
                                                        |k#0@@75|))
                                                    (|Buffers.BufferStack.Query#canCall|
                                                      this@@94
                                                      |k#0@@75|)
                                                    (|Buffers.BufferStack.Query#canCall|
                                                      |other#0@@13|
                                                      |k#0@@75|)))))
                                  (=> (and (= (type |k#0@@75|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@75| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |k#0@@75|)
                                           a!1)))
                                :pattern ((Buffers.BufferStack.Query
                                            |other#0@@13|
                                            |k#0@@75|))
                                :pattern ((Buffers.BufferStack.Query
                                            this@@94
                                            |k#0@@75|))
                                :pattern ((Buffers.__default.AnyKey |k#0@@75|))
                                :skolemid |2932|
                                :qid |Buffersidfy.65:14|)))
                      (a!3 (forall ((|k#0@@76| T@U))
                             (! (=> (= (type |k#0@@76|) (SeqType BoxType))
                                    (=> (and ($Is |k#0@@76| Tclass.KeyType.Key)
                                             (Buffers.__default.AnyKey
                                               |k#0@@76|))
                                        (|ValueMessage.Message#Equal|
                                          (Buffers.BufferStack.Query
                                            this@@94
                                            |k#0@@76|)
                                          (Buffers.BufferStack.Query
                                            |other#0@@13|
                                            |k#0@@76|))))
                                :pattern ((Buffers.BufferStack.Query
                                            |other#0@@13|
                                            |k#0@@76|))
                                :pattern ((Buffers.BufferStack.Query
                                            this@@94
                                            |k#0@@76|))
                                :pattern ((Buffers.__default.AnyKey |k#0@@76|))
                                :skolemid |2931|
                                :qid |Buffersidfy.65:14|))))
                  (=> a!1
                      (and a!2
                           (= (Buffers.BufferStack.Equivalent
                                this@@94
                                |other#0@@13|)
                              a!3))))
                :pattern ((Buffers.BufferStack.Equivalent
                            this@@94
                            |other#0@@13|))
                :skolemid |2933|
                :qid |Buffersidfy.63:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@95 T@U) (|other#0@@14| T@U))
      (! (let ((a!1 (and (= (type this@@95) DatatypeTypeType)
                         (= (type |other#0@@14|) DatatypeTypeType)
                         (or (|Buffers.BufferStack.Equivalent#canCall|
                               (Lit this@@95)
                               (Lit |other#0@@14|))
                             (and ($Is this@@95 Tclass.Buffers.BufferStack)
                                  ($Is |other#0@@14| Tclass.Buffers.BufferStack)))))
               (a!2 (forall ((|k#1@@10| T@U))
                      (! (let ((a!1 (and (|$IsA#ValueMessage.Message|
                                           (Buffers.BufferStack.Query
                                             (Lit this@@95)
                                             |k#1@@10|))
                                         (|$IsA#ValueMessage.Message|
                                           (Buffers.BufferStack.Query
                                             (Lit |other#0@@14|)
                                             |k#1@@10|))
                                         (|Buffers.BufferStack.Query#canCall|
                                           (Lit this@@95)
                                           |k#1@@10|)
                                         (|Buffers.BufferStack.Query#canCall|
                                           (Lit |other#0@@14|)
                                           |k#1@@10|))))
                           (=> (and (= (type |k#1@@10|) (SeqType BoxType))
                                    ($Is |k#1@@10| Tclass.KeyType.Key))
                               (and (|Buffers.__default.AnyKey#canCall|
                                      |k#1@@10|)
                                    (=> (Buffers.__default.AnyKey |k#1@@10|)
                                        a!1))))
                         :pattern ((Buffers.BufferStack.Query
                                     |other#0@@14|
                                     |k#1@@10|))
                         :pattern ((Buffers.BufferStack.Query
                                     this@@95
                                     |k#1@@10|))
                         :pattern ((Buffers.__default.AnyKey |k#1@@10|))
                         :skolemid |2935|
                         :qid |Buffersidfy.65:14|)))
               (a!3 (forall ((|k#1@@11| T@U))
                      (! (let ((a!1 (=> (and ($Is |k#1@@11| Tclass.KeyType.Key)
                                             (Buffers.__default.AnyKey
                                               |k#1@@11|))
                                        (|ValueMessage.Message#Equal|
                                          (Buffers.BufferStack.Query
                                            (Lit this@@95)
                                            |k#1@@11|)
                                          (Buffers.BufferStack.Query
                                            (Lit |other#0@@14|)
                                            |k#1@@11|)))))
                           (=> (= (type |k#1@@11|) (SeqType BoxType)) a!1))
                         :pattern ((Buffers.BufferStack.Query
                                     |other#0@@14|
                                     |k#1@@11|))
                         :pattern ((Buffers.BufferStack.Query
                                     this@@95
                                     |k#1@@11|))
                         :pattern ((Buffers.__default.AnyKey |k#1@@11|))
                         :skolemid |2934|
                         :qid |Buffersidfy.65:14|))))
         (let ((a!4 (and a!2
                         (= (Buffers.BufferStack.Equivalent
                              (Lit this@@95)
                              (Lit |other#0@@14|))
                            a!3))))
           (=> a!1 a!4)))
         :pattern ((Buffers.BufferStack.Equivalent
                     (Lit this@@95)
                     (Lit |other#0@@14|)))
         :weight 3
         :skolemid |2936|
         :qid |Buffersidfy.63:15|))))
(assert (= (type Tclass.Buffers.__default) TyType))
(assert (= (Tag Tclass.Buffers.__default) Tagclass.Buffers.__default))
(assert (= (TagFamily Tclass.Buffers.__default) tytagFamily$_default))
(assert (forall ((bx@@159 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@159)) bx@@159)
                     ($Is ($Unbox refType bx@@159) Tclass.Buffers.__default))))
       (=> (and (= (type bx@@159) BoxType)
                ($IsBox bx@@159 Tclass.Buffers.__default))
           a!1))
     :pattern (($IsBox bx@@159 Tclass.Buffers.__default))
     :skolemid |2937|
     :qid |unknown.0:0|)))
(assert (forall (($o@@47 T@U))
  (! (let ((a!1 (= ($Is $o@@47 Tclass.Buffers.__default)
                   (or (= $o@@47 null)
                       (= (dtype $o@@47) Tclass.Buffers.__default)))))
       (=> (= (type $o@@47) refType) a!1))
     :pattern (($Is $o@@47 Tclass.Buffers.__default))
     :skolemid |2938|
     :qid |unknown.0:0|)))
(assert (forall (($o@@48 T@U) ($h@@105 T@U))
  (! (let ((a!1 (or (= $o@@48 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@105 $o@@48)
                                              alloc)))))
       (=> (and (= (type $o@@48) refType)
                (= (type $h@@105) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@48 Tclass.Buffers.__default $h@@105) a!1)))
     :pattern (($IsAlloc $o@@48 Tclass.Buffers.__default $h@@105))
     :skolemid |2939|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((|key#0@@44| T@U))
             (! (=> (and (= (type |key#0@@44|) (SeqType BoxType))
                         (or (|Buffers.__default.AnyKey#canCall| |key#0@@44|)
                             ($Is |key#0@@44| Tclass.KeyType.Key)))
                    true)
                :pattern ((Buffers.__default.AnyKey |key#0@@44|))
                :skolemid |2940|
                :qid |Buffersidfy.15:20|))))
  (=> true a!1)))
(assert (forall ((|key#0@@45| T@U))
  (! (=> (and (= (type |key#0@@45|) (SeqType BoxType))
              ($Is |key#0@@45| Tclass.KeyType.Key))
         (= (|Buffers.__default.AnyKey#requires| |key#0@@45|) true))
     :pattern ((|Buffers.__default.AnyKey#requires| |key#0@@45|))
     :skolemid |2941|
     :qid |Buffersidfy.15:20|)))
(assert (let ((a!1 (forall ((|key#0@@46| T@U))
             (! (let ((a!1 (= (Buffers.__default.AnyKey |key#0@@46|)
                              (U_2_bool (Lit (bool_2_U true))))))
                  (=> (and (= (type |key#0@@46|) (SeqType BoxType))
                           (or (|Buffers.__default.AnyKey#canCall| |key#0@@46|)
                               ($Is |key#0@@46| Tclass.KeyType.Key)))
                      a!1))
                :pattern ((Buffers.__default.AnyKey |key#0@@46|))
                :skolemid |2942|
                :qid |Buffersidfy.15:20|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|key#0@@47| T@U))
      (! (let ((a!1 (and (= (type |key#0@@47|) (SeqType BoxType))
                         (or (|Buffers.__default.AnyKey#canCall|
                               (Lit |key#0@@47|))
                             ($Is |key#0@@47| Tclass.KeyType.Key))))
               (a!2 (= (Buffers.__default.AnyKey (Lit |key#0@@47|))
                       (U_2_bool (Lit (bool_2_U true))))))
           (=> a!1 a!2))
         :pattern ((Buffers.__default.AnyKey (Lit |key#0@@47|)))
         :weight 3
         :skolemid |2943|
         :qid |Buffersidfy.15:20|))))
(assert (=> true
    (forall ((|keys#0| T@U))
      (! (let ((a!1 (and (= (type |keys#0|) (MapType0Type BoxType boolType))
                         (or (|Buffers.__default.Total#canCall| |keys#0|)
                             ($Is |keys#0| (TISet Tclass.KeyType.Key))))))
           (=> a!1 true))
         :pattern ((Buffers.__default.Total |keys#0|))
         :skolemid |2944|
         :qid |Buffersidfy.16:19|))))
(assert (forall ((|keys#0@@0| T@U))
  (! (=> (and (= (type |keys#0@@0|) (MapType0Type BoxType boolType))
              ($Is |keys#0@@0| (TISet Tclass.KeyType.Key)))
         (= (|Buffers.__default.Total#requires| |keys#0@@0|) true))
     :pattern ((|Buffers.__default.Total#requires| |keys#0@@0|))
     :skolemid |2945|
     :qid |Buffersidfy.16:19|)))
(assert (let ((a!1 (forall ((|keys#0@@1| T@U))
             (! (let ((a!1 (and (= (type |keys#0@@1|)
                                   (MapType0Type BoxType boolType))
                                (or (|Buffers.__default.Total#canCall|
                                      |keys#0@@1|)
                                    ($Is |keys#0@@1| (TISet Tclass.KeyType.Key)))))
                      (a!2 (forall ((|k#0@@77| T@U))
                             (! (=> (and (= (type |k#0@@77|) (SeqType BoxType))
                                         ($Is |k#0@@77| Tclass.KeyType.Key))
                                    (|Buffers.__default.AnyKey#canCall|
                                      |k#0@@77|))
                                :pattern ((MapType0Select |keys#0@@1|
                                                          ($Box |k#0@@77|)))
                                :pattern ((Buffers.__default.AnyKey |k#0@@77|))
                                :skolemid |2947|
                                :qid |Buffersidfy.17:12|)))
                      (a!3 (forall ((|k#0@@78| T@U))
                             (! (let ((a!1 (=> (and ($Is |k#0@@78|
                                                         Tclass.KeyType.Key)
                                                    (Buffers.__default.AnyKey
                                                      |k#0@@78|))
                                               (U_2_bool (MapType0Select |keys#0@@1|
                                                                         ($Box |k#0@@78|))))))
                                  (=> (= (type |k#0@@78|) (SeqType BoxType))
                                      a!1))
                                :pattern ((MapType0Select |keys#0@@1|
                                                          ($Box |k#0@@78|)))
                                :pattern ((Buffers.__default.AnyKey |k#0@@78|))
                                :skolemid |2946|
                                :qid |Buffersidfy.17:12|))))
                  (=> a!1
                      (and a!2 (= (Buffers.__default.Total |keys#0@@1|) a!3))))
                :pattern ((Buffers.__default.Total |keys#0@@1|))
                :skolemid |2948|
                :qid |Buffersidfy.16:19|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|keys#0@@2| T@U))
      (! (let ((a!1 (and (= (type |keys#0@@2|) (MapType0Type BoxType boolType))
                         (or (|Buffers.__default.Total#canCall|
                               (Lit |keys#0@@2|))
                             ($Is |keys#0@@2| (TISet Tclass.KeyType.Key)))))
               (a!2 (forall ((|k#1@@12| T@U))
                      (! (=> (and (= (type |k#1@@12|) (SeqType BoxType))
                                  ($Is |k#1@@12| Tclass.KeyType.Key))
                             (|Buffers.__default.AnyKey#canCall| |k#1@@12|))
                         :pattern ((MapType0Select |keys#0@@2| ($Box |k#1@@12|)))
                         :pattern ((Buffers.__default.AnyKey |k#1@@12|))
                         :skolemid |2950|
                         :qid |Buffersidfy.17:12|)))
               (a!3 (forall ((|k#1@@13| T@U))
                      (! (let ((a!1 (=> (and ($Is |k#1@@13| Tclass.KeyType.Key)
                                             (Buffers.__default.AnyKey
                                               |k#1@@13|))
                                        (U_2_bool (MapType0Select (Lit |keys#0@@2|)
                                                                  ($Box |k#1@@13|))))))
                           (=> (= (type |k#1@@13|) (SeqType BoxType)) a!1))
                         :pattern ((MapType0Select |keys#0@@2| ($Box |k#1@@13|)))
                         :pattern ((Buffers.__default.AnyKey |k#1@@13|))
                         :skolemid |2949|
                         :qid |Buffersidfy.17:12|))))
         (let ((a!4 (and a!2
                         (= (Buffers.__default.Total (Lit |keys#0@@2|)) a!3))))
           (=> a!1 a!4)))
         :pattern ((Buffers.__default.Total (Lit |keys#0@@2|)))
         :weight 3
         :skolemid |2951|
         :qid |Buffersidfy.16:19|))))
(assert (= (type Buffers.__default.AllKeys) (MapType0Type BoxType boolType)))
(assert (let ((a!1 (=> true
               (and (Buffers.__default.Total Buffers.__default.AllKeys)
                    ($Is Buffers.__default.AllKeys (TISet Tclass.KeyType.Key))))))
  (=> true a!1)))
(assert (= |Buffers.__default.AllKeys#requires| true))
(assert (forall ((arg0@@550 T@U))
  (! (= (type (|lambda#242| arg0@@550)) (MapType0Type BoxType boolType))
     :pattern ((|lambda#242| arg0@@550))
     :qid |funType:lambda#242|)))
(assert (let ((a!1 (forall ((|k#0@@79| T@U))
             (! (=> (and (= (type |k#0@@79|) (SeqType BoxType))
                         ($Is |k#0@@79| Tclass.KeyType.Key))
                    (|Buffers.__default.AnyKey#canCall| |k#0@@79|))
                :pattern ((Buffers.__default.AnyKey |k#0@@79|))
                :skolemid |2952|
                :qid |Buffersidfy.22:10|))))
(let ((a!2 (=> true
               (and a!1
                    (= Buffers.__default.AllKeys
                       (|lambda#242| Tclass.KeyType.Key))))))
  (=> true a!2))))
(assert (let ((a!1 (forall ((|k#1@@14| T@U))
             (! (=> (and (= (type |k#1@@14|) (SeqType BoxType))
                         ($Is |k#1@@14| Tclass.KeyType.Key))
                    (|Buffers.__default.AnyKey#canCall| |k#1@@14|))
                :pattern ((Buffers.__default.AnyKey |k#1@@14|))
                :skolemid |2953|
                :qid |Buffersidfy.22:10|))))
(let ((a!2 (=> true
               (and a!1
                    (= Buffers.__default.AllKeys
                       (|lambda#242| Tclass.KeyType.Key))))))
  (=> true a!2))))
(assert (forall ((arg0@@551 T@U) (arg1@@278 Int))
  (! (= (type (|#MemtableMod.Memtable.Memtable| arg0@@551 arg1@@278))
        DatatypeTypeType)
     :pattern ((|#MemtableMod.Memtable.Memtable| arg0@@551 arg1@@278))
     :qid |funType:#MemtableMod.Memtable.Memtable|)))
(assert (forall ((|a#0#0#0@@5| T@U) (|a#0#1#0@@2| Int))
  (! (=> (= (type |a#0#0#0@@5|) (MapType BoxType BoxType))
         (= (DatatypeCtorId (|#MemtableMod.Memtable.Memtable|
                              |a#0#0#0@@5|
                              |a#0#1#0@@2|))
            |##MemtableMod.Memtable.Memtable|))
     :pattern ((|#MemtableMod.Memtable.Memtable| |a#0#0#0@@5| |a#0#1#0@@2|))
     :skolemid |2954|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((d@@66 T@U))
  (! (=> (= (type d@@66) DatatypeTypeType)
         (= (MemtableMod.Memtable.Memtable_q d@@66)
            (= (DatatypeCtorId d@@66) |##MemtableMod.Memtable.Memtable|)))
     :pattern ((MemtableMod.Memtable.Memtable_q d@@66))
     :skolemid |2955|
     :qid |unknown.0:0|)))
(assert (forall ((d@@67 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@5| T@U) (|a#1#1#0@@2| Int))
                  (! (and (= (type |a#1#0#0@@5|) (MapType BoxType BoxType))
                          (= d@@67
                             (|#MemtableMod.Memtable.Memtable|
                               |a#1#0#0@@5|
                               |a#1#1#0@@2|)))
                     :no-pattern (type |a#1#0#0@@5|)
                     :no-pattern (U_2_int |a#1#0#0@@5|)
                     :no-pattern (U_2_bool |a#1#0#0@@5|)
                     :skolemid |2956|
                     :qid |Memtableidfy.15:32|))))
       (=> (and (= (type d@@67) DatatypeTypeType)
                (MemtableMod.Memtable.Memtable_q d@@67))
           a!1))
     :pattern ((MemtableMod.Memtable.Memtable_q d@@67))
     :skolemid |2957|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@5| T@U) (|a#2#1#0@@2| Int))
  (! (let ((a!1 (= ($Is (|#MemtableMod.Memtable.Memtable|
                          |a#2#0#0@@5|
                          |a#2#1#0@@2|)
                        Tclass.MemtableMod.Memtable)
                   (and ($Is |a#2#0#0@@5|
                             (TMap Tclass.KeyType.Key
                                   Tclass.ValueMessage.Message))
                        ($Is (int_2_U |a#2#1#0@@2|) Tclass._System.nat)))))
       (=> (= (type |a#2#0#0@@5|) (MapType BoxType BoxType)) a!1))
     :pattern (($Is (|#MemtableMod.Memtable.Memtable| |a#2#0#0@@5| |a#2#1#0@@2|)
                    Tclass.MemtableMod.Memtable))
     :skolemid |2958|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((|a#3#0#0@@5| T@U) (|a#3#1#0@@2| Int) ($h@@106 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#MemtableMod.Memtable.Memtable|
                               |a#3#0#0@@5|
                               |a#3#1#0@@2|)
                             Tclass.MemtableMod.Memtable
                             $h@@106)
                   (and ($IsAlloc |a#3#0#0@@5|
                                  (TMap Tclass.KeyType.Key
                                        Tclass.ValueMessage.Message)
                                  $h@@106)
                        ($IsAlloc (int_2_U |a#3#1#0@@2|)
                                  Tclass._System.nat
                                  $h@@106)))))
       (=> (and (= (type |a#3#0#0@@5|) (MapType BoxType BoxType))
                (= (type $h@@106) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@106))
           a!1))
     :pattern (($IsAlloc (|#MemtableMod.Memtable.Memtable|
                           |a#3#0#0@@5|
                           |a#3#1#0@@2|)
                         Tclass.MemtableMod.Memtable
                         $h@@106))
     :skolemid |2959|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((arg0@@552 T@U))
  (! (= (type (MemtableMod.Memtable.mapp arg0@@552)) (MapType BoxType BoxType))
     :pattern ((MemtableMod.Memtable.mapp arg0@@552))
     :qid |funType:MemtableMod.Memtable.mapp|)))
(assert (forall ((d@@68 T@U) ($h@@107 T@U))
  (! (=> (and (= (type d@@68) DatatypeTypeType)
              (= (type $h@@107) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@107)
              (MemtableMod.Memtable.Memtable_q d@@68)
              ($IsAlloc d@@68 Tclass.MemtableMod.Memtable $h@@107))
         ($IsAlloc (MemtableMod.Memtable.mapp d@@68)
                   (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message)
                   $h@@107))
     :pattern (($IsAlloc (MemtableMod.Memtable.mapp d@@68)
                         (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message)
                         $h@@107))
     :skolemid |2960|
     :qid |unknown.0:0|)))
(assert (forall ((d@@69 T@U) ($h@@108 T@U))
  (! (=> (and (= (type d@@69) DatatypeTypeType)
              (= (type $h@@108) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@108)
              (MemtableMod.Memtable.Memtable_q d@@69)
              ($IsAlloc d@@69 Tclass.MemtableMod.Memtable $h@@108))
         ($IsAlloc (int_2_U (MemtableMod.Memtable.seqEnd d@@69))
                   Tclass._System.nat
                   $h@@108))
     :pattern (($IsAlloc (int_2_U (MemtableMod.Memtable.seqEnd d@@69))
                         Tclass._System.nat
                         $h@@108))
     :skolemid |2961|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@5| T@U) (|a#4#1#0@@2| Int))
  (! (=> (= (type |a#4#0#0@@5|) (MapType BoxType BoxType))
         (= (|#MemtableMod.Memtable.Memtable|
              (Lit |a#4#0#0@@5|)
              (LitInt |a#4#1#0@@2|))
            (Lit (|#MemtableMod.Memtable.Memtable| |a#4#0#0@@5| |a#4#1#0@@2|))))
     :pattern ((|#MemtableMod.Memtable.Memtable|
                 (Lit |a#4#0#0@@5|)
                 (LitInt |a#4#1#0@@2|)))
     :skolemid |2962|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((|a#5#0#0@@6| T@U) (|a#5#1#0@@2| Int))
  (! (=> (= (type |a#5#0#0@@6|) (MapType BoxType BoxType))
         (= (MemtableMod.Memtable.mapp
              (|#MemtableMod.Memtable.Memtable| |a#5#0#0@@6| |a#5#1#0@@2|))
            |a#5#0#0@@6|))
     :pattern ((|#MemtableMod.Memtable.Memtable| |a#5#0#0@@6| |a#5#1#0@@2|))
     :skolemid |2963|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((|a#6#0#0@@6| T@U) (|a#6#1#0@@2| Int) (d@@70 T@U))
  (! (let ((a!1 (and (= (type |a#6#0#0@@6|) (MapType BoxType BoxType))
                     (= (type d@@70) DatatypeTypeType)
                     (U_2_bool (MapType0Select (|Map#Domain| |a#6#0#0@@6|)
                                               ($Box d@@70))))))
       (=> a!1
           (< (DtRank d@@70)
              (DtRank (|#MemtableMod.Memtable.Memtable|
                        |a#6#0#0@@6|
                        |a#6#1#0@@2|)))))
     :pattern ((MapType0Select (|Map#Domain| |a#6#0#0@@6|) ($Box d@@70))
               (|#MemtableMod.Memtable.Memtable| |a#6#0#0@@6| |a#6#1#0@@2|))
     :skolemid |2964|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((|a#7#0#0@@6| T@U) (|a#7#1#0@@2| Int) (bx@@160 T@U))
  (! (let ((a!1 (and (= (type |a#7#0#0@@6|) (MapType BoxType BoxType))
                     (= (type bx@@160) BoxType)
                     (U_2_bool (MapType0Select (|Map#Domain| |a#7#0#0@@6|)
                                               bx@@160))))
           (a!2 (DtRank ($Unbox DatatypeTypeType
                                (MapType0Select (|Map#Elements| |a#7#0#0@@6|)
                                                bx@@160)))))
       (=> a!1
           (< a!2
              (DtRank (|#MemtableMod.Memtable.Memtable|
                        |a#7#0#0@@6|
                        |a#7#1#0@@2|)))))
     :pattern ((MapType0Select (|Map#Domain| |a#7#0#0@@6|) bx@@160)
               (|#MemtableMod.Memtable.Memtable| |a#7#0#0@@6| |a#7#1#0@@2|))
     :skolemid |2965|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((|a#8#0#0@@3| T@U) (|a#8#1#0@@1| Int))
  (! (=> (= (type |a#8#0#0@@3|) (MapType BoxType BoxType))
         (= (MemtableMod.Memtable.seqEnd
              (|#MemtableMod.Memtable.Memtable| |a#8#0#0@@3| |a#8#1#0@@1|))
            |a#8#1#0@@1|))
     :pattern ((|#MemtableMod.Memtable.Memtable| |a#8#0#0@@3| |a#8#1#0@@1|))
     :skolemid |2966|
     :qid |Memtableidfy.15:32|)))
(assert (forall ((d@@71 T@U))
  (! (=> (and (= (type d@@71) DatatypeTypeType)
              (|$IsA#MemtableMod.Memtable| d@@71))
         (MemtableMod.Memtable.Memtable_q d@@71))
     :pattern ((|$IsA#MemtableMod.Memtable| d@@71))
     :skolemid |2967|
     :qid |unknown.0:0|)))
(assert (forall ((d@@72 T@U))
  (! (=> (and (= (type d@@72) DatatypeTypeType)
              ($Is d@@72 Tclass.MemtableMod.Memtable))
         (MemtableMod.Memtable.Memtable_q d@@72))
     :pattern ((MemtableMod.Memtable.Memtable_q d@@72)
               ($Is d@@72 Tclass.MemtableMod.Memtable))
     :skolemid |2968|
     :qid |unknown.0:0|)))
(assert (forall ((a@@136 T@U) (b@@86 T@U))
  (! (let ((a!1 (= (|MemtableMod.Memtable#Equal| a@@136 b@@86)
                   (and (|Map#Equal| (MemtableMod.Memtable.mapp a@@136)
                                     (MemtableMod.Memtable.mapp b@@86))
                        (= (MemtableMod.Memtable.seqEnd a@@136)
                           (MemtableMod.Memtable.seqEnd b@@86))))))
       (=> (and (= (type a@@136) DatatypeTypeType)
                (= (type b@@86) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|MemtableMod.Memtable#Equal| a@@136 b@@86))
     :skolemid |2969|
     :qid |unknown.0:0|)))
(assert (forall ((a@@137 T@U) (b@@87 T@U))
  (! (=> (and (= (type a@@137) DatatypeTypeType)
              (= (type b@@87) DatatypeTypeType))
         (= (|MemtableMod.Memtable#Equal| a@@137 b@@87) (= a@@137 b@@87)))
     :pattern ((|MemtableMod.Memtable#Equal| a@@137 b@@87))
     :skolemid |2970|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((this@@96 T@U) (|key#0@@48| T@U))
             (! (let ((a!1 (and (= (type this@@96) DatatypeTypeType)
                                (= (type |key#0@@48|) (SeqType BoxType))
                                (or (|MemtableMod.Memtable.Get#canCall|
                                      this@@96
                                      |key#0@@48|)
                                    (and ($Is this@@96
                                              Tclass.MemtableMod.Memtable)
                                         ($Is |key#0@@48| Tclass.KeyType.Key))))))
                  (=> a!1
                      ($Is (MemtableMod.Memtable.Get this@@96 |key#0@@48|)
                           Tclass.ValueMessage.Message)))
                :pattern ((MemtableMod.Memtable.Get this@@96 |key#0@@48|))
                :skolemid |2971|
                :qid |Memtableidfy.17:14|))))
  (=> true a!1)))
(assert (forall ((this@@97 T@U) (|key#0@@49| T@U))
  (! (=> (and (= (type this@@97) DatatypeTypeType)
              (= (type |key#0@@49|) (SeqType BoxType))
              ($Is this@@97 Tclass.MemtableMod.Memtable)
              ($Is |key#0@@49| Tclass.KeyType.Key))
         (= (|MemtableMod.Memtable.Get#requires| this@@97 |key#0@@49|) true))
     :pattern ((|MemtableMod.Memtable.Get#requires| this@@97 |key#0@@49|))
     :skolemid |2972|
     :qid |Memtableidfy.17:14|)))
(assert (let ((a!1 (forall ((this@@98 T@U) (|key#0@@50| T@U))
             (! (let ((a!1 (and (= (type this@@98) DatatypeTypeType)
                                (= (type |key#0@@50|) (SeqType BoxType))
                                (or (|MemtableMod.Memtable.Get#canCall|
                                      this@@98
                                      |key#0@@50|)
                                    (and ($Is this@@98
                                              Tclass.MemtableMod.Memtable)
                                         ($Is |key#0@@50| Tclass.KeyType.Key)))))
                      (a!2 (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp
                                                                     this@@98))
                                                     ($Box |key#0@@50|))))
                      (a!3 ($Unbox DatatypeTypeType
                                   (MapType0Select (|Map#Elements| (MemtableMod.Memtable.mapp
                                                                     this@@98))
                                                   ($Box |key#0@@50|)))))
                (let ((a!4 (= (MemtableMod.Memtable.Get this@@98 |key#0@@50|)
                              (ite a!2
                                   a!3
                                   (|#ValueMessage.Message.Update|
                                     (Lit ValueMessage.__default.NopDelta))))))
                  (=> a!1
                      (and (MemtableMod.Memtable.Memtable_q this@@98)
                           (=> a!2 (MemtableMod.Memtable.Memtable_q this@@98))
                           (=> (not a!2)
                               |ValueMessage.__default.NopDelta#canCall|)
                           a!4))))
                :pattern ((MemtableMod.Memtable.Get this@@98 |key#0@@50|))
                :skolemid |2973|
                :qid |Memtableidfy.17:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@99 T@U) (|key#0@@51| T@U))
      (! (let ((a!1 (and (= (type this@@99) DatatypeTypeType)
                         (= (type |key#0@@51|) (SeqType BoxType))
                         (or (|MemtableMod.Memtable.Get#canCall|
                               (Lit this@@99)
                               (Lit |key#0@@51|))
                             (and ($Is this@@99 Tclass.MemtableMod.Memtable)
                                  ($Is |key#0@@51| Tclass.KeyType.Key)))))
               (a!2 (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp
                                                    (Lit this@@99)))
                                    ($Box |key#0@@51|)))
               (a!3 (|Map#Elements| (Lit (MemtableMod.Memtable.mapp
                                           (Lit this@@99))))))
         (let ((a!4 ($Unbox DatatypeTypeType
                            (MapType0Select a!3 ($Box (Lit |key#0@@51|))))))
         (let ((a!5 (= (MemtableMod.Memtable.Get
                         (Lit this@@99)
                         (Lit |key#0@@51|))
                       (ite (U_2_bool a!2)
                            a!4
                            (|#ValueMessage.Message.Update|
                              (Lit ValueMessage.__default.NopDelta))))))
         (let ((a!6 (and (MemtableMod.Memtable.Memtable_q (Lit this@@99))
                         (=> (U_2_bool a!2)
                             (MemtableMod.Memtable.Memtable_q (Lit this@@99)))
                         (=> (not (U_2_bool a!2))
                             |ValueMessage.__default.NopDelta#canCall|)
                         a!5)))
           (=> a!1 a!6)))))
         :pattern ((MemtableMod.Memtable.Get (Lit this@@99) (Lit |key#0@@51|)))
         :weight 3
         :skolemid |2974|
         :qid |Memtableidfy.17:14|))))
(assert (forall ((arg0@@553 T@U) (arg1@@279 T@U))
  (! (= (type (MemtableMod.Memtable.ApplyPut arg0@@553 arg1@@279))
        DatatypeTypeType)
     :pattern ((MemtableMod.Memtable.ApplyPut arg0@@553 arg1@@279))
     :qid |funType:MemtableMod.Memtable.ApplyPut|)))
(assert (let ((a!1 (forall ((this@@100 T@U) (|km#0| T@U))
             (! (let ((a!1 (and (= (type this@@100) DatatypeTypeType)
                                (= (type |km#0|) DatatypeTypeType)
                                (or (|MemtableMod.Memtable.ApplyPut#canCall|
                                      this@@100
                                      |km#0|)
                                    (and ($Is this@@100
                                              Tclass.MemtableMod.Memtable)
                                         ($Is |km#0|
                                              Tclass.MsgHistoryMod.KeyedMessage))))))
                  (=> a!1
                      ($Is (MemtableMod.Memtable.ApplyPut this@@100 |km#0|)
                           Tclass.MemtableMod.Memtable)))
                :pattern ((MemtableMod.Memtable.ApplyPut this@@100 |km#0|))
                :skolemid |2975|
                :qid |Memtableidfy.22:14|))))
  (=> true a!1)))
(assert (forall ((this@@101 T@U) (|km#0@@0| T@U))
  (! (=> (and (= (type this@@101) DatatypeTypeType)
              (= (type |km#0@@0|) DatatypeTypeType)
              ($Is this@@101 Tclass.MemtableMod.Memtable)
              ($Is |km#0@@0| Tclass.MsgHistoryMod.KeyedMessage))
         (= (|MemtableMod.Memtable.ApplyPut#requires| this@@101 |km#0@@0|) true))
     :pattern ((|MemtableMod.Memtable.ApplyPut#requires| this@@101 |km#0@@0|))
     :skolemid |2976|
     :qid |Memtableidfy.22:14|)))
(assert (=> true
    (forall ((this@@102 T@U) (|km#0@@1| T@U))
      (! (let ((a!1 (and (= (type this@@102) DatatypeTypeType)
                         (= (type |km#0@@1|) DatatypeTypeType)
                         (or (|MemtableMod.Memtable.ApplyPut#canCall|
                               this@@102
                               |km#0@@1|)
                             (and ($Is this@@102 Tclass.MemtableMod.Memtable)
                                  ($Is |km#0@@1|
                                       Tclass.MsgHistoryMod.KeyedMessage)))))
               (a!2 ($Box (ValueMessage.__default.Merge
                            (MsgHistoryMod.KeyedMessage.message |km#0@@1|)
                            (MemtableMod.Memtable.Get
                              this@@102
                              (MsgHistoryMod.KeyedMessage.key |km#0@@1|))))))
         (let ((a!3 (|#MemtableMod.Memtable.Memtable|
                      (|Map#Build| (MemtableMod.Memtable.mapp this@@102)
                                   ($Box (MsgHistoryMod.KeyedMessage.key
                                           |km#0@@1|))
                                   a!2)
                      (INTERNAL_add_boogie
                        (MemtableMod.Memtable.seqEnd this@@102)
                        1))))
         (let ((a!4 (and (MemtableMod.Memtable.Memtable_q this@@102)
                         (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|)
                         (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|)
                         (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|)
                         (|MemtableMod.Memtable.Get#canCall|
                           this@@102
                           (MsgHistoryMod.KeyedMessage.key |km#0@@1|))
                         (|ValueMessage.__default.Merge#canCall|
                           (MsgHistoryMod.KeyedMessage.message |km#0@@1|)
                           (MemtableMod.Memtable.Get
                             this@@102
                             (MsgHistoryMod.KeyedMessage.key |km#0@@1|)))
                         (MemtableMod.Memtable.Memtable_q this@@102)
                         (= (MemtableMod.Memtable.ApplyPut this@@102 |km#0@@1|)
                            a!3))))
           (=> a!1 a!4))))
         :pattern ((MemtableMod.Memtable.ApplyPut this@@102 |km#0@@1|))
         :skolemid |2977|
         :qid |Memtableidfy.22:14|))))
(assert (=> true
    (forall ((this@@103 T@U) (|km#0@@2| T@U))
      (! (let ((a!1 (and (= (type this@@103) DatatypeTypeType)
                         (= (type |km#0@@2|) DatatypeTypeType)
                         (or (|MemtableMod.Memtable.ApplyPut#canCall|
                               (Lit this@@103)
                               (Lit |km#0@@2|))
                             (and ($Is this@@103 Tclass.MemtableMod.Memtable)
                                  ($Is |km#0@@2|
                                       Tclass.MsgHistoryMod.KeyedMessage)))))
               (a!2 (|MemtableMod.Memtable.Get#canCall|
                      (Lit this@@103)
                      (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))))
               (a!3 (MemtableMod.Memtable.Get
                      (Lit this@@103)
                      (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))))
               (a!5 ($Box (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))))
               (a!8 (LitInt (INTERNAL_add_boogie
                              (MemtableMod.Memtable.seqEnd (Lit this@@103))
                              1))))
         (let ((a!4 (|ValueMessage.__default.Merge#canCall|
                      (Lit (MsgHistoryMod.KeyedMessage.message (Lit |km#0@@2|)))
                      (Lit a!3)))
               (a!6 (ValueMessage.__default.Merge
                      (Lit (MsgHistoryMod.KeyedMessage.message (Lit |km#0@@2|)))
                      (Lit a!3))))
         (let ((a!7 (|Map#Build| (Lit (MemtableMod.Memtable.mapp
                                        (Lit this@@103)))
                                 a!5
                                 ($Box (Lit a!6)))))
         (let ((a!9 (and (MemtableMod.Memtable.Memtable_q (Lit this@@103))
                         (MsgHistoryMod.KeyedMessage.KeyedMessage_q
                           (Lit |km#0@@2|))
                         (MsgHistoryMod.KeyedMessage.KeyedMessage_q
                           (Lit |km#0@@2|))
                         (MsgHistoryMod.KeyedMessage.KeyedMessage_q
                           (Lit |km#0@@2|))
                         a!2
                         a!4
                         (MemtableMod.Memtable.Memtable_q (Lit this@@103))
                         (= (MemtableMod.Memtable.ApplyPut
                              (Lit this@@103)
                              (Lit |km#0@@2|))
                            (|#MemtableMod.Memtable.Memtable| a!7 a!8)))))
           (=> a!1 a!9)))))
         :pattern ((MemtableMod.Memtable.ApplyPut
                     (Lit this@@103)
                     (Lit |km#0@@2|)))
         :weight 3
         :skolemid |2978|
         :qid |Memtableidfy.22:14|))))
(assert (forall ((arg0@@554 T@U) (arg1@@280 T@U) (arg2@@159 T@U))
  (! (= (type (MemtableMod.Memtable.ApplyPuts arg0@@554 arg1@@280 arg2@@159))
        DatatypeTypeType)
     :pattern ((MemtableMod.Memtable.ApplyPuts arg0@@554 arg1@@280 arg2@@159))
     :qid |funType:MemtableMod.Memtable.ApplyPuts|)))
(assert (forall (($ly@@323 T@U) (this@@104 T@U) (|puts#0@@0| T@U))
  (! (=> (and (= (type $ly@@323) LayerTypeType)
              (= (type this@@104) DatatypeTypeType)
              (= (type |puts#0@@0|) DatatypeTypeType))
         (= (MemtableMod.Memtable.ApplyPuts
              ($LS $ly@@323)
              this@@104
              |puts#0@@0|)
            (MemtableMod.Memtable.ApplyPuts $ly@@323 this@@104 |puts#0@@0|)))
     :pattern ((MemtableMod.Memtable.ApplyPuts
                 ($LS $ly@@323)
                 this@@104
                 |puts#0@@0|))
     :skolemid |2979|
     :qid |Memtableidfy.27:14|)))
(assert (forall (($ly@@324 T@U) (this@@105 T@U) (|puts#0@@1| T@U))
  (! (=> (and (= (type $ly@@324) LayerTypeType)
              (= (type this@@105) DatatypeTypeType)
              (= (type |puts#0@@1|) DatatypeTypeType))
         (= (MemtableMod.Memtable.ApplyPuts $ly@@324 this@@105 |puts#0@@1|)
            (MemtableMod.Memtable.ApplyPuts $LZ this@@105 |puts#0@@1|)))
     :pattern ((MemtableMod.Memtable.ApplyPuts
                 (AsFuelBottom $ly@@324)
                 this@@105
                 |puts#0@@1|))
     :skolemid |2980|
     :qid |Memtableidfy.27:14|)))
(assert (let ((a!1 (forall (($ly@@325 T@U) (this@@106 T@U) (|puts#0@@2| T@U))
             (! (let ((a!1 (or (|MemtableMod.Memtable.ApplyPuts#canCall|
                                 this@@106
                                 |puts#0@@2|)
                               (and ($Is this@@106 Tclass.MemtableMod.Memtable)
                                    ($Is |puts#0@@2|
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    (MsgHistoryMod.MsgHistory.WF |puts#0@@2|)
                                    (= (MsgHistoryMod.MsgHistory.seqStart
                                         |puts#0@@2|)
                                       (MemtableMod.Memtable.seqEnd this@@106))))))
                  (=> (and (= (type $ly@@325) LayerTypeType)
                           (= (type this@@106) DatatypeTypeType)
                           (= (type |puts#0@@2|) DatatypeTypeType)
                           a!1)
                      ($Is (MemtableMod.Memtable.ApplyPuts
                             $ly@@325
                             this@@106
                             |puts#0@@2|)
                           Tclass.MemtableMod.Memtable)))
                :pattern ((MemtableMod.Memtable.ApplyPuts
                            $ly@@325
                            this@@106
                            |puts#0@@2|))
                :skolemid |2981|
                :qid |Memtableidfy.27:14|))))
  (=> true a!1)))
(assert (forall (($ly@@326 T@U) (this@@107 T@U) (|puts#0@@3| T@U))
  (! (let ((a!1 (= (|MemtableMod.Memtable.ApplyPuts#requires|
                     $ly@@326
                     this@@107
                     |puts#0@@3|)
                   (and (MsgHistoryMod.MsgHistory.WF |puts#0@@3|)
                        (= (MsgHistoryMod.MsgHistory.seqStart |puts#0@@3|)
                           (MemtableMod.Memtable.seqEnd this@@107))))))
       (=> (and (= (type $ly@@326) LayerTypeType)
                (= (type this@@107) DatatypeTypeType)
                (= (type |puts#0@@3|) DatatypeTypeType)
                ($Is this@@107 Tclass.MemtableMod.Memtable)
                ($Is |puts#0@@3| Tclass.MsgHistoryMod.MsgHistory))
           a!1))
     :pattern ((|MemtableMod.Memtable.ApplyPuts#requires|
                 $ly@@326
                 this@@107
                 |puts#0@@3|))
     :skolemid |2982|
     :qid |Memtableidfy.27:14|)))
(assert (let ((a!1 (forall (($ly@@327 T@U) (this@@108 T@U) (|puts#0@@4| T@U))
             (! (let ((a!1 (or (|MemtableMod.Memtable.ApplyPuts#canCall|
                                 this@@108
                                 |puts#0@@4|)
                               (and ($Is this@@108 Tclass.MemtableMod.Memtable)
                                    ($Is |puts#0@@4|
                                         Tclass.MsgHistoryMod.MsgHistory)
                                    (MsgHistoryMod.MsgHistory.WF |puts#0@@4|)
                                    (= (MsgHistoryMod.MsgHistory.seqStart
                                         |puts#0@@4|)
                                       (MemtableMod.Memtable.seqEnd this@@108)))))
                      (a!2 (|MemtableMod.Memtable.ApplyPuts#canCall|
                             this@@108
                             (MsgHistoryMod.MsgHistory.DiscardRecent
                               |puts#0@@4|
                               (INTERNAL_sub_boogie
                                 (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|)
                                 1))))
                      (a!3 (MemtableMod.Memtable.ApplyPuts
                             $ly@@327
                             this@@108
                             (MsgHistoryMod.MsgHistory.DiscardRecent
                               |puts#0@@4|
                               (INTERNAL_sub_boogie
                                 (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|)
                                 1))))
                      (a!4 ($Box (int_2_U (INTERNAL_sub_boogie
                                            (MsgHistoryMod.MsgHistory.seqEnd
                                              |puts#0@@4|)
                                            1)))))
                (let ((a!5 ($Unbox DatatypeTypeType
                                   (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs
                                                                     |puts#0@@4|))
                                                   a!4))))
                (let ((a!6 (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                  |puts#0@@4|)
                                (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                                  |puts#0@@4|
                                  (INTERNAL_sub_boogie
                                    (MsgHistoryMod.MsgHistory.seqEnd
                                      |puts#0@@4|)
                                    1))
                                a!2
                                (MsgHistoryMod.MsgHistory.MsgHistory_q
                                  |puts#0@@4|)
                                (MsgHistoryMod.MsgHistory.MsgHistory_q
                                  |puts#0@@4|)
                                (|MemtableMod.Memtable.ApplyPut#canCall|
                                  a!3
                                  a!5))))
                (let ((a!7 (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                                  |puts#0@@4|)
                                (=> (not (MsgHistoryMod.MsgHistory.IsEmpty
                                           |puts#0@@4|))
                                    a!6)
                                (= (MemtableMod.Memtable.ApplyPuts
                                     ($LS $ly@@327)
                                     this@@108
                                     |puts#0@@4|)
                                   (ite (MsgHistoryMod.MsgHistory.IsEmpty
                                          |puts#0@@4|)
                                        this@@108
                                        (MemtableMod.Memtable.ApplyPut a!3 a!5))))))
                  (=> (and (= (type $ly@@327) LayerTypeType)
                           (= (type this@@108) DatatypeTypeType)
                           (= (type |puts#0@@4|) DatatypeTypeType)
                           a!1)
                      a!7)))))
                :pattern ((MemtableMod.Memtable.ApplyPuts
                            ($LS $ly@@327)
                            this@@108
                            |puts#0@@4|))
                :skolemid |2983|
                :qid |Memtableidfy.27:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($ly@@328 T@U) (this@@109 T@U) (|puts#0@@5| T@U))
             (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                            (Lit |puts#0@@5|)))))
                      (a!2 (= (LitInt (MsgHistoryMod.MsgHistory.seqStart
                                        (Lit |puts#0@@5|)))
                              (MemtableMod.Memtable.seqEnd this@@109)))
                      (a!4 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty
                                            (Lit |puts#0@@5|)))))
                      (a!5 (LitInt (INTERNAL_sub_boogie
                                     (MsgHistoryMod.MsgHistory.seqEnd
                                       (Lit |puts#0@@5|))
                                     1)))
                      (a!8 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                                  (Lit |puts#0@@5|))))))
                (let ((a!3 (and (= (type $ly@@328) LayerTypeType)
                                (= (type this@@109) DatatypeTypeType)
                                (= (type |puts#0@@5|) DatatypeTypeType)
                                (or (|MemtableMod.Memtable.ApplyPuts#canCall|
                                      this@@109
                                      (Lit |puts#0@@5|))
                                    (and ($Is this@@109
                                              Tclass.MemtableMod.Memtable)
                                         ($Is |puts#0@@5|
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         (U_2_bool a!1)
                                         a!2))))
                      (a!6 (|MemtableMod.Memtable.ApplyPuts#canCall|
                             this@@109
                             (Lit (MsgHistoryMod.MsgHistory.DiscardRecent
                                    (Lit |puts#0@@5|)
                                    a!5))))
                      (a!7 (MemtableMod.Memtable.ApplyPuts
                             ($LS $ly@@328)
                             this@@109
                             (Lit (MsgHistoryMod.MsgHistory.DiscardRecent
                                    (Lit |puts#0@@5|)
                                    a!5))))
                      (a!9 ($Unbox DatatypeTypeType
                                   (MapType0Select a!8 ($Box (int_2_U a!5))))))
                (let ((a!10 (=> (not (U_2_bool a!4))
                                (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       (Lit |puts#0@@5|))
                                     (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                                       (Lit |puts#0@@5|)
                                       a!5)
                                     a!6
                                     (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       (Lit |puts#0@@5|))
                                     (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       (Lit |puts#0@@5|))
                                     (|MemtableMod.Memtable.ApplyPut#canCall|
                                       a!7
                                       a!9))))
                      (a!11 (= (MemtableMod.Memtable.ApplyPuts
                                 ($LS $ly@@328)
                                 this@@109
                                 (Lit |puts#0@@5|))
                               (ite (MsgHistoryMod.MsgHistory.IsEmpty
                                      (Lit |puts#0@@5|))
                                    this@@109
                                    (MemtableMod.Memtable.ApplyPut a!7 a!9)))))
                  (=> a!3
                      (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                             (Lit |puts#0@@5|))
                           a!10
                           a!11)))))
                :pattern ((MemtableMod.Memtable.ApplyPuts
                            ($LS $ly@@328)
                            this@@109
                            (Lit |puts#0@@5|)))
                :weight 3
                :skolemid |2984|
                :qid |Memtableidfy.27:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($ly@@329 T@U) (this@@110 T@U) (|puts#0@@6| T@U))
             (! (let ((a!1 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF
                                            (Lit |puts#0@@6|)))))
                      (a!2 (= (LitInt (MsgHistoryMod.MsgHistory.seqStart
                                        (Lit |puts#0@@6|)))
                              (LitInt (MemtableMod.Memtable.seqEnd
                                        (Lit this@@110)))))
                      (a!4 (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty
                                            (Lit |puts#0@@6|)))))
                      (a!5 (LitInt (INTERNAL_sub_boogie
                                     (MsgHistoryMod.MsgHistory.seqEnd
                                       (Lit |puts#0@@6|))
                                     1)))
                      (a!8 (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs
                                                  (Lit |puts#0@@6|))))))
                (let ((a!3 (and (= (type $ly@@329) LayerTypeType)
                                (= (type this@@110) DatatypeTypeType)
                                (= (type |puts#0@@6|) DatatypeTypeType)
                                (or (|MemtableMod.Memtable.ApplyPuts#canCall|
                                      (Lit this@@110)
                                      (Lit |puts#0@@6|))
                                    (and ($Is this@@110
                                              Tclass.MemtableMod.Memtable)
                                         ($Is |puts#0@@6|
                                              Tclass.MsgHistoryMod.MsgHistory)
                                         (U_2_bool a!1)
                                         a!2))))
                      (a!6 (|MemtableMod.Memtable.ApplyPuts#canCall|
                             (Lit this@@110)
                             (Lit (MsgHistoryMod.MsgHistory.DiscardRecent
                                    (Lit |puts#0@@6|)
                                    a!5))))
                      (a!7 (MemtableMod.Memtable.ApplyPuts
                             ($LS $ly@@329)
                             (Lit this@@110)
                             (Lit (MsgHistoryMod.MsgHistory.DiscardRecent
                                    (Lit |puts#0@@6|)
                                    a!5))))
                      (a!9 ($Unbox DatatypeTypeType
                                   (MapType0Select a!8 ($Box (int_2_U a!5))))))
                (let ((a!10 (=> (not (U_2_bool a!4))
                                (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       (Lit |puts#0@@6|))
                                     (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall|
                                       (Lit |puts#0@@6|)
                                       a!5)
                                     a!6
                                     (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       (Lit |puts#0@@6|))
                                     (MsgHistoryMod.MsgHistory.MsgHistory_q
                                       (Lit |puts#0@@6|))
                                     (|MemtableMod.Memtable.ApplyPut#canCall|
                                       (Lit a!7)
                                       a!9))))
                      (a!11 (= (MemtableMod.Memtable.ApplyPuts
                                 ($LS $ly@@329)
                                 (Lit this@@110)
                                 (Lit |puts#0@@6|))
                               (ite (MsgHistoryMod.MsgHistory.IsEmpty
                                      (Lit |puts#0@@6|))
                                    this@@110
                                    (MemtableMod.Memtable.ApplyPut
                                      (Lit a!7)
                                      a!9)))))
                  (=> a!3
                      (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall|
                             (Lit |puts#0@@6|))
                           a!10
                           a!11)))))
                :pattern ((MemtableMod.Memtable.ApplyPuts
                            ($LS $ly@@329)
                            (Lit this@@110)
                            (Lit |puts#0@@6|)))
                :weight 3
                :skolemid |2985|
                :qid |Memtableidfy.27:14|))))
  (=> true a!1)))
(assert (forall ((arg0@@555 T@U) (arg1@@281 T@U))
  (! (= (type (MemtableMod.Memtable.Query arg0@@555 arg1@@281))
        DatatypeTypeType)
     :pattern ((MemtableMod.Memtable.Query arg0@@555 arg1@@281))
     :qid |funType:MemtableMod.Memtable.Query|)))
(assert (let ((a!1 (forall ((this@@111 T@U) (|key#0@@52| T@U))
             (! (let ((a!1 (and (= (type this@@111) DatatypeTypeType)
                                (= (type |key#0@@52|) (SeqType BoxType))
                                (or (|MemtableMod.Memtable.Query#canCall|
                                      this@@111
                                      |key#0@@52|)
                                    (and ($Is this@@111
                                              Tclass.MemtableMod.Memtable)
                                         ($Is |key#0@@52| Tclass.KeyType.Key))))))
                  (=> a!1
                      ($Is (MemtableMod.Memtable.Query this@@111 |key#0@@52|)
                           Tclass.ValueMessage.Message)))
                :pattern ((MemtableMod.Memtable.Query this@@111 |key#0@@52|))
                :skolemid |2986|
                :qid |Memtableidfy.36:14|))))
  (=> true a!1)))
(assert (forall ((this@@112 T@U) (|key#0@@53| T@U))
  (! (=> (and (= (type this@@112) DatatypeTypeType)
              (= (type |key#0@@53|) (SeqType BoxType))
              ($Is this@@112 Tclass.MemtableMod.Memtable)
              ($Is |key#0@@53| Tclass.KeyType.Key))
         (= (|MemtableMod.Memtable.Query#requires| this@@112 |key#0@@53|) true))
     :pattern ((|MemtableMod.Memtable.Query#requires| this@@112 |key#0@@53|))
     :skolemid |2987|
     :qid |Memtableidfy.36:14|)))
(assert (let ((a!1 (forall ((this@@113 T@U) (|key#0@@54| T@U))
             (! (let ((a!1 (and (= (type this@@113) DatatypeTypeType)
                                (= (type |key#0@@54|) (SeqType BoxType))
                                (or (|MemtableMod.Memtable.Query#canCall|
                                      this@@113
                                      |key#0@@54|)
                                    (and ($Is this@@113
                                              Tclass.MemtableMod.Memtable)
                                         ($Is |key#0@@54| Tclass.KeyType.Key)))))
                      (a!2 (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp
                                                                     this@@113))
                                                     ($Box |key#0@@54|))))
                      (a!3 ($Unbox DatatypeTypeType
                                   (MapType0Select (|Map#Elements| (MemtableMod.Memtable.mapp
                                                                     this@@113))
                                                   ($Box |key#0@@54|)))))
                (let ((a!4 (= (MemtableMod.Memtable.Query this@@113 |key#0@@54|)
                              (ite a!2
                                   a!3
                                   (|#ValueMessage.Message.Update|
                                     (Lit ValueMessage.__default.NopDelta))))))
                  (=> a!1
                      (and (MemtableMod.Memtable.Memtable_q this@@113)
                           (=> a!2 (MemtableMod.Memtable.Memtable_q this@@113))
                           (=> (not a!2)
                               |ValueMessage.__default.NopDelta#canCall|)
                           a!4))))
                :pattern ((MemtableMod.Memtable.Query this@@113 |key#0@@54|))
                :skolemid |2988|
                :qid |Memtableidfy.36:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@114 T@U) (|key#0@@55| T@U))
      (! (let ((a!1 (and (= (type this@@114) DatatypeTypeType)
                         (= (type |key#0@@55|) (SeqType BoxType))
                         (or (|MemtableMod.Memtable.Query#canCall|
                               (Lit this@@114)
                               (Lit |key#0@@55|))
                             (and ($Is this@@114 Tclass.MemtableMod.Memtable)
                                  ($Is |key#0@@55| Tclass.KeyType.Key)))))
               (a!2 (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp
                                                    (Lit this@@114)))
                                    ($Box |key#0@@55|)))
               (a!3 (|Map#Elements| (Lit (MemtableMod.Memtable.mapp
                                           (Lit this@@114))))))
         (let ((a!4 ($Unbox DatatypeTypeType
                            (MapType0Select a!3 ($Box (Lit |key#0@@55|))))))
         (let ((a!5 (= (MemtableMod.Memtable.Query
                         (Lit this@@114)
                         (Lit |key#0@@55|))
                       (ite (U_2_bool a!2)
                            a!4
                            (|#ValueMessage.Message.Update|
                              (Lit ValueMessage.__default.NopDelta))))))
         (let ((a!6 (and (MemtableMod.Memtable.Memtable_q (Lit this@@114))
                         (=> (U_2_bool a!2)
                             (MemtableMod.Memtable.Memtable_q (Lit this@@114)))
                         (=> (not (U_2_bool a!2))
                             |ValueMessage.__default.NopDelta#canCall|)
                         a!5)))
           (=> a!1 a!6)))))
         :pattern ((MemtableMod.Memtable.Query
                     (Lit this@@114)
                     (Lit |key#0@@55|)))
         :weight 3
         :skolemid |2989|
         :qid |Memtableidfy.36:14|))))
(assert (forall ((arg0@@556 T@U))
  (! (= (type (MemtableMod.Memtable.Drain arg0@@556)) DatatypeTypeType)
     :pattern ((MemtableMod.Memtable.Drain arg0@@556))
     :qid |funType:MemtableMod.Memtable.Drain|)))
(assert (let ((a!1 (forall ((this@@115 T@U))
             (! (=> (and (= (type this@@115) DatatypeTypeType)
                         (or (|MemtableMod.Memtable.Drain#canCall| this@@115)
                             ($Is this@@115 Tclass.MemtableMod.Memtable)))
                    ($Is (MemtableMod.Memtable.Drain this@@115)
                         Tclass.MemtableMod.Memtable))
                :pattern ((MemtableMod.Memtable.Drain this@@115))
                :skolemid |2990|
                :qid |Memtableidfy.42:14|))))
  (=> true a!1)))
(assert (forall ((this@@116 T@U))
  (! (=> (and (= (type this@@116) DatatypeTypeType)
              ($Is this@@116 Tclass.MemtableMod.Memtable))
         (= (|MemtableMod.Memtable.Drain#requires| this@@116) true))
     :pattern ((|MemtableMod.Memtable.Drain#requires| this@@116))
     :skolemid |2991|
     :qid |Memtableidfy.42:14|)))
(assert (forall ((arg0@@557 Int))
  (! (= (type (MemtableMod.__default.EmptyMemtable arg0@@557)) DatatypeTypeType)
     :pattern ((MemtableMod.__default.EmptyMemtable arg0@@557))
     :qid |funType:MemtableMod.__default.EmptyMemtable|)))
(assert (let ((a!1 (forall ((this@@117 T@U))
             (! (let ((a!1 (and (MemtableMod.Memtable.Memtable_q this@@117)
                                (|MemtableMod.__default.EmptyMemtable#canCall|
                                  (MemtableMod.Memtable.seqEnd this@@117))
                                (= (MemtableMod.Memtable.Drain this@@117)
                                   (MemtableMod.__default.EmptyMemtable
                                     (MemtableMod.Memtable.seqEnd this@@117))))))
                  (=> (and (= (type this@@117) DatatypeTypeType)
                           (or (|MemtableMod.Memtable.Drain#canCall| this@@117)
                               ($Is this@@117 Tclass.MemtableMod.Memtable)))
                      a!1))
                :pattern ((MemtableMod.Memtable.Drain this@@117))
                :skolemid |2992|
                :qid |Memtableidfy.42:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@118 T@U))
      (! (let ((a!1 (and (= (type this@@118) DatatypeTypeType)
                         (or (|MemtableMod.Memtable.Drain#canCall|
                               (Lit this@@118))
                             ($Is this@@118 Tclass.MemtableMod.Memtable))))
               (a!2 (|MemtableMod.__default.EmptyMemtable#canCall|
                      (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@118)))))
               (a!3 (MemtableMod.__default.EmptyMemtable
                      (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@118))))))
         (let ((a!4 (and (MemtableMod.Memtable.Memtable_q (Lit this@@118))
                         a!2
                         (= (MemtableMod.Memtable.Drain (Lit this@@118))
                            (Lit a!3)))))
           (=> a!1 a!4)))
         :pattern ((MemtableMod.Memtable.Drain (Lit this@@118)))
         :weight 3
         :skolemid |2993|
         :qid |Memtableidfy.42:14|))))
(assert (let ((a!1 (forall ((this@@119 T@U))
             (! (=> (and (= (type this@@119) DatatypeTypeType)
                         (or (|MemtableMod.Memtable.IsEmpty#canCall| this@@119)
                             ($Is this@@119 Tclass.MemtableMod.Memtable)))
                    true)
                :pattern ((MemtableMod.Memtable.IsEmpty this@@119))
                :skolemid |2994|
                :qid |Memtableidfy.47:15|))))
  (=> true a!1)))
(assert (forall ((this@@120 T@U))
  (! (=> (and (= (type this@@120) DatatypeTypeType)
              ($Is this@@120 Tclass.MemtableMod.Memtable))
         (= (|MemtableMod.Memtable.IsEmpty#requires| this@@120) true))
     :pattern ((|MemtableMod.Memtable.IsEmpty#requires| this@@120))
     :skolemid |2995|
     :qid |Memtableidfy.47:15|)))
(assert (let ((a!1 (forall ((this@@121 T@U))
             (! (let ((a!1 (= (MemtableMod.Memtable.IsEmpty this@@121)
                              (|Set#Equal| (|Map#Domain| (MemtableMod.Memtable.mapp
                                                           this@@121))
                                           (|Set#Empty| BoxType)))))
                  (=> (and (= (type this@@121) DatatypeTypeType)
                           (or (|MemtableMod.Memtable.IsEmpty#canCall|
                                 this@@121)
                               ($Is this@@121 Tclass.MemtableMod.Memtable)))
                      (and (MemtableMod.Memtable.Memtable_q this@@121) a!1)))
                :pattern ((MemtableMod.Memtable.IsEmpty this@@121))
                :skolemid |2996|
                :qid |Memtableidfy.47:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@122 T@U))
      (! (let ((a!1 (and (= (type this@@122) DatatypeTypeType)
                         (or (|MemtableMod.Memtable.IsEmpty#canCall|
                               (Lit this@@122))
                             ($Is this@@122 Tclass.MemtableMod.Memtable))))
               (a!2 (|Map#Domain| (Lit (MemtableMod.Memtable.mapp
                                         (Lit this@@122))))))
         (let ((a!3 (and (MemtableMod.Memtable.Memtable_q (Lit this@@122))
                         (= (MemtableMod.Memtable.IsEmpty (Lit this@@122))
                            (|Set#Equal| a!2 (|Set#Empty| BoxType))))))
           (=> a!1 a!3)))
         :pattern ((MemtableMod.Memtable.IsEmpty (Lit this@@122)))
         :weight 3
         :skolemid |2997|
         :qid |Memtableidfy.47:15|))))
(assert (= (type Tclass.MemtableMod.__default) TyType))
(assert (= (Tag Tclass.MemtableMod.__default) Tagclass.MemtableMod.__default))
(assert (= (TagFamily Tclass.MemtableMod.__default) tytagFamily$_default))
(assert (forall ((bx@@161 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@161)) bx@@161)
                     ($Is ($Unbox refType bx@@161) Tclass.MemtableMod.__default))))
       (=> (and (= (type bx@@161) BoxType)
                ($IsBox bx@@161 Tclass.MemtableMod.__default))
           a!1))
     :pattern (($IsBox bx@@161 Tclass.MemtableMod.__default))
     :skolemid |2998|
     :qid |unknown.0:0|)))
(assert (forall (($o@@49 T@U))
  (! (let ((a!1 (= ($Is $o@@49 Tclass.MemtableMod.__default)
                   (or (= $o@@49 null)
                       (= (dtype $o@@49) Tclass.MemtableMod.__default)))))
       (=> (= (type $o@@49) refType) a!1))
     :pattern (($Is $o@@49 Tclass.MemtableMod.__default))
     :skolemid |2999|
     :qid |unknown.0:0|)))
(assert (forall (($o@@50 T@U) ($h@@109 T@U))
  (! (let ((a!1 (or (= $o@@50 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@109 $o@@50)
                                              alloc)))))
       (=> (and (= (type $o@@50) refType)
                (= (type $h@@109) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@50 Tclass.MemtableMod.__default $h@@109) a!1)))
     :pattern (($IsAlloc $o@@50 Tclass.MemtableMod.__default $h@@109))
     :skolemid |3000|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((|lsn#0@@36| Int))
             (! (=> (or (|MemtableMod.__default.EmptyMemtable#canCall|
                          |lsn#0@@36|)
                        (INTERNAL_le_boogie 0 |lsn#0@@36|))
                    ($Is (MemtableMod.__default.EmptyMemtable |lsn#0@@36|)
                         Tclass.MemtableMod.Memtable))
                :pattern ((MemtableMod.__default.EmptyMemtable |lsn#0@@36|))
                :skolemid |3001|
                :qid |Memtableidfy.53:26|))))
  (=> true a!1)))
(assert (forall ((|lsn#0@@37| Int))
  (! (=> (INTERNAL_le_boogie 0 |lsn#0@@37|)
         (= (|MemtableMod.__default.EmptyMemtable#requires| |lsn#0@@37|) true))
     :pattern ((|MemtableMod.__default.EmptyMemtable#requires| |lsn#0@@37|))
     :skolemid |3002|
     :qid |Memtableidfy.53:26|)))
(assert (let ((a!1 (forall ((|lsn#0@@38| Int))
             (! (let ((a!1 (= (MemtableMod.__default.EmptyMemtable |lsn#0@@38|)
                              (|#MemtableMod.Memtable.Memtable|
                                (Lit (|Map#Empty| BoxType BoxType))
                                |lsn#0@@38|))))
                  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall|
                            |lsn#0@@38|)
                          (INTERNAL_le_boogie 0 |lsn#0@@38|))
                      a!1))
                :pattern ((MemtableMod.__default.EmptyMemtable |lsn#0@@38|))
                :skolemid |3003|
                :qid |Memtableidfy.53:26|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|lsn#0@@39| Int))
             (! (let ((a!1 (Lit (|#MemtableMod.Memtable.Memtable|
                                  (Lit (|Map#Empty| BoxType BoxType))
                                  (LitInt |lsn#0@@39|)))))
                  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall|
                            (LitInt |lsn#0@@39|))
                          (INTERNAL_le_boogie 0 |lsn#0@@39|))
                      (= (MemtableMod.__default.EmptyMemtable
                           (LitInt |lsn#0@@39|))
                         a!1)))
                :pattern ((MemtableMod.__default.EmptyMemtable
                            (LitInt |lsn#0@@39|)))
                :weight 3
                :skolemid |3004|
                :qid |Memtableidfy.53:26|))))
  (=> true a!1)))
(assert (forall ((arg0@@558 Int) (arg1@@282 T@U) (arg2@@160 T@U))
  (! (= (type (|#PagedBetree.TransitionLabel.QueryLabel|
                arg0@@558
                arg1@@282
                arg2@@160))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.TransitionLabel.QueryLabel|
                 arg0@@558
                 arg1@@282
                 arg2@@160))
     :qid |funType:#PagedBetree.TransitionLabel.QueryLabel|)))
(assert (forall ((|a#0#0#0@@6| Int) (|a#0#1#0@@3| T@U) (|a#0#2#0| T@U))
  (! (=> (and (= (type |a#0#1#0@@3|) (SeqType BoxType))
              (= (type |a#0#2#0|) (SeqType BoxType)))
         (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.QueryLabel|
                              |a#0#0#0@@6|
                              |a#0#1#0@@3|
                              |a#0#2#0|))
            |##PagedBetree.TransitionLabel.QueryLabel|))
     :pattern ((|#PagedBetree.TransitionLabel.QueryLabel|
                 |a#0#0#0@@6|
                 |a#0#1#0@@3|
                 |a#0#2#0|))
     :skolemid |3005|
     :qid |PagedBetreeidfy.42:18|)))
(assert (forall ((d@@73 T@U))
  (! (=> (= (type d@@73) DatatypeTypeType)
         (= (PagedBetree.TransitionLabel.QueryLabel_q d@@73)
            (= (DatatypeCtorId d@@73)
               |##PagedBetree.TransitionLabel.QueryLabel|)))
     :pattern ((PagedBetree.TransitionLabel.QueryLabel_q d@@73))
     :skolemid |3006|
     :qid |unknown.0:0|)))
(assert (forall ((d@@74 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@6| Int) (|a#1#1#0@@3| T@U) (|a#1#2#0| T@U))
                  (! (and (= (type |a#1#1#0@@3|) (SeqType BoxType))
                          (= (type |a#1#2#0|) (SeqType BoxType))
                          (= d@@74
                             (|#PagedBetree.TransitionLabel.QueryLabel|
                               |a#1#0#0@@6|
                               |a#1#1#0@@3|
                               |a#1#2#0|)))
                     :no-pattern (type |a#1#1#0@@3|)
                     :no-pattern (type |a#1#2#0|)
                     :no-pattern (U_2_int |a#1#1#0@@3|)
                     :no-pattern (U_2_bool |a#1#1#0@@3|)
                     :no-pattern (U_2_int |a#1#2#0|)
                     :no-pattern (U_2_bool |a#1#2#0|)
                     :skolemid |3007|
                     :qid |PagedBetreeidfy.42:18|))))
       (=> (and (= (type d@@74) DatatypeTypeType)
                (PagedBetree.TransitionLabel.QueryLabel_q d@@74))
           a!1))
     :pattern ((PagedBetree.TransitionLabel.QueryLabel_q d@@74))
     :skolemid |3008|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@6| Int) (|a#2#1#0@@3| T@U) (|a#2#2#0| T@U))
  (! (let ((a!1 (= ($Is (|#PagedBetree.TransitionLabel.QueryLabel|
                          |a#2#0#0@@6|
                          |a#2#1#0@@3|
                          |a#2#2#0|)
                        Tclass.PagedBetree.TransitionLabel)
                   (and ($Is (int_2_U |a#2#0#0@@6|) Tclass._System.nat)
                        ($Is |a#2#1#0@@3| Tclass.KeyType.Key)
                        ($Is |a#2#2#0| Tclass.ValueType.Value)))))
       (=> (and (= (type |a#2#1#0@@3|) (SeqType BoxType))
                (= (type |a#2#2#0|) (SeqType BoxType)))
           a!1))
     :pattern (($Is (|#PagedBetree.TransitionLabel.QueryLabel|
                      |a#2#0#0@@6|
                      |a#2#1#0@@3|
                      |a#2#2#0|)
                    Tclass.PagedBetree.TransitionLabel))
     :skolemid |3009|
     :qid |PagedBetreeidfy.42:18|)))
(assert (forall ((|a#3#0#0@@6| Int) (|a#3#1#0@@3| T@U) (|a#3#2#0| T@U) ($h@@110 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#PagedBetree.TransitionLabel.QueryLabel|
                               |a#3#0#0@@6|
                               |a#3#1#0@@3|
                               |a#3#2#0|)
                             Tclass.PagedBetree.TransitionLabel
                             $h@@110)
                   (and ($IsAlloc (int_2_U |a#3#0#0@@6|)
                                  Tclass._System.nat
                                  $h@@110)
                        ($IsAlloc |a#3#1#0@@3| Tclass.KeyType.Key $h@@110)
                        ($IsAlloc |a#3#2#0| Tclass.ValueType.Value $h@@110)))))
       (=> (and (= (type |a#3#1#0@@3|) (SeqType BoxType))
                (= (type |a#3#2#0|) (SeqType BoxType))
                (= (type $h@@110) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@110))
           a!1))
     :pattern (($IsAlloc (|#PagedBetree.TransitionLabel.QueryLabel|
                           |a#3#0#0@@6|
                           |a#3#1#0@@3|
                           |a#3#2#0|)
                         Tclass.PagedBetree.TransitionLabel
                         $h@@110))
     :skolemid |3010|
     :qid |PagedBetreeidfy.42:18|)))
(assert (forall ((d@@75 T@U) ($h@@111 T@U))
  (! (=> (and (= (type d@@75) DatatypeTypeType)
              (= (type $h@@111) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@111)
              (PagedBetree.TransitionLabel.QueryLabel_q d@@75)
              ($IsAlloc d@@75 Tclass.PagedBetree.TransitionLabel $h@@111))
         ($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@75))
                   Tclass._System.nat
                   $h@@111))
     :pattern (($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@75))
                         Tclass._System.nat
                         $h@@111))
     :skolemid |3011|
     :qid |unknown.0:0|)))
(assert (forall ((d@@76 T@U) ($h@@112 T@U))
  (! (=> (and (= (type d@@76) DatatypeTypeType)
              (= (type $h@@112) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@112)
              (PagedBetree.TransitionLabel.QueryLabel_q d@@76)
              ($IsAlloc d@@76 Tclass.PagedBetree.TransitionLabel $h@@112))
         ($IsAlloc (PagedBetree.TransitionLabel.key d@@76)
                   Tclass.KeyType.Key
                   $h@@112))
     :pattern (($IsAlloc (PagedBetree.TransitionLabel.key d@@76)
                         Tclass.KeyType.Key
                         $h@@112))
     :skolemid |3012|
     :qid |unknown.0:0|)))
(assert (forall ((d@@77 T@U) ($h@@113 T@U))
  (! (=> (and (= (type d@@77) DatatypeTypeType)
              (= (type $h@@113) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@113)
              (PagedBetree.TransitionLabel.QueryLabel_q d@@77)
              ($IsAlloc d@@77 Tclass.PagedBetree.TransitionLabel $h@@113))
         ($IsAlloc (PagedBetree.TransitionLabel.value d@@77)
                   Tclass.ValueType.Value
                   $h@@113))
     :pattern (($IsAlloc (PagedBetree.TransitionLabel.value d@@77)
                         Tclass.ValueType.Value
                         $h@@113))
     :skolemid |3013|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@6| Int) (|a#4#1#0@@3| T@U) (|a#4#2#0| T@U))
  (! (=> (and (= (type |a#4#1#0@@3|) (SeqType BoxType))
              (= (type |a#4#2#0|) (SeqType BoxType)))
         (= (|#PagedBetree.TransitionLabel.QueryLabel|
              (LitInt |a#4#0#0@@6|)
              (Lit |a#4#1#0@@3|)
              (Lit |a#4#2#0|))
            (Lit (|#PagedBetree.TransitionLabel.QueryLabel|
                   |a#4#0#0@@6|
                   |a#4#1#0@@3|
                   |a#4#2#0|))))
     :pattern ((|#PagedBetree.TransitionLabel.QueryLabel|
                 (LitInt |a#4#0#0@@6|)
                 (Lit |a#4#1#0@@3|)
                 (Lit |a#4#2#0|)))
     :skolemid |3014|
     :qid |PagedBetreeidfy.42:18|)))
(assert (forall ((|a#5#0#0@@7| Int) (|a#5#1#0@@3| T@U) (|a#5#2#0| T@U))
  (! (=> (and (= (type |a#5#1#0@@3|) (SeqType BoxType))
              (= (type |a#5#2#0|) (SeqType BoxType)))
         (= (PagedBetree.TransitionLabel.endLsn
              (|#PagedBetree.TransitionLabel.QueryLabel|
                |a#5#0#0@@7|
                |a#5#1#0@@3|
                |a#5#2#0|))
            |a#5#0#0@@7|))
     :pattern ((|#PagedBetree.TransitionLabel.QueryLabel|
                 |a#5#0#0@@7|
                 |a#5#1#0@@3|
                 |a#5#2#0|))
     :skolemid |3015|
     :qid |PagedBetreeidfy.42:18|)))
(assert (forall ((|a#6#0#0@@7| Int) (|a#6#1#0@@3| T@U) (|a#6#2#0| T@U))
  (! (=> (and (= (type |a#6#1#0@@3|) (SeqType BoxType))
              (= (type |a#6#2#0|) (SeqType BoxType)))
         (= (PagedBetree.TransitionLabel.key
              (|#PagedBetree.TransitionLabel.QueryLabel|
                |a#6#0#0@@7|
                |a#6#1#0@@3|
                |a#6#2#0|))
            |a#6#1#0@@3|))
     :pattern ((|#PagedBetree.TransitionLabel.QueryLabel|
                 |a#6#0#0@@7|
                 |a#6#1#0@@3|
                 |a#6#2#0|))
     :skolemid |3016|
     :qid |PagedBetreeidfy.42:18|)))
(assert (forall ((|a#7#0#0@@7| Int) (|a#7#1#0@@3| T@U) (|a#7#2#0| T@U))
  (! (=> (and (= (type |a#7#1#0@@3|) (SeqType BoxType))
              (= (type |a#7#2#0|) (SeqType BoxType)))
         (= (PagedBetree.TransitionLabel.value
              (|#PagedBetree.TransitionLabel.QueryLabel|
                |a#7#0#0@@7|
                |a#7#1#0@@3|
                |a#7#2#0|))
            |a#7#2#0|))
     :pattern ((|#PagedBetree.TransitionLabel.QueryLabel|
                 |a#7#0#0@@7|
                 |a#7#1#0@@3|
                 |a#7#2#0|))
     :skolemid |3017|
     :qid |PagedBetreeidfy.42:18|)))
(assert (forall ((arg0@@559 T@U))
  (! (= (type (|#PagedBetree.TransitionLabel.PutLabel| arg0@@559))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.TransitionLabel.PutLabel| arg0@@559))
     :qid |funType:#PagedBetree.TransitionLabel.PutLabel|)))
(assert (forall ((|a#8#0#0@@4| T@U))
  (! (=> (= (type |a#8#0#0@@4|) DatatypeTypeType)
         (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.PutLabel|
                              |a#8#0#0@@4|))
            |##PagedBetree.TransitionLabel.PutLabel|))
     :pattern ((|#PagedBetree.TransitionLabel.PutLabel| |a#8#0#0@@4|))
     :skolemid |3018|
     :qid |PagedBetreeidfy.43:16|)))
(assert (forall ((d@@78 T@U))
  (! (=> (= (type d@@78) DatatypeTypeType)
         (= (PagedBetree.TransitionLabel.PutLabel_q d@@78)
            (= (DatatypeCtorId d@@78) |##PagedBetree.TransitionLabel.PutLabel|)))
     :pattern ((PagedBetree.TransitionLabel.PutLabel_q d@@78))
     :skolemid |3019|
     :qid |unknown.0:0|)))
(assert (forall ((d@@79 T@U))
  (! (let ((a!1 (exists ((|a#9#0#0@@2| T@U))
                  (! (and (= (type |a#9#0#0@@2|) DatatypeTypeType)
                          (= d@@79
                             (|#PagedBetree.TransitionLabel.PutLabel|
                               |a#9#0#0@@2|)))
                     :no-pattern (type |a#9#0#0@@2|)
                     :no-pattern (U_2_int |a#9#0#0@@2|)
                     :no-pattern (U_2_bool |a#9#0#0@@2|)
                     :skolemid |3020|
                     :qid |PagedBetreeidfy.43:16|))))
       (=> (and (= (type d@@79) DatatypeTypeType)
                (PagedBetree.TransitionLabel.PutLabel_q d@@79))
           a!1))
     :pattern ((PagedBetree.TransitionLabel.PutLabel_q d@@79))
     :skolemid |3021|
     :qid |unknown.0:0|)))
(assert (forall ((|a#10#0#0@@2| T@U))
  (! (=> (= (type |a#10#0#0@@2|) DatatypeTypeType)
         (= ($Is (|#PagedBetree.TransitionLabel.PutLabel| |a#10#0#0@@2|)
                 Tclass.PagedBetree.TransitionLabel)
            ($Is |a#10#0#0@@2| Tclass.MsgHistoryMod.MsgHistory)))
     :pattern (($Is (|#PagedBetree.TransitionLabel.PutLabel| |a#10#0#0@@2|)
                    Tclass.PagedBetree.TransitionLabel))
     :skolemid |3022|
     :qid |PagedBetreeidfy.43:16|)))
(assert (forall ((|a#11#0#0@@2| T@U) ($h@@114 T@U))
  (! (=> (and (= (type |a#11#0#0@@2|) DatatypeTypeType)
              (= (type $h@@114) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@114))
         (= ($IsAlloc (|#PagedBetree.TransitionLabel.PutLabel| |a#11#0#0@@2|)
                      Tclass.PagedBetree.TransitionLabel
                      $h@@114)
            ($IsAlloc |a#11#0#0@@2| Tclass.MsgHistoryMod.MsgHistory $h@@114)))
     :pattern (($IsAlloc (|#PagedBetree.TransitionLabel.PutLabel| |a#11#0#0@@2|)
                         Tclass.PagedBetree.TransitionLabel
                         $h@@114))
     :skolemid |3023|
     :qid |PagedBetreeidfy.43:16|)))
(assert (forall ((d@@80 T@U) ($h@@115 T@U))
  (! (=> (and (= (type d@@80) DatatypeTypeType)
              (= (type $h@@115) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@115)
              (PagedBetree.TransitionLabel.PutLabel_q d@@80)
              ($IsAlloc d@@80 Tclass.PagedBetree.TransitionLabel $h@@115))
         ($IsAlloc (PagedBetree.TransitionLabel.puts d@@80)
                   Tclass.MsgHistoryMod.MsgHistory
                   $h@@115))
     :pattern (($IsAlloc (PagedBetree.TransitionLabel.puts d@@80)
                         Tclass.MsgHistoryMod.MsgHistory
                         $h@@115))
     :skolemid |3024|
     :qid |unknown.0:0|)))
(assert (forall ((|a#12#0#0@@1| T@U))
  (! (=> (= (type |a#12#0#0@@1|) DatatypeTypeType)
         (= (|#PagedBetree.TransitionLabel.PutLabel| (Lit |a#12#0#0@@1|))
            (Lit (|#PagedBetree.TransitionLabel.PutLabel| |a#12#0#0@@1|))))
     :pattern ((|#PagedBetree.TransitionLabel.PutLabel| (Lit |a#12#0#0@@1|)))
     :skolemid |3025|
     :qid |PagedBetreeidfy.43:16|)))
(assert (forall ((|a#13#0#0@@0| T@U))
  (! (=> (= (type |a#13#0#0@@0|) DatatypeTypeType)
         (= (PagedBetree.TransitionLabel.puts
              (|#PagedBetree.TransitionLabel.PutLabel| |a#13#0#0@@0|))
            |a#13#0#0@@0|))
     :pattern ((|#PagedBetree.TransitionLabel.PutLabel| |a#13#0#0@@0|))
     :skolemid |3026|
     :qid |PagedBetreeidfy.43:16|)))
(assert (forall ((|a#14#0#0@@1| T@U))
  (! (=> (= (type |a#14#0#0@@1|) DatatypeTypeType)
         (< (DtRank |a#14#0#0@@1|)
            (DtRank (|#PagedBetree.TransitionLabel.PutLabel| |a#14#0#0@@1|))))
     :pattern ((|#PagedBetree.TransitionLabel.PutLabel| |a#14#0#0@@1|))
     :skolemid |3027|
     :qid |PagedBetreeidfy.43:16|)))
(assert (forall ((arg0@@560 Int))
  (! (= (type (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| arg0@@560))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.TransitionLabel.QueryEndLsnLabel| arg0@@560))
     :qid |funType:#PagedBetree.TransitionLabel.QueryEndLsnLabel|)))
(assert (forall ((|a#15#0#0@@1| Int))
  (! (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.QueryEndLsnLabel|
                          |a#15#0#0@@1|))
        |##PagedBetree.TransitionLabel.QueryEndLsnLabel|)
     :pattern ((|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#15#0#0@@1|))
     :skolemid |3028|
     :qid |PagedBetreeidfy.44:24|)))
(assert (forall ((d@@81 T@U))
  (! (=> (= (type d@@81) DatatypeTypeType)
         (= (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@81)
            (= (DatatypeCtorId d@@81)
               |##PagedBetree.TransitionLabel.QueryEndLsnLabel|)))
     :pattern ((PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@81))
     :skolemid |3029|
     :qid |unknown.0:0|)))
(assert (forall ((d@@82 T@U))
  (! (=> (and (= (type d@@82) DatatypeTypeType)
              (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@82))
         (exists ((|a#16#0#0@@1| Int))
           (! (= d@@82
                 (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#16#0#0@@1|))
              :skolemid |3030|
              :qid |PagedBetreeidfy.44:24|)))
     :pattern ((PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@82))
     :skolemid |3031|
     :qid |unknown.0:0|)))
(assert (forall ((|a#17#0#0@@1| Int))
  (! (= ($Is (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#17#0#0@@1|)
             Tclass.PagedBetree.TransitionLabel)
        ($Is (int_2_U |a#17#0#0@@1|) Tclass._System.nat))
     :pattern (($Is (|#PagedBetree.TransitionLabel.QueryEndLsnLabel|
                      |a#17#0#0@@1|)
                    Tclass.PagedBetree.TransitionLabel))
     :skolemid |3032|
     :qid |PagedBetreeidfy.44:24|)))
(assert (forall ((|a#18#0#0@@0| Int) ($h@@116 T@U))
  (! (=> (and (= (type $h@@116) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@116))
         (= ($IsAlloc (|#PagedBetree.TransitionLabel.QueryEndLsnLabel|
                        |a#18#0#0@@0|)
                      Tclass.PagedBetree.TransitionLabel
                      $h@@116)
            ($IsAlloc (int_2_U |a#18#0#0@@0|) Tclass._System.nat $h@@116)))
     :pattern (($IsAlloc (|#PagedBetree.TransitionLabel.QueryEndLsnLabel|
                           |a#18#0#0@@0|)
                         Tclass.PagedBetree.TransitionLabel
                         $h@@116))
     :skolemid |3033|
     :qid |PagedBetreeidfy.44:24|)))
(assert (forall ((d@@83 T@U) ($h@@117 T@U))
  (! (=> (and (= (type d@@83) DatatypeTypeType)
              (= (type $h@@117) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@117)
              (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@83)
              ($IsAlloc d@@83 Tclass.PagedBetree.TransitionLabel $h@@117))
         ($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@83))
                   Tclass._System.nat
                   $h@@117))
     :pattern (($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@83))
                         Tclass._System.nat
                         $h@@117))
     :skolemid |3034|
     :qid |unknown.0:0|)))
(assert (forall ((|a#19#0#0@@0| Int))
  (! (= (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| (LitInt |a#19#0#0@@0|))
        (Lit (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#19#0#0@@0|)))
     :pattern ((|#PagedBetree.TransitionLabel.QueryEndLsnLabel|
                 (LitInt |a#19#0#0@@0|)))
     :skolemid |3035|
     :qid |PagedBetreeidfy.44:24|)))
(assert (forall ((|a#20#0#0@@0| Int))
  (! (= (PagedBetree.TransitionLabel.endLsn
          (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@0|))
        |a#20#0#0@@0|)
     :pattern ((|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@0|))
     :skolemid |3036|
     :qid |PagedBetreeidfy.44:24|)))
(assert (forall ((arg0@@561 T@U))
  (! (= (type (|#PagedBetree.TransitionLabel.FreezeAsLabel| arg0@@561))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.TransitionLabel.FreezeAsLabel| arg0@@561))
     :qid |funType:#PagedBetree.TransitionLabel.FreezeAsLabel|)))
(assert (forall ((|a#21#0#0@@0| T@U))
  (! (=> (= (type |a#21#0#0@@0|) DatatypeTypeType)
         (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.FreezeAsLabel|
                              |a#21#0#0@@0|))
            |##PagedBetree.TransitionLabel.FreezeAsLabel|))
     :pattern ((|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#21#0#0@@0|))
     :skolemid |3037|
     :qid |PagedBetreeidfy.45:21|)))
(assert (forall ((d@@84 T@U))
  (! (=> (= (type d@@84) DatatypeTypeType)
         (= (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@84)
            (= (DatatypeCtorId d@@84)
               |##PagedBetree.TransitionLabel.FreezeAsLabel|)))
     :pattern ((PagedBetree.TransitionLabel.FreezeAsLabel_q d@@84))
     :skolemid |3038|
     :qid |unknown.0:0|)))
(assert (forall ((d@@85 T@U))
  (! (let ((a!1 (exists ((|a#22#0#0@@0| T@U))
                  (! (and (= (type |a#22#0#0@@0|) DatatypeTypeType)
                          (= d@@85
                             (|#PagedBetree.TransitionLabel.FreezeAsLabel|
                               |a#22#0#0@@0|)))
                     :no-pattern (type |a#22#0#0@@0|)
                     :no-pattern (U_2_int |a#22#0#0@@0|)
                     :no-pattern (U_2_bool |a#22#0#0@@0|)
                     :skolemid |3039|
                     :qid |PagedBetreeidfy.45:21|))))
       (=> (and (= (type d@@85) DatatypeTypeType)
                (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@85))
           a!1))
     :pattern ((PagedBetree.TransitionLabel.FreezeAsLabel_q d@@85))
     :skolemid |3040|
     :qid |unknown.0:0|)))
(assert (forall ((|a#23#0#0| T@U))
  (! (=> (= (type |a#23#0#0|) DatatypeTypeType)
         (= ($Is (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#23#0#0|)
                 Tclass.PagedBetree.TransitionLabel)
            ($Is |a#23#0#0|
                 (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode))))
     :pattern (($Is (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#23#0#0|)
                    Tclass.PagedBetree.TransitionLabel))
     :skolemid |3041|
     :qid |PagedBetreeidfy.45:21|)))
(assert (forall ((|a#24#0#0| T@U) ($h@@118 T@U))
  (! (=> (and (= (type |a#24#0#0|) DatatypeTypeType)
              (= (type $h@@118) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@118))
         (= ($IsAlloc (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#24#0#0|)
                      Tclass.PagedBetree.TransitionLabel
                      $h@@118)
            ($IsAlloc |a#24#0#0|
                      (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)
                      $h@@118)))
     :pattern (($IsAlloc (|#PagedBetree.TransitionLabel.FreezeAsLabel|
                           |a#24#0#0|)
                         Tclass.PagedBetree.TransitionLabel
                         $h@@118))
     :skolemid |3042|
     :qid |PagedBetreeidfy.45:21|)))
(assert (forall ((d@@86 T@U) ($h@@119 T@U))
  (! (=> (and (= (type d@@86) DatatypeTypeType)
              (= (type $h@@119) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@119)
              (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@86)
              ($IsAlloc d@@86 Tclass.PagedBetree.TransitionLabel $h@@119))
         ($IsAlloc (PagedBetree.TransitionLabel.stampedBetree d@@86)
                   (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)
                   $h@@119))
     :pattern (($IsAlloc (PagedBetree.TransitionLabel.stampedBetree d@@86)
                         (Tclass.StampedMod.Stamped
                           Tclass.PagedBetree.BetreeNode)
                         $h@@119))
     :skolemid |3043|
     :qid |unknown.0:0|)))
(assert (forall ((|a#25#0#0| T@U))
  (! (=> (= (type |a#25#0#0|) DatatypeTypeType)
         (= (|#PagedBetree.TransitionLabel.FreezeAsLabel| (Lit |a#25#0#0|))
            (Lit (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#25#0#0|))))
     :pattern ((|#PagedBetree.TransitionLabel.FreezeAsLabel| (Lit |a#25#0#0|)))
     :skolemid |3044|
     :qid |PagedBetreeidfy.45:21|)))
(assert (forall ((|a#26#0#0| T@U))
  (! (=> (= (type |a#26#0#0|) DatatypeTypeType)
         (= (PagedBetree.TransitionLabel.stampedBetree
              (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#26#0#0|))
            |a#26#0#0|))
     :pattern ((|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#26#0#0|))
     :skolemid |3045|
     :qid |PagedBetreeidfy.45:21|)))
(assert (forall ((|a#27#0#0| T@U))
  (! (=> (= (type |a#27#0#0|) DatatypeTypeType)
         (< (DtRank |a#27#0#0|)
            (DtRank (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#27#0#0|))))
     :pattern ((|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#27#0#0|))
     :skolemid |3046|
     :qid |PagedBetreeidfy.45:21|)))
(assert (= (type |#PagedBetree.TransitionLabel.InternalLabel|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PagedBetree.TransitionLabel.InternalLabel|)
   |##PagedBetree.TransitionLabel.InternalLabel|))
(assert (forall ((d@@87 T@U))
  (! (=> (= (type d@@87) DatatypeTypeType)
         (= (PagedBetree.TransitionLabel.InternalLabel_q d@@87)
            (= (DatatypeCtorId d@@87)
               |##PagedBetree.TransitionLabel.InternalLabel|)))
     :pattern ((PagedBetree.TransitionLabel.InternalLabel_q d@@87))
     :skolemid |3047|
     :qid |unknown.0:0|)))
(assert (forall ((d@@88 T@U))
  (! (=> (and (= (type d@@88) DatatypeTypeType)
              (PagedBetree.TransitionLabel.InternalLabel_q d@@88))
         (= d@@88 |#PagedBetree.TransitionLabel.InternalLabel|))
     :pattern ((PagedBetree.TransitionLabel.InternalLabel_q d@@88))
     :skolemid |3048|
     :qid |unknown.0:0|)))
(assert ($Is |#PagedBetree.TransitionLabel.InternalLabel|
     Tclass.PagedBetree.TransitionLabel))
(assert (forall (($h@@120 T@U))
  (! (=> (and (= (type $h@@120) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@120))
         ($IsAlloc |#PagedBetree.TransitionLabel.InternalLabel|
                   Tclass.PagedBetree.TransitionLabel
                   $h@@120))
     :pattern (($IsAlloc |#PagedBetree.TransitionLabel.InternalLabel|
                         Tclass.PagedBetree.TransitionLabel
                         $h@@120))
     :skolemid |3049|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#PagedBetree.TransitionLabel.InternalLabel|
   (Lit |#PagedBetree.TransitionLabel.InternalLabel|)))
(assert (forall ((d@@89 T@U))
  (! (=> (and (= (type d@@89) DatatypeTypeType)
              (|$IsA#PagedBetree.TransitionLabel| d@@89))
         (or (PagedBetree.TransitionLabel.QueryLabel_q d@@89)
             (PagedBetree.TransitionLabel.PutLabel_q d@@89)
             (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@89)
             (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@89)
             (PagedBetree.TransitionLabel.InternalLabel_q d@@89)))
     :pattern ((|$IsA#PagedBetree.TransitionLabel| d@@89))
     :skolemid |3050|
     :qid |unknown.0:0|)))
(assert (forall ((d@@90 T@U))
  (! (=> (and (= (type d@@90) DatatypeTypeType)
              ($Is d@@90 Tclass.PagedBetree.TransitionLabel))
         (or (PagedBetree.TransitionLabel.QueryLabel_q d@@90)
             (PagedBetree.TransitionLabel.PutLabel_q d@@90)
             (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@90)
             (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@90)
             (PagedBetree.TransitionLabel.InternalLabel_q d@@90)))
     :pattern ((PagedBetree.TransitionLabel.InternalLabel_q d@@90)
               ($Is d@@90 Tclass.PagedBetree.TransitionLabel))
     :pattern ((PagedBetree.TransitionLabel.FreezeAsLabel_q d@@90)
               ($Is d@@90 Tclass.PagedBetree.TransitionLabel))
     :pattern ((PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@90)
               ($Is d@@90 Tclass.PagedBetree.TransitionLabel))
     :pattern ((PagedBetree.TransitionLabel.PutLabel_q d@@90)
               ($Is d@@90 Tclass.PagedBetree.TransitionLabel))
     :pattern ((PagedBetree.TransitionLabel.QueryLabel_q d@@90)
               ($Is d@@90 Tclass.PagedBetree.TransitionLabel))
     :skolemid |3051|
     :qid |unknown.0:0|)))
(assert (forall ((a@@138 T@U) (b@@88 T@U))
  (! (let ((a!1 (= (|PagedBetree.TransitionLabel#Equal| a@@138 b@@88)
                   (and (= (PagedBetree.TransitionLabel.endLsn a@@138)
                           (PagedBetree.TransitionLabel.endLsn b@@88))
                        (|Seq#Equal| (PagedBetree.TransitionLabel.key a@@138)
                                     (PagedBetree.TransitionLabel.key b@@88))
                        (|Seq#Equal| (PagedBetree.TransitionLabel.value a@@138)
                                     (PagedBetree.TransitionLabel.value b@@88))))))
       (=> (and (= (type a@@138) DatatypeTypeType)
                (= (type b@@88) DatatypeTypeType)
                (PagedBetree.TransitionLabel.QueryLabel_q a@@138)
                (PagedBetree.TransitionLabel.QueryLabel_q b@@88))
           a!1))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@138 b@@88)
               (PagedBetree.TransitionLabel.QueryLabel_q a@@138))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@138 b@@88)
               (PagedBetree.TransitionLabel.QueryLabel_q b@@88))
     :skolemid |3052|
     :qid |unknown.0:0|)))
(assert (forall ((a@@139 T@U) (b@@89 T@U))
  (! (=> (and (= (type a@@139) DatatypeTypeType)
              (= (type b@@89) DatatypeTypeType)
              (PagedBetree.TransitionLabel.PutLabel_q a@@139)
              (PagedBetree.TransitionLabel.PutLabel_q b@@89))
         (= (|PagedBetree.TransitionLabel#Equal| a@@139 b@@89)
            (|MsgHistoryMod.MsgHistory#Equal|
              (PagedBetree.TransitionLabel.puts a@@139)
              (PagedBetree.TransitionLabel.puts b@@89))))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@139 b@@89)
               (PagedBetree.TransitionLabel.PutLabel_q a@@139))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@139 b@@89)
               (PagedBetree.TransitionLabel.PutLabel_q b@@89))
     :skolemid |3053|
     :qid |unknown.0:0|)))
(assert (forall ((a@@140 T@U) (b@@90 T@U))
  (! (=> (and (= (type a@@140) DatatypeTypeType)
              (= (type b@@90) DatatypeTypeType)
              (PagedBetree.TransitionLabel.QueryEndLsnLabel_q a@@140)
              (PagedBetree.TransitionLabel.QueryEndLsnLabel_q b@@90))
         (= (|PagedBetree.TransitionLabel#Equal| a@@140 b@@90)
            (= (PagedBetree.TransitionLabel.endLsn a@@140)
               (PagedBetree.TransitionLabel.endLsn b@@90))))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@140 b@@90)
               (PagedBetree.TransitionLabel.QueryEndLsnLabel_q a@@140))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@140 b@@90)
               (PagedBetree.TransitionLabel.QueryEndLsnLabel_q b@@90))
     :skolemid |3054|
     :qid |unknown.0:0|)))
(assert (forall ((a@@141 T@U) (b@@91 T@U))
  (! (=> (and (= (type a@@141) DatatypeTypeType)
              (= (type b@@91) DatatypeTypeType)
              (PagedBetree.TransitionLabel.FreezeAsLabel_q a@@141)
              (PagedBetree.TransitionLabel.FreezeAsLabel_q b@@91))
         (= (|PagedBetree.TransitionLabel#Equal| a@@141 b@@91)
            (|StampedMod.Stamped#Equal|
              (PagedBetree.TransitionLabel.stampedBetree a@@141)
              (PagedBetree.TransitionLabel.stampedBetree b@@91))))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@141 b@@91)
               (PagedBetree.TransitionLabel.FreezeAsLabel_q a@@141))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@141 b@@91)
               (PagedBetree.TransitionLabel.FreezeAsLabel_q b@@91))
     :skolemid |3055|
     :qid |unknown.0:0|)))
(assert (forall ((a@@142 T@U) (b@@92 T@U))
  (! (=> (and (= (type a@@142) DatatypeTypeType)
              (= (type b@@92) DatatypeTypeType)
              (PagedBetree.TransitionLabel.InternalLabel_q a@@142)
              (PagedBetree.TransitionLabel.InternalLabel_q b@@92))
         (= (|PagedBetree.TransitionLabel#Equal| a@@142 b@@92) true))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@142 b@@92)
               (PagedBetree.TransitionLabel.InternalLabel_q a@@142))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@142 b@@92)
               (PagedBetree.TransitionLabel.InternalLabel_q b@@92))
     :skolemid |3056|
     :qid |unknown.0:0|)))
(assert (forall ((a@@143 T@U) (b@@93 T@U))
  (! (=> (and (= (type a@@143) DatatypeTypeType)
              (= (type b@@93) DatatypeTypeType))
         (= (|PagedBetree.TransitionLabel#Equal| a@@143 b@@93) (= a@@143 b@@93)))
     :pattern ((|PagedBetree.TransitionLabel#Equal| a@@143 b@@93))
     :skolemid |3057|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@562 T@U))
  (! (= (type (|#PagedBetree.ChildMap.ChildMap| arg0@@562)) DatatypeTypeType)
     :pattern ((|#PagedBetree.ChildMap.ChildMap| arg0@@562))
     :qid |funType:#PagedBetree.ChildMap.ChildMap|)))
(assert (forall ((|a#33#0#0| T@U))
  (! (=> (= (type |a#33#0#0|) (IMapType BoxType BoxType))
         (= (DatatypeCtorId (|#PagedBetree.ChildMap.ChildMap| |a#33#0#0|))
            |##PagedBetree.ChildMap.ChildMap|))
     :pattern ((|#PagedBetree.ChildMap.ChildMap| |a#33#0#0|))
     :skolemid |3058|
     :qid |PagedBetreeidfy.48:32|)))
(assert (forall ((d@@91 T@U))
  (! (=> (= (type d@@91) DatatypeTypeType)
         (= (PagedBetree.ChildMap.ChildMap_q d@@91)
            (= (DatatypeCtorId d@@91) |##PagedBetree.ChildMap.ChildMap|)))
     :pattern ((PagedBetree.ChildMap.ChildMap_q d@@91))
     :skolemid |3059|
     :qid |unknown.0:0|)))
(assert (forall ((d@@92 T@U))
  (! (let ((a!1 (exists ((|a#34#0#0| T@U))
                  (! (and (= (type |a#34#0#0|) (IMapType BoxType BoxType))
                          (= d@@92
                             (|#PagedBetree.ChildMap.ChildMap| |a#34#0#0|)))
                     :no-pattern (type |a#34#0#0|)
                     :no-pattern (U_2_int |a#34#0#0|)
                     :no-pattern (U_2_bool |a#34#0#0|)
                     :skolemid |3060|
                     :qid |PagedBetreeidfy.48:32|))))
       (=> (and (= (type d@@92) DatatypeTypeType)
                (PagedBetree.ChildMap.ChildMap_q d@@92))
           a!1))
     :pattern ((PagedBetree.ChildMap.ChildMap_q d@@92))
     :skolemid |3061|
     :qid |unknown.0:0|)))
(assert (forall ((|a#35#0#0| T@U))
  (! (=> (= (type |a#35#0#0|) (IMapType BoxType BoxType))
         (= ($Is (|#PagedBetree.ChildMap.ChildMap| |a#35#0#0|)
                 Tclass.PagedBetree.ChildMap)
            ($Is |a#35#0#0|
                 (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))
     :pattern (($Is (|#PagedBetree.ChildMap.ChildMap| |a#35#0#0|)
                    Tclass.PagedBetree.ChildMap))
     :skolemid |3062|
     :qid |PagedBetreeidfy.48:32|)))
(assert (forall ((|a#36#0#0| T@U) ($h@@121 T@U))
  (! (=> (and (= (type |a#36#0#0|) (IMapType BoxType BoxType))
              (= (type $h@@121) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@121))
         (= ($IsAlloc (|#PagedBetree.ChildMap.ChildMap| |a#36#0#0|)
                      Tclass.PagedBetree.ChildMap
                      $h@@121)
            ($IsAlloc |a#36#0#0|
                      (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)
                      $h@@121)))
     :pattern (($IsAlloc (|#PagedBetree.ChildMap.ChildMap| |a#36#0#0|)
                         Tclass.PagedBetree.ChildMap
                         $h@@121))
     :skolemid |3063|
     :qid |PagedBetreeidfy.48:32|)))
(assert (forall ((d@@93 T@U) ($h@@122 T@U))
  (! (=> (and (= (type d@@93) DatatypeTypeType)
              (= (type $h@@122) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@122)
              (PagedBetree.ChildMap.ChildMap_q d@@93)
              ($IsAlloc d@@93 Tclass.PagedBetree.ChildMap $h@@122))
         ($IsAlloc (PagedBetree.ChildMap.mapp d@@93)
                   (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)
                   $h@@122))
     :pattern (($IsAlloc (PagedBetree.ChildMap.mapp d@@93)
                         (TIMap Tclass.KeyType.Key
                                Tclass.PagedBetree.BetreeNode)
                         $h@@122))
     :skolemid |3064|
     :qid |unknown.0:0|)))
(assert (forall ((|a#37#0#0| T@U))
  (! (=> (= (type |a#37#0#0|) (IMapType BoxType BoxType))
         (= (|#PagedBetree.ChildMap.ChildMap| (Lit |a#37#0#0|))
            (Lit (|#PagedBetree.ChildMap.ChildMap| |a#37#0#0|))))
     :pattern ((|#PagedBetree.ChildMap.ChildMap| (Lit |a#37#0#0|)))
     :skolemid |3065|
     :qid |PagedBetreeidfy.48:32|)))
(assert (forall ((|a#38#0#0| T@U))
  (! (=> (= (type |a#38#0#0|) (IMapType BoxType BoxType))
         (= (PagedBetree.ChildMap.mapp
              (|#PagedBetree.ChildMap.ChildMap| |a#38#0#0|))
            |a#38#0#0|))
     :pattern ((|#PagedBetree.ChildMap.ChildMap| |a#38#0#0|))
     :skolemid |3066|
     :qid |PagedBetreeidfy.48:32|)))
(assert (forall ((|a#39#0#0| T@U) (d@@94 T@U))
  (! (let ((a!1 (and (= (type |a#39#0#0|) (IMapType BoxType BoxType))
                     (= (type d@@94) DatatypeTypeType)
                     (U_2_bool (MapType0Select (|IMap#Domain| |a#39#0#0|)
                                               ($Box d@@94))))))
       (=> a!1
           (< (DtRank d@@94)
              (DtRank (|#PagedBetree.ChildMap.ChildMap| |a#39#0#0|)))))
     :pattern ((MapType0Select (|IMap#Domain| |a#39#0#0|) ($Box d@@94))
               (|#PagedBetree.ChildMap.ChildMap| |a#39#0#0|))
     :skolemid |3067|
     :qid |PagedBetreeidfy.48:32|)))
(assert (forall ((|a#40#0#0| T@U) (bx@@162 T@U))
  (! (let ((a!1 (and (= (type |a#40#0#0|) (IMapType BoxType BoxType))
                     (= (type bx@@162) BoxType)
                     (U_2_bool (MapType0Select (|IMap#Domain| |a#40#0#0|)
                                               bx@@162))))
           (a!2 (DtRank ($Unbox DatatypeTypeType
                                (MapType0Select (|IMap#Elements| |a#40#0#0|)
                                                bx@@162)))))
       (=> a!1 (< a!2 (DtRank (|#PagedBetree.ChildMap.ChildMap| |a#40#0#0|)))))
     :pattern ((MapType0Select (|IMap#Domain| |a#40#0#0|) bx@@162)
               (|#PagedBetree.ChildMap.ChildMap| |a#40#0#0|))
     :skolemid |3068|
     :qid |PagedBetreeidfy.48:32|)))
(assert (forall ((d@@95 T@U))
  (! (=> (and (= (type d@@95) DatatypeTypeType)
              (|$IsA#PagedBetree.ChildMap| d@@95))
         (PagedBetree.ChildMap.ChildMap_q d@@95))
     :pattern ((|$IsA#PagedBetree.ChildMap| d@@95))
     :skolemid |3069|
     :qid |unknown.0:0|)))
(assert (forall ((d@@96 T@U))
  (! (=> (and (= (type d@@96) DatatypeTypeType)
              ($Is d@@96 Tclass.PagedBetree.ChildMap))
         (PagedBetree.ChildMap.ChildMap_q d@@96))
     :pattern ((PagedBetree.ChildMap.ChildMap_q d@@96)
               ($Is d@@96 Tclass.PagedBetree.ChildMap))
     :skolemid |3070|
     :qid |unknown.0:0|)))
(assert (forall ((a@@144 T@U) (b@@94 T@U))
  (! (=> (and (= (type a@@144) DatatypeTypeType)
              (= (type b@@94) DatatypeTypeType)
              true)
         (= (|PagedBetree.ChildMap#Equal| a@@144 b@@94)
            (|IMap#Equal| (PagedBetree.ChildMap.mapp a@@144)
                          (PagedBetree.ChildMap.mapp b@@94))))
     :pattern ((|PagedBetree.ChildMap#Equal| a@@144 b@@94))
     :skolemid |3071|
     :qid |unknown.0:0|)))
(assert (forall ((a@@145 T@U) (b@@95 T@U))
  (! (=> (and (= (type a@@145) DatatypeTypeType)
              (= (type b@@95) DatatypeTypeType))
         (= (|PagedBetree.ChildMap#Equal| a@@145 b@@95) (= a@@145 b@@95)))
     :pattern ((|PagedBetree.ChildMap#Equal| a@@145 b@@95))
     :skolemid |3072|
     :qid |unknown.0:0|)))
(assert (forall (($ly@@330 T@U) (this@@123 T@U))
  (! (=> (and (= (type $ly@@330) LayerTypeType)
              (= (type this@@123) DatatypeTypeType))
         (= (PagedBetree.ChildMap.WF ($LS $ly@@330) this@@123)
            (PagedBetree.ChildMap.WF $ly@@330 this@@123)))
     :pattern ((PagedBetree.ChildMap.WF ($LS $ly@@330) this@@123))
     :skolemid |3073|
     :qid |PagedBetreeidfy.49:15|)))
(assert (forall (($ly@@331 T@U) (this@@124 T@U))
  (! (=> (and (= (type $ly@@331) LayerTypeType)
              (= (type this@@124) DatatypeTypeType))
         (= (PagedBetree.ChildMap.WF $ly@@331 this@@124)
            (PagedBetree.ChildMap.WF $LZ this@@124)))
     :pattern ((PagedBetree.ChildMap.WF (AsFuelBottom $ly@@331) this@@124))
     :skolemid |3074|
     :qid |PagedBetreeidfy.49:15|)))
(assert (let ((a!1 (forall (($ly@@332 T@U) (this@@125 T@U))
             (! (=> (and (= (type $ly@@332) LayerTypeType)
                         (= (type this@@125) DatatypeTypeType)
                         (or (|PagedBetree.ChildMap.WF#canCall| this@@125)
                             ($Is this@@125 Tclass.PagedBetree.ChildMap)))
                    true)
                :pattern ((PagedBetree.ChildMap.WF $ly@@332 this@@125))
                :skolemid |3075|
                :qid |PagedBetreeidfy.49:15|))))
  (=> true a!1)))
(assert (forall (($ly@@333 T@U) (this@@126 T@U))
  (! (=> (and (= (type $ly@@333) LayerTypeType)
              (= (type this@@126) DatatypeTypeType)
              ($Is this@@126 Tclass.PagedBetree.ChildMap))
         (= (|PagedBetree.ChildMap.WF#requires| $ly@@333 this@@126) true))
     :pattern ((|PagedBetree.ChildMap.WF#requires| $ly@@333 this@@126))
     :skolemid |3076|
     :qid |PagedBetreeidfy.49:15|)))
(assert (let ((a!1 (forall (($ly@@334 T@U) (this@@127 T@U))
             (! (let ((a!1 (forall ((|k#0@@80| T@U))
                             (! (let ((a!1 ($Unbox DatatypeTypeType
                                                   (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                      this@@127))
                                                                   ($Box |k#0@@80|)))))
                                (let ((a!2 (and (|Buffers.__default.AnyKey#canCall|
                                                  |k#0@@80|)
                                                (=> (Buffers.__default.AnyKey
                                                      |k#0@@80|)
                                                    (and (PagedBetree.ChildMap.ChildMap_q
                                                           this@@127)
                                                         (|PagedBetree.BetreeNode.WF#canCall|
                                                           a!1))))))
                                  (=> (and (= (type |k#0@@80|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@80| Tclass.KeyType.Key))
                                      a!2)))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                     this@@127))
                                                                  ($Box |k#0@@80|))))
                                :pattern ((Buffers.__default.AnyKey |k#0@@80|))
                                :skolemid |3078|
                                :qid |PagedBetreeidfy.51:18|)))
                      (a!3 (forall ((|k#0@@81| T@U))
                             (! (let ((a!1 ($Unbox DatatypeTypeType
                                                   (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                      this@@127))
                                                                   ($Box |k#0@@81|)))))
                                  (=> (= (type |k#0@@81|) (SeqType BoxType))
                                      (=> (and ($Is |k#0@@81|
                                                    Tclass.KeyType.Key)
                                               (Buffers.__default.AnyKey
                                                 |k#0@@81|))
                                          (PagedBetree.BetreeNode.WF
                                            $ly@@334
                                            a!1))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                     this@@127))
                                                                  ($Box |k#0@@81|))))
                                :pattern ((Buffers.__default.AnyKey |k#0@@81|))
                                :skolemid |3077|
                                :qid |PagedBetreeidfy.51:18|))))
                (let ((a!2 (=> (Buffers.__default.Total
                                 (|IMap#Domain| (PagedBetree.ChildMap.mapp
                                                  this@@127)))
                               a!1))
                      (a!4 (and (Buffers.__default.Total
                                  (|IMap#Domain| (PagedBetree.ChildMap.mapp
                                                   this@@127)))
                                a!3)))
                (let ((a!5 (and (PagedBetree.ChildMap.ChildMap_q this@@127)
                                (|Buffers.__default.Total#canCall|
                                  (|IMap#Domain| (PagedBetree.ChildMap.mapp
                                                   this@@127)))
                                a!2
                                (= (PagedBetree.ChildMap.WF
                                     ($LS $ly@@334)
                                     this@@127)
                                   a!4))))
                  (=> (and (= (type $ly@@334) LayerTypeType)
                           (= (type this@@127) DatatypeTypeType)
                           (or (|PagedBetree.ChildMap.WF#canCall| this@@127)
                               ($Is this@@127 Tclass.PagedBetree.ChildMap)))
                      a!5))))
                :pattern ((PagedBetree.ChildMap.WF ($LS $ly@@334) this@@127))
                :skolemid |3079|
                :qid |PagedBetreeidfy.49:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($ly@@335 T@U) (this@@128 T@U))
             (! (let ((a!1 (and (= (type $ly@@335) LayerTypeType)
                                (= (type this@@128) DatatypeTypeType)
                                (or (|PagedBetree.ChildMap.WF#canCall|
                                      (Lit this@@128))
                                    ($Is this@@128 Tclass.PagedBetree.ChildMap))))
                      (a!2 (|IMap#Domain| (Lit (PagedBetree.ChildMap.mapp
                                                 (Lit this@@128)))))
                      (a!4 (forall ((|k#1@@15| T@U))
                             (! (let ((a!1 (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp
                                                                   (Lit this@@128))))))
                                (let ((a!2 (|PagedBetree.BetreeNode.WF#canCall|
                                             ($Unbox DatatypeTypeType
                                                     (MapType0Select a!1
                                                                     ($Box |k#1@@15|))))))
                                (let ((a!3 (=> (Buffers.__default.AnyKey
                                                 |k#1@@15|)
                                               (and (PagedBetree.ChildMap.ChildMap_q
                                                      (Lit this@@128))
                                                    a!2))))
                                  (=> (and (= (type |k#1@@15|)
                                              (SeqType BoxType))
                                           ($Is |k#1@@15| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |k#1@@15|)
                                           a!3)))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                     this@@128))
                                                                  ($Box |k#1@@15|))))
                                :pattern ((Buffers.__default.AnyKey |k#1@@15|))
                                :skolemid |3081|
                                :qid |PagedBetreeidfy.51:18|)))
                      (a!5 (forall ((|k#1@@16| T@U))
                             (! (let ((a!1 (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp
                                                                   (Lit this@@128))))))
                                (let ((a!2 (PagedBetree.BetreeNode.WF
                                             ($LS $ly@@335)
                                             ($Unbox DatatypeTypeType
                                                     (MapType0Select a!1
                                                                     ($Box |k#1@@16|))))))
                                  (=> (= (type |k#1@@16|) (SeqType BoxType))
                                      (=> (and ($Is |k#1@@16|
                                                    Tclass.KeyType.Key)
                                               (Buffers.__default.AnyKey
                                                 |k#1@@16|))
                                          a!2))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                     this@@128))
                                                                  ($Box |k#1@@16|))))
                                :pattern ((Buffers.__default.AnyKey |k#1@@16|))
                                :skolemid |3080|
                                :qid |PagedBetreeidfy.51:18|))))
                (let ((a!3 (Lit (bool_2_U (Buffers.__default.Total (Lit a!2)))))
                      (a!6 (= (PagedBetree.ChildMap.WF
                                ($LS $ly@@335)
                                (Lit this@@128))
                              (and (Buffers.__default.Total (Lit a!2)) a!5))))
                  (=> a!1
                      (and (PagedBetree.ChildMap.ChildMap_q (Lit this@@128))
                           (|Buffers.__default.Total#canCall| (Lit a!2))
                           (=> (U_2_bool a!3) a!4)
                           a!6))))
                :pattern ((PagedBetree.ChildMap.WF
                            ($LS $ly@@335)
                            (Lit this@@128)))
                :weight 3
                :skolemid |3082|
                :qid |PagedBetreeidfy.49:15|))))
  (=> true a!1)))
(assert (= (DatatypeCtorId |#PagedBetree.BetreeNode.Nil|)
   |##PagedBetree.BetreeNode.Nil|))
(assert (forall ((d@@97 T@U))
  (! (=> (= (type d@@97) DatatypeTypeType)
         (= (PagedBetree.BetreeNode.Nil_q d@@97)
            (= (DatatypeCtorId d@@97) |##PagedBetree.BetreeNode.Nil|)))
     :pattern ((PagedBetree.BetreeNode.Nil_q d@@97))
     :skolemid |3083|
     :qid |unknown.0:0|)))
(assert (forall ((d@@98 T@U))
  (! (=> (and (= (type d@@98) DatatypeTypeType)
              (PagedBetree.BetreeNode.Nil_q d@@98))
         (= d@@98 |#PagedBetree.BetreeNode.Nil|))
     :pattern ((PagedBetree.BetreeNode.Nil_q d@@98))
     :skolemid |3084|
     :qid |unknown.0:0|)))
(assert ($Is |#PagedBetree.BetreeNode.Nil| Tclass.PagedBetree.BetreeNode))
(assert (forall (($h@@123 T@U))
  (! (=> (and (= (type $h@@123) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@123))
         ($IsAlloc |#PagedBetree.BetreeNode.Nil|
                   Tclass.PagedBetree.BetreeNode
                   $h@@123))
     :pattern (($IsAlloc |#PagedBetree.BetreeNode.Nil|
                         Tclass.PagedBetree.BetreeNode
                         $h@@123))
     :skolemid |3085|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#PagedBetree.BetreeNode.Nil| (Lit |#PagedBetree.BetreeNode.Nil|)))
(assert (forall ((arg0@@563 T@U) (arg1@@283 T@U))
  (! (= (type (|#PagedBetree.BetreeNode.BetreeNode| arg0@@563 arg1@@283))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.BetreeNode.BetreeNode| arg0@@563 arg1@@283))
     :qid |funType:#PagedBetree.BetreeNode.BetreeNode|)))
(assert (forall ((|a#5#0#0@@8| T@U) (|a#5#1#0@@4| T@U))
  (! (=> (and (= (type |a#5#0#0@@8|) DatatypeTypeType)
              (= (type |a#5#1#0@@4|) DatatypeTypeType))
         (= (DatatypeCtorId (|#PagedBetree.BetreeNode.BetreeNode|
                              |a#5#0#0@@8|
                              |a#5#1#0@@4|))
            |##PagedBetree.BetreeNode.BetreeNode|))
     :pattern ((|#PagedBetree.BetreeNode.BetreeNode| |a#5#0#0@@8| |a#5#1#0@@4|))
     :skolemid |3086|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((d@@99 T@U))
  (! (=> (= (type d@@99) DatatypeTypeType)
         (= (PagedBetree.BetreeNode.BetreeNode_q d@@99)
            (= (DatatypeCtorId d@@99) |##PagedBetree.BetreeNode.BetreeNode|)))
     :pattern ((PagedBetree.BetreeNode.BetreeNode_q d@@99))
     :skolemid |3087|
     :qid |unknown.0:0|)))
(assert (forall ((d@@100 T@U))
  (! (let ((a!1 (exists ((|a#6#0#0@@8| T@U) (|a#6#1#0@@4| T@U))
                  (! (and (= (type |a#6#0#0@@8|) DatatypeTypeType)
                          (= (type |a#6#1#0@@4|) DatatypeTypeType)
                          (= d@@100
                             (|#PagedBetree.BetreeNode.BetreeNode|
                               |a#6#0#0@@8|
                               |a#6#1#0@@4|)))
                     :no-pattern (type |a#6#0#0@@8|)
                     :no-pattern (type |a#6#1#0@@4|)
                     :no-pattern (U_2_int |a#6#0#0@@8|)
                     :no-pattern (U_2_bool |a#6#0#0@@8|)
                     :no-pattern (U_2_int |a#6#1#0@@4|)
                     :no-pattern (U_2_bool |a#6#1#0@@4|)
                     :skolemid |3088|
                     :qid |PagedBetreeidfy.69:5|))))
       (=> (and (= (type d@@100) DatatypeTypeType)
                (PagedBetree.BetreeNode.BetreeNode_q d@@100))
           a!1))
     :pattern ((PagedBetree.BetreeNode.BetreeNode_q d@@100))
     :skolemid |3089|
     :qid |unknown.0:0|)))
(assert (forall ((|a#7#0#0@@8| T@U) (|a#7#1#0@@4| T@U))
  (! (=> (and (= (type |a#7#0#0@@8|) DatatypeTypeType)
              (= (type |a#7#1#0@@4|) DatatypeTypeType))
         (= ($Is (|#PagedBetree.BetreeNode.BetreeNode|
                   |a#7#0#0@@8|
                   |a#7#1#0@@4|)
                 Tclass.PagedBetree.BetreeNode)
            (and ($Is |a#7#0#0@@8| Tclass.Buffers.BufferStack)
                 ($Is |a#7#1#0@@4| Tclass.PagedBetree.ChildMap))))
     :pattern (($Is (|#PagedBetree.BetreeNode.BetreeNode|
                      |a#7#0#0@@8|
                      |a#7#1#0@@4|)
                    Tclass.PagedBetree.BetreeNode))
     :skolemid |3090|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((|a#8#0#0@@5| T@U) (|a#8#1#0@@2| T@U) ($h@@124 T@U))
  (! (=> (and (= (type |a#8#0#0@@5|) DatatypeTypeType)
              (= (type |a#8#1#0@@2|) DatatypeTypeType)
              (= (type $h@@124) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@124))
         (= ($IsAlloc (|#PagedBetree.BetreeNode.BetreeNode|
                        |a#8#0#0@@5|
                        |a#8#1#0@@2|)
                      Tclass.PagedBetree.BetreeNode
                      $h@@124)
            (and ($IsAlloc |a#8#0#0@@5| Tclass.Buffers.BufferStack $h@@124)
                 ($IsAlloc |a#8#1#0@@2| Tclass.PagedBetree.ChildMap $h@@124))))
     :pattern (($IsAlloc (|#PagedBetree.BetreeNode.BetreeNode|
                           |a#8#0#0@@5|
                           |a#8#1#0@@2|)
                         Tclass.PagedBetree.BetreeNode
                         $h@@124))
     :skolemid |3091|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((d@@101 T@U) ($h@@125 T@U))
  (! (=> (and (= (type d@@101) DatatypeTypeType)
              (= (type $h@@125) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@125)
              (PagedBetree.BetreeNode.BetreeNode_q d@@101)
              ($IsAlloc d@@101 Tclass.PagedBetree.BetreeNode $h@@125))
         ($IsAlloc (PagedBetree.BetreeNode.buffers d@@101)
                   Tclass.Buffers.BufferStack
                   $h@@125))
     :pattern (($IsAlloc (PagedBetree.BetreeNode.buffers d@@101)
                         Tclass.Buffers.BufferStack
                         $h@@125))
     :skolemid |3092|
     :qid |unknown.0:0|)))
(assert (forall ((d@@102 T@U) ($h@@126 T@U))
  (! (=> (and (= (type d@@102) DatatypeTypeType)
              (= (type $h@@126) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@126)
              (PagedBetree.BetreeNode.BetreeNode_q d@@102)
              ($IsAlloc d@@102 Tclass.PagedBetree.BetreeNode $h@@126))
         ($IsAlloc (PagedBetree.BetreeNode.children d@@102)
                   Tclass.PagedBetree.ChildMap
                   $h@@126))
     :pattern (($IsAlloc (PagedBetree.BetreeNode.children d@@102)
                         Tclass.PagedBetree.ChildMap
                         $h@@126))
     :skolemid |3093|
     :qid |unknown.0:0|)))
(assert (forall ((|a#9#0#0@@3| T@U) (|a#9#1#0@@0| T@U))
  (! (=> (and (= (type |a#9#0#0@@3|) DatatypeTypeType)
              (= (type |a#9#1#0@@0|) DatatypeTypeType))
         (= (|#PagedBetree.BetreeNode.BetreeNode|
              (Lit |a#9#0#0@@3|)
              (Lit |a#9#1#0@@0|))
            (Lit (|#PagedBetree.BetreeNode.BetreeNode|
                   |a#9#0#0@@3|
                   |a#9#1#0@@0|))))
     :pattern ((|#PagedBetree.BetreeNode.BetreeNode|
                 (Lit |a#9#0#0@@3|)
                 (Lit |a#9#1#0@@0|)))
     :skolemid |3094|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((|a#10#0#0@@3| T@U) (|a#10#1#0@@0| T@U))
  (! (=> (and (= (type |a#10#0#0@@3|) DatatypeTypeType)
              (= (type |a#10#1#0@@0|) DatatypeTypeType))
         (= (PagedBetree.BetreeNode.buffers
              (|#PagedBetree.BetreeNode.BetreeNode| |a#10#0#0@@3| |a#10#1#0@@0|))
            |a#10#0#0@@3|))
     :pattern ((|#PagedBetree.BetreeNode.BetreeNode|
                 |a#10#0#0@@3|
                 |a#10#1#0@@0|))
     :skolemid |3095|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((|a#11#0#0@@3| T@U) (|a#11#1#0@@0| T@U))
  (! (=> (and (= (type |a#11#0#0@@3|) DatatypeTypeType)
              (= (type |a#11#1#0@@0|) DatatypeTypeType))
         (< (DtRank |a#11#0#0@@3|)
            (DtRank (|#PagedBetree.BetreeNode.BetreeNode|
                      |a#11#0#0@@3|
                      |a#11#1#0@@0|))))
     :pattern ((|#PagedBetree.BetreeNode.BetreeNode|
                 |a#11#0#0@@3|
                 |a#11#1#0@@0|))
     :skolemid |3096|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((|a#12#0#0@@2| T@U) (|a#12#1#0@@0| T@U))
  (! (=> (and (= (type |a#12#0#0@@2|) DatatypeTypeType)
              (= (type |a#12#1#0@@0|) DatatypeTypeType))
         (= (PagedBetree.BetreeNode.children
              (|#PagedBetree.BetreeNode.BetreeNode| |a#12#0#0@@2| |a#12#1#0@@0|))
            |a#12#1#0@@0|))
     :pattern ((|#PagedBetree.BetreeNode.BetreeNode|
                 |a#12#0#0@@2|
                 |a#12#1#0@@0|))
     :skolemid |3097|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((|a#13#0#0@@1| T@U) (|a#13#1#0@@0| T@U))
  (! (=> (and (= (type |a#13#0#0@@1|) DatatypeTypeType)
              (= (type |a#13#1#0@@0|) DatatypeTypeType))
         (< (DtRank |a#13#1#0@@0|)
            (DtRank (|#PagedBetree.BetreeNode.BetreeNode|
                      |a#13#0#0@@1|
                      |a#13#1#0@@0|))))
     :pattern ((|#PagedBetree.BetreeNode.BetreeNode|
                 |a#13#0#0@@1|
                 |a#13#1#0@@0|))
     :skolemid |3098|
     :qid |PagedBetreeidfy.69:5|)))
(assert (forall ((d@@103 T@U))
  (! (=> (and (= (type d@@103) DatatypeTypeType)
              (|$IsA#PagedBetree.BetreeNode| d@@103))
         (or (PagedBetree.BetreeNode.Nil_q d@@103)
             (PagedBetree.BetreeNode.BetreeNode_q d@@103)))
     :pattern ((|$IsA#PagedBetree.BetreeNode| d@@103))
     :skolemid |3099|
     :qid |unknown.0:0|)))
(assert (forall ((d@@104 T@U))
  (! (=> (and (= (type d@@104) DatatypeTypeType)
              ($Is d@@104 Tclass.PagedBetree.BetreeNode))
         (or (PagedBetree.BetreeNode.Nil_q d@@104)
             (PagedBetree.BetreeNode.BetreeNode_q d@@104)))
     :pattern ((PagedBetree.BetreeNode.BetreeNode_q d@@104)
               ($Is d@@104 Tclass.PagedBetree.BetreeNode))
     :pattern ((PagedBetree.BetreeNode.Nil_q d@@104)
               ($Is d@@104 Tclass.PagedBetree.BetreeNode))
     :skolemid |3100|
     :qid |unknown.0:0|)))
(assert (forall ((a@@146 T@U) (b@@96 T@U))
  (! (=> (and (= (type a@@146) DatatypeTypeType)
              (= (type b@@96) DatatypeTypeType)
              (PagedBetree.BetreeNode.Nil_q a@@146)
              (PagedBetree.BetreeNode.Nil_q b@@96))
         (= (|PagedBetree.BetreeNode#Equal| a@@146 b@@96) true))
     :pattern ((|PagedBetree.BetreeNode#Equal| a@@146 b@@96)
               (PagedBetree.BetreeNode.Nil_q a@@146))
     :pattern ((|PagedBetree.BetreeNode#Equal| a@@146 b@@96)
               (PagedBetree.BetreeNode.Nil_q b@@96))
     :skolemid |3101|
     :qid |unknown.0:0|)))
(assert (forall ((a@@147 T@U) (b@@97 T@U))
  (! (let ((a!1 (= (|PagedBetree.BetreeNode#Equal| a@@147 b@@97)
                   (and (|Buffers.BufferStack#Equal|
                          (PagedBetree.BetreeNode.buffers a@@147)
                          (PagedBetree.BetreeNode.buffers b@@97))
                        (|PagedBetree.ChildMap#Equal|
                          (PagedBetree.BetreeNode.children a@@147)
                          (PagedBetree.BetreeNode.children b@@97))))))
       (=> (and (= (type a@@147) DatatypeTypeType)
                (= (type b@@97) DatatypeTypeType)
                (PagedBetree.BetreeNode.BetreeNode_q a@@147)
                (PagedBetree.BetreeNode.BetreeNode_q b@@97))
           a!1))
     :pattern ((|PagedBetree.BetreeNode#Equal| a@@147 b@@97)
               (PagedBetree.BetreeNode.BetreeNode_q a@@147))
     :pattern ((|PagedBetree.BetreeNode#Equal| a@@147 b@@97)
               (PagedBetree.BetreeNode.BetreeNode_q b@@97))
     :skolemid |3102|
     :qid |unknown.0:0|)))
(assert (forall ((a@@148 T@U) (b@@98 T@U))
  (! (=> (and (= (type a@@148) DatatypeTypeType)
              (= (type b@@98) DatatypeTypeType))
         (= (|PagedBetree.BetreeNode#Equal| a@@148 b@@98) (= a@@148 b@@98)))
     :pattern ((|PagedBetree.BetreeNode#Equal| a@@148 b@@98))
     :skolemid |3103|
     :qid |unknown.0:0|)))
(assert (forall (($ly@@336 T@U) (this@@129 T@U))
  (! (=> (and (= (type $ly@@336) LayerTypeType)
              (= (type this@@129) DatatypeTypeType))
         (= (PagedBetree.BetreeNode.WF ($LS $ly@@336) this@@129)
            (PagedBetree.BetreeNode.WF $ly@@336 this@@129)))
     :pattern ((PagedBetree.BetreeNode.WF ($LS $ly@@336) this@@129))
     :skolemid |3104|
     :qid |PagedBetreeidfy.72:15|)))
(assert (forall (($ly@@337 T@U) (this@@130 T@U))
  (! (=> (and (= (type $ly@@337) LayerTypeType)
              (= (type this@@130) DatatypeTypeType))
         (= (PagedBetree.BetreeNode.WF $ly@@337 this@@130)
            (PagedBetree.BetreeNode.WF $LZ this@@130)))
     :pattern ((PagedBetree.BetreeNode.WF (AsFuelBottom $ly@@337) this@@130))
     :skolemid |3105|
     :qid |PagedBetreeidfy.72:15|)))
(assert (let ((a!1 (forall (($ly@@338 T@U) (this@@131 T@U))
             (! (=> (and (= (type $ly@@338) LayerTypeType)
                         (= (type this@@131) DatatypeTypeType)
                         (or (|PagedBetree.BetreeNode.WF#canCall| this@@131)
                             ($Is this@@131 Tclass.PagedBetree.BetreeNode)))
                    true)
                :pattern ((PagedBetree.BetreeNode.WF $ly@@338 this@@131))
                :skolemid |3106|
                :qid |PagedBetreeidfy.72:15|))))
  (=> true a!1)))
(assert (forall (($ly@@339 T@U) (this@@132 T@U))
  (! (=> (and (= (type $ly@@339) LayerTypeType)
              (= (type this@@132) DatatypeTypeType)
              ($Is this@@132 Tclass.PagedBetree.BetreeNode))
         (= (|PagedBetree.BetreeNode.WF#requires| $ly@@339 this@@132) true))
     :pattern ((|PagedBetree.BetreeNode.WF#requires| $ly@@339 this@@132))
     :skolemid |3107|
     :qid |PagedBetreeidfy.72:15|)))
(assert (let ((a!1 (forall (($ly@@340 T@U) (this@@133 T@U))
             (! (let ((a!1 (=> (U_2_bool (Lit (bool_2_U true)))
                               (=> (PagedBetree.BetreeNode.BetreeNode_q
                                     this@@133)
                                   (|PagedBetree.ChildMap.WF#canCall|
                                     (PagedBetree.BetreeNode.children this@@133)))))
                      (a!2 (and true
                                (=> (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@133)
                                    (PagedBetree.ChildMap.WF
                                      $ly@@340
                                      (PagedBetree.BetreeNode.children
                                        this@@133))))))
                (let ((a!3 (and a!1
                                (= (PagedBetree.BetreeNode.WF
                                     ($LS $ly@@340)
                                     this@@133)
                                   a!2))))
                  (=> (and (= (type $ly@@340) LayerTypeType)
                           (= (type this@@133) DatatypeTypeType)
                           (or (|PagedBetree.BetreeNode.WF#canCall| this@@133)
                               ($Is this@@133 Tclass.PagedBetree.BetreeNode)))
                      a!3)))
                :pattern ((PagedBetree.BetreeNode.WF ($LS $ly@@340) this@@133))
                :skolemid |3108|
                :qid |PagedBetreeidfy.72:15|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@341 T@U) (this@@134 T@U))
      (! (let ((a!1 (and (= (type $ly@@341) LayerTypeType)
                         (= (type this@@134) DatatypeTypeType)
                         (or (|PagedBetree.BetreeNode.WF#canCall|
                               (Lit this@@134))
                             ($Is this@@134 Tclass.PagedBetree.BetreeNode))))
               (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                     (Lit this@@134)))))
               (a!3 (|PagedBetree.ChildMap.WF#canCall|
                      (Lit (PagedBetree.BetreeNode.children (Lit this@@134)))))
               (a!5 (PagedBetree.ChildMap.WF
                      ($LS $ly@@341)
                      (Lit (PagedBetree.BetreeNode.children (Lit this@@134))))))
         (let ((a!4 (=> (U_2_bool (Lit (bool_2_U true)))
                        (=> (U_2_bool a!2) a!3)))
               (a!6 (and true
                         (=> (PagedBetree.BetreeNode.BetreeNode_q
                               (Lit this@@134))
                             a!5))))
         (let ((a!7 (= (PagedBetree.BetreeNode.WF
                         ($LS $ly@@341)
                         (Lit this@@134))
                       (U_2_bool (Lit (bool_2_U a!6))))))
           (=> a!1 (and a!4 a!7)))))
         :pattern ((PagedBetree.BetreeNode.WF ($LS $ly@@341) (Lit this@@134)))
         :weight 3
         :skolemid |3109|
         :qid |PagedBetreeidfy.72:15|))))
(assert (forall ((arg0@@564 T@U) (arg1@@284 T@U))
  (! (= (type (PagedBetree.BetreeNode.Child arg0@@564 arg1@@284))
        DatatypeTypeType)
     :pattern ((PagedBetree.BetreeNode.Child arg0@@564 arg1@@284))
     :qid |funType:PagedBetree.BetreeNode.Child|)))
(assert (let ((a!1 (forall ((this@@135 T@U) (|key#0@@56| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Child#canCall|
                                 this@@135
                                 |key#0@@56|)
                               (and ($Is this@@135
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@56| Tclass.KeyType.Key)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@135)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@135)))))
                  (=> (and (= (type this@@135) DatatypeTypeType)
                           (= (type |key#0@@56|) (SeqType BoxType))
                           a!1)
                      ($Is (PagedBetree.BetreeNode.Child this@@135 |key#0@@56|)
                           Tclass.PagedBetree.BetreeNode)))
                :pattern ((PagedBetree.BetreeNode.Child this@@135 |key#0@@56|))
                :skolemid |3110|
                :qid |PagedBetreeidfy.76:14|))))
  (=> true a!1)))
(assert (forall ((this@@136 T@U) (|key#0@@57| T@U))
  (! (let ((a!1 (= (|PagedBetree.BetreeNode.Child#requires|
                     this@@136
                     |key#0@@57|)
                   (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@136)
                        (PagedBetree.BetreeNode.BetreeNode_q this@@136)))))
       (=> (and (= (type this@@136) DatatypeTypeType)
                (= (type |key#0@@57|) (SeqType BoxType))
                ($Is this@@136 Tclass.PagedBetree.BetreeNode)
                ($Is |key#0@@57| Tclass.KeyType.Key))
           a!1))
     :pattern ((|PagedBetree.BetreeNode.Child#requires| this@@136 |key#0@@57|))
     :skolemid |3111|
     :qid |PagedBetreeidfy.76:14|)))
(assert (let ((a!1 (forall ((this@@137 T@U) (|key#0@@58| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Child#canCall|
                                 this@@137
                                 |key#0@@58|)
                               (and ($Is this@@137
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |key#0@@58| Tclass.KeyType.Key)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@137)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@137))))
                      (a!2 (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                              (PagedBetree.BetreeNode.children
                                                                this@@137)))
                                           ($Box |key#0@@58|))))
                  (=> (and (= (type this@@137) DatatypeTypeType)
                           (= (type |key#0@@58|) (SeqType BoxType))
                           a!1)
                      (and (PagedBetree.ChildMap.ChildMap_q
                             (PagedBetree.BetreeNode.children this@@137))
                           (= (PagedBetree.BetreeNode.Child
                                this@@137
                                |key#0@@58|)
                              ($Unbox DatatypeTypeType a!2)))))
                :pattern ((PagedBetree.BetreeNode.Child this@@137 |key#0@@58|))
                :skolemid |3112|
                :qid |PagedBetreeidfy.76:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@138 T@U) (|key#0@@59| T@U))
      (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (Lit this@@138)))))
               (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                     (Lit this@@138)))))
               (a!4 (PagedBetree.ChildMap.ChildMap_q
                      (Lit (PagedBetree.BetreeNode.children (Lit this@@138)))))
               (a!5 (PagedBetree.ChildMap.mapp
                      (Lit (PagedBetree.BetreeNode.children (Lit this@@138))))))
         (let ((a!3 (and (= (type this@@138) DatatypeTypeType)
                         (= (type |key#0@@59|) (SeqType BoxType))
                         (or (|PagedBetree.BetreeNode.Child#canCall|
                               (Lit this@@138)
                               (Lit |key#0@@59|))
                             (and ($Is this@@138 Tclass.PagedBetree.BetreeNode)
                                  ($Is |key#0@@59| Tclass.KeyType.Key)
                                  (U_2_bool a!1)
                                  (U_2_bool a!2)))))
               (a!6 ($Unbox DatatypeTypeType
                            (MapType0Select (|IMap#Elements| (Lit a!5))
                                            ($Box (Lit |key#0@@59|))))))
         (let ((a!7 (and a!4
                         (= (PagedBetree.BetreeNode.Child
                              (Lit this@@138)
                              (Lit |key#0@@59|))
                            a!6))))
           (=> a!3 a!7))))
         :pattern ((PagedBetree.BetreeNode.Child
                     (Lit this@@138)
                     (Lit |key#0@@59|)))
         :weight 3
         :skolemid |3113|
         :qid |PagedBetreeidfy.76:14|))))
(assert (let ((a!1 (forall ((this@@139 T@U) (|memtable#0@@6| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.PushMemtable#canCall|
                                 this@@139
                                 |memtable#0@@6|)
                               (and ($Is this@@139
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |memtable#0@@6|
                                         Tclass.MemtableMod.Memtable)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@139)))))
                  (=> (and (= (type this@@139) DatatypeTypeType)
                           (= (type |memtable#0@@6|) DatatypeTypeType)
                           a!1)
                      ($Is (PagedBetree.BetreeNode.PushMemtable
                             this@@139
                             |memtable#0@@6|)
                           (Tclass.StampedMod.Stamped
                             Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.BetreeNode.PushMemtable
                            this@@139
                            |memtable#0@@6|))
                :skolemid |3114|
                :qid |PagedBetreeidfy.84:14|))))
  (=> true a!1)))
(assert (forall ((this@@140 T@U) (|memtable#0@@7| T@U))
  (! (=> (and (= (type this@@140) DatatypeTypeType)
              (= (type |memtable#0@@7|) DatatypeTypeType)
              ($Is this@@140 Tclass.PagedBetree.BetreeNode)
              ($Is |memtable#0@@7| Tclass.MemtableMod.Memtable))
         (= (|PagedBetree.BetreeNode.PushMemtable#requires|
              this@@140
              |memtable#0@@7|)
            (PagedBetree.BetreeNode.WF ($LS $LZ) this@@140)))
     :pattern ((|PagedBetree.BetreeNode.PushMemtable#requires|
                 this@@140
                 |memtable#0@@7|))
     :skolemid |3115|
     :qid |PagedBetreeidfy.84:14|)))
(assert (let ((a!1 (forall ((arg0@@565 T@U))
             (! (= (type (PagedBetree.BetreeNode.Promote arg0@@565))
                   DatatypeTypeType)
                :pattern ((PagedBetree.BetreeNode.Promote arg0@@565))
                :qid |funType:PagedBetree.BetreeNode.Promote|)))
      (a!2 (forall ((arg0@@566 T@U) (arg1@@285 T@U))
             (! (= (type (PagedBetree.BetreeNode.PushBufferStack
                           arg0@@566
                           arg1@@285))
                   DatatypeTypeType)
                :pattern ((PagedBetree.BetreeNode.PushBufferStack
                            arg0@@566
                            arg1@@285))
                :qid |funType:PagedBetree.BetreeNode.PushBufferStack|))))
  (and a!1 a!2)))
(assert (let ((a!1 (forall ((this@@141 T@U) (|memtable#0@@8| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.PushMemtable#canCall|
                                 this@@141
                                 |memtable#0@@8|)
                               (and ($Is this@@141
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |memtable#0@@8|
                                         Tclass.MemtableMod.Memtable)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@141))))
                      (a!2 (|Seq#Build| (|Seq#Empty| BoxType)
                                        ($Box (|#Buffers.Buffer.Buffer|
                                                (MemtableMod.Memtable.mapp
                                                  |memtable#0@@8|))))))
                (let ((a!3 (|#StampedMod.Stamped.Stamped|
                             ($Box (PagedBetree.BetreeNode.PushBufferStack
                                     (PagedBetree.BetreeNode.Promote this@@141)
                                     (|#Buffers.BufferStack.BufferStack| a!2)))
                             (MemtableMod.Memtable.seqEnd |memtable#0@@8|))))
                  (=> (and (= (type this@@141) DatatypeTypeType)
                           (= (type |memtable#0@@8|) DatatypeTypeType)
                           a!1)
                      (and (MemtableMod.Memtable.Memtable_q |memtable#0@@8|)
                           (|PagedBetree.BetreeNode.Promote#canCall| this@@141)
                           (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                             (PagedBetree.BetreeNode.Promote this@@141)
                             (|#Buffers.BufferStack.BufferStack| a!2))
                           (MemtableMod.Memtable.Memtable_q |memtable#0@@8|)
                           (= (PagedBetree.BetreeNode.PushMemtable
                                this@@141
                                |memtable#0@@8|)
                              a!3)))))
                :pattern ((PagedBetree.BetreeNode.PushMemtable
                            this@@141
                            |memtable#0@@8|))
                :skolemid |3116|
                :qid |PagedBetreeidfy.84:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@142 T@U) (|memtable#0@@9| T@U))
      (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (Lit this@@142)))))
               (a!3 (|#Buffers.Buffer.Buffer|
                      (Lit (MemtableMod.Memtable.mapp (Lit |memtable#0@@9|))))))
         (let ((a!2 (and (= (type this@@142) DatatypeTypeType)
                         (= (type |memtable#0@@9|) DatatypeTypeType)
                         (or (|PagedBetree.BetreeNode.PushMemtable#canCall|
                               (Lit this@@142)
                               (Lit |memtable#0@@9|))
                             (and ($Is this@@142 Tclass.PagedBetree.BetreeNode)
                                  ($Is |memtable#0@@9|
                                       Tclass.MemtableMod.Memtable)
                                  (U_2_bool a!1)))))
               (a!4 (|#Buffers.BufferStack.BufferStack|
                      (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit a!3)))))
               (a!6 (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit a!3))))))
         (let ((a!5 (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                      (Lit (PagedBetree.BetreeNode.Promote (Lit this@@142)))
                      a!4))
               (a!7 (PagedBetree.BetreeNode.PushBufferStack
                      (Lit (PagedBetree.BetreeNode.Promote (Lit this@@142)))
                      (Lit (|#Buffers.BufferStack.BufferStack| a!6)))))
         (let ((a!8 (|#StampedMod.Stamped.Stamped|
                      ($Box (Lit a!7))
                      (LitInt (MemtableMod.Memtable.seqEnd
                                (Lit |memtable#0@@9|))))))
         (let ((a!9 (and (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@9|))
                         (|PagedBetree.BetreeNode.Promote#canCall|
                           (Lit this@@142))
                         a!5
                         (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@9|))
                         (= (PagedBetree.BetreeNode.PushMemtable
                              (Lit this@@142)
                              (Lit |memtable#0@@9|))
                            (Lit a!8)))))
           (=> a!2 a!9))))))
         :pattern ((PagedBetree.BetreeNode.PushMemtable
                     (Lit this@@142)
                     (Lit |memtable#0@@9|)))
         :weight 3
         :skolemid |3117|
         :qid |PagedBetreeidfy.84:14|))))
(assert (let ((a!1 (forall ((this@@143 T@U) (|bufferStack#0| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                                 this@@143
                                 |bufferStack#0|)
                               (and ($Is this@@143
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |bufferStack#0|
                                         Tclass.Buffers.BufferStack)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@143)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@143)))))
                  (=> (and (= (type this@@143) DatatypeTypeType)
                           (= (type |bufferStack#0|) DatatypeTypeType)
                           a!1)
                      (and (PagedBetree.BetreeNode.WF
                             ($LS $LZ)
                             (PagedBetree.BetreeNode.PushBufferStack
                               this@@143
                               |bufferStack#0|))
                           ($Is (PagedBetree.BetreeNode.PushBufferStack
                                  this@@143
                                  |bufferStack#0|)
                                Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.BetreeNode.PushBufferStack
                            this@@143
                            |bufferStack#0|))
                :skolemid |3118|
                :qid |PagedBetreeidfy.91:14|))))
  (=> true a!1)))
(assert (forall ((this@@144 T@U) (|bufferStack#0@@0| T@U))
  (! (let ((a!1 (= (|PagedBetree.BetreeNode.PushBufferStack#requires|
                     this@@144
                     |bufferStack#0@@0|)
                   (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@144)
                        (PagedBetree.BetreeNode.BetreeNode_q this@@144)))))
       (=> (and (= (type this@@144) DatatypeTypeType)
                (= (type |bufferStack#0@@0|) DatatypeTypeType)
                ($Is this@@144 Tclass.PagedBetree.BetreeNode)
                ($Is |bufferStack#0@@0| Tclass.Buffers.BufferStack))
           a!1))
     :pattern ((|PagedBetree.BetreeNode.PushBufferStack#requires|
                 this@@144
                 |bufferStack#0@@0|))
     :skolemid |3119|
     :qid |PagedBetreeidfy.91:14|)))
(assert (let ((a!1 (forall ((this@@145 T@U) (|bufferStack#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                                 this@@145
                                 |bufferStack#0@@1|)
                               (and ($Is this@@145
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |bufferStack#0@@1|
                                         Tclass.Buffers.BufferStack)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@145)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@145))))
                      (a!2 (= (PagedBetree.BetreeNode.PushBufferStack
                                this@@145
                                |bufferStack#0@@1|)
                              (|#PagedBetree.BetreeNode.BetreeNode|
                                (Buffers.BufferStack.PushBufferStack
                                  (PagedBetree.BetreeNode.buffers this@@145)
                                  |bufferStack#0@@1|)
                                (PagedBetree.BetreeNode.children this@@145)))))
                  (=> (and (= (type this@@145) DatatypeTypeType)
                           (= (type |bufferStack#0@@1|) DatatypeTypeType)
                           a!1)
                      (and (|Buffers.BufferStack.PushBufferStack#canCall|
                             (PagedBetree.BetreeNode.buffers this@@145)
                             |bufferStack#0@@1|)
                           a!2)))
                :pattern ((PagedBetree.BetreeNode.PushBufferStack
                            this@@145
                            |bufferStack#0@@1|))
                :skolemid |3120|
                :qid |PagedBetreeidfy.91:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@146 T@U) (|bufferStack#0@@2| T@U))
      (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (Lit this@@146)))))
               (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                     (Lit this@@146)))))
               (a!4 (|Buffers.BufferStack.PushBufferStack#canCall|
                      (Lit (PagedBetree.BetreeNode.buffers (Lit this@@146)))
                      (Lit |bufferStack#0@@2|)))
               (a!5 (Buffers.BufferStack.PushBufferStack
                      (Lit (PagedBetree.BetreeNode.buffers (Lit this@@146)))
                      (Lit |bufferStack#0@@2|))))
         (let ((a!3 (and (= (type this@@146) DatatypeTypeType)
                         (= (type |bufferStack#0@@2|) DatatypeTypeType)
                         (or (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                               (Lit this@@146)
                               (Lit |bufferStack#0@@2|))
                             (and ($Is this@@146 Tclass.PagedBetree.BetreeNode)
                                  ($Is |bufferStack#0@@2|
                                       Tclass.Buffers.BufferStack)
                                  (U_2_bool a!1)
                                  (U_2_bool a!2)))))
               (a!6 (|#PagedBetree.BetreeNode.BetreeNode|
                      (Lit a!5)
                      (Lit (PagedBetree.BetreeNode.children (Lit this@@146))))))
         (let ((a!7 (and a!4
                         (= (PagedBetree.BetreeNode.PushBufferStack
                              (Lit this@@146)
                              (Lit |bufferStack#0@@2|))
                            (Lit a!6)))))
           (=> a!3 a!7))))
         :pattern ((PagedBetree.BetreeNode.PushBufferStack
                     (Lit this@@146)
                     (Lit |bufferStack#0@@2|)))
         :weight 3
         :skolemid |3121|
         :qid |PagedBetreeidfy.91:14|))))
(assert (forall ((arg0@@567 T@U) (arg1@@286 T@U))
  (! (= (type (PagedBetree.BetreeNode.FilterBuffersAndChildren
                arg0@@567
                arg1@@286))
        DatatypeTypeType)
     :pattern ((PagedBetree.BetreeNode.FilterBuffersAndChildren
                 arg0@@567
                 arg1@@286))
     :qid |funType:PagedBetree.BetreeNode.FilterBuffersAndChildren|)))
(assert (let ((a!1 (forall ((this@@147 T@U) (|filter#0| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                 this@@147
                                 |filter#0|)
                               (and ($Is this@@147
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |filter#0| (TISet Tclass.KeyType.Key))
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@147)))))
                  (=> (and (= (type this@@147) DatatypeTypeType)
                           (= (type |filter#0|) (MapType0Type BoxType boolType))
                           a!1)
                      (and (PagedBetree.BetreeNode.WF
                             ($LS $LZ)
                             (PagedBetree.BetreeNode.FilterBuffersAndChildren
                               this@@147
                               |filter#0|))
                           ($Is (PagedBetree.BetreeNode.FilterBuffersAndChildren
                                  this@@147
                                  |filter#0|)
                                Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.BetreeNode.FilterBuffersAndChildren
                            this@@147
                            |filter#0|))
                :skolemid |3122|
                :qid |PagedBetreeidfy.99:14|))))
  (=> true a!1)))
(assert (forall ((this@@148 T@U) (|filter#0@@0| T@U))
  (! (=> (and (= (type this@@148) DatatypeTypeType)
              (= (type |filter#0@@0|) (MapType0Type BoxType boolType))
              ($Is this@@148 Tclass.PagedBetree.BetreeNode)
              ($Is |filter#0@@0| (TISet Tclass.KeyType.Key)))
         (= (|PagedBetree.BetreeNode.FilterBuffersAndChildren#requires|
              this@@148
              |filter#0@@0|)
            (PagedBetree.BetreeNode.WF ($LS $LZ) this@@148)))
     :pattern ((|PagedBetree.BetreeNode.FilterBuffersAndChildren#requires|
                 this@@148
                 |filter#0@@0|))
     :skolemid |3123|
     :qid |PagedBetreeidfy.99:14|)))
(assert (forall ((arg0@@568 T@U) (arg1@@287 T@U) (arg2@@161 T@U))
  (! (= (type (|lambda#245| arg0@@568 arg1@@287 arg2@@161))
        (MapType0Type BoxType BoxType))
     :pattern ((|lambda#245| arg0@@568 arg1@@287 arg2@@161))
     :qid |funType:lambda#245|)))
(assert (let ((a!1 (forall ((this@@149 T@U) (|filter#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                 this@@149
                                 |filter#0@@1|)
                               (and ($Is this@@149
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |filter#0@@1|
                                         (TISet Tclass.KeyType.Key))
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@149))))
                      (a!2 (forall ((|key#0@@60| T@U))
                             (! (let ((a!1 (=> (U_2_bool (MapType0Select |filter#0@@1|
                                                                         ($Box |key#0@@60|)))
                                               (PagedBetree.ChildMap.ChildMap_q
                                                 (PagedBetree.BetreeNode.children
                                                   this@@149)))))
                                  (=> (and (= (type |key#0@@60|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@60| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |key#0@@60|)
                                           (=> (Buffers.__default.AnyKey
                                                 |key#0@@60|)
                                               a!1))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                     (PagedBetree.BetreeNode.children
                                                                                       this@@149)))
                                                                  ($Box |key#0@@60|))))
                                :pattern ((MapType0Select |filter#0@@1|
                                                          ($Box |key#0@@60|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@60|))
                                :skolemid |3124|
                                :qid |PagedBetreeidfy.105:47|)))
                      (a!4 (|lambda#245| |filter#0@@1|
                                         (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                            (PagedBetree.BetreeNode.children
                                                              this@@149)))
                                         |#PagedBetree.BetreeNode.Nil|)))
                (let ((a!3 (=> (not (PagedBetree.BetreeNode.Nil_q this@@149))
                               (and a!2
                                    (|Buffers.BufferStack.ApplyFilter#canCall|
                                      (PagedBetree.BetreeNode.buffers this@@149)
                                      |filter#0@@1|))))
                      (a!5 (|#PagedBetree.BetreeNode.BetreeNode|
                             (Buffers.BufferStack.ApplyFilter
                               (PagedBetree.BetreeNode.buffers this@@149)
                               |filter#0@@1|)
                             (|#PagedBetree.ChildMap.ChildMap|
                               (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                            a!4
                                            (TIMap Tclass.KeyType.Key
                                                   Tclass.PagedBetree.BetreeNode))))))
                (let ((a!6 (and a!3
                                (= (PagedBetree.BetreeNode.FilterBuffersAndChildren
                                     this@@149
                                     |filter#0@@1|)
                                   (ite (PagedBetree.BetreeNode.Nil_q this@@149)
                                        |#PagedBetree.BetreeNode.Nil|
                                        a!5)))))
                  (=> (and (= (type this@@149) DatatypeTypeType)
                           (= (type |filter#0@@1|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      a!6))))
                :pattern ((PagedBetree.BetreeNode.FilterBuffersAndChildren
                            this@@149
                            |filter#0@@1|))
                :skolemid |3125|
                :qid |PagedBetreeidfy.99:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@150 T@U) (|filter#0@@2| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit this@@150)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q
                                            (Lit this@@150)))))
                      (a!4 (forall ((|key#0@@61| T@U))
                             (! (let ((a!1 (PagedBetree.ChildMap.ChildMap_q
                                             (Lit (PagedBetree.BetreeNode.children
                                                    (Lit this@@150))))))
                                (let ((a!2 (=> (U_2_bool (MapType0Select |filter#0@@2|
                                                                         ($Box |key#0@@61|)))
                                               a!1)))
                                  (=> (and (= (type |key#0@@61|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@61| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |key#0@@61|)
                                           (=> (Buffers.__default.AnyKey
                                                 |key#0@@61|)
                                               a!2)))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                     (PagedBetree.BetreeNode.children
                                                                                       this@@150)))
                                                                  ($Box |key#0@@61|))))
                                :pattern ((MapType0Select |filter#0@@2|
                                                          ($Box |key#0@@61|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@61|))
                                :skolemid |3126|
                                :qid |PagedBetreeidfy.105:47|)))
                      (a!5 (|Buffers.BufferStack.ApplyFilter#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@150)))
                             |filter#0@@2|))
                      (a!6 (Buffers.BufferStack.ApplyFilter
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@150)))
                             |filter#0@@2|))
                      (a!7 (PagedBetree.ChildMap.mapp
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit this@@150))))))
                (let ((a!2 (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                 (Lit this@@150)
                                 |filter#0@@2|)
                               (and ($Is this@@150
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |filter#0@@2|
                                         (TISet Tclass.KeyType.Key))
                                    (U_2_bool a!1))))
                      (a!8 (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                        (|lambda#245| |filter#0@@2|
                                                      (|IMap#Elements| (Lit a!7))
                                                      |#PagedBetree.BetreeNode.Nil|)
                                        (TIMap Tclass.KeyType.Key
                                               Tclass.PagedBetree.BetreeNode))))
                (let ((a!9 (= (PagedBetree.BetreeNode.FilterBuffersAndChildren
                                (Lit this@@150)
                                |filter#0@@2|)
                              (ite (PagedBetree.BetreeNode.Nil_q
                                     (Lit this@@150))
                                   |#PagedBetree.BetreeNode.Nil|
                                   (|#PagedBetree.BetreeNode.BetreeNode|
                                     a!6
                                     (|#PagedBetree.ChildMap.ChildMap| a!8))))))
                (let ((a!10 (and (=> (not (U_2_bool a!3)) (and a!4 a!5)) a!9)))
                  (=> (and (= (type this@@150) DatatypeTypeType)
                           (= (type |filter#0@@2|)
                              (MapType0Type BoxType boolType))
                           a!2)
                      a!10)))))
                :pattern ((PagedBetree.BetreeNode.FilterBuffersAndChildren
                            (Lit this@@150)
                            |filter#0@@2|))
                :weight 3
                :skolemid |3127|
                :qid |PagedBetreeidfy.99:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@151 T@U) (|filter#0@@3| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit this@@151)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q
                                            (Lit this@@151)))))
                      (a!4 (forall ((|key#0@@62| T@U))
                             (! (let ((a!1 (PagedBetree.ChildMap.ChildMap_q
                                             (Lit (PagedBetree.BetreeNode.children
                                                    (Lit this@@151))))))
                                (let ((a!2 (=> (U_2_bool (MapType0Select (Lit |filter#0@@3|)
                                                                         ($Box |key#0@@62|)))
                                               a!1)))
                                  (=> (and (= (type |key#0@@62|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@62| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |key#0@@62|)
                                           (=> (Buffers.__default.AnyKey
                                                 |key#0@@62|)
                                               a!2)))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                                     (PagedBetree.BetreeNode.children
                                                                                       this@@151)))
                                                                  ($Box |key#0@@62|))))
                                :pattern ((MapType0Select |filter#0@@3|
                                                          ($Box |key#0@@62|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@62|))
                                :skolemid |3128|
                                :qid |PagedBetreeidfy.105:47|)))
                      (a!5 (|Buffers.BufferStack.ApplyFilter#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@151)))
                             (Lit |filter#0@@3|)))
                      (a!6 (Buffers.BufferStack.ApplyFilter
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@151)))
                             (Lit |filter#0@@3|)))
                      (a!7 (PagedBetree.ChildMap.mapp
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit this@@151))))))
                (let ((a!2 (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                 (Lit this@@151)
                                 (Lit |filter#0@@3|))
                               (and ($Is this@@151
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |filter#0@@3|
                                         (TISet Tclass.KeyType.Key))
                                    (U_2_bool a!1))))
                      (a!8 (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                        (|lambda#245| (Lit |filter#0@@3|)
                                                      (|IMap#Elements| (Lit a!7))
                                                      |#PagedBetree.BetreeNode.Nil|)
                                        (TIMap Tclass.KeyType.Key
                                               Tclass.PagedBetree.BetreeNode))))
                (let ((a!9 (= (PagedBetree.BetreeNode.FilterBuffersAndChildren
                                (Lit this@@151)
                                (Lit |filter#0@@3|))
                              (ite (PagedBetree.BetreeNode.Nil_q
                                     (Lit this@@151))
                                   |#PagedBetree.BetreeNode.Nil|
                                   (|#PagedBetree.BetreeNode.BetreeNode|
                                     (Lit a!6)
                                     (|#PagedBetree.ChildMap.ChildMap| a!8))))))
                (let ((a!10 (and (=> (not (U_2_bool a!3)) (and a!4 a!5)) a!9)))
                  (=> (and (= (type this@@151) DatatypeTypeType)
                           (= (type |filter#0@@3|)
                              (MapType0Type BoxType boolType))
                           a!2)
                      a!10)))))
                :pattern ((PagedBetree.BetreeNode.FilterBuffersAndChildren
                            (Lit this@@151)
                            (Lit |filter#0@@3|)))
                :weight 3
                :skolemid |3129|
                :qid |PagedBetreeidfy.99:14|))))
  (=> true a!1)))
(assert (forall ((arg0@@569 T@U) (arg1@@288 T@U) (arg2@@162 T@U))
  (! (= (type (PagedBetree.BetreeNode.Split arg0@@569 arg1@@288 arg2@@162))
        DatatypeTypeType)
     :pattern ((PagedBetree.BetreeNode.Split arg0@@569 arg1@@288 arg2@@162))
     :qid |funType:PagedBetree.BetreeNode.Split|)))
(assert (let ((a!1 (forall ((this@@152 T@U) (|leftKeys#0| T@U) (|rightKeys#0| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Split#canCall|
                                 this@@152
                                 |leftKeys#0|
                                 |rightKeys#0|)
                               (and ($Is this@@152
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |leftKeys#0|
                                         (TISet Tclass.KeyType.Key))
                                    ($Is |rightKeys#0|
                                         (TISet Tclass.KeyType.Key))
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@152)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@152)))))
                  (=> (and (= (type this@@152) DatatypeTypeType)
                           (= (type |leftKeys#0|)
                              (MapType0Type BoxType boolType))
                           (= (type |rightKeys#0|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and (PagedBetree.BetreeNode.WF
                             ($LS $LZ)
                             (PagedBetree.BetreeNode.Split
                               this@@152
                               |leftKeys#0|
                               |rightKeys#0|))
                           ($Is (PagedBetree.BetreeNode.Split
                                  this@@152
                                  |leftKeys#0|
                                  |rightKeys#0|)
                                Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.BetreeNode.Split
                            this@@152
                            |leftKeys#0|
                            |rightKeys#0|))
                :skolemid |3130|
                :qid |PagedBetreeidfy.109:14|))))
  (=> true a!1)))
(assert (forall ((this@@153 T@U) (|leftKeys#0@@0| T@U) (|rightKeys#0@@0| T@U))
  (! (let ((a!1 (= (|PagedBetree.BetreeNode.Split#requires|
                     this@@153
                     |leftKeys#0@@0|
                     |rightKeys#0@@0|)
                   (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@153)
                        (PagedBetree.BetreeNode.BetreeNode_q this@@153)))))
       (=> (and (= (type this@@153) DatatypeTypeType)
                (= (type |leftKeys#0@@0|) (MapType0Type BoxType boolType))
                (= (type |rightKeys#0@@0|) (MapType0Type BoxType boolType))
                ($Is this@@153 Tclass.PagedBetree.BetreeNode)
                ($Is |leftKeys#0@@0| (TISet Tclass.KeyType.Key))
                ($Is |rightKeys#0@@0| (TISet Tclass.KeyType.Key)))
           a!1))
     :pattern ((|PagedBetree.BetreeNode.Split#requires|
                 this@@153
                 |leftKeys#0@@0|
                 |rightKeys#0@@0|))
     :skolemid |3131|
     :qid |PagedBetreeidfy.109:14|)))
(assert (forall ((arg0@@570 T@U)
         (arg1@@289 T@U)
         (arg2@@163 T@U)
         (arg3@@96 T@U)
         (arg4@@58 T@U)
         (arg5@@22 T@U)
         (arg6@@8 T@U))
  (! (= (type (|lambda#251| arg0@@570
                            arg1@@289
                            arg2@@163
                            arg3@@96
                            arg4@@58
                            arg5@@22
                            arg6@@8))
        (MapType0Type BoxType BoxType))
     :pattern ((|lambda#251| arg0@@570
                             arg1@@289
                             arg2@@163
                             arg3@@96
                             arg4@@58
                             arg5@@22
                             arg6@@8))
     :qid |funType:lambda#251|)))
(assert (let ((a!1 (forall ((this@@154 T@U)
                    (|leftKeys#0@@1| T@U)
                    (|rightKeys#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Split#canCall|
                                 this@@154
                                 |leftKeys#0@@1|
                                 |rightKeys#0@@1|)
                               (and ($Is this@@154
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |leftKeys#0@@1|
                                         (TISet Tclass.KeyType.Key))
                                    ($Is |rightKeys#0@@1|
                                         (TISet Tclass.KeyType.Key))
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@154)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@154))))
                      (a!2 (forall ((|key#0@@63| T@U))
                             (! (let ((a!1 (=> (U_2_bool (MapType0Select |leftKeys#0@@1|
                                                                         ($Box |key#0@@63|)))
                                               (and (|PagedBetree.BetreeNode.Child#canCall|
                                                      this@@154
                                                      |key#0@@63|)
                                                    (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                                      (PagedBetree.BetreeNode.Child
                                                        this@@154
                                                        |key#0@@63|)
                                                      |leftKeys#0@@1|))))
                                      (a!2 (not (U_2_bool (MapType0Select |leftKeys#0@@1|
                                                                          ($Box |key#0@@63|)))))
                                      (a!3 (=> (U_2_bool (MapType0Select |rightKeys#0@@1|
                                                                         ($Box |key#0@@63|)))
                                               (and (|PagedBetree.BetreeNode.Child#canCall|
                                                      this@@154
                                                      |key#0@@63|)
                                                    (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                                      (PagedBetree.BetreeNode.Child
                                                        this@@154
                                                        |key#0@@63|)
                                                      |rightKeys#0@@1|))))
                                      (a!4 (not (U_2_bool (MapType0Select |rightKeys#0@@1|
                                                                          ($Box |key#0@@63|))))))
                                (let ((a!5 (=> a!2
                                               (and a!3
                                                    (=> a!4
                                                        (|PagedBetree.BetreeNode.Child#canCall|
                                                          this@@154
                                                          |key#0@@63|))))))
                                  (=> (and (= (type |key#0@@63|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@63| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |key#0@@63|)
                                           (=> (Buffers.__default.AnyKey
                                                 |key#0@@63|)
                                               (and a!1 a!5))))))
                                :pattern ((MapType0Select |rightKeys#0@@1|
                                                          ($Box |key#0@@63|)))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            this@@154
                                            |key#0@@63|))
                                :pattern ((MapType0Select |leftKeys#0@@1|
                                                          ($Box |key#0@@63|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@63|))
                                :skolemid |3132|
                                :qid |PagedBetreeidfy.118:24|)))
                      (a!3 (|#PagedBetree.BetreeNode.BetreeNode|
                             (PagedBetree.BetreeNode.buffers this@@154)
                             (|#PagedBetree.ChildMap.ChildMap|
                               (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                            (|lambda#251| |leftKeys#0@@1|
                                                          this@@154
                                                          |leftKeys#0@@1|
                                                          |rightKeys#0@@1|
                                                          this@@154
                                                          |rightKeys#0@@1|
                                                          this@@154)
                                            (TIMap Tclass.KeyType.Key
                                                   Tclass.PagedBetree.BetreeNode))))))
                  (=> (and (= (type this@@154) DatatypeTypeType)
                           (= (type |leftKeys#0@@1|)
                              (MapType0Type BoxType boolType))
                           (= (type |rightKeys#0@@1|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and a!2
                           (= (PagedBetree.BetreeNode.Split
                                this@@154
                                |leftKeys#0@@1|
                                |rightKeys#0@@1|)
                              a!3))))
                :pattern ((PagedBetree.BetreeNode.Split
                            this@@154
                            |leftKeys#0@@1|
                            |rightKeys#0@@1|))
                :skolemid |3133|
                :qid |PagedBetreeidfy.109:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@155 T@U)
                    (|leftKeys#0@@2| T@U)
                    (|rightKeys#0@@2| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit this@@155)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                            (Lit this@@155)))))
                      (a!4 (forall ((|key#0@@64| T@U))
                             (! (let ((a!1 (and (|PagedBetree.BetreeNode.Child#canCall|
                                                  (Lit this@@155)
                                                  |key#0@@64|)
                                                (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                                  (PagedBetree.BetreeNode.Child
                                                    (Lit this@@155)
                                                    |key#0@@64|)
                                                  |leftKeys#0@@2|)))
                                      (a!3 (not (U_2_bool (MapType0Select |leftKeys#0@@2|
                                                                          ($Box |key#0@@64|)))))
                                      (a!4 (and (|PagedBetree.BetreeNode.Child#canCall|
                                                  (Lit this@@155)
                                                  |key#0@@64|)
                                                (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                                  (PagedBetree.BetreeNode.Child
                                                    (Lit this@@155)
                                                    |key#0@@64|)
                                                  |rightKeys#0@@2|)))
                                      (a!6 (not (U_2_bool (MapType0Select |rightKeys#0@@2|
                                                                          ($Box |key#0@@64|))))))
                                (let ((a!2 (=> (U_2_bool (MapType0Select |leftKeys#0@@2|
                                                                         ($Box |key#0@@64|)))
                                               a!1))
                                      (a!5 (=> (U_2_bool (MapType0Select |rightKeys#0@@2|
                                                                         ($Box |key#0@@64|)))
                                               a!4)))
                                (let ((a!7 (and a!5
                                                (=> a!6
                                                    (|PagedBetree.BetreeNode.Child#canCall|
                                                      (Lit this@@155)
                                                      |key#0@@64|)))))
                                (let ((a!8 (and (|Buffers.__default.AnyKey#canCall|
                                                  |key#0@@64|)
                                                (=> (Buffers.__default.AnyKey
                                                      |key#0@@64|)
                                                    (and a!2 (=> a!3 a!7))))))
                                  (=> (and (= (type |key#0@@64|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@64| Tclass.KeyType.Key))
                                      a!8)))))
                                :pattern ((MapType0Select |rightKeys#0@@2|
                                                          ($Box |key#0@@64|)))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            this@@155
                                            |key#0@@64|))
                                :pattern ((MapType0Select |leftKeys#0@@2|
                                                          ($Box |key#0@@64|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@64|))
                                :skolemid |3134|
                                :qid |PagedBetreeidfy.118:24|)))
                      (a!5 (|#PagedBetree.ChildMap.ChildMap|
                             (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                          (|lambda#251| |leftKeys#0@@2|
                                                        (Lit this@@155)
                                                        |leftKeys#0@@2|
                                                        |rightKeys#0@@2|
                                                        (Lit this@@155)
                                                        |rightKeys#0@@2|
                                                        (Lit this@@155))
                                          (TIMap Tclass.KeyType.Key
                                                 Tclass.PagedBetree.BetreeNode)))))
                (let ((a!3 (or (|PagedBetree.BetreeNode.Split#canCall|
                                 (Lit this@@155)
                                 |leftKeys#0@@2|
                                 |rightKeys#0@@2|)
                               (and ($Is this@@155
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |leftKeys#0@@2|
                                         (TISet Tclass.KeyType.Key))
                                    ($Is |rightKeys#0@@2|
                                         (TISet Tclass.KeyType.Key))
                                    (U_2_bool a!1)
                                    (U_2_bool a!2))))
                      (a!6 (|#PagedBetree.BetreeNode.BetreeNode|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@155)))
                             a!5)))
                (let ((a!7 (and a!4
                                (= (PagedBetree.BetreeNode.Split
                                     (Lit this@@155)
                                     |leftKeys#0@@2|
                                     |rightKeys#0@@2|)
                                   a!6))))
                  (=> (and (= (type this@@155) DatatypeTypeType)
                           (= (type |leftKeys#0@@2|)
                              (MapType0Type BoxType boolType))
                           (= (type |rightKeys#0@@2|)
                              (MapType0Type BoxType boolType))
                           a!3)
                      a!7))))
                :pattern ((PagedBetree.BetreeNode.Split
                            (Lit this@@155)
                            |leftKeys#0@@2|
                            |rightKeys#0@@2|))
                :weight 3
                :skolemid |3135|
                :qid |PagedBetreeidfy.109:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@156 T@U)
                    (|leftKeys#0@@3| T@U)
                    (|rightKeys#0@@3| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit this@@156)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                            (Lit this@@156)))))
                      (a!4 (forall ((|key#0@@65| T@U))
                             (! (let ((a!1 (and (|PagedBetree.BetreeNode.Child#canCall|
                                                  (Lit this@@156)
                                                  |key#0@@65|)
                                                (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                                  (PagedBetree.BetreeNode.Child
                                                    (Lit this@@156)
                                                    |key#0@@65|)
                                                  (Lit |leftKeys#0@@3|))))
                                      (a!3 (not (U_2_bool (MapType0Select (Lit |leftKeys#0@@3|)
                                                                          ($Box |key#0@@65|)))))
                                      (a!4 (and (|PagedBetree.BetreeNode.Child#canCall|
                                                  (Lit this@@156)
                                                  |key#0@@65|)
                                                (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall|
                                                  (PagedBetree.BetreeNode.Child
                                                    (Lit this@@156)
                                                    |key#0@@65|)
                                                  (Lit |rightKeys#0@@3|))))
                                      (a!6 (not (U_2_bool (MapType0Select (Lit |rightKeys#0@@3|)
                                                                          ($Box |key#0@@65|))))))
                                (let ((a!2 (=> (U_2_bool (MapType0Select (Lit |leftKeys#0@@3|)
                                                                         ($Box |key#0@@65|)))
                                               a!1))
                                      (a!5 (=> (U_2_bool (MapType0Select (Lit |rightKeys#0@@3|)
                                                                         ($Box |key#0@@65|)))
                                               a!4)))
                                (let ((a!7 (and a!5
                                                (=> a!6
                                                    (|PagedBetree.BetreeNode.Child#canCall|
                                                      (Lit this@@156)
                                                      |key#0@@65|)))))
                                (let ((a!8 (and (|Buffers.__default.AnyKey#canCall|
                                                  |key#0@@65|)
                                                (=> (Buffers.__default.AnyKey
                                                      |key#0@@65|)
                                                    (and a!2 (=> a!3 a!7))))))
                                  (=> (and (= (type |key#0@@65|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@65| Tclass.KeyType.Key))
                                      a!8)))))
                                :pattern ((MapType0Select |rightKeys#0@@3|
                                                          ($Box |key#0@@65|)))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            this@@156
                                            |key#0@@65|))
                                :pattern ((MapType0Select |leftKeys#0@@3|
                                                          ($Box |key#0@@65|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@65|))
                                :skolemid |3136|
                                :qid |PagedBetreeidfy.118:24|)))
                      (a!5 (|#PagedBetree.ChildMap.ChildMap|
                             (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                          (|lambda#251| (Lit |leftKeys#0@@3|)
                                                        (Lit this@@156)
                                                        (Lit |leftKeys#0@@3|)
                                                        (Lit |rightKeys#0@@3|)
                                                        (Lit this@@156)
                                                        (Lit |rightKeys#0@@3|)
                                                        (Lit this@@156))
                                          (TIMap Tclass.KeyType.Key
                                                 Tclass.PagedBetree.BetreeNode)))))
                (let ((a!3 (or (|PagedBetree.BetreeNode.Split#canCall|
                                 (Lit this@@156)
                                 (Lit |leftKeys#0@@3|)
                                 (Lit |rightKeys#0@@3|))
                               (and ($Is this@@156
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |leftKeys#0@@3|
                                         (TISet Tclass.KeyType.Key))
                                    ($Is |rightKeys#0@@3|
                                         (TISet Tclass.KeyType.Key))
                                    (U_2_bool a!1)
                                    (U_2_bool a!2))))
                      (a!6 (|#PagedBetree.BetreeNode.BetreeNode|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@156)))
                             a!5)))
                (let ((a!7 (and a!4
                                (= (PagedBetree.BetreeNode.Split
                                     (Lit this@@156)
                                     (Lit |leftKeys#0@@3|)
                                     (Lit |rightKeys#0@@3|))
                                   a!6))))
                  (=> (and (= (type this@@156) DatatypeTypeType)
                           (= (type |leftKeys#0@@3|)
                              (MapType0Type BoxType boolType))
                           (= (type |rightKeys#0@@3|)
                              (MapType0Type BoxType boolType))
                           a!3)
                      a!7))))
                :pattern ((PagedBetree.BetreeNode.Split
                            (Lit this@@156)
                            (Lit |leftKeys#0@@3|)
                            (Lit |rightKeys#0@@3|)))
                :weight 3
                :skolemid |3137|
                :qid |PagedBetreeidfy.109:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@157 T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Promote#canCall|
                                 this@@157)
                               (and ($Is this@@157
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@157)))))
                  (=> (and (= (type this@@157) DatatypeTypeType) a!1)
                      (and (PagedBetree.BetreeNode.WF
                             ($LS $LZ)
                             (PagedBetree.BetreeNode.Promote this@@157))
                           ($Is (PagedBetree.BetreeNode.Promote this@@157)
                                Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.BetreeNode.Promote this@@157))
                :skolemid |3138|
                :qid |PagedBetreeidfy.129:14|))))
  (=> true a!1)))
(assert (forall ((this@@158 T@U))
  (! (=> (and (= (type this@@158) DatatypeTypeType)
              ($Is this@@158 Tclass.PagedBetree.BetreeNode))
         (= (|PagedBetree.BetreeNode.Promote#requires| this@@158)
            (PagedBetree.BetreeNode.WF ($LS $LZ) this@@158)))
     :pattern ((|PagedBetree.BetreeNode.Promote#requires| this@@158))
     :skolemid |3139|
     :qid |PagedBetreeidfy.129:14|)))
(assert (= (type PagedBetree.__default.EmptyRoot) DatatypeTypeType))
(assert (let ((a!1 (forall ((this@@159 T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Promote#canCall|
                                 this@@159)
                               (and ($Is this@@159
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@159))))
                      (a!2 (and (=> (PagedBetree.BetreeNode.Nil_q this@@159)
                                    |PagedBetree.__default.EmptyRoot#canCall|)
                                (= (PagedBetree.BetreeNode.Promote this@@159)
                                   (ite (PagedBetree.BetreeNode.Nil_q this@@159)
                                        PagedBetree.__default.EmptyRoot
                                        this@@159)))))
                  (=> (and (= (type this@@159) DatatypeTypeType) a!1) a!2))
                :pattern ((PagedBetree.BetreeNode.Promote this@@159))
                :skolemid |3140|
                :qid |PagedBetreeidfy.129:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@160 T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit this@@160)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q
                                            (Lit this@@160)))))
                      (a!4 (= (PagedBetree.BetreeNode.Promote (Lit this@@160))
                              (ite (PagedBetree.BetreeNode.Nil_q
                                     (Lit this@@160))
                                   PagedBetree.__default.EmptyRoot
                                   this@@160))))
                (let ((a!2 (and (= (type this@@160) DatatypeTypeType)
                                (or (|PagedBetree.BetreeNode.Promote#canCall|
                                      (Lit this@@160))
                                    (and ($Is this@@160
                                              Tclass.PagedBetree.BetreeNode)
                                         (U_2_bool a!1))))))
                  (=> a!2
                      (and (=> (U_2_bool a!3)
                               |PagedBetree.__default.EmptyRoot#canCall|)
                           a!4))))
                :pattern ((PagedBetree.BetreeNode.Promote (Lit this@@160)))
                :weight 3
                :skolemid |3141|
                :qid |PagedBetreeidfy.129:14|))))
  (=> true a!1)))
(assert (forall ((arg0@@571 T@U) (arg1@@290 T@U))
  (! (= (type (PagedBetree.BetreeNode.Flush arg0@@571 arg1@@290))
        DatatypeTypeType)
     :pattern ((PagedBetree.BetreeNode.Flush arg0@@571 arg1@@290))
     :qid |funType:PagedBetree.BetreeNode.Flush|)))
(assert (let ((a!1 (forall ((this@@161 T@U) (|downKeys#0| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Flush#canCall|
                                 this@@161
                                 |downKeys#0|)
                               (and ($Is this@@161
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |downKeys#0|
                                         (TISet Tclass.KeyType.Key))
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@161)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@161)))))
                  (=> (and (= (type this@@161) DatatypeTypeType)
                           (= (type |downKeys#0|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and (PagedBetree.BetreeNode.WF
                             ($LS $LZ)
                             (PagedBetree.BetreeNode.Flush
                               this@@161
                               |downKeys#0|))
                           ($Is (PagedBetree.BetreeNode.Flush
                                  this@@161
                                  |downKeys#0|)
                                Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.BetreeNode.Flush this@@161 |downKeys#0|))
                :skolemid |3142|
                :qid |PagedBetreeidfy.136:14|))))
  (=> true a!1)))
(assert (forall ((this@@162 T@U) (|downKeys#0@@0| T@U))
  (! (let ((a!1 (= (|PagedBetree.BetreeNode.Flush#requires|
                     this@@162
                     |downKeys#0@@0|)
                   (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@162)
                        (PagedBetree.BetreeNode.BetreeNode_q this@@162)))))
       (=> (and (= (type this@@162) DatatypeTypeType)
                (= (type |downKeys#0@@0|) (MapType0Type BoxType boolType))
                ($Is this@@162 Tclass.PagedBetree.BetreeNode)
                ($Is |downKeys#0@@0| (TISet Tclass.KeyType.Key)))
           a!1))
     :pattern ((|PagedBetree.BetreeNode.Flush#requires|
                 this@@162
                 |downKeys#0@@0|))
     :skolemid |3143|
     :qid |PagedBetreeidfy.136:14|)))
(assert (forall ((arg0@@572 T@U) (arg1@@291 T@U) (arg2@@164 T@U) (arg3@@97 T@U))
  (! (= (type (|lambda#257| arg0@@572 arg1@@291 arg2@@164 arg3@@97))
        (MapType0Type BoxType BoxType))
     :pattern ((|lambda#257| arg0@@572 arg1@@291 arg2@@164 arg3@@97))
     :qid |funType:lambda#257|)))
(assert (let ((a!1 (forall ((this@@163 T@U) (|downKeys#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetree.BetreeNode.Flush#canCall|
                                 this@@163
                                 |downKeys#0@@1|)
                               (and ($Is this@@163
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |downKeys#0@@1|
                                         (TISet Tclass.KeyType.Key))
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      this@@163)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      this@@163))))
                      (a!2 (forall ((|key#0@@66| T@U))
                             (! (let ((a!1 (and (|PagedBetree.BetreeNode.Child#canCall|
                                                  this@@163
                                                  |key#0@@66|)
                                                (|PagedBetree.BetreeNode.Promote#canCall|
                                                  (PagedBetree.BetreeNode.Child
                                                    this@@163
                                                    |key#0@@66|))
                                                (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                                                  (PagedBetree.BetreeNode.Promote
                                                    (PagedBetree.BetreeNode.Child
                                                      this@@163
                                                      |key#0@@66|))
                                                  (Buffers.BufferStack.ApplyFilter
                                                    (PagedBetree.BetreeNode.buffers
                                                      this@@163)
                                                    |downKeys#0@@1|))))
                                      (a!3 (not (U_2_bool (MapType0Select |downKeys#0@@1|
                                                                          ($Box |key#0@@66|))))))
                                (let ((a!2 (=> (U_2_bool (MapType0Select |downKeys#0@@1|
                                                                         ($Box |key#0@@66|)))
                                               a!1)))
                                (let ((a!4 (=> (Buffers.__default.AnyKey
                                                 |key#0@@66|)
                                               (and a!2
                                                    (=> a!3
                                                        (|PagedBetree.BetreeNode.Child#canCall|
                                                          this@@163
                                                          |key#0@@66|))))))
                                  (=> (and (= (type |key#0@@66|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@66| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |key#0@@66|)
                                           a!4)))))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            this@@163
                                            |key#0@@66|))
                                :pattern ((MapType0Select |downKeys#0@@1|
                                                          ($Box |key#0@@66|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@66|))
                                :skolemid |3144|
                                :qid |PagedBetreeidfy.145:40|)))
                      (a!3 (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                        (|lambda#257| |downKeys#0@@1|
                                                      this@@163
                                                      (Buffers.BufferStack.ApplyFilter
                                                        (PagedBetree.BetreeNode.buffers
                                                          this@@163)
                                                        |downKeys#0@@1|)
                                                      this@@163)
                                        (TIMap Tclass.KeyType.Key
                                               Tclass.PagedBetree.BetreeNode))))
                (let ((a!4 (= (PagedBetree.BetreeNode.Flush
                                this@@163
                                |downKeys#0@@1|)
                              (|#PagedBetree.BetreeNode.BetreeNode|
                                (Buffers.BufferStack.ApplyFilter
                                  (PagedBetree.BetreeNode.buffers this@@163)
                                  (|ISet#Difference|
                                    Buffers.__default.AllKeys
                                    |downKeys#0@@1|))
                                (|#PagedBetree.ChildMap.ChildMap| a!3)))))
                  (=> (and (= (type this@@163) DatatypeTypeType)
                           (= (type |downKeys#0@@1|)
                              (MapType0Type BoxType boolType))
                           a!1)
                      (and |Buffers.__default.AllKeys#canCall|
                           (|Buffers.BufferStack.ApplyFilter#canCall|
                             (PagedBetree.BetreeNode.buffers this@@163)
                             (|ISet#Difference|
                               Buffers.__default.AllKeys
                               |downKeys#0@@1|))
                           (|Buffers.BufferStack.ApplyFilter#canCall|
                             (PagedBetree.BetreeNode.buffers this@@163)
                             |downKeys#0@@1|)
                           a!2
                           a!4))))
                :pattern ((PagedBetree.BetreeNode.Flush
                            this@@163
                            |downKeys#0@@1|))
                :skolemid |3145|
                :qid |PagedBetreeidfy.136:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@164 T@U) (|downKeys#0@@2| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit this@@164)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                            (Lit this@@164)))))
                      (a!4 (|Buffers.BufferStack.ApplyFilter#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@164)))
                             (|ISet#Difference|
                               Buffers.__default.AllKeys
                               |downKeys#0@@2|)))
                      (a!5 (|Buffers.BufferStack.ApplyFilter#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@164)))
                             |downKeys#0@@2|))
                      (a!6 (forall ((|key#0@@67| T@U))
                             (! (let ((a!1 (Buffers.BufferStack.ApplyFilter
                                             (Lit (PagedBetree.BetreeNode.buffers
                                                    (Lit this@@164)))
                                             |downKeys#0@@2|))
                                      (a!5 (not (U_2_bool (MapType0Select |downKeys#0@@2|
                                                                          ($Box |key#0@@67|))))))
                                (let ((a!2 (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                                             (PagedBetree.BetreeNode.Promote
                                               (PagedBetree.BetreeNode.Child
                                                 (Lit this@@164)
                                                 |key#0@@67|))
                                             a!1)))
                                (let ((a!3 (and (|PagedBetree.BetreeNode.Child#canCall|
                                                  (Lit this@@164)
                                                  |key#0@@67|)
                                                (|PagedBetree.BetreeNode.Promote#canCall|
                                                  (PagedBetree.BetreeNode.Child
                                                    (Lit this@@164)
                                                    |key#0@@67|))
                                                a!2)))
                                (let ((a!4 (=> (U_2_bool (MapType0Select |downKeys#0@@2|
                                                                         ($Box |key#0@@67|)))
                                               a!3)))
                                (let ((a!6 (and a!4
                                                (=> a!5
                                                    (|PagedBetree.BetreeNode.Child#canCall|
                                                      (Lit this@@164)
                                                      |key#0@@67|)))))
                                  (=> (and (= (type |key#0@@67|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@67| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |key#0@@67|)
                                           (=> (Buffers.__default.AnyKey
                                                 |key#0@@67|)
                                               a!6))))))))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            this@@164
                                            |key#0@@67|))
                                :pattern ((MapType0Select |downKeys#0@@2|
                                                          ($Box |key#0@@67|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@67|))
                                :skolemid |3146|
                                :qid |PagedBetreeidfy.145:40|)))
                      (a!7 (Buffers.BufferStack.ApplyFilter
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@164)))
                             (|ISet#Difference|
                               Buffers.__default.AllKeys
                               |downKeys#0@@2|)))
                      (a!8 (Buffers.BufferStack.ApplyFilter
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@164)))
                             |downKeys#0@@2|)))
                (let ((a!3 (or (|PagedBetree.BetreeNode.Flush#canCall|
                                 (Lit this@@164)
                                 |downKeys#0@@2|)
                               (and ($Is this@@164
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |downKeys#0@@2|
                                         (TISet Tclass.KeyType.Key))
                                    (U_2_bool a!1)
                                    (U_2_bool a!2))))
                      (a!9 (|#PagedBetree.ChildMap.ChildMap|
                             (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                          (|lambda#257| |downKeys#0@@2|
                                                        (Lit this@@164)
                                                        a!8
                                                        (Lit this@@164))
                                          (TIMap Tclass.KeyType.Key
                                                 Tclass.PagedBetree.BetreeNode)))))
                (let ((a!10 (and |Buffers.__default.AllKeys#canCall|
                                 a!4
                                 a!5
                                 a!6
                                 (= (PagedBetree.BetreeNode.Flush
                                      (Lit this@@164)
                                      |downKeys#0@@2|)
                                    (|#PagedBetree.BetreeNode.BetreeNode|
                                      a!7
                                      a!9)))))
                  (=> (and (= (type this@@164) DatatypeTypeType)
                           (= (type |downKeys#0@@2|)
                              (MapType0Type BoxType boolType))
                           a!3)
                      a!10))))
                :pattern ((PagedBetree.BetreeNode.Flush
                            (Lit this@@164)
                            |downKeys#0@@2|))
                :weight 3
                :skolemid |3147|
                :qid |PagedBetreeidfy.136:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@165 T@U) (|downKeys#0@@3| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit this@@165)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                            (Lit this@@165)))))
                      (a!4 (|Buffers.BufferStack.ApplyFilter#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@165)))
                             (|ISet#Difference|
                               Buffers.__default.AllKeys
                               |downKeys#0@@3|)))
                      (a!5 (|Buffers.BufferStack.ApplyFilter#canCall|
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@165)))
                             (Lit |downKeys#0@@3|)))
                      (a!6 (forall ((|key#0@@68| T@U))
                             (! (let ((a!1 (Buffers.BufferStack.ApplyFilter
                                             (Lit (PagedBetree.BetreeNode.buffers
                                                    (Lit this@@165)))
                                             (Lit |downKeys#0@@3|)))
                                      (a!5 (not (U_2_bool (MapType0Select (Lit |downKeys#0@@3|)
                                                                          ($Box |key#0@@68|))))))
                                (let ((a!2 (|PagedBetree.BetreeNode.PushBufferStack#canCall|
                                             (PagedBetree.BetreeNode.Promote
                                               (PagedBetree.BetreeNode.Child
                                                 (Lit this@@165)
                                                 |key#0@@68|))
                                             (Lit a!1))))
                                (let ((a!3 (and (|PagedBetree.BetreeNode.Child#canCall|
                                                  (Lit this@@165)
                                                  |key#0@@68|)
                                                (|PagedBetree.BetreeNode.Promote#canCall|
                                                  (PagedBetree.BetreeNode.Child
                                                    (Lit this@@165)
                                                    |key#0@@68|))
                                                a!2)))
                                (let ((a!4 (=> (U_2_bool (MapType0Select (Lit |downKeys#0@@3|)
                                                                         ($Box |key#0@@68|)))
                                               a!3)))
                                (let ((a!6 (and a!4
                                                (=> a!5
                                                    (|PagedBetree.BetreeNode.Child#canCall|
                                                      (Lit this@@165)
                                                      |key#0@@68|)))))
                                  (=> (and (= (type |key#0@@68|)
                                              (SeqType BoxType))
                                           ($Is |key#0@@68| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |key#0@@68|)
                                           (=> (Buffers.__default.AnyKey
                                                 |key#0@@68|)
                                               a!6))))))))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            this@@165
                                            |key#0@@68|))
                                :pattern ((MapType0Select |downKeys#0@@3|
                                                          ($Box |key#0@@68|)))
                                :pattern ((Buffers.__default.AnyKey |key#0@@68|))
                                :skolemid |3148|
                                :qid |PagedBetreeidfy.145:40|)))
                      (a!7 (Buffers.BufferStack.ApplyFilter
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@165)))
                             (|ISet#Difference|
                               Buffers.__default.AllKeys
                               |downKeys#0@@3|)))
                      (a!8 (Buffers.BufferStack.ApplyFilter
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit this@@165)))
                             (Lit |downKeys#0@@3|))))
                (let ((a!3 (or (|PagedBetree.BetreeNode.Flush#canCall|
                                 (Lit this@@165)
                                 (Lit |downKeys#0@@3|))
                               (and ($Is this@@165
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |downKeys#0@@3|
                                         (TISet Tclass.KeyType.Key))
                                    (U_2_bool a!1)
                                    (U_2_bool a!2))))
                      (a!9 (|#PagedBetree.ChildMap.ChildMap|
                             (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                          (|lambda#257| (Lit |downKeys#0@@3|)
                                                        (Lit this@@165)
                                                        (Lit a!8)
                                                        (Lit this@@165))
                                          (TIMap Tclass.KeyType.Key
                                                 Tclass.PagedBetree.BetreeNode)))))
                (let ((a!10 (and |Buffers.__default.AllKeys#canCall|
                                 a!4
                                 a!5
                                 a!6
                                 (= (PagedBetree.BetreeNode.Flush
                                      (Lit this@@165)
                                      (Lit |downKeys#0@@3|))
                                    (|#PagedBetree.BetreeNode.BetreeNode|
                                      a!7
                                      a!9)))))
                  (=> (and (= (type this@@165) DatatypeTypeType)
                           (= (type |downKeys#0@@3|)
                              (MapType0Type BoxType boolType))
                           a!3)
                      a!10))))
                :pattern ((PagedBetree.BetreeNode.Flush
                            (Lit this@@165)
                            (Lit |downKeys#0@@3|)))
                :weight 3
                :skolemid |3149|
                :qid |PagedBetreeidfy.136:14|))))
  (=> true a!1)))
(assert (forall ((|a#0#0#0@@7| T@U) (|a#0#1#0@@4| T@U))
  (! (=> (and (= (type |a#0#0#0@@7|) DatatypeTypeType)
              (= (type |a#0#1#0@@4|) DatatypeTypeType))
         (= (DatatypeCtorId (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                              |a#0#0#0@@7|
                              |a#0#1#0@@4|))
            |##PagedBetree.QueryReceiptLine.QueryReceiptLine|))
     :pattern ((|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                 |a#0#0#0@@7|
                 |a#0#1#0@@4|))
     :skolemid |3150|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((d@@105 T@U))
  (! (=> (= (type d@@105) DatatypeTypeType)
         (= (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@105)
            (= (DatatypeCtorId d@@105)
               |##PagedBetree.QueryReceiptLine.QueryReceiptLine|)))
     :pattern ((PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@105))
     :skolemid |3151|
     :qid |unknown.0:0|)))
(assert (forall ((d@@106 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@7| T@U) (|a#1#1#0@@4| T@U))
                  (! (and (= (type |a#1#0#0@@7|) DatatypeTypeType)
                          (= (type |a#1#1#0@@4|) DatatypeTypeType)
                          (= d@@106
                             (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                               |a#1#0#0@@7|
                               |a#1#1#0@@4|)))
                     :no-pattern (type |a#1#0#0@@7|)
                     :no-pattern (type |a#1#1#0@@4|)
                     :no-pattern (U_2_int |a#1#0#0@@7|)
                     :no-pattern (U_2_bool |a#1#0#0@@7|)
                     :no-pattern (U_2_int |a#1#1#0@@4|)
                     :no-pattern (U_2_bool |a#1#1#0@@4|)
                     :skolemid |3152|
                     :qid |PagedBetreeidfy.161:5|))))
       (=> (and (= (type d@@106) DatatypeTypeType)
                (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@106))
           a!1))
     :pattern ((PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@106))
     :skolemid |3153|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@7| T@U) (|a#2#1#0@@4| T@U))
  (! (=> (and (= (type |a#2#0#0@@7|) DatatypeTypeType)
              (= (type |a#2#1#0@@4|) DatatypeTypeType))
         (= ($Is (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                   |a#2#0#0@@7|
                   |a#2#1#0@@4|)
                 Tclass.PagedBetree.QueryReceiptLine)
            (and ($Is |a#2#0#0@@7| Tclass.PagedBetree.BetreeNode)
                 ($Is |a#2#1#0@@4| Tclass.ValueMessage.Message))))
     :pattern (($Is (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                      |a#2#0#0@@7|
                      |a#2#1#0@@4|)
                    Tclass.PagedBetree.QueryReceiptLine))
     :skolemid |3154|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((|a#3#0#0@@7| T@U) (|a#3#1#0@@4| T@U) ($h@@127 T@U))
  (! (=> (and (= (type |a#3#0#0@@7|) DatatypeTypeType)
              (= (type |a#3#1#0@@4|) DatatypeTypeType)
              (= (type $h@@127) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@127))
         (= ($IsAlloc (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                        |a#3#0#0@@7|
                        |a#3#1#0@@4|)
                      Tclass.PagedBetree.QueryReceiptLine
                      $h@@127)
            (and ($IsAlloc |a#3#0#0@@7| Tclass.PagedBetree.BetreeNode $h@@127)
                 ($IsAlloc |a#3#1#0@@4| Tclass.ValueMessage.Message $h@@127))))
     :pattern (($IsAlloc (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                           |a#3#0#0@@7|
                           |a#3#1#0@@4|)
                         Tclass.PagedBetree.QueryReceiptLine
                         $h@@127))
     :skolemid |3155|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((arg0@@573 T@U))
  (! (= (type (PagedBetree.QueryReceiptLine.node arg0@@573)) DatatypeTypeType)
     :pattern ((PagedBetree.QueryReceiptLine.node arg0@@573))
     :qid |funType:PagedBetree.QueryReceiptLine.node|)))
(assert (forall ((d@@107 T@U) ($h@@128 T@U))
  (! (=> (and (= (type d@@107) DatatypeTypeType)
              (= (type $h@@128) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@128)
              (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@107)
              ($IsAlloc d@@107 Tclass.PagedBetree.QueryReceiptLine $h@@128))
         ($IsAlloc (PagedBetree.QueryReceiptLine.node d@@107)
                   Tclass.PagedBetree.BetreeNode
                   $h@@128))
     :pattern (($IsAlloc (PagedBetree.QueryReceiptLine.node d@@107)
                         Tclass.PagedBetree.BetreeNode
                         $h@@128))
     :skolemid |3156|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@574 T@U))
  (! (= (type (PagedBetree.QueryReceiptLine.result arg0@@574)) DatatypeTypeType)
     :pattern ((PagedBetree.QueryReceiptLine.result arg0@@574))
     :qid |funType:PagedBetree.QueryReceiptLine.result|)))
(assert (forall ((d@@108 T@U) ($h@@129 T@U))
  (! (=> (and (= (type d@@108) DatatypeTypeType)
              (= (type $h@@129) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@129)
              (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@108)
              ($IsAlloc d@@108 Tclass.PagedBetree.QueryReceiptLine $h@@129))
         ($IsAlloc (PagedBetree.QueryReceiptLine.result d@@108)
                   Tclass.ValueMessage.Message
                   $h@@129))
     :pattern (($IsAlloc (PagedBetree.QueryReceiptLine.result d@@108)
                         Tclass.ValueMessage.Message
                         $h@@129))
     :skolemid |3157|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@7| T@U) (|a#4#1#0@@4| T@U))
  (! (=> (and (= (type |a#4#0#0@@7|) DatatypeTypeType)
              (= (type |a#4#1#0@@4|) DatatypeTypeType))
         (= (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
              (Lit |a#4#0#0@@7|)
              (Lit |a#4#1#0@@4|))
            (Lit (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                   |a#4#0#0@@7|
                   |a#4#1#0@@4|))))
     :pattern ((|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                 (Lit |a#4#0#0@@7|)
                 (Lit |a#4#1#0@@4|)))
     :skolemid |3158|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((|a#5#0#0@@9| T@U) (|a#5#1#0@@5| T@U))
  (! (=> (and (= (type |a#5#0#0@@9|) DatatypeTypeType)
              (= (type |a#5#1#0@@5|) DatatypeTypeType))
         (= (PagedBetree.QueryReceiptLine.node
              (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                |a#5#0#0@@9|
                |a#5#1#0@@5|))
            |a#5#0#0@@9|))
     :pattern ((|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                 |a#5#0#0@@9|
                 |a#5#1#0@@5|))
     :skolemid |3159|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((|a#6#0#0@@9| T@U) (|a#6#1#0@@5| T@U))
  (! (=> (and (= (type |a#6#0#0@@9|) DatatypeTypeType)
              (= (type |a#6#1#0@@5|) DatatypeTypeType))
         (< (DtRank |a#6#0#0@@9|)
            (DtRank (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                      |a#6#0#0@@9|
                      |a#6#1#0@@5|))))
     :pattern ((|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                 |a#6#0#0@@9|
                 |a#6#1#0@@5|))
     :skolemid |3160|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((|a#7#0#0@@9| T@U) (|a#7#1#0@@5| T@U))
  (! (=> (and (= (type |a#7#0#0@@9|) DatatypeTypeType)
              (= (type |a#7#1#0@@5|) DatatypeTypeType))
         (= (PagedBetree.QueryReceiptLine.result
              (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                |a#7#0#0@@9|
                |a#7#1#0@@5|))
            |a#7#1#0@@5|))
     :pattern ((|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                 |a#7#0#0@@9|
                 |a#7#1#0@@5|))
     :skolemid |3161|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((|a#8#0#0@@6| T@U) (|a#8#1#0@@3| T@U))
  (! (=> (and (= (type |a#8#0#0@@6|) DatatypeTypeType)
              (= (type |a#8#1#0@@3|) DatatypeTypeType))
         (< (DtRank |a#8#1#0@@3|)
            (DtRank (|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                      |a#8#0#0@@6|
                      |a#8#1#0@@3|))))
     :pattern ((|#PagedBetree.QueryReceiptLine.QueryReceiptLine|
                 |a#8#0#0@@6|
                 |a#8#1#0@@3|))
     :skolemid |3162|
     :qid |PagedBetreeidfy.161:5|)))
(assert (forall ((d@@109 T@U))
  (! (=> (and (= (type d@@109) DatatypeTypeType)
              (|$IsA#PagedBetree.QueryReceiptLine| d@@109))
         (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@109))
     :pattern ((|$IsA#PagedBetree.QueryReceiptLine| d@@109))
     :skolemid |3163|
     :qid |unknown.0:0|)))
(assert (forall ((d@@110 T@U))
  (! (=> (and (= (type d@@110) DatatypeTypeType)
              ($Is d@@110 Tclass.PagedBetree.QueryReceiptLine))
         (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@110))
     :pattern ((PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@110)
               ($Is d@@110 Tclass.PagedBetree.QueryReceiptLine))
     :skolemid |3164|
     :qid |unknown.0:0|)))
(assert (forall ((a@@149 T@U) (b@@99 T@U))
  (! (let ((a!1 (= (|PagedBetree.QueryReceiptLine#Equal| a@@149 b@@99)
                   (and (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.QueryReceiptLine.node a@@149)
                          (PagedBetree.QueryReceiptLine.node b@@99))
                        (|ValueMessage.Message#Equal|
                          (PagedBetree.QueryReceiptLine.result a@@149)
                          (PagedBetree.QueryReceiptLine.result b@@99))))))
       (=> (and (= (type a@@149) DatatypeTypeType)
                (= (type b@@99) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|PagedBetree.QueryReceiptLine#Equal| a@@149 b@@99))
     :skolemid |3165|
     :qid |unknown.0:0|)))
(assert (forall ((a@@150 T@U) (b@@100 T@U))
  (! (=> (and (= (type a@@150) DatatypeTypeType)
              (= (type b@@100) DatatypeTypeType))
         (= (|PagedBetree.QueryReceiptLine#Equal| a@@150 b@@100)
            (= a@@150 b@@100)))
     :pattern ((|PagedBetree.QueryReceiptLine#Equal| a@@150 b@@100))
     :skolemid |3166|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((this@@166 T@U))
             (! (=> (and (= (type this@@166) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceiptLine.WF#canCall|
                               this@@166)
                             ($Is this@@166 Tclass.PagedBetree.QueryReceiptLine)))
                    true)
                :pattern ((PagedBetree.QueryReceiptLine.WF this@@166))
                :skolemid |3167|
                :qid |PagedBetreeidfy.164:15|))))
  (=> true a!1)))
(assert (forall ((this@@167 T@U))
  (! (=> (and (= (type this@@167) DatatypeTypeType)
              ($Is this@@167 Tclass.PagedBetree.QueryReceiptLine))
         (= (|PagedBetree.QueryReceiptLine.WF#requires| this@@167) true))
     :pattern ((|PagedBetree.QueryReceiptLine.WF#requires| this@@167))
     :skolemid |3168|
     :qid |PagedBetreeidfy.164:15|)))
(assert (let ((a!1 (forall ((this@@168 T@U))
             (! (let ((a!1 (= (PagedBetree.QueryReceiptLine.WF this@@168)
                              (and (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (PagedBetree.QueryReceiptLine.node
                                       this@@168))
                                   (ValueMessage.Message.Define_q
                                     (PagedBetree.QueryReceiptLine.result
                                       this@@168))))))
                (let ((a!2 (and (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                  this@@168)
                                (|PagedBetree.BetreeNode.WF#canCall|
                                  (PagedBetree.QueryReceiptLine.node this@@168))
                                (=> (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      (PagedBetree.QueryReceiptLine.node
                                        this@@168))
                                    (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                      this@@168))
                                a!1)))
                  (=> (and (= (type this@@168) DatatypeTypeType)
                           (or (|PagedBetree.QueryReceiptLine.WF#canCall|
                                 this@@168)
                               ($Is this@@168
                                    Tclass.PagedBetree.QueryReceiptLine)))
                      a!2)))
                :pattern ((PagedBetree.QueryReceiptLine.WF this@@168))
                :skolemid |3169|
                :qid |PagedBetreeidfy.164:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@169 T@U))
      (! (let ((a!1 (and (= (type this@@169) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceiptLine.WF#canCall|
                               (Lit this@@169))
                             ($Is this@@169 Tclass.PagedBetree.QueryReceiptLine))))
               (a!2 (|PagedBetree.BetreeNode.WF#canCall|
                      (Lit (PagedBetree.QueryReceiptLine.node (Lit this@@169)))))
               (a!3 (PagedBetree.BetreeNode.WF
                      ($LS $LZ)
                      (Lit (PagedBetree.QueryReceiptLine.node (Lit this@@169)))))
               (a!5 (ValueMessage.Message.Define_q
                      (Lit (PagedBetree.QueryReceiptLine.result (Lit this@@169))))))
         (let ((a!4 (=> (U_2_bool (Lit (bool_2_U a!3)))
                        (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                          (Lit this@@169))))
               (a!6 (U_2_bool (Lit (bool_2_U (and a!3 a!5))))))
         (let ((a!7 (and (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                           (Lit this@@169))
                         a!2
                         a!4
                         (= (PagedBetree.QueryReceiptLine.WF (Lit this@@169))
                            a!6))))
           (=> a!1 a!7))))
         :pattern ((PagedBetree.QueryReceiptLine.WF (Lit this@@169)))
         :weight 3
         :skolemid |3170|
         :qid |PagedBetreeidfy.164:15|))))
(assert (forall ((|a#0#0#0@@8| T@U) (|a#0#1#0@@5| T@U) (|a#0#2#0@@0| T@U))
  (! (=> (and (= (type |a#0#0#0@@8|) (SeqType BoxType))
              (= (type |a#0#1#0@@5|) DatatypeTypeType)
              (= (type |a#0#2#0@@0|) (SeqType BoxType)))
         (= (DatatypeCtorId (|#PagedBetree.QueryReceipt.QueryReceipt|
                              |a#0#0#0@@8|
                              |a#0#1#0@@5|
                              |a#0#2#0@@0|))
            |##PagedBetree.QueryReceipt.QueryReceipt|))
     :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                 |a#0#0#0@@8|
                 |a#0#1#0@@5|
                 |a#0#2#0@@0|))
     :skolemid |3171|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((d@@111 T@U))
  (! (=> (= (type d@@111) DatatypeTypeType)
         (= (PagedBetree.QueryReceipt.QueryReceipt_q d@@111)
            (= (DatatypeCtorId d@@111)
               |##PagedBetree.QueryReceipt.QueryReceipt|)))
     :pattern ((PagedBetree.QueryReceipt.QueryReceipt_q d@@111))
     :skolemid |3172|
     :qid |unknown.0:0|)))
(assert (forall ((d@@112 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@8| T@U)
                         (|a#1#1#0@@5| T@U)
                         (|a#1#2#0@@0| T@U))
                  (! (and (= (type |a#1#0#0@@8|) (SeqType BoxType))
                          (= (type |a#1#1#0@@5|) DatatypeTypeType)
                          (= (type |a#1#2#0@@0|) (SeqType BoxType))
                          (= d@@112
                             (|#PagedBetree.QueryReceipt.QueryReceipt|
                               |a#1#0#0@@8|
                               |a#1#1#0@@5|
                               |a#1#2#0@@0|)))
                     :no-pattern (type |a#1#0#0@@8|)
                     :no-pattern (type |a#1#1#0@@5|)
                     :no-pattern (type |a#1#2#0@@0|)
                     :no-pattern (U_2_int |a#1#0#0@@8|)
                     :no-pattern (U_2_bool |a#1#0#0@@8|)
                     :no-pattern (U_2_int |a#1#1#0@@5|)
                     :no-pattern (U_2_bool |a#1#1#0@@5|)
                     :no-pattern (U_2_int |a#1#2#0@@0|)
                     :no-pattern (U_2_bool |a#1#2#0@@0|)
                     :skolemid |3173|
                     :qid |PagedBetreeidfy.174:5|))))
       (=> (and (= (type d@@112) DatatypeTypeType)
                (PagedBetree.QueryReceipt.QueryReceipt_q d@@112))
           a!1))
     :pattern ((PagedBetree.QueryReceipt.QueryReceipt_q d@@112))
     :skolemid |3174|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@8| T@U) (|a#2#1#0@@5| T@U) (|a#2#2#0@@0| T@U))
  (! (let ((a!1 (= ($Is (|#PagedBetree.QueryReceipt.QueryReceipt|
                          |a#2#0#0@@8|
                          |a#2#1#0@@5|
                          |a#2#2#0@@0|)
                        Tclass.PagedBetree.QueryReceipt)
                   (and ($Is |a#2#0#0@@8| Tclass.KeyType.Key)
                        ($Is |a#2#1#0@@5| Tclass.PagedBetree.BetreeNode)
                        ($Is |a#2#2#0@@0|
                             (TSeq Tclass.PagedBetree.QueryReceiptLine))))))
       (=> (and (= (type |a#2#0#0@@8|) (SeqType BoxType))
                (= (type |a#2#1#0@@5|) DatatypeTypeType)
                (= (type |a#2#2#0@@0|) (SeqType BoxType)))
           a!1))
     :pattern (($Is (|#PagedBetree.QueryReceipt.QueryReceipt|
                      |a#2#0#0@@8|
                      |a#2#1#0@@5|
                      |a#2#2#0@@0|)
                    Tclass.PagedBetree.QueryReceipt))
     :skolemid |3175|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((|a#3#0#0@@8| T@U) (|a#3#1#0@@5| T@U) (|a#3#2#0@@0| T@U) ($h@@130 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#PagedBetree.QueryReceipt.QueryReceipt|
                               |a#3#0#0@@8|
                               |a#3#1#0@@5|
                               |a#3#2#0@@0|)
                             Tclass.PagedBetree.QueryReceipt
                             $h@@130)
                   (and ($IsAlloc |a#3#0#0@@8| Tclass.KeyType.Key $h@@130)
                        ($IsAlloc |a#3#1#0@@5|
                                  Tclass.PagedBetree.BetreeNode
                                  $h@@130)
                        ($IsAlloc |a#3#2#0@@0|
                                  (TSeq Tclass.PagedBetree.QueryReceiptLine)
                                  $h@@130)))))
       (=> (and (= (type |a#3#0#0@@8|) (SeqType BoxType))
                (= (type |a#3#1#0@@5|) DatatypeTypeType)
                (= (type |a#3#2#0@@0|) (SeqType BoxType))
                (= (type $h@@130) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@130))
           a!1))
     :pattern (($IsAlloc (|#PagedBetree.QueryReceipt.QueryReceipt|
                           |a#3#0#0@@8|
                           |a#3#1#0@@5|
                           |a#3#2#0@@0|)
                         Tclass.PagedBetree.QueryReceipt
                         $h@@130))
     :skolemid |3176|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((d@@113 T@U) ($h@@131 T@U))
  (! (=> (and (= (type d@@113) DatatypeTypeType)
              (= (type $h@@131) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@131)
              (PagedBetree.QueryReceipt.QueryReceipt_q d@@113)
              ($IsAlloc d@@113 Tclass.PagedBetree.QueryReceipt $h@@131))
         ($IsAlloc (PagedBetree.QueryReceipt.key d@@113)
                   Tclass.KeyType.Key
                   $h@@131))
     :pattern (($IsAlloc (PagedBetree.QueryReceipt.key d@@113)
                         Tclass.KeyType.Key
                         $h@@131))
     :skolemid |3177|
     :qid |unknown.0:0|)))
(assert (forall ((d@@114 T@U) ($h@@132 T@U))
  (! (=> (and (= (type d@@114) DatatypeTypeType)
              (= (type $h@@132) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@132)
              (PagedBetree.QueryReceipt.QueryReceipt_q d@@114)
              ($IsAlloc d@@114 Tclass.PagedBetree.QueryReceipt $h@@132))
         ($IsAlloc (PagedBetree.QueryReceipt.root d@@114)
                   Tclass.PagedBetree.BetreeNode
                   $h@@132))
     :pattern (($IsAlloc (PagedBetree.QueryReceipt.root d@@114)
                         Tclass.PagedBetree.BetreeNode
                         $h@@132))
     :skolemid |3178|
     :qid |unknown.0:0|)))
(assert (forall ((d@@115 T@U) ($h@@133 T@U))
  (! (=> (and (= (type d@@115) DatatypeTypeType)
              (= (type $h@@133) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@133)
              (PagedBetree.QueryReceipt.QueryReceipt_q d@@115)
              ($IsAlloc d@@115 Tclass.PagedBetree.QueryReceipt $h@@133))
         ($IsAlloc (PagedBetree.QueryReceipt.lines d@@115)
                   (TSeq Tclass.PagedBetree.QueryReceiptLine)
                   $h@@133))
     :pattern (($IsAlloc (PagedBetree.QueryReceipt.lines d@@115)
                         (TSeq Tclass.PagedBetree.QueryReceiptLine)
                         $h@@133))
     :skolemid |3179|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@8| T@U) (|a#4#1#0@@5| T@U) (|a#4#2#0@@0| T@U))
  (! (=> (and (= (type |a#4#0#0@@8|) (SeqType BoxType))
              (= (type |a#4#1#0@@5|) DatatypeTypeType)
              (= (type |a#4#2#0@@0|) (SeqType BoxType)))
         (= (|#PagedBetree.QueryReceipt.QueryReceipt|
              (Lit |a#4#0#0@@8|)
              (Lit |a#4#1#0@@5|)
              (Lit |a#4#2#0@@0|))
            (Lit (|#PagedBetree.QueryReceipt.QueryReceipt|
                   |a#4#0#0@@8|
                   |a#4#1#0@@5|
                   |a#4#2#0@@0|))))
     :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                 (Lit |a#4#0#0@@8|)
                 (Lit |a#4#1#0@@5|)
                 (Lit |a#4#2#0@@0|)))
     :skolemid |3180|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((|a#5#0#0@@10| T@U) (|a#5#1#0@@6| T@U) (|a#5#2#0@@0| T@U))
  (! (=> (and (= (type |a#5#0#0@@10|) (SeqType BoxType))
              (= (type |a#5#1#0@@6|) DatatypeTypeType)
              (= (type |a#5#2#0@@0|) (SeqType BoxType)))
         (= (PagedBetree.QueryReceipt.key
              (|#PagedBetree.QueryReceipt.QueryReceipt|
                |a#5#0#0@@10|
                |a#5#1#0@@6|
                |a#5#2#0@@0|))
            |a#5#0#0@@10|))
     :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                 |a#5#0#0@@10|
                 |a#5#1#0@@6|
                 |a#5#2#0@@0|))
     :skolemid |3181|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((|a#6#0#0@@10| T@U) (|a#6#1#0@@6| T@U) (|a#6#2#0@@0| T@U))
  (! (=> (and (= (type |a#6#0#0@@10|) (SeqType BoxType))
              (= (type |a#6#1#0@@6|) DatatypeTypeType)
              (= (type |a#6#2#0@@0|) (SeqType BoxType)))
         (= (PagedBetree.QueryReceipt.root
              (|#PagedBetree.QueryReceipt.QueryReceipt|
                |a#6#0#0@@10|
                |a#6#1#0@@6|
                |a#6#2#0@@0|))
            |a#6#1#0@@6|))
     :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                 |a#6#0#0@@10|
                 |a#6#1#0@@6|
                 |a#6#2#0@@0|))
     :skolemid |3182|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((|a#7#0#0@@10| T@U) (|a#7#1#0@@6| T@U) (|a#7#2#0@@0| T@U))
  (! (=> (and (= (type |a#7#0#0@@10|) (SeqType BoxType))
              (= (type |a#7#1#0@@6|) DatatypeTypeType)
              (= (type |a#7#2#0@@0|) (SeqType BoxType)))
         (< (DtRank |a#7#1#0@@6|)
            (DtRank (|#PagedBetree.QueryReceipt.QueryReceipt|
                      |a#7#0#0@@10|
                      |a#7#1#0@@6|
                      |a#7#2#0@@0|))))
     :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                 |a#7#0#0@@10|
                 |a#7#1#0@@6|
                 |a#7#2#0@@0|))
     :skolemid |3183|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((|a#8#0#0@@7| T@U) (|a#8#1#0@@4| T@U) (|a#8#2#0@@0| T@U))
  (! (=> (and (= (type |a#8#0#0@@7|) (SeqType BoxType))
              (= (type |a#8#1#0@@4|) DatatypeTypeType)
              (= (type |a#8#2#0@@0|) (SeqType BoxType)))
         (= (PagedBetree.QueryReceipt.lines
              (|#PagedBetree.QueryReceipt.QueryReceipt|
                |a#8#0#0@@7|
                |a#8#1#0@@4|
                |a#8#2#0@@0|))
            |a#8#2#0@@0|))
     :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                 |a#8#0#0@@7|
                 |a#8#1#0@@4|
                 |a#8#2#0@@0|))
     :skolemid |3184|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((|a#9#0#0@@4| T@U) (|a#9#1#0@@1| T@U) (|a#9#2#0@@0| T@U) (i@@26 Int))
  (! (let ((a!1 (< (DtRank ($Unbox DatatypeTypeType
                                   (|Seq#Index| |a#9#2#0@@0| i@@26)))
                   (DtRank (|#PagedBetree.QueryReceipt.QueryReceipt|
                             |a#9#0#0@@4|
                             |a#9#1#0@@1|
                             |a#9#2#0@@0|)))))
       (=> (and (= (type |a#9#0#0@@4|) (SeqType BoxType))
                (= (type |a#9#1#0@@1|) DatatypeTypeType)
                (= (type |a#9#2#0@@0|) (SeqType BoxType))
                (<= 0 i@@26)
                (< i@@26 (|Seq#Length| |a#9#2#0@@0|)))
           a!1))
     :pattern ((|Seq#Index| |a#9#2#0@@0| i@@26)
               (|#PagedBetree.QueryReceipt.QueryReceipt|
                 |a#9#0#0@@4|
                 |a#9#1#0@@1|
                 |a#9#2#0@@0|))
     :skolemid |3185|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((|a#10#0#0@@4| T@U) (|a#10#1#0@@1| T@U) (|a#10#2#0@@0| T@U))
  (! (=> (and (= (type |a#10#0#0@@4|) (SeqType BoxType))
              (= (type |a#10#1#0@@1|) DatatypeTypeType)
              (= (type |a#10#2#0@@0|) (SeqType BoxType)))
         (< (|Seq#Rank| |a#10#2#0@@0|)
            (DtRank (|#PagedBetree.QueryReceipt.QueryReceipt|
                      |a#10#0#0@@4|
                      |a#10#1#0@@1|
                      |a#10#2#0@@0|))))
     :pattern ((|#PagedBetree.QueryReceipt.QueryReceipt|
                 |a#10#0#0@@4|
                 |a#10#1#0@@1|
                 |a#10#2#0@@0|))
     :skolemid |3186|
     :qid |PagedBetreeidfy.174:5|)))
(assert (forall ((d@@116 T@U))
  (! (=> (and (= (type d@@116) DatatypeTypeType)
              (|$IsA#PagedBetree.QueryReceipt| d@@116))
         (PagedBetree.QueryReceipt.QueryReceipt_q d@@116))
     :pattern ((|$IsA#PagedBetree.QueryReceipt| d@@116))
     :skolemid |3187|
     :qid |unknown.0:0|)))
(assert (forall ((d@@117 T@U))
  (! (=> (and (= (type d@@117) DatatypeTypeType)
              ($Is d@@117 Tclass.PagedBetree.QueryReceipt))
         (PagedBetree.QueryReceipt.QueryReceipt_q d@@117))
     :pattern ((PagedBetree.QueryReceipt.QueryReceipt_q d@@117)
               ($Is d@@117 Tclass.PagedBetree.QueryReceipt))
     :skolemid |3188|
     :qid |unknown.0:0|)))
(assert (forall ((a@@151 T@U) (b@@101 T@U))
  (! (let ((a!1 (= (|PagedBetree.QueryReceipt#Equal| a@@151 b@@101)
                   (and (|Seq#Equal| (PagedBetree.QueryReceipt.key a@@151)
                                     (PagedBetree.QueryReceipt.key b@@101))
                        (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.QueryReceipt.root a@@151)
                          (PagedBetree.QueryReceipt.root b@@101))
                        (|Seq#Equal| (PagedBetree.QueryReceipt.lines a@@151)
                                     (PagedBetree.QueryReceipt.lines b@@101))))))
       (=> (and (= (type a@@151) DatatypeTypeType)
                (= (type b@@101) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|PagedBetree.QueryReceipt#Equal| a@@151 b@@101))
     :skolemid |3189|
     :qid |unknown.0:0|)))
(assert (forall ((a@@152 T@U) (b@@102 T@U))
  (! (=> (and (= (type a@@152) DatatypeTypeType)
              (= (type b@@102) DatatypeTypeType))
         (= (|PagedBetree.QueryReceipt#Equal| a@@152 b@@102) (= a@@152 b@@102)))
     :pattern ((|PagedBetree.QueryReceipt#Equal| a@@152 b@@102))
     :skolemid |3190|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((this@@170 T@U))
             (! (=> (and (= (type this@@170) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.Structure#canCall|
                               this@@170)
                             ($Is this@@170 Tclass.PagedBetree.QueryReceipt)))
                    true)
                :pattern ((PagedBetree.QueryReceipt.Structure this@@170))
                :skolemid |3191|
                :qid |PagedBetreeidfy.178:15|))))
  (=> true a!1)))
(assert (forall ((this@@171 T@U))
  (! (=> (and (= (type this@@171) DatatypeTypeType)
              ($Is this@@171 Tclass.PagedBetree.QueryReceipt))
         (= (|PagedBetree.QueryReceipt.Structure#requires| this@@171) true))
     :pattern ((|PagedBetree.QueryReceipt.Structure#requires| this@@171))
     :skolemid |3192|
     :qid |PagedBetreeidfy.178:15|)))
(assert (let ((a!1 (forall ((this@@172 T@U))
             (! (let ((a!1 (PagedBetree.QueryReceiptLine.node
                             ($Unbox DatatypeTypeType
                                     (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                    this@@172)
                                                  (LitInt 0)))))
                      (a!2 (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                             ($Unbox DatatypeTypeType
                                     (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                    this@@172)
                                                  (LitInt 0)))))
                      (a!3 (forall ((|i#0@@104| Int))
                             (! (let ((a!1 (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                             ($Unbox DatatypeTypeType
                                                     (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                    this@@172)
                                                                  |i#0@@104|)))))
                                (let ((a!2 (=> (INTERNAL_lt_boogie
                                                 |i#0@@104|
                                                 (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                                 this@@172)))
                                               (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                                      this@@172)
                                                    a!1
                                                    (PagedBetree.QueryReceipt.QueryReceipt_q
                                                      this@@172)))))
                                  (=> (INTERNAL_le_boogie 0 |i#0@@104|)
                                      (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                             this@@172)
                                           a!2))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                 this@@172)
                                                               |i#0@@104|)))
                                :skolemid |3194|
                                :qid |PagedBetreeidfy.182:18|)))
                      (a!4 (forall ((|i#0@@105| Int))
                             (! (let ((a!1 (and (INTERNAL_le_boogie
                                                  0
                                                  |i#0@@105|)
                                                (INTERNAL_lt_boogie
                                                  |i#0@@105|
                                                  (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                                  this@@172)))))
                                      (a!2 (PagedBetree.QueryReceiptLine.node
                                             ($Unbox DatatypeTypeType
                                                     (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                    this@@172)
                                                                  |i#0@@105|))))
                                      (a!3 (INTERNAL_lt_boogie
                                             |i#0@@105|
                                             (INTERNAL_sub_boogie
                                               (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                               this@@172))
                                               1))))
                                  (=> a!1
                                      (= (PagedBetree.BetreeNode.BetreeNode_q
                                           a!2)
                                         a!3)))
                                :pattern (($Unbox DatatypeTypeType
                                                  (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                 this@@172)
                                                               |i#0@@105|)))
                                :skolemid |3195|
                                :qid |PagedBetreeidfy.182:18|)))
                      (a!5 (PagedBetree.QueryReceiptLine.result
                             ($Unbox DatatypeTypeType
                                     (Sequences.__default.Last
                                       Tclass.PagedBetree.QueryReceiptLine
                                       (PagedBetree.QueryReceipt.lines
                                         this@@172)))))
                      (a!6 (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                             ($Unbox DatatypeTypeType
                                     (Sequences.__default.Last
                                       Tclass.PagedBetree.QueryReceiptLine
                                       (PagedBetree.QueryReceipt.lines
                                         this@@172)))))
                      (a!10 (forall ((|i#0@@106| Int))
                              (! (let ((a!1 (and (INTERNAL_le_boogie
                                                   0
                                                   |i#0@@106|)
                                                 (INTERNAL_lt_boogie
                                                   |i#0@@106|
                                                   (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                                   this@@172)))))
                                       (a!2 (PagedBetree.QueryReceiptLine.node
                                              ($Unbox DatatypeTypeType
                                                      (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                     this@@172)
                                                                   |i#0@@106|))))
                                       (a!3 (INTERNAL_lt_boogie
                                              |i#0@@106|
                                              (INTERNAL_sub_boogie
                                                (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                                this@@172))
                                                1))))
                                   (=> a!1
                                       (= (PagedBetree.BetreeNode.BetreeNode_q
                                            a!2)
                                          a!3)))
                                 :pattern (($Unbox DatatypeTypeType
                                                   (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                  this@@172)
                                                                |i#0@@106|)))
                                 :skolemid |3193|
                                 :qid |PagedBetreeidfy.182:18|))))
                (let ((a!7 (=> a!4
                               (and (|$IsA#ValueMessage.Message| a!5)
                                    (PagedBetree.QueryReceipt.QueryReceipt_q
                                      this@@172)
                                    (|Sequences.__default.Last#canCall|
                                      Tclass.PagedBetree.QueryReceiptLine
                                      (PagedBetree.QueryReceipt.lines this@@172))
                                    a!6
                                    |ValueMessage.__default.DefaultValue#canCall|)))
                      (a!11 (and (INTERNAL_lt_boogie
                                   0
                                   (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                   this@@172)))
                                 (|PagedBetree.BetreeNode#Equal|
                                   a!1
                                   (PagedBetree.QueryReceipt.root this@@172))
                                 a!10
                                 (|ValueMessage.Message#Equal|
                                   a!5
                                   (|#ValueMessage.Message.Define|
                                     (Lit ValueMessage.__default.DefaultValue))))))
                (let ((a!8 (and (|$IsA#PagedBetree.BetreeNode| a!1)
                                (|$IsA#PagedBetree.BetreeNode|
                                  (PagedBetree.QueryReceipt.root this@@172))
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  this@@172)
                                a!2
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  this@@172)
                                (=> (|PagedBetree.BetreeNode#Equal|
                                      a!1
                                      (PagedBetree.QueryReceipt.root this@@172))
                                    (and a!3 a!7)))))
                (let ((a!9 (=> (INTERNAL_lt_boogie
                                 0
                                 (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                 this@@172)))
                               a!8)))
                  (=> (and (= (type this@@172) DatatypeTypeType)
                           (or (|PagedBetree.QueryReceipt.Structure#canCall|
                                 this@@172)
                               ($Is this@@172 Tclass.PagedBetree.QueryReceipt)))
                      (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@172)
                           a!9
                           (= (PagedBetree.QueryReceipt.Structure this@@172)
                              a!11)))))))
                :pattern ((PagedBetree.QueryReceipt.Structure this@@172))
                :skolemid |3196|
                :qid |PagedBetreeidfy.178:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@173 T@U))
      (! (let ((a!1 (and (= (type this@@173) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.Structure#canCall|
                               (Lit this@@173))
                             ($Is this@@173 Tclass.PagedBetree.QueryReceipt))))
               (a!2 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                         (Lit this@@173)))))
               (a!3 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                        (Lit this@@173)))
                                 (LitInt 0)))
               (a!4 (|$IsA#PagedBetree.BetreeNode|
                      (Lit (PagedBetree.QueryReceipt.root (Lit this@@173)))))
               (a!5 (forall ((|i#1@@20| Int))
                      (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                         (Lit this@@173)))))
                               (a!2 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                                        (Lit this@@173)))
                                                 |i#1@@20|)))
                         (let ((a!3 (=> (INTERNAL_lt_boogie |i#1@@20| a!1)
                                        (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                               (Lit this@@173))
                                             (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                               ($Unbox DatatypeTypeType a!2))
                                             (PagedBetree.QueryReceipt.QueryReceipt_q
                                               (Lit this@@173))))))
                           (=> (INTERNAL_le_boogie 0 |i#1@@20|)
                               (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                      (Lit this@@173))
                                    a!3))))
                         :pattern (($Unbox DatatypeTypeType
                                           (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                          this@@173)
                                                        |i#1@@20|)))
                         :skolemid |3198|
                         :qid |PagedBetreeidfy.182:18|)))
               (a!6 (forall ((|i#1@@21| Int))
                      (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                         (Lit this@@173)))))
                               (a!2 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                                        (Lit this@@173)))
                                                 |i#1@@21|)))
                         (let ((a!3 (= (PagedBetree.BetreeNode.BetreeNode_q
                                         (PagedBetree.QueryReceiptLine.node
                                           ($Unbox DatatypeTypeType a!2)))
                                       (INTERNAL_lt_boogie
                                         |i#1@@21|
                                         (INTERNAL_sub_boogie a!1 1)))))
                           (=> (and (INTERNAL_le_boogie 0 |i#1@@21|)
                                    (INTERNAL_lt_boogie |i#1@@21| a!1))
                               a!3)))
                         :pattern (($Unbox DatatypeTypeType
                                           (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                          this@@173)
                                                        |i#1@@21|)))
                         :skolemid |3199|
                         :qid |PagedBetreeidfy.182:18|)))
               (a!7 (Sequences.__default.Last
                      Tclass.PagedBetree.QueryReceiptLine
                      (Lit (PagedBetree.QueryReceipt.lines (Lit this@@173)))))
               (a!9 (|Sequences.__default.Last#canCall|
                      Tclass.PagedBetree.QueryReceiptLine
                      (Lit (PagedBetree.QueryReceipt.lines (Lit this@@173)))))
               (a!13 (forall ((|i#1@@22| Int))
                       (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                          (Lit this@@173)))))
                                (a!2 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                                         (Lit this@@173)))
                                                  |i#1@@22|)))
                          (let ((a!3 (= (PagedBetree.BetreeNode.BetreeNode_q
                                          (PagedBetree.QueryReceiptLine.node
                                            ($Unbox DatatypeTypeType a!2)))
                                        (INTERNAL_lt_boogie
                                          |i#1@@22|
                                          (INTERNAL_sub_boogie a!1 1)))))
                            (=> (and (INTERNAL_le_boogie 0 |i#1@@22|)
                                     (INTERNAL_lt_boogie |i#1@@22| a!1))
                                a!3)))
                          :pattern (($Unbox DatatypeTypeType
                                            (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                           this@@173)
                                                         |i#1@@22|)))
                          :skolemid |3197|
                          :qid |PagedBetreeidfy.182:18|))))
         (let ((a!8 (Lit (PagedBetree.QueryReceiptLine.result
                           (Lit ($Unbox DatatypeTypeType a!7)))))
               (a!14 (|ValueMessage.Message#Equal|
                       (PagedBetree.QueryReceiptLine.result
                         (Lit ($Unbox DatatypeTypeType a!7)))
                       (|#ValueMessage.Message.Define|
                         (Lit ValueMessage.__default.DefaultValue)))))
         (let ((a!10 (and (|$IsA#ValueMessage.Message| a!8)
                          (PagedBetree.QueryReceipt.QueryReceipt_q
                            (Lit this@@173))
                          a!9
                          (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                            (Lit ($Unbox DatatypeTypeType a!7)))
                          |ValueMessage.__default.DefaultValue#canCall|))
               (a!15 (and (INTERNAL_lt_boogie 0 a!2)
                          (|PagedBetree.BetreeNode#Equal|
                            (PagedBetree.QueryReceiptLine.node
                              ($Unbox DatatypeTypeType a!3))
                            (PagedBetree.QueryReceipt.root (Lit this@@173)))
                          a!13
                          a!14)))
         (let ((a!11 (=> (|PagedBetree.BetreeNode#Equal|
                           (PagedBetree.QueryReceiptLine.node
                             ($Unbox DatatypeTypeType a!3))
                           (PagedBetree.QueryReceipt.root (Lit this@@173)))
                         (and a!5 (=> a!6 a!10)))))
         (let ((a!12 (and (|$IsA#PagedBetree.BetreeNode|
                            (PagedBetree.QueryReceiptLine.node
                              ($Unbox DatatypeTypeType a!3)))
                          a!4
                          (PagedBetree.QueryReceipt.QueryReceipt_q
                            (Lit this@@173))
                          (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                            ($Unbox DatatypeTypeType a!3))
                          (PagedBetree.QueryReceipt.QueryReceipt_q
                            (Lit this@@173))
                          a!11)))
         (let ((a!16 (and (PagedBetree.QueryReceipt.QueryReceipt_q
                            (Lit this@@173))
                          (=> (INTERNAL_lt_boogie 0 a!2) a!12)
                          (= (PagedBetree.QueryReceipt.Structure
                               (Lit this@@173))
                             a!15))))
           (=> a!1 a!16)))))))
         :pattern ((PagedBetree.QueryReceipt.Structure (Lit this@@173)))
         :weight 3
         :skolemid |3200|
         :qid |PagedBetreeidfy.178:15|))))
(assert (let ((a!1 (forall ((this@@174 T@U))
             (! (=> (and (= (type this@@174) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.AllLinesWF#canCall|
                               this@@174)
                             ($Is this@@174 Tclass.PagedBetree.QueryReceipt)))
                    true)
                :pattern ((PagedBetree.QueryReceipt.AllLinesWF this@@174))
                :skolemid |3201|
                :qid |PagedBetreeidfy.186:15|))))
  (=> true a!1)))
(assert (forall ((this@@175 T@U))
  (! (=> (and (= (type this@@175) DatatypeTypeType)
              ($Is this@@175 Tclass.PagedBetree.QueryReceipt))
         (= (|PagedBetree.QueryReceipt.AllLinesWF#requires| this@@175) true))
     :pattern ((|PagedBetree.QueryReceipt.AllLinesWF#requires| this@@175))
     :skolemid |3202|
     :qid |PagedBetreeidfy.186:15|)))
(assert (let ((a!1 (forall ((this@@176 T@U))
             (! (let ((a!1 (forall ((|i#0@@107| Int))
                             (! (let ((a!1 (|PagedBetree.QueryReceiptLine.WF#canCall|
                                             ($Unbox DatatypeTypeType
                                                     (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                    this@@176)
                                                                  |i#0@@107|)))))
                                (let ((a!2 (=> (INTERNAL_lt_boogie
                                                 |i#0@@107|
                                                 (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                                 this@@176)))
                                               (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                                      this@@176)
                                                    a!1))))
                                  (=> (INTERNAL_le_boogie 0 |i#0@@107|)
                                      (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                             this@@176)
                                           a!2))))
                                :pattern (($Unbox DatatypeTypeType
                                                  (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                 this@@176)
                                                               |i#0@@107|)))
                                :skolemid |3204|
                                :qid |PagedBetreeidfy.188:18|)))
                      (a!3 (= (PagedBetree.QueryReceipt.AllLinesWF this@@176)
                              (and true
                                   (forall ((|i#0@@108| Int))
                                     (! (let ((a!1 (and (INTERNAL_le_boogie
                                                          0
                                                          |i#0@@108|)
                                                        (INTERNAL_lt_boogie
                                                          |i#0@@108|
                                                          (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                                          this@@176)))))
                                              (a!2 (PagedBetree.QueryReceiptLine.WF
                                                     ($Unbox DatatypeTypeType
                                                             (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                            this@@176)
                                                                          |i#0@@108|)))))
                                          (=> a!1 a!2))
                                        :pattern (($Unbox DatatypeTypeType
                                                          (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                                         this@@176)
                                                                       |i#0@@108|)))
                                        :skolemid |3203|
                                        :qid |PagedBetreeidfy.188:18|))))))
                (let ((a!2 (=> (U_2_bool (Lit (bool_2_U true))) a!1)))
                  (=> (and (= (type this@@176) DatatypeTypeType)
                           (or (|PagedBetree.QueryReceipt.AllLinesWF#canCall|
                                 this@@176)
                               ($Is this@@176 Tclass.PagedBetree.QueryReceipt)))
                      (and a!2 a!3))))
                :pattern ((PagedBetree.QueryReceipt.AllLinesWF this@@176))
                :skolemid |3205|
                :qid |PagedBetreeidfy.186:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@177 T@U))
      (! (let ((a!1 (and (= (type this@@177) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.AllLinesWF#canCall|
                               (Lit this@@177))
                             ($Is this@@177 Tclass.PagedBetree.QueryReceipt))))
               (a!2 (forall ((|i#1@@23| Int))
                      (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                         (Lit this@@177)))))
                               (a!2 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                                        (Lit this@@177)))
                                                 |i#1@@23|)))
                         (let ((a!3 (=> (INTERNAL_lt_boogie |i#1@@23| a!1)
                                        (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                               (Lit this@@177))
                                             (|PagedBetree.QueryReceiptLine.WF#canCall|
                                               ($Unbox DatatypeTypeType a!2))))))
                           (=> (INTERNAL_le_boogie 0 |i#1@@23|)
                               (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                      (Lit this@@177))
                                    a!3))))
                         :pattern (($Unbox DatatypeTypeType
                                           (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                          this@@177)
                                                        |i#1@@23|)))
                         :skolemid |3207|
                         :qid |PagedBetreeidfy.188:18|)))
               (a!4 (forall ((|i#1@@24| Int))
                      (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                         (Lit this@@177)))))
                               (a!2 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                                        (Lit this@@177)))
                                                 |i#1@@24|)))
                           (=> (and (INTERNAL_le_boogie 0 |i#1@@24|)
                                    (INTERNAL_lt_boogie |i#1@@24| a!1))
                               (PagedBetree.QueryReceiptLine.WF
                                 ($Unbox DatatypeTypeType a!2))))
                         :pattern (($Unbox DatatypeTypeType
                                           (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                          this@@177)
                                                        |i#1@@24|)))
                         :skolemid |3206|
                         :qid |PagedBetreeidfy.188:18|))))
         (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true))) a!2)))
         (let ((a!5 (and a!3
                         (= (PagedBetree.QueryReceipt.AllLinesWF
                              (Lit this@@177))
                            (and true a!4)))))
           (=> a!1 a!5))))
         :pattern ((PagedBetree.QueryReceipt.AllLinesWF (Lit this@@177)))
         :weight 3
         :skolemid |3208|
         :qid |PagedBetreeidfy.186:15|))))
(assert (forall ((arg0@@575 T@U) (arg1@@292 Int))
  (! (= (type (PagedBetree.QueryReceipt.ChildAt arg0@@575 arg1@@292))
        DatatypeTypeType)
     :pattern ((PagedBetree.QueryReceipt.ChildAt arg0@@575 arg1@@292))
     :qid |funType:PagedBetree.QueryReceipt.ChildAt|)))
(assert (let ((a!1 (forall ((this@@178 T@U) (|i#0@@109| Int))
             (! (let ((a!1 (INTERNAL_lt_boogie
                             |i#0@@109|
                             (INTERNAL_sub_boogie
                               (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                               this@@178))
                               1))))
                (let ((a!2 (and (= (type this@@178) DatatypeTypeType)
                                (or (|PagedBetree.QueryReceipt.ChildAt#canCall|
                                      this@@178
                                      |i#0@@109|)
                                    (and ($Is this@@178
                                              Tclass.PagedBetree.QueryReceipt)
                                         (INTERNAL_le_boogie 0 |i#0@@109|)
                                         (PagedBetree.QueryReceipt.AllLinesWF
                                           this@@178)
                                         (PagedBetree.QueryReceipt.Structure
                                           this@@178)
                                         a!1)))))
                  (=> a!2
                      ($Is (PagedBetree.QueryReceipt.ChildAt
                             this@@178
                             |i#0@@109|)
                           Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.QueryReceipt.ChildAt
                            this@@178
                            |i#0@@109|))
                :skolemid |3209|
                :qid |PagedBetreeidfy.191:14|))))
  (=> true a!1)))
(assert (forall ((this@@179 T@U) (|i#0@@110| Int))
  (! (let ((a!1 (INTERNAL_lt_boogie
                  |i#0@@110|
                  (INTERNAL_sub_boogie
                    (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@179))
                    1))))
     (let ((a!2 (=> (and ($Is this@@179 Tclass.PagedBetree.QueryReceipt)
                         (INTERNAL_le_boogie 0 |i#0@@110|))
                    (= (|PagedBetree.QueryReceipt.ChildAt#requires|
                         this@@179
                         |i#0@@110|)
                       (and (PagedBetree.QueryReceipt.AllLinesWF this@@179)
                            (PagedBetree.QueryReceipt.Structure this@@179)
                            a!1)))))
       (=> (= (type this@@179) DatatypeTypeType) a!2)))
     :pattern ((|PagedBetree.QueryReceipt.ChildAt#requires|
                 this@@179
                 |i#0@@110|))
     :skolemid |3210|
     :qid |PagedBetreeidfy.191:14|)))
(assert (=> true
    (forall ((this@@180 T@U) (|i#0@@111| Int))
      (! (let ((a!1 (INTERNAL_lt_boogie
                      |i#0@@111|
                      (INTERNAL_sub_boogie
                        (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@180))
                        1)))
               (a!3 (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                      ($Unbox DatatypeTypeType
                              (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                             this@@180)
                                           |i#0@@111|))))
               (a!4 (PagedBetree.QueryReceiptLine.node
                      ($Unbox DatatypeTypeType
                              (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                             this@@180)
                                           |i#0@@111|)))))
         (let ((a!2 (and (= (type this@@180) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.ChildAt#canCall|
                               this@@180
                               |i#0@@111|)
                             (and ($Is this@@180
                                       Tclass.PagedBetree.QueryReceipt)
                                  (INTERNAL_le_boogie 0 |i#0@@111|)
                                  (PagedBetree.QueryReceipt.AllLinesWF
                                    this@@180)
                                  (PagedBetree.QueryReceipt.Structure this@@180)
                                  a!1))))
               (a!5 (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@180)
                         a!3
                         (PagedBetree.QueryReceipt.QueryReceipt_q this@@180)
                         (|PagedBetree.BetreeNode.Child#canCall|
                           a!4
                           (PagedBetree.QueryReceipt.key this@@180))
                         (= (PagedBetree.QueryReceipt.ChildAt
                              this@@180
                              |i#0@@111|)
                            (PagedBetree.BetreeNode.Child
                              a!4
                              (PagedBetree.QueryReceipt.key this@@180))))))
           (=> a!2 a!5)))
         :pattern ((PagedBetree.QueryReceipt.ChildAt this@@180 |i#0@@111|))
         :skolemid |3211|
         :qid |PagedBetreeidfy.191:14|))))
(assert (let ((a!1 (forall ((this@@181 T@U) (|i#0@@112| Int))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF
                                            (Lit this@@181)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure
                                            (Lit this@@181)))))
                      (a!3 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                (Lit this@@181)))))
                      (a!5 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                               (Lit this@@181)))
                                        (LitInt |i#0@@112|))))
                (let ((a!4 (or (|PagedBetree.QueryReceipt.ChildAt#canCall|
                                 (Lit this@@181)
                                 (LitInt |i#0@@112|))
                               (and ($Is this@@181
                                         Tclass.PagedBetree.QueryReceipt)
                                    (INTERNAL_le_boogie 0 |i#0@@112|)
                                    (U_2_bool a!1)
                                    (U_2_bool a!2)
                                    (INTERNAL_lt_boogie
                                      |i#0@@112|
                                      (INTERNAL_sub_boogie a!3 1)))))
                      (a!6 (|PagedBetree.BetreeNode.Child#canCall|
                             (PagedBetree.QueryReceiptLine.node
                               ($Unbox DatatypeTypeType a!5))
                             (Lit (PagedBetree.QueryReceipt.key (Lit this@@181)))))
                      (a!7 (PagedBetree.BetreeNode.Child
                             (PagedBetree.QueryReceiptLine.node
                               ($Unbox DatatypeTypeType a!5))
                             (Lit (PagedBetree.QueryReceipt.key (Lit this@@181))))))
                (let ((a!8 (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit this@@181))
                                (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                  ($Unbox DatatypeTypeType a!5))
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit this@@181))
                                a!6
                                (= (PagedBetree.QueryReceipt.ChildAt
                                     (Lit this@@181)
                                     (LitInt |i#0@@112|))
                                   a!7))))
                  (=> (and (= (type this@@181) DatatypeTypeType) a!4) a!8))))
                :pattern ((PagedBetree.QueryReceipt.ChildAt
                            (Lit this@@181)
                            (LitInt |i#0@@112|)))
                :weight 3
                :skolemid |3212|
                :qid |PagedBetreeidfy.191:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@182 T@U) (|i#0@@113| Int))
      (! (let ((a!1 (INTERNAL_lt_boogie
                      |i#0@@113|
                      (INTERNAL_sub_boogie
                        (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@182))
                        1))))
         (let ((a!2 (and (= (type this@@182) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall|
                               this@@182
                               |i#0@@113|)
                             (and ($Is this@@182
                                       Tclass.PagedBetree.QueryReceipt)
                                  (INTERNAL_le_boogie 0 |i#0@@113|)
                                  (PagedBetree.QueryReceipt.AllLinesWF
                                    this@@182)
                                  (PagedBetree.QueryReceipt.Structure this@@182)
                                  a!1)))))
           (=> a!2 true)))
         :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt this@@182 |i#0@@113|))
         :skolemid |3213|
         :qid |PagedBetreeidfy.200:15|))))
(assert (forall ((this@@183 T@U) (|i#0@@114| Int))
  (! (let ((a!1 (INTERNAL_lt_boogie
                  |i#0@@114|
                  (INTERNAL_sub_boogie
                    (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@183))
                    1))))
     (let ((a!2 (=> (and ($Is this@@183 Tclass.PagedBetree.QueryReceipt)
                         (INTERNAL_le_boogie 0 |i#0@@114|))
                    (= (|PagedBetree.QueryReceipt.ChildLinkedAt#requires|
                         this@@183
                         |i#0@@114|)
                       (and (PagedBetree.QueryReceipt.AllLinesWF this@@183)
                            (PagedBetree.QueryReceipt.Structure this@@183)
                            a!1)))))
       (=> (= (type this@@183) DatatypeTypeType) a!2)))
     :pattern ((|PagedBetree.QueryReceipt.ChildLinkedAt#requires|
                 this@@183
                 |i#0@@114|))
     :skolemid |3214|
     :qid |PagedBetreeidfy.200:15|)))
(assert (=> true
    (forall ((this@@184 T@U) (|i#0@@115| Int))
      (! (let ((a!1 (INTERNAL_lt_boogie
                      |i#0@@115|
                      (INTERNAL_sub_boogie
                        (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@184))
                        1)))
               (a!3 (PagedBetree.QueryReceiptLine.node
                      ($Unbox DatatypeTypeType
                              (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                             this@@184)
                                           (INTERNAL_add_boogie |i#0@@115| 1)))))
               (a!4 (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                      ($Unbox DatatypeTypeType
                              (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                             this@@184)
                                           (INTERNAL_add_boogie |i#0@@115| 1))))))
         (let ((a!2 (and (= (type this@@184) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall|
                               this@@184
                               |i#0@@115|)
                             (and ($Is this@@184
                                       Tclass.PagedBetree.QueryReceipt)
                                  (INTERNAL_le_boogie 0 |i#0@@115|)
                                  (PagedBetree.QueryReceipt.AllLinesWF
                                    this@@184)
                                  (PagedBetree.QueryReceipt.Structure this@@184)
                                  a!1))))
               (a!5 (and (|$IsA#PagedBetree.BetreeNode| a!3)
                         (|$IsA#PagedBetree.BetreeNode|
                           (PagedBetree.QueryReceipt.ChildAt
                             this@@184
                             |i#0@@115|))
                         (PagedBetree.QueryReceipt.QueryReceipt_q this@@184)
                         a!4
                         (|PagedBetree.QueryReceipt.ChildAt#canCall|
                           this@@184
                           |i#0@@115|)
                         (= (PagedBetree.QueryReceipt.ChildLinkedAt
                              this@@184
                              |i#0@@115|)
                            (|PagedBetree.BetreeNode#Equal|
                              a!3
                              (PagedBetree.QueryReceipt.ChildAt
                                this@@184
                                |i#0@@115|))))))
           (=> a!2 a!5)))
         :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt this@@184 |i#0@@115|))
         :skolemid |3215|
         :qid |PagedBetreeidfy.200:15|))))
(assert (let ((a!1 (forall ((this@@185 T@U) (|i#0@@116| Int))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF
                                            (Lit this@@185)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure
                                            (Lit this@@185)))))
                      (a!3 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                (Lit this@@185)))))
                      (a!5 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                               (Lit this@@185)))
                                        (LitInt (INTERNAL_add_boogie
                                                  |i#0@@116|
                                                  1))))
                      (a!6 (|$IsA#PagedBetree.BetreeNode|
                             (Lit (PagedBetree.QueryReceipt.ChildAt
                                    (Lit this@@185)
                                    (LitInt |i#0@@116|))))))
                (let ((a!4 (or (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall|
                                 (Lit this@@185)
                                 (LitInt |i#0@@116|))
                               (and ($Is this@@185
                                         Tclass.PagedBetree.QueryReceipt)
                                    (INTERNAL_le_boogie 0 |i#0@@116|)
                                    (U_2_bool a!1)
                                    (U_2_bool a!2)
                                    (INTERNAL_lt_boogie
                                      |i#0@@116|
                                      (INTERNAL_sub_boogie a!3 1)))))
                      (a!7 (= (PagedBetree.QueryReceipt.ChildLinkedAt
                                (Lit this@@185)
                                (LitInt |i#0@@116|))
                              (|PagedBetree.BetreeNode#Equal|
                                (PagedBetree.QueryReceiptLine.node
                                  ($Unbox DatatypeTypeType a!5))
                                (PagedBetree.QueryReceipt.ChildAt
                                  (Lit this@@185)
                                  (LitInt |i#0@@116|))))))
                (let ((a!8 (and (|$IsA#PagedBetree.BetreeNode|
                                  (PagedBetree.QueryReceiptLine.node
                                    ($Unbox DatatypeTypeType a!5)))
                                a!6
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit this@@185))
                                (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                  ($Unbox DatatypeTypeType a!5))
                                (|PagedBetree.QueryReceipt.ChildAt#canCall|
                                  (Lit this@@185)
                                  (LitInt |i#0@@116|))
                                a!7)))
                  (=> (and (= (type this@@185) DatatypeTypeType) a!4) a!8))))
                :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt
                            (Lit this@@185)
                            (LitInt |i#0@@116|)))
                :weight 3
                :skolemid |3216|
                :qid |PagedBetreeidfy.200:15|))))
  (=> true a!1)))
(assert (forall ((arg0@@576 T@U) (arg1@@293 Int))
  (! (= (type (PagedBetree.QueryReceipt.ResultAt arg0@@576 arg1@@293))
        DatatypeTypeType)
     :pattern ((PagedBetree.QueryReceipt.ResultAt arg0@@576 arg1@@293))
     :qid |funType:PagedBetree.QueryReceipt.ResultAt|)))
(assert (let ((a!1 (forall ((this@@186 T@U) (|i#0@@117| Int))
             (! (let ((a!1 (and ($Is this@@186 Tclass.PagedBetree.QueryReceipt)
                                (INTERNAL_le_boogie 0 |i#0@@117|)
                                (INTERNAL_lt_boogie
                                  |i#0@@117|
                                  (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                  this@@186))))))
                  (=> (and (= (type this@@186) DatatypeTypeType)
                           (or (|PagedBetree.QueryReceipt.ResultAt#canCall|
                                 this@@186
                                 |i#0@@117|)
                               a!1))
                      ($Is (PagedBetree.QueryReceipt.ResultAt
                             this@@186
                             |i#0@@117|)
                           Tclass.ValueMessage.Message)))
                :pattern ((PagedBetree.QueryReceipt.ResultAt
                            this@@186
                            |i#0@@117|))
                :skolemid |3217|
                :qid |PagedBetreeidfy.208:14|))))
  (=> true a!1)))
(assert (forall ((this@@187 T@U) (|i#0@@118| Int))
  (! (let ((a!1 (= (|PagedBetree.QueryReceipt.ResultAt#requires|
                     this@@187
                     |i#0@@118|)
                   (INTERNAL_lt_boogie
                     |i#0@@118|
                     (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@187))))))
       (=> (= (type this@@187) DatatypeTypeType)
           (=> (and ($Is this@@187 Tclass.PagedBetree.QueryReceipt)
                    (INTERNAL_le_boogie 0 |i#0@@118|))
               a!1)))
     :pattern ((|PagedBetree.QueryReceipt.ResultAt#requires|
                 this@@187
                 |i#0@@118|))
     :skolemid |3218|
     :qid |PagedBetreeidfy.208:14|)))
(assert (let ((a!1 (forall ((this@@188 T@U) (|i#0@@119| Int))
             (! (let ((a!1 (and ($Is this@@188 Tclass.PagedBetree.QueryReceipt)
                                (INTERNAL_le_boogie 0 |i#0@@119|)
                                (INTERNAL_lt_boogie
                                  |i#0@@119|
                                  (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                  this@@188)))))
                      (a!2 (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                             ($Unbox DatatypeTypeType
                                     (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                    this@@188)
                                                  |i#0@@119|))))
                      (a!3 (PagedBetree.QueryReceiptLine.result
                             ($Unbox DatatypeTypeType
                                     (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                                    this@@188)
                                                  |i#0@@119|)))))
                  (=> (and (= (type this@@188) DatatypeTypeType)
                           (or (|PagedBetree.QueryReceipt.ResultAt#canCall|
                                 this@@188
                                 |i#0@@119|)
                               a!1))
                      (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@188)
                           a!2
                           (= (PagedBetree.QueryReceipt.ResultAt
                                this@@188
                                |i#0@@119|)
                              a!3))))
                :pattern ((PagedBetree.QueryReceipt.ResultAt
                            this@@188
                            |i#0@@119|))
                :skolemid |3219|
                :qid |PagedBetreeidfy.208:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@189 T@U) (|i#0@@120| Int))
      (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                         (Lit this@@189)))))
               (a!3 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                        (Lit this@@189)))
                                 (LitInt |i#0@@120|))))
         (let ((a!2 (and (= (type this@@189) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.ResultAt#canCall|
                               (Lit this@@189)
                               (LitInt |i#0@@120|))
                             (and ($Is this@@189
                                       Tclass.PagedBetree.QueryReceipt)
                                  (INTERNAL_le_boogie 0 |i#0@@120|)
                                  (INTERNAL_lt_boogie |i#0@@120| a!1)))))
               (a!4 (and (PagedBetree.QueryReceipt.QueryReceipt_q
                           (Lit this@@189))
                         (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                           ($Unbox DatatypeTypeType a!3))
                         (= (PagedBetree.QueryReceipt.ResultAt
                              (Lit this@@189)
                              (LitInt |i#0@@120|))
                            (PagedBetree.QueryReceiptLine.result
                              ($Unbox DatatypeTypeType a!3))))))
           (=> a!2 a!4)))
         :pattern ((PagedBetree.QueryReceipt.ResultAt
                     (Lit this@@189)
                     (LitInt |i#0@@120|)))
         :weight 3
         :skolemid |3220|
         :qid |PagedBetreeidfy.208:14|))))
(assert (=> true
    (forall ((this@@190 T@U) (|i#0@@121| Int))
      (! (let ((a!1 (INTERNAL_lt_boogie
                      |i#0@@121|
                      (INTERNAL_sub_boogie
                        (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@190))
                        1))))
         (let ((a!2 (and (= (type this@@190) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall|
                               this@@190
                               |i#0@@121|)
                             (and ($Is this@@190
                                       Tclass.PagedBetree.QueryReceipt)
                                  (INTERNAL_le_boogie 0 |i#0@@121|)
                                  (PagedBetree.QueryReceipt.Structure this@@190)
                                  (PagedBetree.QueryReceipt.AllLinesWF
                                    this@@190)
                                  a!1)))))
           (=> a!2 true)))
         :pattern ((PagedBetree.QueryReceipt.ResultLinkedAt
                     this@@190
                     |i#0@@121|))
         :skolemid |3221|
         :qid |PagedBetreeidfy.214:15|))))
(assert (forall ((this@@191 T@U) (|i#0@@122| Int))
  (! (let ((a!1 (INTERNAL_lt_boogie
                  |i#0@@122|
                  (INTERNAL_sub_boogie
                    (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@191))
                    1))))
     (let ((a!2 (=> (and ($Is this@@191 Tclass.PagedBetree.QueryReceipt)
                         (INTERNAL_le_boogie 0 |i#0@@122|))
                    (= (|PagedBetree.QueryReceipt.ResultLinkedAt#requires|
                         this@@191
                         |i#0@@122|)
                       (and (PagedBetree.QueryReceipt.Structure this@@191)
                            (PagedBetree.QueryReceipt.AllLinesWF this@@191)
                            a!1)))))
       (=> (= (type this@@191) DatatypeTypeType) a!2)))
     :pattern ((|PagedBetree.QueryReceipt.ResultLinkedAt#requires|
                 this@@191
                 |i#0@@122|))
     :skolemid |3222|
     :qid |PagedBetreeidfy.214:15|)))
(assert (=> true
    (forall ((this@@192 T@U) (|i#0@@123| Int))
      (! (let ((a!1 (INTERNAL_lt_boogie
                      |i#0@@123|
                      (INTERNAL_sub_boogie
                        (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@192))
                        1)))
               (a!3 (PagedBetree.QueryReceiptLine.result
                      ($Unbox DatatypeTypeType
                              (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                             this@@192)
                                           |i#0@@123|))))
               (a!4 (PagedBetree.QueryReceiptLine.node
                      ($Unbox DatatypeTypeType
                              (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                             this@@192)
                                           |i#0@@123|))))
               (a!6 (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                      ($Unbox DatatypeTypeType
                              (|Seq#Index| (PagedBetree.QueryReceipt.lines
                                             this@@192)
                                           |i#0@@123|)))))
         (let ((a!2 (and (= (type this@@192) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall|
                               this@@192
                               |i#0@@123|)
                             (and ($Is this@@192
                                       Tclass.PagedBetree.QueryReceipt)
                                  (INTERNAL_le_boogie 0 |i#0@@123|)
                                  (PagedBetree.QueryReceipt.Structure this@@192)
                                  (PagedBetree.QueryReceipt.AllLinesWF
                                    this@@192)
                                  a!1))))
               (a!5 (ValueMessage.__default.Merge
                      (Buffers.BufferStack.Query
                        (PagedBetree.BetreeNode.buffers a!4)
                        (PagedBetree.QueryReceipt.key this@@192))
                      (PagedBetree.QueryReceipt.ResultAt
                        this@@192
                        (INTERNAL_add_boogie |i#0@@123| 1)))))
         (let ((a!7 (and (|$IsA#ValueMessage.Message| a!3)
                         (|$IsA#ValueMessage.Message| a!5)
                         (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                this@@192)
                              a!6)
                         (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                this@@192)
                              a!6)
                         (PagedBetree.QueryReceipt.QueryReceipt_q this@@192)
                         (|Buffers.BufferStack.Query#canCall|
                           (PagedBetree.BetreeNode.buffers a!4)
                           (PagedBetree.QueryReceipt.key this@@192))
                         (|PagedBetree.QueryReceipt.ResultAt#canCall|
                           this@@192
                           (INTERNAL_add_boogie |i#0@@123| 1))
                         (|ValueMessage.__default.Merge#canCall|
                           (Buffers.BufferStack.Query
                             (PagedBetree.BetreeNode.buffers a!4)
                             (PagedBetree.QueryReceipt.key this@@192))
                           (PagedBetree.QueryReceipt.ResultAt
                             this@@192
                             (INTERNAL_add_boogie |i#0@@123| 1))))))
         (let ((a!8 (=> (U_2_bool (Lit (bool_2_U true))) a!7)))
         (let ((a!9 (and a!8
                         (= (PagedBetree.QueryReceipt.ResultLinkedAt
                              this@@192
                              |i#0@@123|)
                            (and true (|ValueMessage.Message#Equal| a!3 a!5))))))
           (=> a!2 a!9))))))
         :pattern ((PagedBetree.QueryReceipt.ResultLinkedAt
                     this@@192
                     |i#0@@123|))
         :skolemid |3223|
         :qid |PagedBetreeidfy.214:15|))))
(assert (let ((a!1 (forall ((this@@193 T@U) (|i#0@@124| Int))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure
                                            (Lit this@@193)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF
                                            (Lit this@@193)))))
                      (a!3 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                (Lit this@@193)))))
                      (a!5 (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines
                                               (Lit this@@193)))
                                        (LitInt |i#0@@124|)))
                      (a!7 (Lit (PagedBetree.QueryReceipt.ResultAt
                                  (Lit this@@193)
                                  (LitInt (INTERNAL_add_boogie |i#0@@124| 1))))))
                (let ((a!4 (or (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall|
                                 (Lit this@@193)
                                 (LitInt |i#0@@124|))
                               (and ($Is this@@193
                                         Tclass.PagedBetree.QueryReceipt)
                                    (INTERNAL_le_boogie 0 |i#0@@124|)
                                    (U_2_bool a!1)
                                    (U_2_bool a!2)
                                    (INTERNAL_lt_boogie
                                      |i#0@@124|
                                      (INTERNAL_sub_boogie a!3 1)))))
                      (a!6 (Buffers.BufferStack.Query
                             (PagedBetree.BetreeNode.buffers
                               (PagedBetree.QueryReceiptLine.node
                                 ($Unbox DatatypeTypeType a!5)))
                             (Lit (PagedBetree.QueryReceipt.key (Lit this@@193)))))
                      (a!8 (|Buffers.BufferStack.Query#canCall|
                             (PagedBetree.BetreeNode.buffers
                               (PagedBetree.QueryReceiptLine.node
                                 ($Unbox DatatypeTypeType a!5)))
                             (Lit (PagedBetree.QueryReceipt.key (Lit this@@193))))))
                (let ((a!9 (and (|$IsA#ValueMessage.Message|
                                  (PagedBetree.QueryReceiptLine.result
                                    ($Unbox DatatypeTypeType a!5)))
                                (|$IsA#ValueMessage.Message|
                                  (ValueMessage.__default.Merge a!6 a!7))
                                (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                       (Lit this@@193))
                                     (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                       ($Unbox DatatypeTypeType a!5)))
                                (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                       (Lit this@@193))
                                     (PagedBetree.QueryReceiptLine.QueryReceiptLine_q
                                       ($Unbox DatatypeTypeType a!5)))
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  (Lit this@@193))
                                a!8
                                (|PagedBetree.QueryReceipt.ResultAt#canCall|
                                  (Lit this@@193)
                                  (LitInt (INTERNAL_add_boogie |i#0@@124| 1)))
                                (|ValueMessage.__default.Merge#canCall| a!6 a!7)))
                      (a!11 (and true
                                 (|ValueMessage.Message#Equal|
                                   (PagedBetree.QueryReceiptLine.result
                                     ($Unbox DatatypeTypeType a!5))
                                   (ValueMessage.__default.Merge a!6 a!7)))))
                (let ((a!10 (=> (U_2_bool (Lit (bool_2_U true))) a!9)))
                (let ((a!12 (and a!10
                                 (= (PagedBetree.QueryReceipt.ResultLinkedAt
                                      (Lit this@@193)
                                      (LitInt |i#0@@124|))
                                    a!11))))
                  (=> (and (= (type this@@193) DatatypeTypeType) a!4) a!12))))))
                :pattern ((PagedBetree.QueryReceipt.ResultLinkedAt
                            (Lit this@@193)
                            (LitInt |i#0@@124|)))
                :weight 3
                :skolemid |3224|
                :qid |PagedBetreeidfy.214:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@194 T@U))
             (! (=> (and (= (type this@@194) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.Valid#canCall|
                               this@@194)
                             ($Is this@@194 Tclass.PagedBetree.QueryReceipt)))
                    true)
                :pattern ((PagedBetree.QueryReceipt.Valid this@@194))
                :skolemid |3225|
                :qid |PagedBetreeidfy.222:15|))))
  (=> true a!1)))
(assert (forall ((this@@195 T@U))
  (! (=> (and (= (type this@@195) DatatypeTypeType)
              ($Is this@@195 Tclass.PagedBetree.QueryReceipt))
         (= (|PagedBetree.QueryReceipt.Valid#requires| this@@195) true))
     :pattern ((|PagedBetree.QueryReceipt.Valid#requires| this@@195))
     :skolemid |3226|
     :qid |PagedBetreeidfy.222:15|)))
(assert (let ((a!1 (forall ((this@@196 T@U))
             (! (let ((a!1 (forall ((|i#0@@125| Int))
                             (! (let ((a!1 (INTERNAL_lt_boogie
                                             |i#0@@125|
                                             (INTERNAL_sub_boogie
                                               (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                               this@@196))
                                               1))))
                                  (=> (INTERNAL_le_boogie 0 |i#0@@125|)
                                      (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                             this@@196)
                                           (=> a!1
                                               (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall|
                                                 this@@196
                                                 |i#0@@125|)))))
                                :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt
                                            this@@196
                                            |i#0@@125|))
                                :skolemid |3229|
                                :qid |PagedBetreeidfy.226:18|)))
                      (a!2 (forall ((|i#0@@126| Int))
                             (! (let ((a!1 (INTERNAL_lt_boogie
                                             |i#0@@126|
                                             (INTERNAL_sub_boogie
                                               (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                               this@@196))
                                               1))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#0@@126|)
                                           a!1)
                                      (PagedBetree.QueryReceipt.ChildLinkedAt
                                        this@@196
                                        |i#0@@126|)))
                                :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt
                                            this@@196
                                            |i#0@@126|))
                                :skolemid |3231|
                                :qid |PagedBetreeidfy.226:18|)))
                      (a!3 (forall ((|i#1@@25| Int))
                             (! (let ((a!1 (INTERNAL_lt_boogie
                                             |i#1@@25|
                                             (INTERNAL_sub_boogie
                                               (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                               this@@196))
                                               1))))
                                  (=> (INTERNAL_le_boogie 0 |i#1@@25|)
                                      (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                             this@@196)
                                           (=> a!1
                                               (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall|
                                                 this@@196
                                                 |i#1@@25|)))))
                                :pattern ((PagedBetree.QueryReceipt.ResultLinkedAt
                                            this@@196
                                            |i#1@@25|))
                                :skolemid |3230|
                                :qid |PagedBetreeidfy.227:18|)))
                      (a!5 (forall ((|i#0@@127| Int))
                             (! (let ((a!1 (INTERNAL_lt_boogie
                                             |i#0@@127|
                                             (INTERNAL_sub_boogie
                                               (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                               this@@196))
                                               1))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#0@@127|)
                                           a!1)
                                      (PagedBetree.QueryReceipt.ChildLinkedAt
                                        this@@196
                                        |i#0@@127|)))
                                :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt
                                            this@@196
                                            |i#0@@127|))
                                :skolemid |3227|
                                :qid |PagedBetreeidfy.226:18|)))
                      (a!6 (forall ((|i#1@@26| Int))
                             (! (let ((a!1 (INTERNAL_lt_boogie
                                             |i#1@@26|
                                             (INTERNAL_sub_boogie
                                               (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                                               this@@196))
                                               1))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#1@@26|) a!1)
                                      (PagedBetree.QueryReceipt.ResultLinkedAt
                                        this@@196
                                        |i#1@@26|)))
                                :pattern ((PagedBetree.QueryReceipt.ResultLinkedAt
                                            this@@196
                                            |i#1@@26|))
                                :skolemid |3228|
                                :qid |PagedBetreeidfy.227:18|))))
                (let ((a!4 (and (|PagedBetree.QueryReceipt.AllLinesWF#canCall|
                                  this@@196)
                                (=> (PagedBetree.QueryReceipt.AllLinesWF
                                      this@@196)
                                    (and a!1 (=> a!2 a!3))))))
                (let ((a!7 (and (|PagedBetree.QueryReceipt.Structure#canCall|
                                  this@@196)
                                (=> (PagedBetree.QueryReceipt.Structure
                                      this@@196)
                                    a!4)
                                (= (PagedBetree.QueryReceipt.Valid this@@196)
                                   (and (PagedBetree.QueryReceipt.Structure
                                          this@@196)
                                        (PagedBetree.QueryReceipt.AllLinesWF
                                          this@@196)
                                        a!5
                                        a!6)))))
                  (=> (and (= (type this@@196) DatatypeTypeType)
                           (or (|PagedBetree.QueryReceipt.Valid#canCall|
                                 this@@196)
                               ($Is this@@196 Tclass.PagedBetree.QueryReceipt)))
                      a!7))))
                :pattern ((PagedBetree.QueryReceipt.Valid this@@196))
                :skolemid |3232|
                :qid |PagedBetreeidfy.222:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@197 T@U))
             (! (let ((a!1 (and (= (type this@@197) DatatypeTypeType)
                                (or (|PagedBetree.QueryReceipt.Valid#canCall|
                                      (Lit this@@197))
                                    ($Is this@@197
                                         Tclass.PagedBetree.QueryReceipt))))
                      (a!2 (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure
                                            (Lit this@@197)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF
                                            (Lit this@@197)))))
                      (a!4 (forall ((|i#2@@7| Int))
                             (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                                (Lit this@@197))))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#2@@7|)
                                           (INTERNAL_lt_boogie
                                             |i#2@@7|
                                             (INTERNAL_sub_boogie a!1 1)))
                                      (PagedBetree.QueryReceipt.ChildLinkedAt
                                        (Lit this@@197)
                                        |i#2@@7|)))
                                :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt
                                            this@@197
                                            |i#2@@7|))
                                :skolemid |3237|
                                :qid |PagedBetreeidfy.226:18|)))
                      (a!8 (forall ((|i#2@@8| Int))
                             (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                                (Lit this@@197))))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#2@@8|)
                                           (INTERNAL_lt_boogie
                                             |i#2@@8|
                                             (INTERNAL_sub_boogie a!1 1)))
                                      (PagedBetree.QueryReceipt.ChildLinkedAt
                                        (Lit this@@197)
                                        |i#2@@8|)))
                                :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt
                                            this@@197
                                            |i#2@@8|))
                                :skolemid |3233|
                                :qid |PagedBetreeidfy.226:18|)))
                      (a!9 (forall ((|i#3@@2| Int))
                             (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                                (Lit this@@197))))))
                                  (=> (and (INTERNAL_le_boogie 0 |i#3@@2|)
                                           (INTERNAL_lt_boogie
                                             |i#3@@2|
                                             (INTERNAL_sub_boogie a!1 1)))
                                      (PagedBetree.QueryReceipt.ResultLinkedAt
                                        (Lit this@@197)
                                        |i#3@@2|)))
                                :pattern ((PagedBetree.QueryReceipt.ResultLinkedAt
                                            this@@197
                                            |i#3@@2|))
                                :skolemid |3234|
                                :qid |PagedBetreeidfy.227:18|))))
                (let ((a!5 (=> a!4
                               (forall ((|i#3@@1| Int))
                                 (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                                    (Lit this@@197))))))
                                    (let ((a!2 (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                                      (Lit this@@197))
                                                    (=> (INTERNAL_lt_boogie
                                                          |i#3@@1|
                                                          (INTERNAL_sub_boogie
                                                            a!1
                                                            1))
                                                        (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall|
                                                          (Lit this@@197)
                                                          |i#3@@1|)))))
                                      (=> (INTERNAL_le_boogie 0 |i#3@@1|) a!2)))
                                    :pattern ((PagedBetree.QueryReceipt.ResultLinkedAt
                                                this@@197
                                                |i#3@@1|))
                                    :skolemid |3236|
                                    :qid |PagedBetreeidfy.227:18|))))
                      (a!10 (= (PagedBetree.QueryReceipt.Valid (Lit this@@197))
                               (and (PagedBetree.QueryReceipt.Structure
                                      (Lit this@@197))
                                    (PagedBetree.QueryReceipt.AllLinesWF
                                      (Lit this@@197))
                                    a!8
                                    a!9))))
                (let ((a!6 (and (forall ((|i#2@@6| Int))
                                  (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines
                                                                     (Lit this@@197))))))
                                     (let ((a!2 (and (PagedBetree.QueryReceipt.QueryReceipt_q
                                                       (Lit this@@197))
                                                     (=> (INTERNAL_lt_boogie
                                                           |i#2@@6|
                                                           (INTERNAL_sub_boogie
                                                             a!1
                                                             1))
                                                         (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall|
                                                           (Lit this@@197)
                                                           |i#2@@6|)))))
                                       (=> (INTERNAL_le_boogie 0 |i#2@@6|) a!2)))
                                     :pattern ((PagedBetree.QueryReceipt.ChildLinkedAt
                                                 this@@197
                                                 |i#2@@6|))
                                     :skolemid |3235|
                                     :qid |PagedBetreeidfy.226:18|))
                                a!5)))
                (let ((a!7 (=> (U_2_bool a!2)
                               (and (|PagedBetree.QueryReceipt.AllLinesWF#canCall|
                                      (Lit this@@197))
                                    (=> (U_2_bool a!3) a!6)))))
                  (=> a!1
                      (and (|PagedBetree.QueryReceipt.Structure#canCall|
                             (Lit this@@197))
                           a!7
                           a!10))))))
                :pattern ((PagedBetree.QueryReceipt.Valid (Lit this@@197)))
                :weight 3
                :skolemid |3238|
                :qid |PagedBetreeidfy.222:15|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((this@@198 T@U))
             (! (let ((a!1 (and (= (type this@@198) DatatypeTypeType)
                                (or (|PagedBetree.QueryReceipt.Result#canCall|
                                      this@@198)
                                    (and ($Is this@@198
                                              Tclass.PagedBetree.QueryReceipt)
                                         (PagedBetree.QueryReceipt.Structure
                                           this@@198))))))
                  (=> a!1
                      ($Is (PagedBetree.QueryReceipt.Result this@@198)
                           Tclass.ValueMessage.Message)))
                :pattern ((PagedBetree.QueryReceipt.Result this@@198))
                :skolemid |3239|
                :qid |PagedBetreeidfy.230:14|))))
  (=> true a!1)))
(assert (forall ((this@@199 T@U))
  (! (=> (and (= (type this@@199) DatatypeTypeType)
              ($Is this@@199 Tclass.PagedBetree.QueryReceipt))
         (= (|PagedBetree.QueryReceipt.Result#requires| this@@199)
            (PagedBetree.QueryReceipt.Structure this@@199)))
     :pattern ((|PagedBetree.QueryReceipt.Result#requires| this@@199))
     :skolemid |3240|
     :qid |PagedBetreeidfy.230:14|)))
(assert (=> true
    (forall ((this@@200 T@U))
      (! (let ((a!1 (and (= (type this@@200) DatatypeTypeType)
                         (or (|PagedBetree.QueryReceipt.Result#canCall|
                               this@@200)
                             (and ($Is this@@200
                                       Tclass.PagedBetree.QueryReceipt)
                                  (PagedBetree.QueryReceipt.Structure this@@200)))))
               (a!2 (and (|PagedBetree.QueryReceipt.ResultAt#canCall|
                           this@@200
                           (LitInt 0))
                         (= (PagedBetree.QueryReceipt.Result this@@200)
                            (PagedBetree.QueryReceipt.ResultAt
                              this@@200
                              (LitInt 0))))))
           (=> a!1 a!2))
         :pattern ((PagedBetree.QueryReceipt.Result this@@200))
         :skolemid |3241|
         :qid |PagedBetreeidfy.230:14|))))
(assert (let ((a!1 (forall ((this@@201 T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure
                                            (Lit this@@201)))))
                      (a!3 (= (PagedBetree.QueryReceipt.Result (Lit this@@201))
                              (Lit (PagedBetree.QueryReceipt.ResultAt
                                     (Lit this@@201)
                                     (LitInt 0))))))
                (let ((a!2 (and (= (type this@@201) DatatypeTypeType)
                                (or (|PagedBetree.QueryReceipt.Result#canCall|
                                      (Lit this@@201))
                                    (and ($Is this@@201
                                              Tclass.PagedBetree.QueryReceipt)
                                         (U_2_bool a!1))))))
                  (=> a!2
                      (and (|PagedBetree.QueryReceipt.ResultAt#canCall|
                             (Lit this@@201)
                             (LitInt 0))
                           a!3))))
                :pattern ((PagedBetree.QueryReceipt.Result (Lit this@@201)))
                :weight 3
                :skolemid |3242|
                :qid |PagedBetreeidfy.230:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@202 T@U) (|root#0| T@U) (|key#0@@69| T@U))
      (! (let ((a!1 (and (= (type this@@202) DatatypeTypeType)
                         (= (type |root#0|) DatatypeTypeType)
                         (= (type |key#0@@69|) (SeqType BoxType))
                         (or (|PagedBetree.QueryReceipt.ValidFor#canCall|
                               this@@202
                               |root#0|
                               |key#0@@69|)
                             (and ($Is this@@202
                                       Tclass.PagedBetree.QueryReceipt)
                                  ($Is |root#0| Tclass.PagedBetree.BetreeNode)
                                  ($Is |key#0@@69| Tclass.KeyType.Key))))))
           (=> a!1 true))
         :pattern ((PagedBetree.QueryReceipt.ValidFor
                     this@@202
                     |root#0|
                     |key#0@@69|))
         :skolemid |3243|
         :qid |PagedBetreeidfy.236:15|))))
(assert (forall ((this@@203 T@U) (|root#0@@0| T@U) (|key#0@@70| T@U))
  (! (=> (and (= (type this@@203) DatatypeTypeType)
              (= (type |root#0@@0|) DatatypeTypeType)
              (= (type |key#0@@70|) (SeqType BoxType))
              ($Is this@@203 Tclass.PagedBetree.QueryReceipt)
              ($Is |root#0@@0| Tclass.PagedBetree.BetreeNode)
              ($Is |key#0@@70| Tclass.KeyType.Key))
         (= (|PagedBetree.QueryReceipt.ValidFor#requires|
              this@@203
              |root#0@@0|
              |key#0@@70|)
            true))
     :pattern ((|PagedBetree.QueryReceipt.ValidFor#requires|
                 this@@203
                 |root#0@@0|
                 |key#0@@70|))
     :skolemid |3244|
     :qid |PagedBetreeidfy.236:15|)))
(assert (let ((a!1 (forall ((this@@204 T@U) (|root#0@@1| T@U) (|key#0@@71| T@U))
             (! (let ((a!1 (and (= (type this@@204) DatatypeTypeType)
                                (= (type |root#0@@1|) DatatypeTypeType)
                                (= (type |key#0@@71|) (SeqType BoxType))
                                (or (|PagedBetree.QueryReceipt.ValidFor#canCall|
                                      this@@204
                                      |root#0@@1|
                                      |key#0@@71|)
                                    (and ($Is this@@204
                                              Tclass.PagedBetree.QueryReceipt)
                                         ($Is |root#0@@1|
                                              Tclass.PagedBetree.BetreeNode)
                                         ($Is |key#0@@71| Tclass.KeyType.Key)))))
                      (a!2 (and (|$IsA#PagedBetree.BetreeNode|
                                  (PagedBetree.QueryReceipt.root this@@204))
                                (|$IsA#PagedBetree.BetreeNode| |root#0@@1|)
                                (PagedBetree.QueryReceipt.QueryReceipt_q
                                  this@@204)
                                (=> (|PagedBetree.BetreeNode#Equal|
                                      (PagedBetree.QueryReceipt.root this@@204)
                                      |root#0@@1|)
                                    (PagedBetree.QueryReceipt.QueryReceipt_q
                                      this@@204))))
                      (a!3 (= (PagedBetree.QueryReceipt.ValidFor
                                this@@204
                                |root#0@@1|
                                |key#0@@71|)
                              (and (PagedBetree.QueryReceipt.Valid this@@204)
                                   (|PagedBetree.BetreeNode#Equal|
                                     (PagedBetree.QueryReceipt.root this@@204)
                                     |root#0@@1|)
                                   (|Seq#Equal| (PagedBetree.QueryReceipt.key
                                                  this@@204)
                                                |key#0@@71|)))))
                  (=> a!1
                      (and (|PagedBetree.QueryReceipt.Valid#canCall| this@@204)
                           (=> (PagedBetree.QueryReceipt.Valid this@@204) a!2)
                           a!3)))
                :pattern ((PagedBetree.QueryReceipt.ValidFor
                            this@@204
                            |root#0@@1|
                            |key#0@@71|))
                :skolemid |3245|
                :qid |PagedBetreeidfy.236:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@205 T@U) (|root#0@@2| T@U) (|key#0@@72| T@U))
      (! (let ((a!1 (and (= (type this@@205) DatatypeTypeType)
                         (= (type |root#0@@2|) DatatypeTypeType)
                         (= (type |key#0@@72|) (SeqType BoxType))
                         (or (|PagedBetree.QueryReceipt.ValidFor#canCall|
                               (Lit this@@205)
                               (Lit |root#0@@2|)
                               (Lit |key#0@@72|))
                             (and ($Is this@@205
                                       Tclass.PagedBetree.QueryReceipt)
                                  ($Is |root#0@@2|
                                       Tclass.PagedBetree.BetreeNode)
                                  ($Is |key#0@@72| Tclass.KeyType.Key)))))
               (a!2 (Lit (bool_2_U (PagedBetree.QueryReceipt.Valid
                                     (Lit this@@205)))))
               (a!3 (|$IsA#PagedBetree.BetreeNode|
                      (Lit (PagedBetree.QueryReceipt.root (Lit this@@205)))))
               (a!4 (=> (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.QueryReceipt.root (Lit this@@205))
                          |root#0@@2|)
                        (PagedBetree.QueryReceipt.QueryReceipt_q
                          (Lit this@@205))))
               (a!6 (and (PagedBetree.QueryReceipt.Valid (Lit this@@205))
                         (|PagedBetree.BetreeNode#Equal|
                           (PagedBetree.QueryReceipt.root (Lit this@@205))
                           |root#0@@2|)
                         (|Seq#Equal| (PagedBetree.QueryReceipt.key
                                        (Lit this@@205))
                                      |key#0@@72|))))
         (let ((a!5 (=> (U_2_bool a!2)
                        (and a!3
                             (|$IsA#PagedBetree.BetreeNode| (Lit |root#0@@2|))
                             (PagedBetree.QueryReceipt.QueryReceipt_q
                               (Lit this@@205))
                             a!4))))
         (let ((a!7 (and (|PagedBetree.QueryReceipt.Valid#canCall|
                           (Lit this@@205))
                         a!5
                         (= (PagedBetree.QueryReceipt.ValidFor
                              (Lit this@@205)
                              (Lit |root#0@@2|)
                              (Lit |key#0@@72|))
                            a!6))))
           (=> a!1 a!7))))
         :pattern ((PagedBetree.QueryReceipt.ValidFor
                     (Lit this@@205)
                     (Lit |root#0@@2|)
                     (Lit |key#0@@72|)))
         :weight 3
         :skolemid |3246|
         :qid |PagedBetreeidfy.236:15|))))
(assert (forall ((arg0@@577 T@U) (arg1@@294 T@U))
  (! (= (type (|#PagedBetree.Variables.Variables| arg0@@577 arg1@@294))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.Variables.Variables| arg0@@577 arg1@@294))
     :qid |funType:#PagedBetree.Variables.Variables|)))
(assert (forall ((|a#0#0#0@@9| T@U) (|a#0#1#0@@6| T@U))
  (! (=> (and (= (type |a#0#0#0@@9|) DatatypeTypeType)
              (= (type |a#0#1#0@@6|) DatatypeTypeType))
         (= (DatatypeCtorId (|#PagedBetree.Variables.Variables|
                              |a#0#0#0@@9|
                              |a#0#1#0@@6|))
            |##PagedBetree.Variables.Variables|))
     :pattern ((|#PagedBetree.Variables.Variables| |a#0#0#0@@9| |a#0#1#0@@6|))
     :skolemid |3247|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((d@@118 T@U))
  (! (=> (= (type d@@118) DatatypeTypeType)
         (= (PagedBetree.Variables.Variables_q d@@118)
            (= (DatatypeCtorId d@@118) |##PagedBetree.Variables.Variables|)))
     :pattern ((PagedBetree.Variables.Variables_q d@@118))
     :skolemid |3248|
     :qid |unknown.0:0|)))
(assert (forall ((d@@119 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@9| T@U) (|a#1#1#0@@6| T@U))
                  (! (and (= (type |a#1#0#0@@9|) DatatypeTypeType)
                          (= (type |a#1#1#0@@6|) DatatypeTypeType)
                          (= d@@119
                             (|#PagedBetree.Variables.Variables|
                               |a#1#0#0@@9|
                               |a#1#1#0@@6|)))
                     :no-pattern (type |a#1#0#0@@9|)
                     :no-pattern (type |a#1#1#0@@6|)
                     :no-pattern (U_2_int |a#1#0#0@@9|)
                     :no-pattern (U_2_bool |a#1#0#0@@9|)
                     :no-pattern (U_2_int |a#1#1#0@@6|)
                     :no-pattern (U_2_bool |a#1#1#0@@6|)
                     :skolemid |3249|
                     :qid |PagedBetreeidfy.245:5|))))
       (=> (and (= (type d@@119) DatatypeTypeType)
                (PagedBetree.Variables.Variables_q d@@119))
           a!1))
     :pattern ((PagedBetree.Variables.Variables_q d@@119))
     :skolemid |3250|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@9| T@U) (|a#2#1#0@@6| T@U))
  (! (=> (and (= (type |a#2#0#0@@9|) DatatypeTypeType)
              (= (type |a#2#1#0@@6|) DatatypeTypeType))
         (= ($Is (|#PagedBetree.Variables.Variables| |a#2#0#0@@9| |a#2#1#0@@6|)
                 Tclass.PagedBetree.Variables)
            (and ($Is |a#2#0#0@@9| Tclass.MemtableMod.Memtable)
                 ($Is |a#2#1#0@@6| Tclass.PagedBetree.BetreeNode))))
     :pattern (($Is (|#PagedBetree.Variables.Variables|
                      |a#2#0#0@@9|
                      |a#2#1#0@@6|)
                    Tclass.PagedBetree.Variables))
     :skolemid |3251|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((|a#3#0#0@@9| T@U) (|a#3#1#0@@6| T@U) ($h@@134 T@U))
  (! (=> (and (= (type |a#3#0#0@@9|) DatatypeTypeType)
              (= (type |a#3#1#0@@6|) DatatypeTypeType)
              (= (type $h@@134) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@134))
         (= ($IsAlloc (|#PagedBetree.Variables.Variables|
                        |a#3#0#0@@9|
                        |a#3#1#0@@6|)
                      Tclass.PagedBetree.Variables
                      $h@@134)
            (and ($IsAlloc |a#3#0#0@@9| Tclass.MemtableMod.Memtable $h@@134)
                 ($IsAlloc |a#3#1#0@@6| Tclass.PagedBetree.BetreeNode $h@@134))))
     :pattern (($IsAlloc (|#PagedBetree.Variables.Variables|
                           |a#3#0#0@@9|
                           |a#3#1#0@@6|)
                         Tclass.PagedBetree.Variables
                         $h@@134))
     :skolemid |3252|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((d@@120 T@U) ($h@@135 T@U))
  (! (=> (and (= (type d@@120) DatatypeTypeType)
              (= (type $h@@135) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@135)
              (PagedBetree.Variables.Variables_q d@@120)
              ($IsAlloc d@@120 Tclass.PagedBetree.Variables $h@@135))
         ($IsAlloc (PagedBetree.Variables.memtable d@@120)
                   Tclass.MemtableMod.Memtable
                   $h@@135))
     :pattern (($IsAlloc (PagedBetree.Variables.memtable d@@120)
                         Tclass.MemtableMod.Memtable
                         $h@@135))
     :skolemid |3253|
     :qid |unknown.0:0|)))
(assert (forall ((d@@121 T@U) ($h@@136 T@U))
  (! (=> (and (= (type d@@121) DatatypeTypeType)
              (= (type $h@@136) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@136)
              (PagedBetree.Variables.Variables_q d@@121)
              ($IsAlloc d@@121 Tclass.PagedBetree.Variables $h@@136))
         ($IsAlloc (PagedBetree.Variables.root d@@121)
                   Tclass.PagedBetree.BetreeNode
                   $h@@136))
     :pattern (($IsAlloc (PagedBetree.Variables.root d@@121)
                         Tclass.PagedBetree.BetreeNode
                         $h@@136))
     :skolemid |3254|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@9| T@U) (|a#4#1#0@@6| T@U))
  (! (=> (and (= (type |a#4#0#0@@9|) DatatypeTypeType)
              (= (type |a#4#1#0@@6|) DatatypeTypeType))
         (= (|#PagedBetree.Variables.Variables|
              (Lit |a#4#0#0@@9|)
              (Lit |a#4#1#0@@6|))
            (Lit (|#PagedBetree.Variables.Variables| |a#4#0#0@@9| |a#4#1#0@@6|))))
     :pattern ((|#PagedBetree.Variables.Variables|
                 (Lit |a#4#0#0@@9|)
                 (Lit |a#4#1#0@@6|)))
     :skolemid |3255|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((|a#5#0#0@@11| T@U) (|a#5#1#0@@7| T@U))
  (! (=> (and (= (type |a#5#0#0@@11|) DatatypeTypeType)
              (= (type |a#5#1#0@@7|) DatatypeTypeType))
         (= (PagedBetree.Variables.memtable
              (|#PagedBetree.Variables.Variables| |a#5#0#0@@11| |a#5#1#0@@7|))
            |a#5#0#0@@11|))
     :pattern ((|#PagedBetree.Variables.Variables| |a#5#0#0@@11| |a#5#1#0@@7|))
     :skolemid |3256|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((|a#6#0#0@@11| T@U) (|a#6#1#0@@7| T@U))
  (! (=> (and (= (type |a#6#0#0@@11|) DatatypeTypeType)
              (= (type |a#6#1#0@@7|) DatatypeTypeType))
         (< (DtRank |a#6#0#0@@11|)
            (DtRank (|#PagedBetree.Variables.Variables|
                      |a#6#0#0@@11|
                      |a#6#1#0@@7|))))
     :pattern ((|#PagedBetree.Variables.Variables| |a#6#0#0@@11| |a#6#1#0@@7|))
     :skolemid |3257|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((|a#7#0#0@@11| T@U) (|a#7#1#0@@7| T@U))
  (! (=> (and (= (type |a#7#0#0@@11|) DatatypeTypeType)
              (= (type |a#7#1#0@@7|) DatatypeTypeType))
         (= (PagedBetree.Variables.root
              (|#PagedBetree.Variables.Variables| |a#7#0#0@@11| |a#7#1#0@@7|))
            |a#7#1#0@@7|))
     :pattern ((|#PagedBetree.Variables.Variables| |a#7#0#0@@11| |a#7#1#0@@7|))
     :skolemid |3258|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((|a#8#0#0@@8| T@U) (|a#8#1#0@@5| T@U))
  (! (=> (and (= (type |a#8#0#0@@8|) DatatypeTypeType)
              (= (type |a#8#1#0@@5|) DatatypeTypeType))
         (< (DtRank |a#8#1#0@@5|)
            (DtRank (|#PagedBetree.Variables.Variables|
                      |a#8#0#0@@8|
                      |a#8#1#0@@5|))))
     :pattern ((|#PagedBetree.Variables.Variables| |a#8#0#0@@8| |a#8#1#0@@5|))
     :skolemid |3259|
     :qid |PagedBetreeidfy.245:5|)))
(assert (forall ((d@@122 T@U))
  (! (=> (and (= (type d@@122) DatatypeTypeType)
              (|$IsA#PagedBetree.Variables| d@@122))
         (PagedBetree.Variables.Variables_q d@@122))
     :pattern ((|$IsA#PagedBetree.Variables| d@@122))
     :skolemid |3260|
     :qid |unknown.0:0|)))
(assert (forall ((d@@123 T@U))
  (! (=> (and (= (type d@@123) DatatypeTypeType)
              ($Is d@@123 Tclass.PagedBetree.Variables))
         (PagedBetree.Variables.Variables_q d@@123))
     :pattern ((PagedBetree.Variables.Variables_q d@@123)
               ($Is d@@123 Tclass.PagedBetree.Variables))
     :skolemid |3261|
     :qid |unknown.0:0|)))
(assert (forall ((a@@153 T@U) (b@@103 T@U))
  (! (let ((a!1 (= (|PagedBetree.Variables#Equal| a@@153 b@@103)
                   (and (|MemtableMod.Memtable#Equal|
                          (PagedBetree.Variables.memtable a@@153)
                          (PagedBetree.Variables.memtable b@@103))
                        (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.Variables.root a@@153)
                          (PagedBetree.Variables.root b@@103))))))
       (=> (and (= (type a@@153) DatatypeTypeType)
                (= (type b@@103) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|PagedBetree.Variables#Equal| a@@153 b@@103))
     :skolemid |3262|
     :qid |unknown.0:0|)))
(assert (forall ((a@@154 T@U) (b@@104 T@U))
  (! (=> (and (= (type a@@154) DatatypeTypeType)
              (= (type b@@104) DatatypeTypeType))
         (= (|PagedBetree.Variables#Equal| a@@154 b@@104) (= a@@154 b@@104)))
     :pattern ((|PagedBetree.Variables#Equal| a@@154 b@@104))
     :skolemid |3263|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((this@@206 T@U))
             (! (=> (and (= (type this@@206) DatatypeTypeType)
                         (or (|PagedBetree.Variables.WF#canCall| this@@206)
                             ($Is this@@206 Tclass.PagedBetree.Variables)))
                    true)
                :pattern ((PagedBetree.Variables.WF this@@206))
                :skolemid |3264|
                :qid |PagedBetreeidfy.248:15|))))
  (=> true a!1)))
(assert (forall ((this@@207 T@U))
  (! (=> (and (= (type this@@207) DatatypeTypeType)
              ($Is this@@207 Tclass.PagedBetree.Variables))
         (= (|PagedBetree.Variables.WF#requires| this@@207) true))
     :pattern ((|PagedBetree.Variables.WF#requires| this@@207))
     :skolemid |3265|
     :qid |PagedBetreeidfy.248:15|)))
(assert (let ((a!1 (forall ((this@@208 T@U))
             (! (let ((a!1 (=> (U_2_bool (Lit (bool_2_U true)))
                               (and (PagedBetree.Variables.Variables_q
                                      this@@208)
                                    (|PagedBetree.BetreeNode.WF#canCall|
                                      (PagedBetree.Variables.root this@@208)))))
                      (a!2 (= (PagedBetree.Variables.WF this@@208)
                              (and true
                                   (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (PagedBetree.Variables.root this@@208))))))
                  (=> (and (= (type this@@208) DatatypeTypeType)
                           (or (|PagedBetree.Variables.WF#canCall| this@@208)
                               ($Is this@@208 Tclass.PagedBetree.Variables)))
                      (and a!1 a!2)))
                :pattern ((PagedBetree.Variables.WF this@@208))
                :skolemid |3266|
                :qid |PagedBetreeidfy.248:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@209 T@U))
      (! (let ((a!1 (and (= (type this@@209) DatatypeTypeType)
                         (or (|PagedBetree.Variables.WF#canCall|
                               (Lit this@@209))
                             ($Is this@@209 Tclass.PagedBetree.Variables))))
               (a!2 (|PagedBetree.BetreeNode.WF#canCall|
                      (Lit (PagedBetree.Variables.root (Lit this@@209)))))
               (a!4 (PagedBetree.BetreeNode.WF
                      ($LS $LZ)
                      (Lit (PagedBetree.Variables.root (Lit this@@209))))))
         (let ((a!3 (=> (U_2_bool (Lit (bool_2_U true)))
                        (and (PagedBetree.Variables.Variables_q (Lit this@@209))
                             a!2)))
               (a!5 (U_2_bool (Lit (bool_2_U (and true a!4))))))
         (let ((a!6 (and a!3 (= (PagedBetree.Variables.WF (Lit this@@209)) a!5))))
           (=> a!1 a!6))))
         :pattern ((PagedBetree.Variables.WF (Lit this@@209)))
         :weight 3
         :skolemid |3267|
         :qid |PagedBetreeidfy.248:15|))))
(assert (forall ((arg0@@578 T@U) (arg1@@295 T@U) (arg2@@165 T@U))
  (! (= (type (|#PagedBetree.Path.Path| arg0@@578 arg1@@295 arg2@@165))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.Path.Path| arg0@@578 arg1@@295 arg2@@165))
     :qid |funType:#PagedBetree.Path.Path|)))
(assert (forall ((|a#0#0#0@@10| T@U) (|a#0#1#0@@7| T@U) (|a#0#2#0@@1| T@U))
  (! (=> (and (= (type |a#0#0#0@@10|) DatatypeTypeType)
              (= (type |a#0#1#0@@7|) (SeqType BoxType))
              (= (type |a#0#2#0@@1|) (SeqType BoxType)))
         (= (DatatypeCtorId (|#PagedBetree.Path.Path|
                              |a#0#0#0@@10|
                              |a#0#1#0@@7|
                              |a#0#2#0@@1|))
            |##PagedBetree.Path.Path|))
     :pattern ((|#PagedBetree.Path.Path|
                 |a#0#0#0@@10|
                 |a#0#1#0@@7|
                 |a#0#2#0@@1|))
     :skolemid |3268|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((d@@124 T@U))
  (! (=> (= (type d@@124) DatatypeTypeType)
         (= (PagedBetree.Path.Path_q d@@124)
            (= (DatatypeCtorId d@@124) |##PagedBetree.Path.Path|)))
     :pattern ((PagedBetree.Path.Path_q d@@124))
     :skolemid |3269|
     :qid |unknown.0:0|)))
(assert (forall ((d@@125 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@10| T@U)
                         (|a#1#1#0@@7| T@U)
                         (|a#1#2#0@@1| T@U))
                  (! (and (= (type |a#1#0#0@@10|) DatatypeTypeType)
                          (= (type |a#1#1#0@@7|) (SeqType BoxType))
                          (= (type |a#1#2#0@@1|) (SeqType BoxType))
                          (= d@@125
                             (|#PagedBetree.Path.Path|
                               |a#1#0#0@@10|
                               |a#1#1#0@@7|
                               |a#1#2#0@@1|)))
                     :no-pattern (type |a#1#0#0@@10|)
                     :no-pattern (type |a#1#1#0@@7|)
                     :no-pattern (type |a#1#2#0@@1|)
                     :no-pattern (U_2_int |a#1#0#0@@10|)
                     :no-pattern (U_2_bool |a#1#0#0@@10|)
                     :no-pattern (U_2_int |a#1#1#0@@7|)
                     :no-pattern (U_2_bool |a#1#1#0@@7|)
                     :no-pattern (U_2_int |a#1#2#0@@1|)
                     :no-pattern (U_2_bool |a#1#2#0@@1|)
                     :skolemid |3270|
                     :qid |PagedBetreeidfy.300:24|))))
       (=> (and (= (type d@@125) DatatypeTypeType)
                (PagedBetree.Path.Path_q d@@125))
           a!1))
     :pattern ((PagedBetree.Path.Path_q d@@125))
     :skolemid |3271|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@10| T@U) (|a#2#1#0@@7| T@U) (|a#2#2#0@@1| T@U))
  (! (let ((a!1 (and ($Is |a#2#0#0@@10| Tclass.PagedBetree.BetreeNode)
                     ($Is |a#2#1#0@@7| Tclass.KeyType.Key)
                     ($Is |a#2#2#0@@1| (TSeq (TISet Tclass.KeyType.Key))))))
       (=> (and (= (type |a#2#0#0@@10|) DatatypeTypeType)
                (= (type |a#2#1#0@@7|) (SeqType BoxType))
                (= (type |a#2#2#0@@1|) (SeqType BoxType)))
           (= ($Is (|#PagedBetree.Path.Path|
                     |a#2#0#0@@10|
                     |a#2#1#0@@7|
                     |a#2#2#0@@1|)
                   Tclass.PagedBetree.Path)
              a!1)))
     :pattern (($Is (|#PagedBetree.Path.Path|
                      |a#2#0#0@@10|
                      |a#2#1#0@@7|
                      |a#2#2#0@@1|)
                    Tclass.PagedBetree.Path))
     :skolemid |3272|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((|a#3#0#0@@10| T@U)
         (|a#3#1#0@@7| T@U)
         (|a#3#2#0@@1| T@U)
         ($h@@137 T@U))
  (! (let ((a!1 (and ($IsAlloc |a#3#0#0@@10|
                               Tclass.PagedBetree.BetreeNode
                               $h@@137)
                     ($IsAlloc |a#3#1#0@@7| Tclass.KeyType.Key $h@@137)
                     ($IsAlloc |a#3#2#0@@1|
                               (TSeq (TISet Tclass.KeyType.Key))
                               $h@@137))))
       (=> (and (= (type |a#3#0#0@@10|) DatatypeTypeType)
                (= (type |a#3#1#0@@7|) (SeqType BoxType))
                (= (type |a#3#2#0@@1|) (SeqType BoxType))
                (= (type $h@@137) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@137))
           (= ($IsAlloc (|#PagedBetree.Path.Path|
                          |a#3#0#0@@10|
                          |a#3#1#0@@7|
                          |a#3#2#0@@1|)
                        Tclass.PagedBetree.Path
                        $h@@137)
              a!1)))
     :pattern (($IsAlloc (|#PagedBetree.Path.Path|
                           |a#3#0#0@@10|
                           |a#3#1#0@@7|
                           |a#3#2#0@@1|)
                         Tclass.PagedBetree.Path
                         $h@@137))
     :skolemid |3273|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((arg0@@579 T@U))
  (! (= (type (PagedBetree.Path.node arg0@@579)) DatatypeTypeType)
     :pattern ((PagedBetree.Path.node arg0@@579))
     :qid |funType:PagedBetree.Path.node|)))
(assert (forall ((d@@126 T@U) ($h@@138 T@U))
  (! (=> (and (= (type d@@126) DatatypeTypeType)
              (= (type $h@@138) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@138)
              (PagedBetree.Path.Path_q d@@126)
              ($IsAlloc d@@126 Tclass.PagedBetree.Path $h@@138))
         ($IsAlloc (PagedBetree.Path.node d@@126)
                   Tclass.PagedBetree.BetreeNode
                   $h@@138))
     :pattern (($IsAlloc (PagedBetree.Path.node d@@126)
                         Tclass.PagedBetree.BetreeNode
                         $h@@138))
     :skolemid |3274|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@580 T@U))
  (! (= (type (PagedBetree.Path.key arg0@@580)) (SeqType BoxType))
     :pattern ((PagedBetree.Path.key arg0@@580))
     :qid |funType:PagedBetree.Path.key|)))
(assert (forall ((d@@127 T@U) ($h@@139 T@U))
  (! (=> (and (= (type d@@127) DatatypeTypeType)
              (= (type $h@@139) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@139)
              (PagedBetree.Path.Path_q d@@127)
              ($IsAlloc d@@127 Tclass.PagedBetree.Path $h@@139))
         ($IsAlloc (PagedBetree.Path.key d@@127) Tclass.KeyType.Key $h@@139))
     :pattern (($IsAlloc (PagedBetree.Path.key d@@127)
                         Tclass.KeyType.Key
                         $h@@139))
     :skolemid |3275|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@581 T@U))
  (! (= (type (PagedBetree.Path.routing arg0@@581)) (SeqType BoxType))
     :pattern ((PagedBetree.Path.routing arg0@@581))
     :qid |funType:PagedBetree.Path.routing|)))
(assert (forall ((d@@128 T@U) ($h@@140 T@U))
  (! (=> (and (= (type d@@128) DatatypeTypeType)
              (= (type $h@@140) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@140)
              (PagedBetree.Path.Path_q d@@128)
              ($IsAlloc d@@128 Tclass.PagedBetree.Path $h@@140))
         ($IsAlloc (PagedBetree.Path.routing d@@128)
                   (TSeq (TISet Tclass.KeyType.Key))
                   $h@@140))
     :pattern (($IsAlloc (PagedBetree.Path.routing d@@128)
                         (TSeq (TISet Tclass.KeyType.Key))
                         $h@@140))
     :skolemid |3276|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@10| T@U) (|a#4#1#0@@7| T@U) (|a#4#2#0@@1| T@U))
  (! (=> (and (= (type |a#4#0#0@@10|) DatatypeTypeType)
              (= (type |a#4#1#0@@7|) (SeqType BoxType))
              (= (type |a#4#2#0@@1|) (SeqType BoxType)))
         (= (|#PagedBetree.Path.Path|
              (Lit |a#4#0#0@@10|)
              (Lit |a#4#1#0@@7|)
              (Lit |a#4#2#0@@1|))
            (Lit (|#PagedBetree.Path.Path|
                   |a#4#0#0@@10|
                   |a#4#1#0@@7|
                   |a#4#2#0@@1|))))
     :pattern ((|#PagedBetree.Path.Path|
                 (Lit |a#4#0#0@@10|)
                 (Lit |a#4#1#0@@7|)
                 (Lit |a#4#2#0@@1|)))
     :skolemid |3277|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((|a#5#0#0@@12| T@U) (|a#5#1#0@@8| T@U) (|a#5#2#0@@1| T@U))
  (! (=> (and (= (type |a#5#0#0@@12|) DatatypeTypeType)
              (= (type |a#5#1#0@@8|) (SeqType BoxType))
              (= (type |a#5#2#0@@1|) (SeqType BoxType)))
         (= (PagedBetree.Path.node
              (|#PagedBetree.Path.Path| |a#5#0#0@@12| |a#5#1#0@@8| |a#5#2#0@@1|))
            |a#5#0#0@@12|))
     :pattern ((|#PagedBetree.Path.Path|
                 |a#5#0#0@@12|
                 |a#5#1#0@@8|
                 |a#5#2#0@@1|))
     :skolemid |3278|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((|a#6#0#0@@12| T@U) (|a#6#1#0@@8| T@U) (|a#6#2#0@@1| T@U))
  (! (=> (and (= (type |a#6#0#0@@12|) DatatypeTypeType)
              (= (type |a#6#1#0@@8|) (SeqType BoxType))
              (= (type |a#6#2#0@@1|) (SeqType BoxType)))
         (< (DtRank |a#6#0#0@@12|)
            (DtRank (|#PagedBetree.Path.Path|
                      |a#6#0#0@@12|
                      |a#6#1#0@@8|
                      |a#6#2#0@@1|))))
     :pattern ((|#PagedBetree.Path.Path|
                 |a#6#0#0@@12|
                 |a#6#1#0@@8|
                 |a#6#2#0@@1|))
     :skolemid |3279|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((|a#7#0#0@@12| T@U) (|a#7#1#0@@8| T@U) (|a#7#2#0@@1| T@U))
  (! (=> (and (= (type |a#7#0#0@@12|) DatatypeTypeType)
              (= (type |a#7#1#0@@8|) (SeqType BoxType))
              (= (type |a#7#2#0@@1|) (SeqType BoxType)))
         (= (PagedBetree.Path.key
              (|#PagedBetree.Path.Path| |a#7#0#0@@12| |a#7#1#0@@8| |a#7#2#0@@1|))
            |a#7#1#0@@8|))
     :pattern ((|#PagedBetree.Path.Path|
                 |a#7#0#0@@12|
                 |a#7#1#0@@8|
                 |a#7#2#0@@1|))
     :skolemid |3280|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((|a#8#0#0@@9| T@U) (|a#8#1#0@@6| T@U) (|a#8#2#0@@1| T@U))
  (! (=> (and (= (type |a#8#0#0@@9|) DatatypeTypeType)
              (= (type |a#8#1#0@@6|) (SeqType BoxType))
              (= (type |a#8#2#0@@1|) (SeqType BoxType)))
         (= (PagedBetree.Path.routing
              (|#PagedBetree.Path.Path| |a#8#0#0@@9| |a#8#1#0@@6| |a#8#2#0@@1|))
            |a#8#2#0@@1|))
     :pattern ((|#PagedBetree.Path.Path| |a#8#0#0@@9| |a#8#1#0@@6| |a#8#2#0@@1|))
     :skolemid |3281|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((|a#9#0#0@@5| T@U) (|a#9#1#0@@2| T@U) (|a#9#2#0@@1| T@U) (i@@27 Int))
  (! (let ((a!1 (< (DtRank ($Unbox DatatypeTypeType
                                   (|Seq#Index| |a#9#2#0@@1| i@@27)))
                   (DtRank (|#PagedBetree.Path.Path|
                             |a#9#0#0@@5|
                             |a#9#1#0@@2|
                             |a#9#2#0@@1|)))))
       (=> (and (= (type |a#9#0#0@@5|) DatatypeTypeType)
                (= (type |a#9#1#0@@2|) (SeqType BoxType))
                (= (type |a#9#2#0@@1|) (SeqType BoxType))
                (<= 0 i@@27)
                (< i@@27 (|Seq#Length| |a#9#2#0@@1|)))
           a!1))
     :pattern ((|Seq#Index| |a#9#2#0@@1| i@@27)
               (|#PagedBetree.Path.Path| |a#9#0#0@@5| |a#9#1#0@@2| |a#9#2#0@@1|))
     :skolemid |3282|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((|a#10#0#0@@5| T@U) (|a#10#1#0@@2| T@U) (|a#10#2#0@@1| T@U))
  (! (=> (and (= (type |a#10#0#0@@5|) DatatypeTypeType)
              (= (type |a#10#1#0@@2|) (SeqType BoxType))
              (= (type |a#10#2#0@@1|) (SeqType BoxType)))
         (< (|Seq#Rank| |a#10#2#0@@1|)
            (DtRank (|#PagedBetree.Path.Path|
                      |a#10#0#0@@5|
                      |a#10#1#0@@2|
                      |a#10#2#0@@1|))))
     :pattern ((|#PagedBetree.Path.Path|
                 |a#10#0#0@@5|
                 |a#10#1#0@@2|
                 |a#10#2#0@@1|))
     :skolemid |3283|
     :qid |PagedBetreeidfy.300:24|)))
(assert (forall ((d@@129 T@U))
  (! (=> (and (= (type d@@129) DatatypeTypeType)
              (|$IsA#PagedBetree.Path| d@@129))
         (PagedBetree.Path.Path_q d@@129))
     :pattern ((|$IsA#PagedBetree.Path| d@@129))
     :skolemid |3284|
     :qid |unknown.0:0|)))
(assert (forall ((d@@130 T@U))
  (! (=> (and (= (type d@@130) DatatypeTypeType)
              ($Is d@@130 Tclass.PagedBetree.Path))
         (PagedBetree.Path.Path_q d@@130))
     :pattern ((PagedBetree.Path.Path_q d@@130)
               ($Is d@@130 Tclass.PagedBetree.Path))
     :skolemid |3285|
     :qid |unknown.0:0|)))
(assert (forall ((a@@155 T@U) (b@@105 T@U))
  (! (let ((a!1 (= (|PagedBetree.Path#Equal| a@@155 b@@105)
                   (and (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.Path.node a@@155)
                          (PagedBetree.Path.node b@@105))
                        (|Seq#Equal| (PagedBetree.Path.key a@@155)
                                     (PagedBetree.Path.key b@@105))
                        (|Seq#Equal| (PagedBetree.Path.routing a@@155)
                                     (PagedBetree.Path.routing b@@105))))))
       (=> (and (= (type a@@155) DatatypeTypeType)
                (= (type b@@105) DatatypeTypeType)
                true)
           a!1))
     :pattern ((|PagedBetree.Path#Equal| a@@155 b@@105))
     :skolemid |3286|
     :qid |unknown.0:0|)))
(assert (forall ((a@@156 T@U) (b@@106 T@U))
  (! (=> (and (= (type a@@156) DatatypeTypeType)
              (= (type b@@106) DatatypeTypeType))
         (= (|PagedBetree.Path#Equal| a@@156 b@@106) (= a@@156 b@@106)))
     :pattern ((|PagedBetree.Path#Equal| a@@156 b@@106))
     :skolemid |3287|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@582 T@U))
  (! (= (type (PagedBetree.Path.Subpath arg0@@582)) DatatypeTypeType)
     :pattern ((PagedBetree.Path.Subpath arg0@@582))
     :qid |funType:PagedBetree.Path.Subpath|)))
(assert (let ((a!1 (forall ((this@@210 T@U))
             (! (let ((a!1 (and ($Is this@@210 Tclass.PagedBetree.Path)
                                (INTERNAL_lt_boogie
                                  0
                                  (|Seq#Length| (PagedBetree.Path.routing
                                                  this@@210)))
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  (PagedBetree.Path.node this@@210))
                                (PagedBetree.BetreeNode.BetreeNode_q
                                  (PagedBetree.Path.node this@@210)))))
                  (=> (and (= (type this@@210) DatatypeTypeType)
                           (or (|PagedBetree.Path.Subpath#canCall| this@@210)
                               a!1))
                      ($Is (PagedBetree.Path.Subpath this@@210)
                           Tclass.PagedBetree.Path)))
                :pattern ((PagedBetree.Path.Subpath this@@210))
                :skolemid |3288|
                :qid |PagedBetreeidfy.302:14|))))
  (=> true a!1)))
(assert (forall ((this@@211 T@U))
  (! (let ((a!1 (and (INTERNAL_lt_boogie
                       0
                       (|Seq#Length| (PagedBetree.Path.routing this@@211)))
                     (PagedBetree.BetreeNode.WF
                       ($LS $LZ)
                       (PagedBetree.Path.node this@@211))
                     (PagedBetree.BetreeNode.BetreeNode_q
                       (PagedBetree.Path.node this@@211)))))
       (=> (and (= (type this@@211) DatatypeTypeType)
                ($Is this@@211 Tclass.PagedBetree.Path))
           (= (|PagedBetree.Path.Subpath#requires| this@@211) a!1)))
     :pattern ((|PagedBetree.Path.Subpath#requires| this@@211))
     :skolemid |3289|
     :qid |PagedBetreeidfy.302:14|)))
(assert (let ((a!1 (forall ((this@@212 T@U))
             (! (let ((a!1 (and ($Is this@@212 Tclass.PagedBetree.Path)
                                (INTERNAL_lt_boogie
                                  0
                                  (|Seq#Length| (PagedBetree.Path.routing
                                                  this@@212)))
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  (PagedBetree.Path.node this@@212))
                                (PagedBetree.BetreeNode.BetreeNode_q
                                  (PagedBetree.Path.node this@@212))))
                      (a!2 (= (PagedBetree.Path.Subpath this@@212)
                              (|#PagedBetree.Path.Path|
                                (PagedBetree.BetreeNode.Child
                                  (PagedBetree.Path.node this@@212)
                                  (PagedBetree.Path.key this@@212))
                                (PagedBetree.Path.key this@@212)
                                (|Seq#Drop| (PagedBetree.Path.routing this@@212)
                                            (LitInt 1))))))
                  (=> (and (= (type this@@212) DatatypeTypeType)
                           (or (|PagedBetree.Path.Subpath#canCall| this@@212)
                               a!1))
                      (and (PagedBetree.Path.Path_q this@@212)
                           (PagedBetree.Path.Path_q this@@212)
                           (|PagedBetree.BetreeNode.Child#canCall|
                             (PagedBetree.Path.node this@@212)
                             (PagedBetree.Path.key this@@212))
                           (PagedBetree.Path.Path_q this@@212)
                           (PagedBetree.Path.Path_q this@@212)
                           a!2)))
                :pattern ((PagedBetree.Path.Subpath this@@212))
                :skolemid |3290|
                :qid |PagedBetreeidfy.302:14|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@213 T@U))
      (! (let ((a!1 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                         (Lit this@@213)))))
               (a!2 (PagedBetree.BetreeNode.WF
                      ($LS $LZ)
                      (Lit (PagedBetree.Path.node (Lit this@@213)))))
               (a!3 (PagedBetree.BetreeNode.BetreeNode_q
                      (Lit (PagedBetree.Path.node (Lit this@@213)))))
               (a!6 (|PagedBetree.BetreeNode.Child#canCall|
                      (Lit (PagedBetree.Path.node (Lit this@@213)))
                      (Lit (PagedBetree.Path.key (Lit this@@213)))))
               (a!7 (PagedBetree.BetreeNode.Child
                      (Lit (PagedBetree.Path.node (Lit this@@213)))
                      (Lit (PagedBetree.Path.key (Lit this@@213)))))
               (a!8 (|Seq#Drop| (Lit (PagedBetree.Path.routing (Lit this@@213)))
                                (LitInt 1))))
         (let ((a!4 (and ($Is this@@213 Tclass.PagedBetree.Path)
                         (INTERNAL_lt_boogie 0 a!1)
                         (U_2_bool (Lit (bool_2_U a!2)))
                         (U_2_bool (Lit (bool_2_U a!3)))))
               (a!9 (|#PagedBetree.Path.Path|
                      (Lit a!7)
                      (Lit (PagedBetree.Path.key (Lit this@@213)))
                      (Lit a!8))))
         (let ((a!5 (and (= (type this@@213) DatatypeTypeType)
                         (or (|PagedBetree.Path.Subpath#canCall|
                               (Lit this@@213))
                             a!4)))
               (a!10 (and (PagedBetree.Path.Path_q (Lit this@@213))
                          (PagedBetree.Path.Path_q (Lit this@@213))
                          a!6
                          (PagedBetree.Path.Path_q (Lit this@@213))
                          (PagedBetree.Path.Path_q (Lit this@@213))
                          (= (PagedBetree.Path.Subpath (Lit this@@213))
                             (Lit a!9)))))
           (=> a!5 a!10))))
         :pattern ((PagedBetree.Path.Subpath (Lit this@@213)))
         :weight 3
         :skolemid |3291|
         :qid |PagedBetreeidfy.302:14|))))
(assert (let ((a!1 (forall ((this@@214 T@U))
             (! (let ((a!1 (and ($Is this@@214 Tclass.PagedBetree.Path)
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  (PagedBetree.Path.node this@@214))
                                (PagedBetree.BetreeNode.BetreeNode_q
                                  (PagedBetree.Path.node this@@214))
                                (INTERNAL_lt_boogie
                                  0
                                  (|Seq#Length| (PagedBetree.Path.routing
                                                  this@@214))))))
                  (=> (and (= (type this@@214) DatatypeTypeType)
                           (or (|PagedBetree.Path.CommonChildren#canCall|
                                 this@@214)
                               a!1))
                      true))
                :pattern ((PagedBetree.Path.CommonChildren this@@214))
                :skolemid |3292|
                :qid |PagedBetreeidfy.311:15|))))
  (=> true a!1)))
(assert (forall ((this@@215 T@U))
  (! (let ((a!1 (and (PagedBetree.BetreeNode.WF
                       ($LS $LZ)
                       (PagedBetree.Path.node this@@215))
                     (PagedBetree.BetreeNode.BetreeNode_q
                       (PagedBetree.Path.node this@@215))
                     (INTERNAL_lt_boogie
                       0
                       (|Seq#Length| (PagedBetree.Path.routing this@@215))))))
       (=> (and (= (type this@@215) DatatypeTypeType)
                ($Is this@@215 Tclass.PagedBetree.Path))
           (= (|PagedBetree.Path.CommonChildren#requires| this@@215) a!1)))
     :pattern ((|PagedBetree.Path.CommonChildren#requires| this@@215))
     :skolemid |3293|
     :qid |PagedBetreeidfy.311:15|)))
(assert (let ((a!1 (forall ((this@@216 T@U))
             (! (let ((a!1 (and ($Is this@@216 Tclass.PagedBetree.Path)
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  (PagedBetree.Path.node this@@216))
                                (PagedBetree.BetreeNode.BetreeNode_q
                                  (PagedBetree.Path.node this@@216))
                                (INTERNAL_lt_boogie
                                  0
                                  (|Seq#Length| (PagedBetree.Path.routing
                                                  this@@216)))))
                      (a!2 (forall ((|k#0@@82| T@U))
                             (! (let ((a!1 (MapType0Select ($Unbox (MapType0Type BoxType
                                                                                 boolType)
                                                                   (|Seq#Index| (PagedBetree.Path.routing
                                                                                  this@@216)
                                                                                (LitInt 0)))
                                                           ($Box |k#0@@82|)))
                                      (a!2 (and (|$IsA#PagedBetree.BetreeNode|
                                                  (PagedBetree.BetreeNode.Child
                                                    (PagedBetree.Path.node
                                                      this@@216)
                                                    |k#0@@82|))
                                                (|$IsA#PagedBetree.BetreeNode|
                                                  (PagedBetree.BetreeNode.Child
                                                    (PagedBetree.Path.node
                                                      this@@216)
                                                    (PagedBetree.Path.key
                                                      this@@216)))
                                                (PagedBetree.Path.Path_q
                                                  this@@216)
                                                (|PagedBetree.BetreeNode.Child#canCall|
                                                  (PagedBetree.Path.node
                                                    this@@216)
                                                  |k#0@@82|)
                                                (PagedBetree.Path.Path_q
                                                  this@@216)
                                                (PagedBetree.Path.Path_q
                                                  this@@216)
                                                (|PagedBetree.BetreeNode.Child#canCall|
                                                  (PagedBetree.Path.node
                                                    this@@216)
                                                  (PagedBetree.Path.key
                                                    this@@216)))))
                                  (=> (and (= (type |k#0@@82|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@82| Tclass.KeyType.Key))
                                      (and (PagedBetree.Path.Path_q this@@216)
                                           (=> (U_2_bool a!1) a!2))))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            (PagedBetree.Path.node this@@216)
                                            |k#0@@82|))
                                :pattern ((MapType0Select ($Unbox (MapType0Type BoxType
                                                                                boolType)
                                                                  (|Seq#Index| (PagedBetree.Path.routing
                                                                                 this@@216)
                                                                               0))
                                                          ($Box |k#0@@82|)))
                                :skolemid |3295|
                                :qid |PagedBetreeidfy.316:14|)))
                      (a!3 (forall ((|k#0@@83| T@U))
                             (! (let ((a!1 (MapType0Select ($Unbox (MapType0Type BoxType
                                                                                 boolType)
                                                                   (|Seq#Index| (PagedBetree.Path.routing
                                                                                  this@@216)
                                                                                (LitInt 0)))
                                                           ($Box |k#0@@83|))))
                                (let ((a!2 (=> (and ($Is |k#0@@83|
                                                         Tclass.KeyType.Key)
                                                    (U_2_bool a!1))
                                               (|PagedBetree.BetreeNode#Equal|
                                                 (PagedBetree.BetreeNode.Child
                                                   (PagedBetree.Path.node
                                                     this@@216)
                                                   |k#0@@83|)
                                                 (PagedBetree.BetreeNode.Child
                                                   (PagedBetree.Path.node
                                                     this@@216)
                                                   (PagedBetree.Path.key
                                                     this@@216))))))
                                  (=> (= (type |k#0@@83|) (SeqType BoxType))
                                      a!2)))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            (PagedBetree.Path.node this@@216)
                                            |k#0@@83|))
                                :pattern ((MapType0Select ($Unbox (MapType0Type BoxType
                                                                                boolType)
                                                                  (|Seq#Index| (PagedBetree.Path.routing
                                                                                 this@@216)
                                                                               0))
                                                          ($Box |k#0@@83|)))
                                :skolemid |3294|
                                :qid |PagedBetreeidfy.316:14|))))
                  (=> (and (= (type this@@216) DatatypeTypeType)
                           (or (|PagedBetree.Path.CommonChildren#canCall|
                                 this@@216)
                               a!1))
                      (and a!2
                           (= (PagedBetree.Path.CommonChildren this@@216) a!3))))
                :pattern ((PagedBetree.Path.CommonChildren this@@216))
                :skolemid |3296|
                :qid |PagedBetreeidfy.311:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@217 T@U))
      (! (let ((a!1 (PagedBetree.BetreeNode.WF
                      ($LS $LZ)
                      (Lit (PagedBetree.Path.node (Lit this@@217)))))
               (a!2 (PagedBetree.BetreeNode.BetreeNode_q
                      (Lit (PagedBetree.Path.node (Lit this@@217)))))
               (a!3 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                         (Lit this@@217)))))
               (a!6 (forall ((|k#1@@17| T@U))
                      (! (let ((a!1 (|Seq#Index| (Lit (PagedBetree.Path.routing
                                                        (Lit this@@217)))
                                                 (LitInt 0)))
                               (a!3 (PagedBetree.BetreeNode.Child
                                      (Lit (PagedBetree.Path.node
                                             (Lit this@@217)))
                                      |k#1@@17|))
                               (a!4 (PagedBetree.BetreeNode.Child
                                      (Lit (PagedBetree.Path.node
                                             (Lit this@@217)))
                                      (Lit (PagedBetree.Path.key
                                             (Lit this@@217)))))
                               (a!5 (|PagedBetree.BetreeNode.Child#canCall|
                                      (Lit (PagedBetree.Path.node
                                             (Lit this@@217)))
                                      |k#1@@17|))
                               (a!6 (|PagedBetree.BetreeNode.Child#canCall|
                                      (Lit (PagedBetree.Path.node
                                             (Lit this@@217)))
                                      (Lit (PagedBetree.Path.key
                                             (Lit this@@217))))))
                         (let ((a!2 (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType
                                                                                    boolType)
                                                                      a!1)
                                                              ($Box |k#1@@17|)))))
                         (let ((a!7 (=> a!2
                                        (and (|$IsA#PagedBetree.BetreeNode| a!3)
                                             (|$IsA#PagedBetree.BetreeNode|
                                               (Lit a!4))
                                             (PagedBetree.Path.Path_q
                                               (Lit this@@217))
                                             a!5
                                             (PagedBetree.Path.Path_q
                                               (Lit this@@217))
                                             (PagedBetree.Path.Path_q
                                               (Lit this@@217))
                                             a!6))))
                           (=> (and (= (type |k#1@@17|) (SeqType BoxType))
                                    ($Is |k#1@@17| Tclass.KeyType.Key))
                               (and (PagedBetree.Path.Path_q (Lit this@@217))
                                    a!7)))))
                         :pattern ((PagedBetree.BetreeNode.Child
                                     (PagedBetree.Path.node this@@217)
                                     |k#1@@17|))
                         :pattern ((MapType0Select ($Unbox (MapType0Type BoxType
                                                                         boolType)
                                                           (|Seq#Index| (PagedBetree.Path.routing
                                                                          this@@217)
                                                                        0))
                                                   ($Box |k#1@@17|)))
                         :skolemid |3298|
                         :qid |PagedBetreeidfy.316:14|)))
               (a!7 (forall ((|k#1@@18| T@U))
                      (! (let ((a!1 (|Seq#Index| (Lit (PagedBetree.Path.routing
                                                        (Lit this@@217)))
                                                 (LitInt 0)))
                               (a!3 (PagedBetree.BetreeNode.Child
                                      (Lit (PagedBetree.Path.node
                                             (Lit this@@217)))
                                      |k#1@@18|))
                               (a!4 (PagedBetree.BetreeNode.Child
                                      (Lit (PagedBetree.Path.node
                                             (Lit this@@217)))
                                      (Lit (PagedBetree.Path.key
                                             (Lit this@@217))))))
                         (let ((a!2 (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType
                                                                                    boolType)
                                                                      a!1)
                                                              ($Box |k#1@@18|)))))
                           (=> (= (type |k#1@@18|) (SeqType BoxType))
                               (=> (and ($Is |k#1@@18| Tclass.KeyType.Key) a!2)
                                   (|PagedBetree.BetreeNode#Equal| a!3 a!4)))))
                         :pattern ((PagedBetree.BetreeNode.Child
                                     (PagedBetree.Path.node this@@217)
                                     |k#1@@18|))
                         :pattern ((MapType0Select ($Unbox (MapType0Type BoxType
                                                                         boolType)
                                                           (|Seq#Index| (PagedBetree.Path.routing
                                                                          this@@217)
                                                                        0))
                                                   ($Box |k#1@@18|)))
                         :skolemid |3297|
                         :qid |PagedBetreeidfy.316:14|))))
         (let ((a!4 (and ($Is this@@217 Tclass.PagedBetree.Path)
                         (U_2_bool (Lit (bool_2_U a!1)))
                         (U_2_bool (Lit (bool_2_U a!2)))
                         (INTERNAL_lt_boogie 0 a!3)))
               (a!8 (and a!6
                         (= (PagedBetree.Path.CommonChildren (Lit this@@217))
                            a!7))))
         (let ((a!5 (and (= (type this@@217) DatatypeTypeType)
                         (or (|PagedBetree.Path.CommonChildren#canCall|
                               (Lit this@@217))
                             a!4))))
           (=> a!5 a!8))))
         :pattern ((PagedBetree.Path.CommonChildren (Lit this@@217)))
         :weight 3
         :skolemid |3299|
         :qid |PagedBetreeidfy.311:15|))))
(assert (forall (($ly@@342 T@U) (this@@218 T@U))
  (! (=> (and (= (type $ly@@342) LayerTypeType)
              (= (type this@@218) DatatypeTypeType))
         (= (PagedBetree.Path.Valid ($LS $ly@@342) this@@218)
            (PagedBetree.Path.Valid $ly@@342 this@@218)))
     :pattern ((PagedBetree.Path.Valid ($LS $ly@@342) this@@218))
     :skolemid |3300|
     :qid |PagedBetreeidfy.319:15|)))
(assert (forall (($ly@@343 T@U) (this@@219 T@U))
  (! (=> (and (= (type $ly@@343) LayerTypeType)
              (= (type this@@219) DatatypeTypeType))
         (= (PagedBetree.Path.Valid $ly@@343 this@@219)
            (PagedBetree.Path.Valid $LZ this@@219)))
     :pattern ((PagedBetree.Path.Valid (AsFuelBottom $ly@@343) this@@219))
     :skolemid |3301|
     :qid |PagedBetreeidfy.319:15|)))
(assert (let ((a!1 (forall (($ly@@344 T@U) (this@@220 T@U))
             (! (=> (and (= (type $ly@@344) LayerTypeType)
                         (= (type this@@220) DatatypeTypeType)
                         (or (|PagedBetree.Path.Valid#canCall| this@@220)
                             ($Is this@@220 Tclass.PagedBetree.Path)))
                    true)
                :pattern ((PagedBetree.Path.Valid $ly@@344 this@@220))
                :skolemid |3302|
                :qid |PagedBetreeidfy.319:15|))))
  (=> true a!1)))
(assert (forall (($ly@@345 T@U) (this@@221 T@U))
  (! (=> (and (= (type $ly@@345) LayerTypeType)
              (= (type this@@221) DatatypeTypeType)
              ($Is this@@221 Tclass.PagedBetree.Path))
         (= (|PagedBetree.Path.Valid#requires| $ly@@345 this@@221) true))
     :pattern ((|PagedBetree.Path.Valid#requires| $ly@@345 this@@221))
     :skolemid |3303|
     :qid |PagedBetreeidfy.319:15|)))
(assert (let ((a!1 (forall (($ly@@346 T@U) (this@@222 T@U))
             (! (let ((a!1 (and (|PagedBetree.Path.Subpath#canCall| this@@222)
                                (|PagedBetree.Path.Valid#canCall|
                                  (PagedBetree.Path.Subpath this@@222))
                                (=> (PagedBetree.Path.Valid
                                      $ly@@346
                                      (PagedBetree.Path.Subpath this@@222))
                                    (|PagedBetree.Path.CommonChildren#canCall|
                                      this@@222))))
                      (a!4 (=> (INTERNAL_lt_boogie
                                 0
                                 (|Seq#Length| (PagedBetree.Path.routing
                                                 this@@222)))
                               (and (PagedBetree.Path.Valid
                                      $ly@@346
                                      (PagedBetree.Path.Subpath this@@222))
                                    (PagedBetree.Path.CommonChildren this@@222)))))
                (let ((a!2 (=> (INTERNAL_lt_boogie
                                 0
                                 (|Seq#Length| (PagedBetree.Path.routing
                                                 this@@222)))
                               a!1))
                      (a!5 (= (PagedBetree.Path.Valid ($LS $ly@@346) this@@222)
                              (and (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (PagedBetree.Path.node this@@222))
                                   (PagedBetree.BetreeNode.BetreeNode_q
                                     (PagedBetree.Path.node this@@222))
                                   a!4))))
                (let ((a!3 (and (PagedBetree.Path.Path_q this@@222)
                                (=> (PagedBetree.BetreeNode.BetreeNode_q
                                      (PagedBetree.Path.node this@@222))
                                    (and (PagedBetree.Path.Path_q this@@222)
                                         a!2)))))
                (let ((a!6 (and (PagedBetree.Path.Path_q this@@222)
                                (|PagedBetree.BetreeNode.WF#canCall|
                                  (PagedBetree.Path.node this@@222))
                                (=> (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      (PagedBetree.Path.node this@@222))
                                    a!3)
                                a!5)))
                  (=> (and (= (type $ly@@346) LayerTypeType)
                           (= (type this@@222) DatatypeTypeType)
                           (or (|PagedBetree.Path.Valid#canCall| this@@222)
                               ($Is this@@222 Tclass.PagedBetree.Path)))
                      a!6)))))
                :pattern ((PagedBetree.Path.Valid ($LS $ly@@346) this@@222))
                :skolemid |3304|
                :qid |PagedBetreeidfy.319:15|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@347 T@U) (this@@223 T@U))
      (! (let ((a!1 (and (= (type $ly@@347) LayerTypeType)
                         (= (type this@@223) DatatypeTypeType)
                         (or (|PagedBetree.Path.Valid#canCall| (Lit this@@223))
                             ($Is this@@223 Tclass.PagedBetree.Path))))
               (a!2 (|PagedBetree.BetreeNode.WF#canCall|
                      (Lit (PagedBetree.Path.node (Lit this@@223)))))
               (a!3 (PagedBetree.BetreeNode.WF
                      ($LS $LZ)
                      (Lit (PagedBetree.Path.node (Lit this@@223)))))
               (a!4 (PagedBetree.BetreeNode.BetreeNode_q
                      (Lit (PagedBetree.Path.node (Lit this@@223)))))
               (a!5 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                         (Lit this@@223)))))
               (a!6 (|PagedBetree.Path.Valid#canCall|
                      (Lit (PagedBetree.Path.Subpath (Lit this@@223)))))
               (a!7 (PagedBetree.Path.Valid
                      ($LS $ly@@347)
                      (Lit (PagedBetree.Path.Subpath (Lit this@@223))))))
         (let ((a!8 (=> (U_2_bool (Lit (bool_2_U a!7)))
                        (|PagedBetree.Path.CommonChildren#canCall|
                          (Lit this@@223))))
               (a!12 (=> (INTERNAL_lt_boogie 0 a!5)
                         (and a!7
                              (PagedBetree.Path.CommonChildren (Lit this@@223))))))
         (let ((a!9 (=> (INTERNAL_lt_boogie 0 a!5)
                        (and (|PagedBetree.Path.Subpath#canCall|
                               (Lit this@@223))
                             a!6
                             a!8))))
         (let ((a!10 (=> (U_2_bool (Lit (bool_2_U a!4)))
                         (and (PagedBetree.Path.Path_q (Lit this@@223)) a!9))))
         (let ((a!11 (=> (U_2_bool (Lit (bool_2_U a!3)))
                         (and (PagedBetree.Path.Path_q (Lit this@@223)) a!10))))
         (let ((a!13 (and (PagedBetree.Path.Path_q (Lit this@@223))
                          a!2
                          a!11
                          (= (PagedBetree.Path.Valid
                               ($LS $ly@@347)
                               (Lit this@@223))
                             (and a!3 a!4 a!12)))))
           (=> a!1 a!13)))))))
         :pattern ((PagedBetree.Path.Valid ($LS $ly@@347) (Lit this@@223)))
         :weight 3
         :skolemid |3305|
         :qid |PagedBetreeidfy.319:15|))))
(assert (forall ((arg0@@583 T@U) (arg1@@296 T@U))
  (! (= (type (PagedBetree.Path.Target arg0@@583 arg1@@296)) DatatypeTypeType)
     :pattern ((PagedBetree.Path.Target arg0@@583 arg1@@296))
     :qid |funType:PagedBetree.Path.Target|)))
(assert (forall (($ly@@348 T@U) (this@@224 T@U))
  (! (=> (and (= (type $ly@@348) LayerTypeType)
              (= (type this@@224) DatatypeTypeType))
         (= (PagedBetree.Path.Target ($LS $ly@@348) this@@224)
            (PagedBetree.Path.Target $ly@@348 this@@224)))
     :pattern ((PagedBetree.Path.Target ($LS $ly@@348) this@@224))
     :skolemid |3306|
     :qid |PagedBetreeidfy.330:14|)))
(assert (forall (($ly@@349 T@U) (this@@225 T@U))
  (! (=> (and (= (type $ly@@349) LayerTypeType)
              (= (type this@@225) DatatypeTypeType))
         (= (PagedBetree.Path.Target $ly@@349 this@@225)
            (PagedBetree.Path.Target $LZ this@@225)))
     :pattern ((PagedBetree.Path.Target (AsFuelBottom $ly@@349) this@@225))
     :skolemid |3307|
     :qid |PagedBetreeidfy.330:14|)))
(assert (let ((a!1 (forall (($ly@@350 T@U) (this@@226 T@U))
             (! (let ((a!1 (or (|PagedBetree.Path.Target#canCall| this@@226)
                               (and ($Is this@@226 Tclass.PagedBetree.Path)
                                    (PagedBetree.Path.Valid ($LS $LZ) this@@226)))))
                  (=> (and (= (type $ly@@350) LayerTypeType)
                           (= (type this@@226) DatatypeTypeType)
                           a!1)
                      (and (PagedBetree.BetreeNode.WF
                             ($LS $LZ)
                             (PagedBetree.Path.Target $ly@@350 this@@226))
                           (PagedBetree.BetreeNode.BetreeNode_q
                             (PagedBetree.Path.Target $ly@@350 this@@226))
                           ($Is (PagedBetree.Path.Target $ly@@350 this@@226)
                                Tclass.PagedBetree.BetreeNode))))
                :pattern ((PagedBetree.Path.Target $ly@@350 this@@226))
                :skolemid |3308|
                :qid |PagedBetreeidfy.330:14|))))
  (=> true a!1)))
(assert (forall (($ly@@351 T@U) (this@@227 T@U))
  (! (=> (and (= (type $ly@@351) LayerTypeType)
              (= (type this@@227) DatatypeTypeType)
              ($Is this@@227 Tclass.PagedBetree.Path))
         (= (|PagedBetree.Path.Target#requires| $ly@@351 this@@227)
            (PagedBetree.Path.Valid ($LS $LZ) this@@227)))
     :pattern ((|PagedBetree.Path.Target#requires| $ly@@351 this@@227))
     :skolemid |3309|
     :qid |PagedBetreeidfy.330:14|)))
(assert (let ((a!1 (forall (($ly@@352 T@U) (this@@228 T@U))
             (! (let ((a!1 (or (|PagedBetree.Path.Target#canCall| this@@228)
                               (and ($Is this@@228 Tclass.PagedBetree.Path)
                                    (PagedBetree.Path.Valid ($LS $LZ) this@@228))))
                      (a!2 (=> (= (LitInt 0)
                                  (|Seq#Length| (PagedBetree.Path.routing
                                                  this@@228)))
                               (PagedBetree.Path.Path_q this@@228)))
                      (a!3 (not (= (LitInt 0)
                                   (|Seq#Length| (PagedBetree.Path.routing
                                                   this@@228)))))
                      (a!5 (ite (= (LitInt 0)
                                   (|Seq#Length| (PagedBetree.Path.routing
                                                   this@@228)))
                                (PagedBetree.Path.node this@@228)
                                (PagedBetree.Path.Target
                                  $ly@@352
                                  (PagedBetree.Path.Subpath this@@228)))))
                (let ((a!4 (=> a!3
                               (and (|PagedBetree.Path.Subpath#canCall|
                                      this@@228)
                                    (|PagedBetree.Path.Target#canCall|
                                      (PagedBetree.Path.Subpath this@@228))))))
                (let ((a!6 (and (PagedBetree.Path.Path_q this@@228)
                                a!2
                                a!4
                                (= (PagedBetree.Path.Target
                                     ($LS $ly@@352)
                                     this@@228)
                                   a!5))))
                  (=> (and (= (type $ly@@352) LayerTypeType)
                           (= (type this@@228) DatatypeTypeType)
                           a!1)
                      a!6))))
                :pattern ((PagedBetree.Path.Target ($LS $ly@@352) this@@228))
                :skolemid |3310|
                :qid |PagedBetreeidfy.330:14|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@353 T@U) (this@@229 T@U))
      (! (let ((a!1 (Lit (bool_2_U (PagedBetree.Path.Valid
                                     ($LS $LZ)
                                     (Lit this@@229)))))
               (a!3 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                         (Lit this@@229)))))
               (a!4 (|PagedBetree.Path.Target#canCall|
                      (Lit (PagedBetree.Path.Subpath (Lit this@@229)))))
               (a!6 (PagedBetree.Path.Target
                      ($LS $ly@@353)
                      (Lit (PagedBetree.Path.Subpath (Lit this@@229))))))
         (let ((a!2 (and (= (type $ly@@353) LayerTypeType)
                         (= (type this@@229) DatatypeTypeType)
                         (or (|PagedBetree.Path.Target#canCall| (Lit this@@229))
                             (and ($Is this@@229 Tclass.PagedBetree.Path)
                                  (U_2_bool a!1)))))
               (a!5 (=> (not (= (LitInt 0) a!3))
                        (and (|PagedBetree.Path.Subpath#canCall|
                               (Lit this@@229))
                             a!4)))
               (a!7 (= (PagedBetree.Path.Target ($LS $ly@@353) (Lit this@@229))
                       (ite (= (LitInt 0) a!3)
                            (PagedBetree.Path.node (Lit this@@229))
                            a!6))))
         (let ((a!8 (and (PagedBetree.Path.Path_q (Lit this@@229))
                         (=> (= (LitInt 0) a!3)
                             (PagedBetree.Path.Path_q (Lit this@@229)))
                         a!5
                         a!7)))
           (=> a!2 a!8))))
         :pattern ((PagedBetree.Path.Target ($LS $ly@@353) (Lit this@@229)))
         :weight 3
         :skolemid |3311|
         :qid |PagedBetreeidfy.330:14|))))
(assert (forall ((arg0@@584 T@U) (arg1@@297 T@U) (arg2@@166 T@U))
  (! (= (type (PagedBetree.Path.ReplacedChildren arg0@@584 arg1@@297 arg2@@166))
        DatatypeTypeType)
     :pattern ((PagedBetree.Path.ReplacedChildren arg0@@584 arg1@@297 arg2@@166))
     :qid |funType:PagedBetree.Path.ReplacedChildren|)))
(assert (forall (($ly@@354 T@U) (this@@230 T@U) (|replacement#0| T@U))
  (! (=> (and (= (type $ly@@354) LayerTypeType)
              (= (type this@@230) DatatypeTypeType)
              (= (type |replacement#0|) DatatypeTypeType))
         (= (PagedBetree.Path.ReplacedChildren
              ($LS $ly@@354)
              this@@230
              |replacement#0|)
            (PagedBetree.Path.ReplacedChildren
              $ly@@354
              this@@230
              |replacement#0|)))
     :pattern ((PagedBetree.Path.ReplacedChildren
                 ($LS $ly@@354)
                 this@@230
                 |replacement#0|))
     :skolemid |3312|
     :qid |PagedBetreeidfy.342:24|)))
(assert (forall (($ly@@355 T@U) (this@@231 T@U) (|replacement#0@@0| T@U))
  (! (=> (and (= (type $ly@@355) LayerTypeType)
              (= (type this@@231) DatatypeTypeType)
              (= (type |replacement#0@@0|) DatatypeTypeType))
         (= (PagedBetree.Path.ReplacedChildren
              $ly@@355
              this@@231
              |replacement#0@@0|)
            (PagedBetree.Path.ReplacedChildren $LZ this@@231 |replacement#0@@0|)))
     :pattern ((PagedBetree.Path.ReplacedChildren
                 (AsFuelBottom $ly@@355)
                 this@@231
                 |replacement#0@@0|))
     :skolemid |3313|
     :qid |PagedBetreeidfy.342:24|)))
(assert (let ((a!1 (forall (($ly@@356 T@U) (this@@232 T@U) (|replacement#0@@1| T@U))
             (! (let ((a!1 (and ($Is this@@232 Tclass.PagedBetree.Path)
                                ($Is |replacement#0@@1|
                                     Tclass.PagedBetree.BetreeNode)
                                (PagedBetree.Path.Valid ($LS $LZ) this@@232)
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  |replacement#0@@1|)
                                (INTERNAL_lt_boogie
                                  0
                                  (|Seq#Length| (PagedBetree.Path.routing
                                                  this@@232))))))
                  (=> (and (= (type $ly@@356) LayerTypeType)
                           (= (type this@@232) DatatypeTypeType)
                           (= (type |replacement#0@@1|) DatatypeTypeType)
                           (or (|PagedBetree.Path.ReplacedChildren#canCall|
                                 this@@232
                                 |replacement#0@@1|)
                               a!1))
                      (and (PagedBetree.ChildMap.WF
                             ($LS $LZ)
                             (PagedBetree.Path.ReplacedChildren
                               $ly@@356
                               this@@232
                               |replacement#0@@1|))
                           ($Is (PagedBetree.Path.ReplacedChildren
                                  $ly@@356
                                  this@@232
                                  |replacement#0@@1|)
                                Tclass.PagedBetree.ChildMap))))
                :pattern ((PagedBetree.Path.ReplacedChildren
                            $ly@@356
                            this@@232
                            |replacement#0@@1|))
                :skolemid |3314|
                :qid |PagedBetreeidfy.342:24|))))
  (=> true a!1)))
(assert (forall (($ly@@357 T@U) (this@@233 T@U) (|replacement#0@@2| T@U))
  (! (let ((a!1 (and (PagedBetree.Path.Valid ($LS $LZ) this@@233)
                     (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@2|)
                     (INTERNAL_lt_boogie
                       0
                       (|Seq#Length| (PagedBetree.Path.routing this@@233))))))
       (=> (and (= (type $ly@@357) LayerTypeType)
                (= (type this@@233) DatatypeTypeType)
                (= (type |replacement#0@@2|) DatatypeTypeType)
                ($Is this@@233 Tclass.PagedBetree.Path)
                ($Is |replacement#0@@2| Tclass.PagedBetree.BetreeNode))
           (= (|PagedBetree.Path.ReplacedChildren#requires|
                $ly@@357
                this@@233
                |replacement#0@@2|)
              a!1)))
     :pattern ((|PagedBetree.Path.ReplacedChildren#requires|
                 $ly@@357
                 this@@233
                 |replacement#0@@2|))
     :skolemid |3315|
     :qid |PagedBetreeidfy.342:24|)))
(assert (let ((a!1 (forall ((arg0@@585 T@U) (arg1@@298 T@U) (arg2@@167 T@U))
             (! (= (type (PagedBetree.Path.Substitute
                           arg0@@585
                           arg1@@298
                           arg2@@167))
                   DatatypeTypeType)
                :pattern ((PagedBetree.Path.Substitute
                            arg0@@585
                            arg1@@298
                            arg2@@167))
                :qid |funType:PagedBetree.Path.Substitute|)))
      (a!2 (forall ((arg0@@586 T@U) (arg1@@299 T@U) (arg2@@168 T@U))
             (! (= (type (|lambda#263| arg0@@586 arg1@@299 arg2@@168))
                   (MapType0Type BoxType BoxType))
                :pattern ((|lambda#263| arg0@@586 arg1@@299 arg2@@168))
                :qid |funType:lambda#263|))))
  (and a!1 a!2)))
(assert (let ((a!1 (forall (($ly@@358 T@U) (this@@234 T@U) (|replacement#0@@3| T@U))
             (! (let ((a!1 (and ($Is this@@234 Tclass.PagedBetree.Path)
                                ($Is |replacement#0@@3|
                                     Tclass.PagedBetree.BetreeNode)
                                (PagedBetree.Path.Valid ($LS $LZ) this@@234)
                                (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  |replacement#0@@3|)
                                (INTERNAL_lt_boogie
                                  0
                                  (|Seq#Length| (PagedBetree.Path.routing
                                                  this@@234)))))
                      (a!2 (forall ((|k#0@@84| T@U))
                             (! (let ((a!1 (MapType0Select ($Unbox (MapType0Type BoxType
                                                                                 boolType)
                                                                   (|Seq#Index| (PagedBetree.Path.routing
                                                                                  this@@234)
                                                                                (LitInt 0)))
                                                           ($Box |k#0@@84|))))
                                (let ((a!2 (=> (not (U_2_bool a!1))
                                               (and (PagedBetree.Path.Path_q
                                                      this@@234)
                                                    (|PagedBetree.BetreeNode.Child#canCall|
                                                      (PagedBetree.Path.node
                                                        this@@234)
                                                      |k#0@@84|)))))
                                (let ((a!3 (and (|Buffers.__default.AnyKey#canCall|
                                                  |k#0@@84|)
                                                (=> (Buffers.__default.AnyKey
                                                      |k#0@@84|)
                                                    (and (PagedBetree.Path.Path_q
                                                           this@@234)
                                                         a!2)))))
                                  (=> (and (= (type |k#0@@84|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@84| Tclass.KeyType.Key))
                                      a!3))))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            (PagedBetree.Path.node this@@234)
                                            |k#0@@84|))
                                :pattern ((MapType0Select ($Unbox (MapType0Type BoxType
                                                                                boolType)
                                                                  (|Seq#Index| (PagedBetree.Path.routing
                                                                                 this@@234)
                                                                               0))
                                                          ($Box |k#0@@84|)))
                                :pattern ((Buffers.__default.AnyKey |k#0@@84|))
                                :skolemid |3316|
                                :qid |PagedBetreeidfy.351:21|)))
                      (a!3 (|lambda#263| ($Unbox (MapType0Type BoxType boolType)
                                                 (|Seq#Index| (PagedBetree.Path.routing
                                                                this@@234)
                                                              (LitInt 0)))
                                         (PagedBetree.Path.Substitute
                                           $ly@@358
                                           (PagedBetree.Path.Subpath this@@234)
                                           |replacement#0@@3|)
                                         (PagedBetree.Path.node this@@234))))
                (let ((a!4 (= (PagedBetree.Path.ReplacedChildren
                                ($LS $ly@@358)
                                this@@234
                                |replacement#0@@3|)
                              (|#PagedBetree.ChildMap.ChildMap|
                                (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                             a!3
                                             (TIMap Tclass.KeyType.Key
                                                    Tclass.PagedBetree.BetreeNode))))))
                  (=> (and (= (type $ly@@358) LayerTypeType)
                           (= (type this@@234) DatatypeTypeType)
                           (= (type |replacement#0@@3|) DatatypeTypeType)
                           (or (|PagedBetree.Path.ReplacedChildren#canCall|
                                 this@@234
                                 |replacement#0@@3|)
                               a!1))
                      (and (|PagedBetree.Path.Subpath#canCall| this@@234)
                           (|PagedBetree.Path.Substitute#canCall|
                             (PagedBetree.Path.Subpath this@@234)
                             |replacement#0@@3|)
                           a!2
                           a!4))))
                :pattern ((PagedBetree.Path.ReplacedChildren
                            ($LS $ly@@358)
                            this@@234
                            |replacement#0@@3|))
                :skolemid |3317|
                :qid |PagedBetreeidfy.342:24|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($ly@@359 T@U) (this@@235 T@U) (|replacement#0@@4| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.Path.Valid
                                            ($LS $LZ)
                                            (Lit this@@235)))))
                      (a!2 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                                (Lit this@@235)))))
                      (a!4 (|PagedBetree.Path.Substitute#canCall|
                             (Lit (PagedBetree.Path.Subpath (Lit this@@235)))
                             |replacement#0@@4|))
                      (a!5 (forall ((|k#0@@85| T@U))
                             (! (let ((a!1 (|Seq#Index| (Lit (PagedBetree.Path.routing
                                                               (Lit this@@235)))
                                                        (LitInt 0)))
                                      (a!3 (|PagedBetree.BetreeNode.Child#canCall|
                                             (Lit (PagedBetree.Path.node
                                                    (Lit this@@235)))
                                             |k#0@@85|)))
                                (let ((a!2 (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType
                                                                                           boolType)
                                                                             a!1)
                                                                     ($Box |k#0@@85|)))))
                                (let ((a!4 (=> (not a!2)
                                               (and (PagedBetree.Path.Path_q
                                                      (Lit this@@235))
                                                    a!3))))
                                (let ((a!5 (=> (Buffers.__default.AnyKey
                                                 |k#0@@85|)
                                               (and (PagedBetree.Path.Path_q
                                                      (Lit this@@235))
                                                    a!4))))
                                  (=> (and (= (type |k#0@@85|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@85| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |k#0@@85|)
                                           a!5))))))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            (PagedBetree.Path.node this@@235)
                                            |k#0@@85|))
                                :pattern ((MapType0Select ($Unbox (MapType0Type BoxType
                                                                                boolType)
                                                                  (|Seq#Index| (PagedBetree.Path.routing
                                                                                 this@@235)
                                                                               0))
                                                          ($Box |k#0@@85|)))
                                :pattern ((Buffers.__default.AnyKey |k#0@@85|))
                                :skolemid |3318|
                                :qid |PagedBetreeidfy.351:21|)))
                      (a!6 (|Seq#Index| (Lit (PagedBetree.Path.routing
                                               (Lit this@@235)))
                                        (LitInt 0)))
                      (a!7 (PagedBetree.Path.Substitute
                             ($LS $ly@@359)
                             (Lit (PagedBetree.Path.Subpath (Lit this@@235)))
                             |replacement#0@@4|)))
                (let ((a!3 (or (|PagedBetree.Path.ReplacedChildren#canCall|
                                 (Lit this@@235)
                                 |replacement#0@@4|)
                               (and ($Is this@@235 Tclass.PagedBetree.Path)
                                    ($Is |replacement#0@@4|
                                         Tclass.PagedBetree.BetreeNode)
                                    (U_2_bool a!1)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |replacement#0@@4|)
                                    (INTERNAL_lt_boogie 0 a!2))))
                      (a!8 (|lambda#263| ($Unbox (MapType0Type BoxType boolType)
                                                 a!6)
                                         a!7
                                         (Lit (PagedBetree.Path.node
                                                (Lit this@@235))))))
                (let ((a!9 (= (PagedBetree.Path.ReplacedChildren
                                ($LS $ly@@359)
                                (Lit this@@235)
                                |replacement#0@@4|)
                              (|#PagedBetree.ChildMap.ChildMap|
                                (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                             a!8
                                             (TIMap Tclass.KeyType.Key
                                                    Tclass.PagedBetree.BetreeNode))))))
                  (=> (and (= (type $ly@@359) LayerTypeType)
                           (= (type this@@235) DatatypeTypeType)
                           (= (type |replacement#0@@4|) DatatypeTypeType)
                           a!3)
                      (and (|PagedBetree.Path.Subpath#canCall| (Lit this@@235))
                           a!4
                           a!5
                           a!9)))))
                :pattern ((PagedBetree.Path.ReplacedChildren
                            ($LS $ly@@359)
                            (Lit this@@235)
                            |replacement#0@@4|))
                :weight 3
                :skolemid |3319|
                :qid |PagedBetreeidfy.342:24|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($ly@@360 T@U) (this@@236 T@U) (|replacement#0@@5| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.Path.Valid
                                            ($LS $LZ)
                                            (Lit this@@236)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            (Lit |replacement#0@@5|)))))
                      (a!3 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                                (Lit this@@236)))))
                      (a!5 (|PagedBetree.Path.Substitute#canCall|
                             (Lit (PagedBetree.Path.Subpath (Lit this@@236)))
                             (Lit |replacement#0@@5|)))
                      (a!6 (forall ((|k#0@@86| T@U))
                             (! (let ((a!1 (|Seq#Index| (Lit (PagedBetree.Path.routing
                                                               (Lit this@@236)))
                                                        (LitInt 0)))
                                      (a!3 (|PagedBetree.BetreeNode.Child#canCall|
                                             (Lit (PagedBetree.Path.node
                                                    (Lit this@@236)))
                                             |k#0@@86|)))
                                (let ((a!2 (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType
                                                                                           boolType)
                                                                             a!1)
                                                                     ($Box |k#0@@86|)))))
                                (let ((a!4 (=> (not a!2)
                                               (and (PagedBetree.Path.Path_q
                                                      (Lit this@@236))
                                                    a!3))))
                                (let ((a!5 (=> (Buffers.__default.AnyKey
                                                 |k#0@@86|)
                                               (and (PagedBetree.Path.Path_q
                                                      (Lit this@@236))
                                                    a!4))))
                                  (=> (and (= (type |k#0@@86|)
                                              (SeqType BoxType))
                                           ($Is |k#0@@86| Tclass.KeyType.Key))
                                      (and (|Buffers.__default.AnyKey#canCall|
                                             |k#0@@86|)
                                           a!5))))))
                                :pattern ((PagedBetree.BetreeNode.Child
                                            (PagedBetree.Path.node this@@236)
                                            |k#0@@86|))
                                :pattern ((MapType0Select ($Unbox (MapType0Type BoxType
                                                                                boolType)
                                                                  (|Seq#Index| (PagedBetree.Path.routing
                                                                                 this@@236)
                                                                               0))
                                                          ($Box |k#0@@86|)))
                                :pattern ((Buffers.__default.AnyKey |k#0@@86|))
                                :skolemid |3320|
                                :qid |PagedBetreeidfy.351:21|)))
                      (a!7 (|Seq#Index| (Lit (PagedBetree.Path.routing
                                               (Lit this@@236)))
                                        (LitInt 0)))
                      (a!8 (PagedBetree.Path.Substitute
                             ($LS $ly@@360)
                             (Lit (PagedBetree.Path.Subpath (Lit this@@236)))
                             (Lit |replacement#0@@5|))))
                (let ((a!4 (and (= (type $ly@@360) LayerTypeType)
                                (= (type this@@236) DatatypeTypeType)
                                (= (type |replacement#0@@5|) DatatypeTypeType)
                                (or (|PagedBetree.Path.ReplacedChildren#canCall|
                                      (Lit this@@236)
                                      (Lit |replacement#0@@5|))
                                    (and ($Is this@@236 Tclass.PagedBetree.Path)
                                         ($Is |replacement#0@@5|
                                              Tclass.PagedBetree.BetreeNode)
                                         (U_2_bool a!1)
                                         (U_2_bool a!2)
                                         (INTERNAL_lt_boogie 0 a!3)))))
                      (a!9 (|lambda#263| ($Unbox (MapType0Type BoxType boolType)
                                                 a!7)
                                         (Lit a!8)
                                         (Lit (PagedBetree.Path.node
                                                (Lit this@@236))))))
                (let ((a!10 (= (PagedBetree.Path.ReplacedChildren
                                 ($LS $ly@@360)
                                 (Lit this@@236)
                                 (Lit |replacement#0@@5|))
                               (|#PagedBetree.ChildMap.ChildMap|
                                 (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                              a!9
                                              (TIMap Tclass.KeyType.Key
                                                     Tclass.PagedBetree.BetreeNode))))))
                  (=> a!4
                      (and (|PagedBetree.Path.Subpath#canCall| (Lit this@@236))
                           a!5
                           a!6
                           a!10)))))
                :pattern ((PagedBetree.Path.ReplacedChildren
                            ($LS $ly@@360)
                            (Lit this@@236)
                            (Lit |replacement#0@@5|)))
                :weight 3
                :skolemid |3321|
                :qid |PagedBetreeidfy.342:24|))))
  (=> true a!1)))
(assert (forall (($ly@@361 T@U) (this@@237 T@U) (|replacement#0@@6| T@U))
  (! (=> (and (= (type $ly@@361) LayerTypeType)
              (= (type this@@237) DatatypeTypeType)
              (= (type |replacement#0@@6|) DatatypeTypeType))
         (= (PagedBetree.Path.Substitute
              ($LS $ly@@361)
              this@@237
              |replacement#0@@6|)
            (PagedBetree.Path.Substitute $ly@@361 this@@237 |replacement#0@@6|)))
     :pattern ((PagedBetree.Path.Substitute
                 ($LS $ly@@361)
                 this@@237
                 |replacement#0@@6|))
     :skolemid |3322|
     :qid |PagedBetreeidfy.354:14|)))
(assert (forall (($ly@@362 T@U) (this@@238 T@U) (|replacement#0@@7| T@U))
  (! (=> (and (= (type $ly@@362) LayerTypeType)
              (= (type this@@238) DatatypeTypeType)
              (= (type |replacement#0@@7|) DatatypeTypeType))
         (= (PagedBetree.Path.Substitute $ly@@362 this@@238 |replacement#0@@7|)
            (PagedBetree.Path.Substitute $LZ this@@238 |replacement#0@@7|)))
     :pattern ((PagedBetree.Path.Substitute
                 (AsFuelBottom $ly@@362)
                 this@@238
                 |replacement#0@@7|))
     :skolemid |3323|
     :qid |PagedBetreeidfy.354:14|)))
(assert (let ((a!1 (forall (($ly@@363 T@U) (this@@239 T@U) (|replacement#0@@8| T@U))
             (! (let ((a!1 (or (|PagedBetree.Path.Substitute#canCall|
                                 this@@239
                                 |replacement#0@@8|)
                               (and ($Is this@@239 Tclass.PagedBetree.Path)
                                    ($Is |replacement#0@@8|
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.Path.Valid ($LS $LZ) this@@239)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |replacement#0@@8|)))))
                  (=> (and (= (type $ly@@363) LayerTypeType)
                           (= (type this@@239) DatatypeTypeType)
                           (= (type |replacement#0@@8|) DatatypeTypeType)
                           a!1)
                      ($Is (PagedBetree.Path.Substitute
                             $ly@@363
                             this@@239
                             |replacement#0@@8|)
                           Tclass.PagedBetree.BetreeNode)))
                :pattern ((PagedBetree.Path.Substitute
                            $ly@@363
                            this@@239
                            |replacement#0@@8|))
                :skolemid |3324|
                :qid |PagedBetreeidfy.354:14|))))
  (=> true a!1)))
(assert (forall (($ly@@364 T@U) (this@@240 T@U) (|replacement#0@@9| T@U))
  (! (let ((a!1 (= (|PagedBetree.Path.Substitute#requires|
                     $ly@@364
                     this@@240
                     |replacement#0@@9|)
                   (and (PagedBetree.Path.Valid ($LS $LZ) this@@240)
                        (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@9|)))))
       (=> (and (= (type $ly@@364) LayerTypeType)
                (= (type this@@240) DatatypeTypeType)
                (= (type |replacement#0@@9|) DatatypeTypeType)
                ($Is this@@240 Tclass.PagedBetree.Path)
                ($Is |replacement#0@@9| Tclass.PagedBetree.BetreeNode))
           a!1))
     :pattern ((|PagedBetree.Path.Substitute#requires|
                 $ly@@364
                 this@@240
                 |replacement#0@@9|))
     :skolemid |3325|
     :qid |PagedBetreeidfy.354:14|)))
(assert (let ((a!1 (forall (($ly@@365 T@U) (this@@241 T@U) (|replacement#0@@10| T@U))
             (! (let ((a!1 (or (|PagedBetree.Path.Substitute#canCall|
                                 this@@241
                                 |replacement#0@@10|)
                               (and ($Is this@@241 Tclass.PagedBetree.Path)
                                    ($Is |replacement#0@@10|
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.Path.Valid ($LS $LZ) this@@241)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |replacement#0@@10|))))
                      (a!2 (not (= (LitInt 0)
                                   (|Seq#Length| (PagedBetree.Path.routing
                                                   this@@241)))))
                      (a!3 (ite (= (LitInt 0)
                                   (|Seq#Length| (PagedBetree.Path.routing
                                                   this@@241)))
                                |replacement#0@@10|
                                (|#PagedBetree.BetreeNode.BetreeNode|
                                  (PagedBetree.BetreeNode.buffers
                                    (PagedBetree.Path.node this@@241))
                                  (PagedBetree.Path.ReplacedChildren
                                    $ly@@365
                                    this@@241
                                    |replacement#0@@10|)))))
                (let ((a!4 (and (PagedBetree.Path.Path_q this@@241)
                                (=> a!2
                                    (and (PagedBetree.Path.Path_q this@@241)
                                         (|PagedBetree.Path.ReplacedChildren#canCall|
                                           this@@241
                                           |replacement#0@@10|)))
                                (= (PagedBetree.Path.Substitute
                                     ($LS $ly@@365)
                                     this@@241
                                     |replacement#0@@10|)
                                   a!3))))
                  (=> (and (= (type $ly@@365) LayerTypeType)
                           (= (type this@@241) DatatypeTypeType)
                           (= (type |replacement#0@@10|) DatatypeTypeType)
                           a!1)
                      a!4)))
                :pattern ((PagedBetree.Path.Substitute
                            ($LS $ly@@365)
                            this@@241
                            |replacement#0@@10|))
                :skolemid |3326|
                :qid |PagedBetreeidfy.354:14|))))
  (=> true a!1)))
(assert (let ((a!1 (forall (($ly@@366 T@U) (this@@242 T@U) (|replacement#0@@11| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.Path.Valid
                                            ($LS $LZ)
                                            (Lit this@@242)))))
                      (a!3 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                                (Lit this@@242)))))
                      (a!5 (PagedBetree.BetreeNode.buffers
                             (Lit (PagedBetree.Path.node (Lit this@@242))))))
                (let ((a!2 (or (|PagedBetree.Path.Substitute#canCall|
                                 (Lit this@@242)
                                 |replacement#0@@11|)
                               (and ($Is this@@242 Tclass.PagedBetree.Path)
                                    ($Is |replacement#0@@11|
                                         Tclass.PagedBetree.BetreeNode)
                                    (U_2_bool a!1)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |replacement#0@@11|))))
                      (a!4 (=> (not (= (LitInt 0) a!3))
                               (and (PagedBetree.Path.Path_q (Lit this@@242))
                                    (|PagedBetree.Path.ReplacedChildren#canCall|
                                      (Lit this@@242)
                                      |replacement#0@@11|))))
                      (a!6 (ite (= (LitInt 0) a!3)
                                |replacement#0@@11|
                                (|#PagedBetree.BetreeNode.BetreeNode|
                                  (Lit a!5)
                                  (PagedBetree.Path.ReplacedChildren
                                    ($LS $ly@@366)
                                    (Lit this@@242)
                                    |replacement#0@@11|)))))
                (let ((a!7 (and (PagedBetree.Path.Path_q (Lit this@@242))
                                a!4
                                (= (PagedBetree.Path.Substitute
                                     ($LS $ly@@366)
                                     (Lit this@@242)
                                     |replacement#0@@11|)
                                   a!6))))
                  (=> (and (= (type $ly@@366) LayerTypeType)
                           (= (type this@@242) DatatypeTypeType)
                           (= (type |replacement#0@@11|) DatatypeTypeType)
                           a!2)
                      a!7))))
                :pattern ((PagedBetree.Path.Substitute
                            ($LS $ly@@366)
                            (Lit this@@242)
                            |replacement#0@@11|))
                :weight 3
                :skolemid |3327|
                :qid |PagedBetreeidfy.354:14|))))
  (=> true a!1)))
(assert (=> true
    (forall (($ly@@367 T@U) (this@@243 T@U) (|replacement#0@@12| T@U))
      (! (let ((a!1 (Lit (bool_2_U (PagedBetree.Path.Valid
                                     ($LS $LZ)
                                     (Lit this@@243)))))
               (a!2 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (Lit |replacement#0@@12|)))))
               (a!4 (|Seq#Length| (Lit (PagedBetree.Path.routing
                                         (Lit this@@243)))))
               (a!6 (PagedBetree.BetreeNode.buffers
                      (Lit (PagedBetree.Path.node (Lit this@@243))))))
         (let ((a!3 (and (= (type $ly@@367) LayerTypeType)
                         (= (type this@@243) DatatypeTypeType)
                         (= (type |replacement#0@@12|) DatatypeTypeType)
                         (or (|PagedBetree.Path.Substitute#canCall|
                               (Lit this@@243)
                               (Lit |replacement#0@@12|))
                             (and ($Is this@@243 Tclass.PagedBetree.Path)
                                  ($Is |replacement#0@@12|
                                       Tclass.PagedBetree.BetreeNode)
                                  (U_2_bool a!1)
                                  (U_2_bool a!2)))))
               (a!5 (=> (not (= (LitInt 0) a!4))
                        (and (PagedBetree.Path.Path_q (Lit this@@243))
                             (|PagedBetree.Path.ReplacedChildren#canCall|
                               (Lit this@@243)
                               (Lit |replacement#0@@12|)))))
               (a!7 (ite (= (LitInt 0) a!4)
                         |replacement#0@@12|
                         (|#PagedBetree.BetreeNode.BetreeNode|
                           (Lit a!6)
                           (PagedBetree.Path.ReplacedChildren
                             ($LS $ly@@367)
                             (Lit this@@243)
                             (Lit |replacement#0@@12|))))))
         (let ((a!8 (and (PagedBetree.Path.Path_q (Lit this@@243))
                         a!5
                         (= (PagedBetree.Path.Substitute
                              ($LS $ly@@367)
                              (Lit this@@243)
                              (Lit |replacement#0@@12|))
                            a!7))))
           (=> a!3 a!8))))
         :pattern ((PagedBetree.Path.Substitute
                     ($LS $ly@@367)
                     (Lit this@@243)
                     (Lit |replacement#0@@12|)))
         :weight 3
         :skolemid |3328|
         :qid |PagedBetreeidfy.354:14|))))
(assert (forall ((arg0@@587 T@U))
  (! (= (type (|#PagedBetree.Step.QueryStep| arg0@@587)) DatatypeTypeType)
     :pattern ((|#PagedBetree.Step.QueryStep| arg0@@587))
     :qid |funType:#PagedBetree.Step.QueryStep|)))
(assert (forall ((|a#0#0#0@@11| T@U))
  (! (=> (= (type |a#0#0#0@@11|) DatatypeTypeType)
         (= (DatatypeCtorId (|#PagedBetree.Step.QueryStep| |a#0#0#0@@11|))
            |##PagedBetree.Step.QueryStep|))
     :pattern ((|#PagedBetree.Step.QueryStep| |a#0#0#0@@11|))
     :skolemid |3329|
     :qid |PagedBetreeidfy.424:17|)))
(assert (forall ((d@@131 T@U))
  (! (=> (= (type d@@131) DatatypeTypeType)
         (= (PagedBetree.Step.QueryStep_q d@@131)
            (= (DatatypeCtorId d@@131) |##PagedBetree.Step.QueryStep|)))
     :pattern ((PagedBetree.Step.QueryStep_q d@@131))
     :skolemid |3330|
     :qid |unknown.0:0|)))
(assert (forall ((d@@132 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@11| T@U))
                  (! (and (= (type |a#1#0#0@@11|) DatatypeTypeType)
                          (= d@@132
                             (|#PagedBetree.Step.QueryStep| |a#1#0#0@@11|)))
                     :no-pattern (type |a#1#0#0@@11|)
                     :no-pattern (U_2_int |a#1#0#0@@11|)
                     :no-pattern (U_2_bool |a#1#0#0@@11|)
                     :skolemid |3331|
                     :qid |PagedBetreeidfy.424:17|))))
       (=> (and (= (type d@@132) DatatypeTypeType)
                (PagedBetree.Step.QueryStep_q d@@132))
           a!1))
     :pattern ((PagedBetree.Step.QueryStep_q d@@132))
     :skolemid |3332|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@11| T@U))
  (! (=> (= (type |a#2#0#0@@11|) DatatypeTypeType)
         (= ($Is (|#PagedBetree.Step.QueryStep| |a#2#0#0@@11|)
                 Tclass.PagedBetree.Step)
            ($Is |a#2#0#0@@11| Tclass.PagedBetree.QueryReceipt)))
     :pattern (($Is (|#PagedBetree.Step.QueryStep| |a#2#0#0@@11|)
                    Tclass.PagedBetree.Step))
     :skolemid |3333|
     :qid |PagedBetreeidfy.424:17|)))
(assert (forall ((|a#3#0#0@@11| T@U) ($h@@141 T@U))
  (! (=> (and (= (type |a#3#0#0@@11|) DatatypeTypeType)
              (= (type $h@@141) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@141))
         (= ($IsAlloc (|#PagedBetree.Step.QueryStep| |a#3#0#0@@11|)
                      Tclass.PagedBetree.Step
                      $h@@141)
            ($IsAlloc |a#3#0#0@@11| Tclass.PagedBetree.QueryReceipt $h@@141)))
     :pattern (($IsAlloc (|#PagedBetree.Step.QueryStep| |a#3#0#0@@11|)
                         Tclass.PagedBetree.Step
                         $h@@141))
     :skolemid |3334|
     :qid |PagedBetreeidfy.424:17|)))
(assert (forall ((arg0@@588 T@U))
  (! (= (type (PagedBetree.Step.receipt arg0@@588)) DatatypeTypeType)
     :pattern ((PagedBetree.Step.receipt arg0@@588))
     :qid |funType:PagedBetree.Step.receipt|)))
(assert (forall ((d@@133 T@U) ($h@@142 T@U))
  (! (=> (and (= (type d@@133) DatatypeTypeType)
              (= (type $h@@142) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@142)
              (PagedBetree.Step.QueryStep_q d@@133)
              ($IsAlloc d@@133 Tclass.PagedBetree.Step $h@@142))
         ($IsAlloc (PagedBetree.Step.receipt d@@133)
                   Tclass.PagedBetree.QueryReceipt
                   $h@@142))
     :pattern (($IsAlloc (PagedBetree.Step.receipt d@@133)
                         Tclass.PagedBetree.QueryReceipt
                         $h@@142))
     :skolemid |3335|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@11| T@U))
  (! (=> (= (type |a#4#0#0@@11|) DatatypeTypeType)
         (= (|#PagedBetree.Step.QueryStep| (Lit |a#4#0#0@@11|))
            (Lit (|#PagedBetree.Step.QueryStep| |a#4#0#0@@11|))))
     :pattern ((|#PagedBetree.Step.QueryStep| (Lit |a#4#0#0@@11|)))
     :skolemid |3336|
     :qid |PagedBetreeidfy.424:17|)))
(assert (forall ((|a#5#0#0@@13| T@U))
  (! (=> (= (type |a#5#0#0@@13|) DatatypeTypeType)
         (= (PagedBetree.Step.receipt
              (|#PagedBetree.Step.QueryStep| |a#5#0#0@@13|))
            |a#5#0#0@@13|))
     :pattern ((|#PagedBetree.Step.QueryStep| |a#5#0#0@@13|))
     :skolemid |3337|
     :qid |PagedBetreeidfy.424:17|)))
(assert (forall ((|a#6#0#0@@13| T@U))
  (! (=> (= (type |a#6#0#0@@13|) DatatypeTypeType)
         (< (DtRank |a#6#0#0@@13|)
            (DtRank (|#PagedBetree.Step.QueryStep| |a#6#0#0@@13|))))
     :pattern ((|#PagedBetree.Step.QueryStep| |a#6#0#0@@13|))
     :skolemid |3338|
     :qid |PagedBetreeidfy.424:17|)))
(assert (= (type |#PagedBetree.Step.PutStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PagedBetree.Step.PutStep|) |##PagedBetree.Step.PutStep|))
(assert (forall ((d@@134 T@U))
  (! (=> (= (type d@@134) DatatypeTypeType)
         (= (PagedBetree.Step.PutStep_q d@@134)
            (= (DatatypeCtorId d@@134) |##PagedBetree.Step.PutStep|)))
     :pattern ((PagedBetree.Step.PutStep_q d@@134))
     :skolemid |3339|
     :qid |unknown.0:0|)))
(assert (forall ((d@@135 T@U))
  (! (=> (and (= (type d@@135) DatatypeTypeType)
              (PagedBetree.Step.PutStep_q d@@135))
         (= d@@135 |#PagedBetree.Step.PutStep|))
     :pattern ((PagedBetree.Step.PutStep_q d@@135))
     :skolemid |3340|
     :qid |unknown.0:0|)))
(assert ($Is |#PagedBetree.Step.PutStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@143 T@U))
  (! (=> (and (= (type $h@@143) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@143))
         ($IsAlloc |#PagedBetree.Step.PutStep| Tclass.PagedBetree.Step $h@@143))
     :pattern (($IsAlloc |#PagedBetree.Step.PutStep|
                         Tclass.PagedBetree.Step
                         $h@@143))
     :skolemid |3341|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#PagedBetree.Step.PutStep| (Lit |#PagedBetree.Step.PutStep|)))
(assert (= (type |#PagedBetree.Step.QueryEndLsnStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PagedBetree.Step.QueryEndLsnStep|)
   |##PagedBetree.Step.QueryEndLsnStep|))
(assert (forall ((d@@136 T@U))
  (! (=> (= (type d@@136) DatatypeTypeType)
         (= (PagedBetree.Step.QueryEndLsnStep_q d@@136)
            (= (DatatypeCtorId d@@136) |##PagedBetree.Step.QueryEndLsnStep|)))
     :pattern ((PagedBetree.Step.QueryEndLsnStep_q d@@136))
     :skolemid |3342|
     :qid |unknown.0:0|)))
(assert (forall ((d@@137 T@U))
  (! (=> (and (= (type d@@137) DatatypeTypeType)
              (PagedBetree.Step.QueryEndLsnStep_q d@@137))
         (= d@@137 |#PagedBetree.Step.QueryEndLsnStep|))
     :pattern ((PagedBetree.Step.QueryEndLsnStep_q d@@137))
     :skolemid |3343|
     :qid |unknown.0:0|)))
(assert ($Is |#PagedBetree.Step.QueryEndLsnStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@144 T@U))
  (! (=> (and (= (type $h@@144) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@144))
         ($IsAlloc |#PagedBetree.Step.QueryEndLsnStep|
                   Tclass.PagedBetree.Step
                   $h@@144))
     :pattern (($IsAlloc |#PagedBetree.Step.QueryEndLsnStep|
                         Tclass.PagedBetree.Step
                         $h@@144))
     :skolemid |3344|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#PagedBetree.Step.QueryEndLsnStep|
   (Lit |#PagedBetree.Step.QueryEndLsnStep|)))
(assert (= (type |#PagedBetree.Step.FreezeAsStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PagedBetree.Step.FreezeAsStep|)
   |##PagedBetree.Step.FreezeAsStep|))
(assert (forall ((d@@138 T@U))
  (! (=> (= (type d@@138) DatatypeTypeType)
         (= (PagedBetree.Step.FreezeAsStep_q d@@138)
            (= (DatatypeCtorId d@@138) |##PagedBetree.Step.FreezeAsStep|)))
     :pattern ((PagedBetree.Step.FreezeAsStep_q d@@138))
     :skolemid |3345|
     :qid |unknown.0:0|)))
(assert (forall ((d@@139 T@U))
  (! (=> (and (= (type d@@139) DatatypeTypeType)
              (PagedBetree.Step.FreezeAsStep_q d@@139))
         (= d@@139 |#PagedBetree.Step.FreezeAsStep|))
     :pattern ((PagedBetree.Step.FreezeAsStep_q d@@139))
     :skolemid |3346|
     :qid |unknown.0:0|)))
(assert ($Is |#PagedBetree.Step.FreezeAsStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@145 T@U))
  (! (=> (and (= (type $h@@145) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@145))
         ($IsAlloc |#PagedBetree.Step.FreezeAsStep|
                   Tclass.PagedBetree.Step
                   $h@@145))
     :pattern (($IsAlloc |#PagedBetree.Step.FreezeAsStep|
                         Tclass.PagedBetree.Step
                         $h@@145))
     :skolemid |3347|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#PagedBetree.Step.FreezeAsStep| (Lit |#PagedBetree.Step.FreezeAsStep|)))
(assert (= (type |#PagedBetree.Step.InternalGrowStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PagedBetree.Step.InternalGrowStep|)
   |##PagedBetree.Step.InternalGrowStep|))
(assert (forall ((d@@140 T@U))
  (! (=> (= (type d@@140) DatatypeTypeType)
         (= (PagedBetree.Step.InternalGrowStep_q d@@140)
            (= (DatatypeCtorId d@@140) |##PagedBetree.Step.InternalGrowStep|)))
     :pattern ((PagedBetree.Step.InternalGrowStep_q d@@140))
     :skolemid |3348|
     :qid |unknown.0:0|)))
(assert (forall ((d@@141 T@U))
  (! (=> (and (= (type d@@141) DatatypeTypeType)
              (PagedBetree.Step.InternalGrowStep_q d@@141))
         (= d@@141 |#PagedBetree.Step.InternalGrowStep|))
     :pattern ((PagedBetree.Step.InternalGrowStep_q d@@141))
     :skolemid |3349|
     :qid |unknown.0:0|)))
(assert ($Is |#PagedBetree.Step.InternalGrowStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@146 T@U))
  (! (=> (and (= (type $h@@146) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@146))
         ($IsAlloc |#PagedBetree.Step.InternalGrowStep|
                   Tclass.PagedBetree.Step
                   $h@@146))
     :pattern (($IsAlloc |#PagedBetree.Step.InternalGrowStep|
                         Tclass.PagedBetree.Step
                         $h@@146))
     :skolemid |3350|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#PagedBetree.Step.InternalGrowStep|
   (Lit |#PagedBetree.Step.InternalGrowStep|)))
(assert (forall ((arg0@@589 T@U) (arg1@@300 T@U) (arg2@@169 T@U))
  (! (= (type (|#PagedBetree.Step.InternalSplitStep|
                arg0@@589
                arg1@@300
                arg2@@169))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.Step.InternalSplitStep|
                 arg0@@589
                 arg1@@300
                 arg2@@169))
     :qid |funType:#PagedBetree.Step.InternalSplitStep|)))
(assert (forall ((|a#27#0#0@@0| T@U) (|a#27#1#0| T@U) (|a#27#2#0| T@U))
  (! (=> (and (= (type |a#27#0#0@@0|) DatatypeTypeType)
              (= (type |a#27#1#0|) (MapType0Type BoxType boolType))
              (= (type |a#27#2#0|) (MapType0Type BoxType boolType)))
         (= (DatatypeCtorId (|#PagedBetree.Step.InternalSplitStep|
                              |a#27#0#0@@0|
                              |a#27#1#0|
                              |a#27#2#0|))
            |##PagedBetree.Step.InternalSplitStep|))
     :pattern ((|#PagedBetree.Step.InternalSplitStep|
                 |a#27#0#0@@0|
                 |a#27#1#0|
                 |a#27#2#0|))
     :skolemid |3351|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((d@@142 T@U))
  (! (=> (= (type d@@142) DatatypeTypeType)
         (= (PagedBetree.Step.InternalSplitStep_q d@@142)
            (= (DatatypeCtorId d@@142) |##PagedBetree.Step.InternalSplitStep|)))
     :pattern ((PagedBetree.Step.InternalSplitStep_q d@@142))
     :skolemid |3352|
     :qid |unknown.0:0|)))
(assert (forall ((d@@143 T@U))
  (! (let ((a!1 (exists ((|a#28#0#0| T@U) (|a#28#1#0| T@U) (|a#28#2#0| T@U))
                  (! (and (= (type |a#28#0#0|) DatatypeTypeType)
                          (= (type |a#28#1#0|) (MapType0Type BoxType boolType))
                          (= (type |a#28#2#0|) (MapType0Type BoxType boolType))
                          (= d@@143
                             (|#PagedBetree.Step.InternalSplitStep|
                               |a#28#0#0|
                               |a#28#1#0|
                               |a#28#2#0|)))
                     :no-pattern (type |a#28#0#0|)
                     :no-pattern (type |a#28#1#0|)
                     :no-pattern (type |a#28#2#0|)
                     :no-pattern (U_2_int |a#28#0#0|)
                     :no-pattern (U_2_bool |a#28#0#0|)
                     :no-pattern (U_2_int |a#28#1#0|)
                     :no-pattern (U_2_bool |a#28#1#0|)
                     :no-pattern (U_2_int |a#28#2#0|)
                     :no-pattern (U_2_bool |a#28#2#0|)
                     :skolemid |3353|
                     :qid |PagedBetreeidfy.429:25|))))
       (=> (and (= (type d@@143) DatatypeTypeType)
                (PagedBetree.Step.InternalSplitStep_q d@@143))
           a!1))
     :pattern ((PagedBetree.Step.InternalSplitStep_q d@@143))
     :skolemid |3354|
     :qid |unknown.0:0|)))
(assert (forall ((|a#29#0#0| T@U) (|a#29#1#0| T@U) (|a#29#2#0| T@U))
  (! (let ((a!1 (= ($Is (|#PagedBetree.Step.InternalSplitStep|
                          |a#29#0#0|
                          |a#29#1#0|
                          |a#29#2#0|)
                        Tclass.PagedBetree.Step)
                   (and ($Is |a#29#0#0| Tclass.PagedBetree.Path)
                        ($Is |a#29#1#0| (TISet Tclass.KeyType.Key))
                        ($Is |a#29#2#0| (TISet Tclass.KeyType.Key))))))
       (=> (and (= (type |a#29#0#0|) DatatypeTypeType)
                (= (type |a#29#1#0|) (MapType0Type BoxType boolType))
                (= (type |a#29#2#0|) (MapType0Type BoxType boolType)))
           a!1))
     :pattern (($Is (|#PagedBetree.Step.InternalSplitStep|
                      |a#29#0#0|
                      |a#29#1#0|
                      |a#29#2#0|)
                    Tclass.PagedBetree.Step))
     :skolemid |3355|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((|a#30#0#0| T@U) (|a#30#1#0| T@U) (|a#30#2#0| T@U) ($h@@147 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#PagedBetree.Step.InternalSplitStep|
                               |a#30#0#0|
                               |a#30#1#0|
                               |a#30#2#0|)
                             Tclass.PagedBetree.Step
                             $h@@147)
                   (and ($IsAlloc |a#30#0#0| Tclass.PagedBetree.Path $h@@147)
                        ($IsAlloc |a#30#1#0| (TISet Tclass.KeyType.Key) $h@@147)
                        ($IsAlloc |a#30#2#0| (TISet Tclass.KeyType.Key) $h@@147)))))
       (=> (and (= (type |a#30#0#0|) DatatypeTypeType)
                (= (type |a#30#1#0|) (MapType0Type BoxType boolType))
                (= (type |a#30#2#0|) (MapType0Type BoxType boolType))
                (= (type $h@@147) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@147))
           a!1))
     :pattern (($IsAlloc (|#PagedBetree.Step.InternalSplitStep|
                           |a#30#0#0|
                           |a#30#1#0|
                           |a#30#2#0|)
                         Tclass.PagedBetree.Step
                         $h@@147))
     :skolemid |3356|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((arg0@@590 T@U))
  (! (= (type (PagedBetree.Step.path arg0@@590)) DatatypeTypeType)
     :pattern ((PagedBetree.Step.path arg0@@590))
     :qid |funType:PagedBetree.Step.path|)))
(assert (forall ((d@@144 T@U) ($h@@148 T@U))
  (! (=> (and (= (type d@@144) DatatypeTypeType)
              (= (type $h@@148) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@148)
              (PagedBetree.Step.InternalSplitStep_q d@@144)
              ($IsAlloc d@@144 Tclass.PagedBetree.Step $h@@148))
         ($IsAlloc (PagedBetree.Step.path d@@144)
                   Tclass.PagedBetree.Path
                   $h@@148))
     :pattern (($IsAlloc (PagedBetree.Step.path d@@144)
                         Tclass.PagedBetree.Path
                         $h@@148))
     :skolemid |3357|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@591 T@U))
  (! (= (type (PagedBetree.Step.leftKeys arg0@@591))
        (MapType0Type BoxType boolType))
     :pattern ((PagedBetree.Step.leftKeys arg0@@591))
     :qid |funType:PagedBetree.Step.leftKeys|)))
(assert (forall ((d@@145 T@U) ($h@@149 T@U))
  (! (=> (and (= (type d@@145) DatatypeTypeType)
              (= (type $h@@149) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@149)
              (PagedBetree.Step.InternalSplitStep_q d@@145)
              ($IsAlloc d@@145 Tclass.PagedBetree.Step $h@@149))
         ($IsAlloc (PagedBetree.Step.leftKeys d@@145)
                   (TISet Tclass.KeyType.Key)
                   $h@@149))
     :pattern (($IsAlloc (PagedBetree.Step.leftKeys d@@145)
                         (TISet Tclass.KeyType.Key)
                         $h@@149))
     :skolemid |3358|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@592 T@U))
  (! (= (type (PagedBetree.Step.rightKeys arg0@@592))
        (MapType0Type BoxType boolType))
     :pattern ((PagedBetree.Step.rightKeys arg0@@592))
     :qid |funType:PagedBetree.Step.rightKeys|)))
(assert (forall ((d@@146 T@U) ($h@@150 T@U))
  (! (=> (and (= (type d@@146) DatatypeTypeType)
              (= (type $h@@150) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@150)
              (PagedBetree.Step.InternalSplitStep_q d@@146)
              ($IsAlloc d@@146 Tclass.PagedBetree.Step $h@@150))
         ($IsAlloc (PagedBetree.Step.rightKeys d@@146)
                   (TISet Tclass.KeyType.Key)
                   $h@@150))
     :pattern (($IsAlloc (PagedBetree.Step.rightKeys d@@146)
                         (TISet Tclass.KeyType.Key)
                         $h@@150))
     :skolemid |3359|
     :qid |unknown.0:0|)))
(assert (forall ((|a#31#0#0| T@U) (|a#31#1#0| T@U) (|a#31#2#0| T@U))
  (! (=> (and (= (type |a#31#0#0|) DatatypeTypeType)
              (= (type |a#31#1#0|) (MapType0Type BoxType boolType))
              (= (type |a#31#2#0|) (MapType0Type BoxType boolType)))
         (= (|#PagedBetree.Step.InternalSplitStep|
              (Lit |a#31#0#0|)
              (Lit |a#31#1#0|)
              (Lit |a#31#2#0|))
            (Lit (|#PagedBetree.Step.InternalSplitStep|
                   |a#31#0#0|
                   |a#31#1#0|
                   |a#31#2#0|))))
     :pattern ((|#PagedBetree.Step.InternalSplitStep|
                 (Lit |a#31#0#0|)
                 (Lit |a#31#1#0|)
                 (Lit |a#31#2#0|)))
     :skolemid |3360|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((|a#32#0#0| T@U) (|a#32#1#0| T@U) (|a#32#2#0| T@U))
  (! (=> (and (= (type |a#32#0#0|) DatatypeTypeType)
              (= (type |a#32#1#0|) (MapType0Type BoxType boolType))
              (= (type |a#32#2#0|) (MapType0Type BoxType boolType)))
         (= (PagedBetree.Step.path
              (|#PagedBetree.Step.InternalSplitStep|
                |a#32#0#0|
                |a#32#1#0|
                |a#32#2#0|))
            |a#32#0#0|))
     :pattern ((|#PagedBetree.Step.InternalSplitStep|
                 |a#32#0#0|
                 |a#32#1#0|
                 |a#32#2#0|))
     :skolemid |3361|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((|a#33#0#0@@0| T@U) (|a#33#1#0| T@U) (|a#33#2#0| T@U))
  (! (=> (and (= (type |a#33#0#0@@0|) DatatypeTypeType)
              (= (type |a#33#1#0|) (MapType0Type BoxType boolType))
              (= (type |a#33#2#0|) (MapType0Type BoxType boolType)))
         (< (DtRank |a#33#0#0@@0|)
            (DtRank (|#PagedBetree.Step.InternalSplitStep|
                      |a#33#0#0@@0|
                      |a#33#1#0|
                      |a#33#2#0|))))
     :pattern ((|#PagedBetree.Step.InternalSplitStep|
                 |a#33#0#0@@0|
                 |a#33#1#0|
                 |a#33#2#0|))
     :skolemid |3362|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((|a#34#0#0@@0| T@U) (|a#34#1#0| T@U) (|a#34#2#0| T@U))
  (! (=> (and (= (type |a#34#0#0@@0|) DatatypeTypeType)
              (= (type |a#34#1#0|) (MapType0Type BoxType boolType))
              (= (type |a#34#2#0|) (MapType0Type BoxType boolType)))
         (= (PagedBetree.Step.leftKeys
              (|#PagedBetree.Step.InternalSplitStep|
                |a#34#0#0@@0|
                |a#34#1#0|
                |a#34#2#0|))
            |a#34#1#0|))
     :pattern ((|#PagedBetree.Step.InternalSplitStep|
                 |a#34#0#0@@0|
                 |a#34#1#0|
                 |a#34#2#0|))
     :skolemid |3363|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((|a#35#0#0@@0| T@U) (|a#35#1#0| T@U) (|a#35#2#0| T@U) (d@@147 T@U))
  (! (let ((a!1 (and (= (type |a#35#0#0@@0|) DatatypeTypeType)
                     (= (type |a#35#1#0|) (MapType0Type BoxType boolType))
                     (= (type |a#35#2#0|) (MapType0Type BoxType boolType))
                     (= (type d@@147) DatatypeTypeType)
                     (U_2_bool (MapType0Select |a#35#1#0| ($Box d@@147))))))
       (=> a!1
           (< (DtRank d@@147)
              (DtRank (|#PagedBetree.Step.InternalSplitStep|
                        |a#35#0#0@@0|
                        |a#35#1#0|
                        |a#35#2#0|)))))
     :pattern ((MapType0Select |a#35#1#0| ($Box d@@147))
               (|#PagedBetree.Step.InternalSplitStep|
                 |a#35#0#0@@0|
                 |a#35#1#0|
                 |a#35#2#0|))
     :skolemid |3364|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((|a#36#0#0@@0| T@U) (|a#36#1#0| T@U) (|a#36#2#0| T@U))
  (! (=> (and (= (type |a#36#0#0@@0|) DatatypeTypeType)
              (= (type |a#36#1#0|) (MapType0Type BoxType boolType))
              (= (type |a#36#2#0|) (MapType0Type BoxType boolType)))
         (= (PagedBetree.Step.rightKeys
              (|#PagedBetree.Step.InternalSplitStep|
                |a#36#0#0@@0|
                |a#36#1#0|
                |a#36#2#0|))
            |a#36#2#0|))
     :pattern ((|#PagedBetree.Step.InternalSplitStep|
                 |a#36#0#0@@0|
                 |a#36#1#0|
                 |a#36#2#0|))
     :skolemid |3365|
     :qid |PagedBetreeidfy.429:25|)))
(assert (forall ((|a#37#0#0@@0| T@U) (|a#37#1#0| T@U) (|a#37#2#0| T@U) (d@@148 T@U))
  (! (let ((a!1 (and (= (type |a#37#0#0@@0|) DatatypeTypeType)
                     (= (type |a#37#1#0|) (MapType0Type BoxType boolType))
                     (= (type |a#37#2#0|) (MapType0Type BoxType boolType))
                     (= (type d@@148) DatatypeTypeType)
                     (U_2_bool (MapType0Select |a#37#2#0| ($Box d@@148))))))
       (=> a!1
           (< (DtRank d@@148)
              (DtRank (|#PagedBetree.Step.InternalSplitStep|
                        |a#37#0#0@@0|
                        |a#37#1#0|
                        |a#37#2#0|)))))
     :pattern ((MapType0Select |a#37#2#0| ($Box d@@148))
               (|#PagedBetree.Step.InternalSplitStep|
                 |a#37#0#0@@0|
                 |a#37#1#0|
                 |a#37#2#0|))
     :skolemid |3366|
     :qid |PagedBetreeidfy.429:25|)))
(assert (= (type |#PagedBetree.Step.InternalFlushMemtableStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PagedBetree.Step.InternalFlushMemtableStep|)
   |##PagedBetree.Step.InternalFlushMemtableStep|))
(assert (forall ((d@@149 T@U))
  (! (=> (= (type d@@149) DatatypeTypeType)
         (= (PagedBetree.Step.InternalFlushMemtableStep_q d@@149)
            (= (DatatypeCtorId d@@149)
               |##PagedBetree.Step.InternalFlushMemtableStep|)))
     :pattern ((PagedBetree.Step.InternalFlushMemtableStep_q d@@149))
     :skolemid |3367|
     :qid |unknown.0:0|)))
(assert (forall ((d@@150 T@U))
  (! (=> (and (= (type d@@150) DatatypeTypeType)
              (PagedBetree.Step.InternalFlushMemtableStep_q d@@150))
         (= d@@150 |#PagedBetree.Step.InternalFlushMemtableStep|))
     :pattern ((PagedBetree.Step.InternalFlushMemtableStep_q d@@150))
     :skolemid |3368|
     :qid |unknown.0:0|)))
(assert ($Is |#PagedBetree.Step.InternalFlushMemtableStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@151 T@U))
  (! (=> (and (= (type $h@@151) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@151))
         ($IsAlloc |#PagedBetree.Step.InternalFlushMemtableStep|
                   Tclass.PagedBetree.Step
                   $h@@151))
     :pattern (($IsAlloc |#PagedBetree.Step.InternalFlushMemtableStep|
                         Tclass.PagedBetree.Step
                         $h@@151))
     :skolemid |3369|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#PagedBetree.Step.InternalFlushMemtableStep|
   (Lit |#PagedBetree.Step.InternalFlushMemtableStep|)))
(assert (forall ((arg0@@593 T@U) (arg1@@301 T@U))
  (! (= (type (|#PagedBetree.Step.InternalFlushStep| arg0@@593 arg1@@301))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.Step.InternalFlushStep| arg0@@593 arg1@@301))
     :qid |funType:#PagedBetree.Step.InternalFlushStep|)))
(assert (forall ((|a#43#0#0| T@U) (|a#43#1#0| T@U))
  (! (=> (and (= (type |a#43#0#0|) DatatypeTypeType)
              (= (type |a#43#1#0|) (MapType0Type BoxType boolType)))
         (= (DatatypeCtorId (|#PagedBetree.Step.InternalFlushStep|
                              |a#43#0#0|
                              |a#43#1#0|))
            |##PagedBetree.Step.InternalFlushStep|))
     :pattern ((|#PagedBetree.Step.InternalFlushStep| |a#43#0#0| |a#43#1#0|))
     :skolemid |3370|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((d@@151 T@U))
  (! (=> (= (type d@@151) DatatypeTypeType)
         (= (PagedBetree.Step.InternalFlushStep_q d@@151)
            (= (DatatypeCtorId d@@151) |##PagedBetree.Step.InternalFlushStep|)))
     :pattern ((PagedBetree.Step.InternalFlushStep_q d@@151))
     :skolemid |3371|
     :qid |unknown.0:0|)))
(assert (forall ((d@@152 T@U))
  (! (let ((a!1 (exists ((|a#44#0#0| T@U) (|a#44#1#0| T@U))
                  (! (and (= (type |a#44#0#0|) DatatypeTypeType)
                          (= (type |a#44#1#0|) (MapType0Type BoxType boolType))
                          (= d@@152
                             (|#PagedBetree.Step.InternalFlushStep|
                               |a#44#0#0|
                               |a#44#1#0|)))
                     :no-pattern (type |a#44#0#0|)
                     :no-pattern (type |a#44#1#0|)
                     :no-pattern (U_2_int |a#44#0#0|)
                     :no-pattern (U_2_bool |a#44#0#0|)
                     :no-pattern (U_2_int |a#44#1#0|)
                     :no-pattern (U_2_bool |a#44#1#0|)
                     :skolemid |3372|
                     :qid |PagedBetreeidfy.431:25|))))
       (=> (and (= (type d@@152) DatatypeTypeType)
                (PagedBetree.Step.InternalFlushStep_q d@@152))
           a!1))
     :pattern ((PagedBetree.Step.InternalFlushStep_q d@@152))
     :skolemid |3373|
     :qid |unknown.0:0|)))
(assert (forall ((|a#45#0#0| T@U) (|a#45#1#0| T@U))
  (! (let ((a!1 (= ($Is (|#PagedBetree.Step.InternalFlushStep|
                          |a#45#0#0|
                          |a#45#1#0|)
                        Tclass.PagedBetree.Step)
                   (and ($Is |a#45#0#0| Tclass.PagedBetree.Path)
                        ($Is |a#45#1#0| (TISet Tclass.KeyType.Key))))))
       (=> (and (= (type |a#45#0#0|) DatatypeTypeType)
                (= (type |a#45#1#0|) (MapType0Type BoxType boolType)))
           a!1))
     :pattern (($Is (|#PagedBetree.Step.InternalFlushStep|
                      |a#45#0#0|
                      |a#45#1#0|)
                    Tclass.PagedBetree.Step))
     :skolemid |3374|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((|a#46#0#0| T@U) (|a#46#1#0| T@U) ($h@@152 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#PagedBetree.Step.InternalFlushStep|
                               |a#46#0#0|
                               |a#46#1#0|)
                             Tclass.PagedBetree.Step
                             $h@@152)
                   (and ($IsAlloc |a#46#0#0| Tclass.PagedBetree.Path $h@@152)
                        ($IsAlloc |a#46#1#0| (TISet Tclass.KeyType.Key) $h@@152)))))
       (=> (and (= (type |a#46#0#0|) DatatypeTypeType)
                (= (type |a#46#1#0|) (MapType0Type BoxType boolType))
                (= (type $h@@152) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@152))
           a!1))
     :pattern (($IsAlloc (|#PagedBetree.Step.InternalFlushStep|
                           |a#46#0#0|
                           |a#46#1#0|)
                         Tclass.PagedBetree.Step
                         $h@@152))
     :skolemid |3375|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((d@@153 T@U) ($h@@153 T@U))
  (! (=> (and (= (type d@@153) DatatypeTypeType)
              (= (type $h@@153) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@153)
              (PagedBetree.Step.InternalFlushStep_q d@@153)
              ($IsAlloc d@@153 Tclass.PagedBetree.Step $h@@153))
         ($IsAlloc (PagedBetree.Step.path d@@153)
                   Tclass.PagedBetree.Path
                   $h@@153))
     :pattern (($IsAlloc (PagedBetree.Step.path d@@153)
                         Tclass.PagedBetree.Path
                         $h@@153))
     :skolemid |3376|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@594 T@U))
  (! (= (type (PagedBetree.Step.downKeys arg0@@594))
        (MapType0Type BoxType boolType))
     :pattern ((PagedBetree.Step.downKeys arg0@@594))
     :qid |funType:PagedBetree.Step.downKeys|)))
(assert (forall ((d@@154 T@U) ($h@@154 T@U))
  (! (=> (and (= (type d@@154) DatatypeTypeType)
              (= (type $h@@154) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@154)
              (PagedBetree.Step.InternalFlushStep_q d@@154)
              ($IsAlloc d@@154 Tclass.PagedBetree.Step $h@@154))
         ($IsAlloc (PagedBetree.Step.downKeys d@@154)
                   (TISet Tclass.KeyType.Key)
                   $h@@154))
     :pattern (($IsAlloc (PagedBetree.Step.downKeys d@@154)
                         (TISet Tclass.KeyType.Key)
                         $h@@154))
     :skolemid |3377|
     :qid |unknown.0:0|)))
(assert (forall ((|a#47#0#0| T@U) (|a#47#1#0| T@U))
  (! (=> (and (= (type |a#47#0#0|) DatatypeTypeType)
              (= (type |a#47#1#0|) (MapType0Type BoxType boolType)))
         (= (|#PagedBetree.Step.InternalFlushStep|
              (Lit |a#47#0#0|)
              (Lit |a#47#1#0|))
            (Lit (|#PagedBetree.Step.InternalFlushStep| |a#47#0#0| |a#47#1#0|))))
     :pattern ((|#PagedBetree.Step.InternalFlushStep|
                 (Lit |a#47#0#0|)
                 (Lit |a#47#1#0|)))
     :skolemid |3378|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((|a#48#0#0| T@U) (|a#48#1#0| T@U))
  (! (=> (and (= (type |a#48#0#0|) DatatypeTypeType)
              (= (type |a#48#1#0|) (MapType0Type BoxType boolType)))
         (= (PagedBetree.Step.path
              (|#PagedBetree.Step.InternalFlushStep| |a#48#0#0| |a#48#1#0|))
            |a#48#0#0|))
     :pattern ((|#PagedBetree.Step.InternalFlushStep| |a#48#0#0| |a#48#1#0|))
     :skolemid |3379|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((|a#49#0#0| T@U) (|a#49#1#0| T@U))
  (! (=> (and (= (type |a#49#0#0|) DatatypeTypeType)
              (= (type |a#49#1#0|) (MapType0Type BoxType boolType)))
         (< (DtRank |a#49#0#0|)
            (DtRank (|#PagedBetree.Step.InternalFlushStep|
                      |a#49#0#0|
                      |a#49#1#0|))))
     :pattern ((|#PagedBetree.Step.InternalFlushStep| |a#49#0#0| |a#49#1#0|))
     :skolemid |3380|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((|a#50#0#0| T@U) (|a#50#1#0| T@U))
  (! (=> (and (= (type |a#50#0#0|) DatatypeTypeType)
              (= (type |a#50#1#0|) (MapType0Type BoxType boolType)))
         (= (PagedBetree.Step.downKeys
              (|#PagedBetree.Step.InternalFlushStep| |a#50#0#0| |a#50#1#0|))
            |a#50#1#0|))
     :pattern ((|#PagedBetree.Step.InternalFlushStep| |a#50#0#0| |a#50#1#0|))
     :skolemid |3381|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((|a#51#0#0| T@U) (|a#51#1#0| T@U) (d@@155 T@U))
  (! (let ((a!1 (and (= (type |a#51#0#0|) DatatypeTypeType)
                     (= (type |a#51#1#0|) (MapType0Type BoxType boolType))
                     (= (type d@@155) DatatypeTypeType)
                     (U_2_bool (MapType0Select |a#51#1#0| ($Box d@@155))))))
       (=> a!1
           (< (DtRank d@@155)
              (DtRank (|#PagedBetree.Step.InternalFlushStep|
                        |a#51#0#0|
                        |a#51#1#0|)))))
     :pattern ((MapType0Select |a#51#1#0| ($Box d@@155))
               (|#PagedBetree.Step.InternalFlushStep| |a#51#0#0| |a#51#1#0|))
     :skolemid |3382|
     :qid |PagedBetreeidfy.431:25|)))
(assert (forall ((arg0@@595 T@U) (arg1@@302 T@U))
  (! (= (type (|#PagedBetree.Step.InternalCompactStep| arg0@@595 arg1@@302))
        DatatypeTypeType)
     :pattern ((|#PagedBetree.Step.InternalCompactStep| arg0@@595 arg1@@302))
     :qid |funType:#PagedBetree.Step.InternalCompactStep|)))
(assert (forall ((|a#52#0#0| T@U) (|a#52#1#0| T@U))
  (! (=> (and (= (type |a#52#0#0|) DatatypeTypeType)
              (= (type |a#52#1#0|) DatatypeTypeType))
         (= (DatatypeCtorId (|#PagedBetree.Step.InternalCompactStep|
                              |a#52#0#0|
                              |a#52#1#0|))
            |##PagedBetree.Step.InternalCompactStep|))
     :pattern ((|#PagedBetree.Step.InternalCompactStep| |a#52#0#0| |a#52#1#0|))
     :skolemid |3383|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((d@@156 T@U))
  (! (=> (= (type d@@156) DatatypeTypeType)
         (= (PagedBetree.Step.InternalCompactStep_q d@@156)
            (= (DatatypeCtorId d@@156) |##PagedBetree.Step.InternalCompactStep|)))
     :pattern ((PagedBetree.Step.InternalCompactStep_q d@@156))
     :skolemid |3384|
     :qid |unknown.0:0|)))
(assert (forall ((d@@157 T@U))
  (! (let ((a!1 (exists ((|a#53#0#0| T@U) (|a#53#1#0| T@U))
                  (! (and (= (type |a#53#0#0|) DatatypeTypeType)
                          (= (type |a#53#1#0|) DatatypeTypeType)
                          (= d@@157
                             (|#PagedBetree.Step.InternalCompactStep|
                               |a#53#0#0|
                               |a#53#1#0|)))
                     :no-pattern (type |a#53#0#0|)
                     :no-pattern (type |a#53#1#0|)
                     :no-pattern (U_2_int |a#53#0#0|)
                     :no-pattern (U_2_bool |a#53#0#0|)
                     :no-pattern (U_2_int |a#53#1#0|)
                     :no-pattern (U_2_bool |a#53#1#0|)
                     :skolemid |3385|
                     :qid |PagedBetreeidfy.432:27|))))
       (=> (and (= (type d@@157) DatatypeTypeType)
                (PagedBetree.Step.InternalCompactStep_q d@@157))
           a!1))
     :pattern ((PagedBetree.Step.InternalCompactStep_q d@@157))
     :skolemid |3386|
     :qid |unknown.0:0|)))
(assert (forall ((|a#54#0#0| T@U) (|a#54#1#0| T@U))
  (! (=> (and (= (type |a#54#0#0|) DatatypeTypeType)
              (= (type |a#54#1#0|) DatatypeTypeType))
         (= ($Is (|#PagedBetree.Step.InternalCompactStep| |a#54#0#0| |a#54#1#0|)
                 Tclass.PagedBetree.Step)
            (and ($Is |a#54#0#0| Tclass.PagedBetree.Path)
                 ($Is |a#54#1#0| Tclass.Buffers.BufferStack))))
     :pattern (($Is (|#PagedBetree.Step.InternalCompactStep|
                      |a#54#0#0|
                      |a#54#1#0|)
                    Tclass.PagedBetree.Step))
     :skolemid |3387|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((|a#55#0#0| T@U) (|a#55#1#0| T@U) ($h@@155 T@U))
  (! (=> (and (= (type |a#55#0#0|) DatatypeTypeType)
              (= (type |a#55#1#0|) DatatypeTypeType)
              (= (type $h@@155) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@155))
         (= ($IsAlloc (|#PagedBetree.Step.InternalCompactStep|
                        |a#55#0#0|
                        |a#55#1#0|)
                      Tclass.PagedBetree.Step
                      $h@@155)
            (and ($IsAlloc |a#55#0#0| Tclass.PagedBetree.Path $h@@155)
                 ($IsAlloc |a#55#1#0| Tclass.Buffers.BufferStack $h@@155))))
     :pattern (($IsAlloc (|#PagedBetree.Step.InternalCompactStep|
                           |a#55#0#0|
                           |a#55#1#0|)
                         Tclass.PagedBetree.Step
                         $h@@155))
     :skolemid |3388|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((d@@158 T@U) ($h@@156 T@U))
  (! (=> (and (= (type d@@158) DatatypeTypeType)
              (= (type $h@@156) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@156)
              (PagedBetree.Step.InternalCompactStep_q d@@158)
              ($IsAlloc d@@158 Tclass.PagedBetree.Step $h@@156))
         ($IsAlloc (PagedBetree.Step.path d@@158)
                   Tclass.PagedBetree.Path
                   $h@@156))
     :pattern (($IsAlloc (PagedBetree.Step.path d@@158)
                         Tclass.PagedBetree.Path
                         $h@@156))
     :skolemid |3389|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@596 T@U))
  (! (= (type (PagedBetree.Step.compactedBuffers arg0@@596)) DatatypeTypeType)
     :pattern ((PagedBetree.Step.compactedBuffers arg0@@596))
     :qid |funType:PagedBetree.Step.compactedBuffers|)))
(assert (forall ((d@@159 T@U) ($h@@157 T@U))
  (! (=> (and (= (type d@@159) DatatypeTypeType)
              (= (type $h@@157) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@157)
              (PagedBetree.Step.InternalCompactStep_q d@@159)
              ($IsAlloc d@@159 Tclass.PagedBetree.Step $h@@157))
         ($IsAlloc (PagedBetree.Step.compactedBuffers d@@159)
                   Tclass.Buffers.BufferStack
                   $h@@157))
     :pattern (($IsAlloc (PagedBetree.Step.compactedBuffers d@@159)
                         Tclass.Buffers.BufferStack
                         $h@@157))
     :skolemid |3390|
     :qid |unknown.0:0|)))
(assert (forall ((|a#56#0#0| T@U) (|a#56#1#0| T@U))
  (! (=> (and (= (type |a#56#0#0|) DatatypeTypeType)
              (= (type |a#56#1#0|) DatatypeTypeType))
         (= (|#PagedBetree.Step.InternalCompactStep|
              (Lit |a#56#0#0|)
              (Lit |a#56#1#0|))
            (Lit (|#PagedBetree.Step.InternalCompactStep| |a#56#0#0| |a#56#1#0|))))
     :pattern ((|#PagedBetree.Step.InternalCompactStep|
                 (Lit |a#56#0#0|)
                 (Lit |a#56#1#0|)))
     :skolemid |3391|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((|a#57#0#0| T@U) (|a#57#1#0| T@U))
  (! (=> (and (= (type |a#57#0#0|) DatatypeTypeType)
              (= (type |a#57#1#0|) DatatypeTypeType))
         (= (PagedBetree.Step.path
              (|#PagedBetree.Step.InternalCompactStep| |a#57#0#0| |a#57#1#0|))
            |a#57#0#0|))
     :pattern ((|#PagedBetree.Step.InternalCompactStep| |a#57#0#0| |a#57#1#0|))
     :skolemid |3392|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((|a#58#0#0| T@U) (|a#58#1#0| T@U))
  (! (=> (and (= (type |a#58#0#0|) DatatypeTypeType)
              (= (type |a#58#1#0|) DatatypeTypeType))
         (< (DtRank |a#58#0#0|)
            (DtRank (|#PagedBetree.Step.InternalCompactStep|
                      |a#58#0#0|
                      |a#58#1#0|))))
     :pattern ((|#PagedBetree.Step.InternalCompactStep| |a#58#0#0| |a#58#1#0|))
     :skolemid |3393|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((|a#59#0#0| T@U) (|a#59#1#0| T@U))
  (! (=> (and (= (type |a#59#0#0|) DatatypeTypeType)
              (= (type |a#59#1#0|) DatatypeTypeType))
         (= (PagedBetree.Step.compactedBuffers
              (|#PagedBetree.Step.InternalCompactStep| |a#59#0#0| |a#59#1#0|))
            |a#59#1#0|))
     :pattern ((|#PagedBetree.Step.InternalCompactStep| |a#59#0#0| |a#59#1#0|))
     :skolemid |3394|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((|a#60#0#0| T@U) (|a#60#1#0| T@U))
  (! (=> (and (= (type |a#60#0#0|) DatatypeTypeType)
              (= (type |a#60#1#0|) DatatypeTypeType))
         (< (DtRank |a#60#1#0|)
            (DtRank (|#PagedBetree.Step.InternalCompactStep|
                      |a#60#0#0|
                      |a#60#1#0|))))
     :pattern ((|#PagedBetree.Step.InternalCompactStep| |a#60#0#0| |a#60#1#0|))
     :skolemid |3395|
     :qid |PagedBetreeidfy.432:27|)))
(assert (forall ((d@@160 T@U))
  (! (=> (and (= (type d@@160) DatatypeTypeType)
              (|$IsA#PagedBetree.Step| d@@160))
         (or (PagedBetree.Step.QueryStep_q d@@160)
             (PagedBetree.Step.PutStep_q d@@160)
             (PagedBetree.Step.QueryEndLsnStep_q d@@160)
             (PagedBetree.Step.FreezeAsStep_q d@@160)
             (PagedBetree.Step.InternalGrowStep_q d@@160)
             (PagedBetree.Step.InternalSplitStep_q d@@160)
             (PagedBetree.Step.InternalFlushMemtableStep_q d@@160)
             (PagedBetree.Step.InternalFlushStep_q d@@160)
             (PagedBetree.Step.InternalCompactStep_q d@@160)))
     :pattern ((|$IsA#PagedBetree.Step| d@@160))
     :skolemid |3396|
     :qid |unknown.0:0|)))
(assert (forall ((d@@161 T@U))
  (! (=> (and (= (type d@@161) DatatypeTypeType)
              ($Is d@@161 Tclass.PagedBetree.Step))
         (or (PagedBetree.Step.QueryStep_q d@@161)
             (PagedBetree.Step.PutStep_q d@@161)
             (PagedBetree.Step.QueryEndLsnStep_q d@@161)
             (PagedBetree.Step.FreezeAsStep_q d@@161)
             (PagedBetree.Step.InternalGrowStep_q d@@161)
             (PagedBetree.Step.InternalSplitStep_q d@@161)
             (PagedBetree.Step.InternalFlushMemtableStep_q d@@161)
             (PagedBetree.Step.InternalFlushStep_q d@@161)
             (PagedBetree.Step.InternalCompactStep_q d@@161)))
     :pattern ((PagedBetree.Step.InternalCompactStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.InternalFlushStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.InternalFlushMemtableStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.InternalSplitStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.InternalGrowStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.FreezeAsStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.QueryEndLsnStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.PutStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :pattern ((PagedBetree.Step.QueryStep_q d@@161)
               ($Is d@@161 Tclass.PagedBetree.Step))
     :skolemid |3397|
     :qid |unknown.0:0|)))
(assert (forall ((a@@157 T@U) (b@@107 T@U))
  (! (=> (and (= (type a@@157) DatatypeTypeType)
              (= (type b@@107) DatatypeTypeType)
              (PagedBetree.Step.QueryStep_q a@@157)
              (PagedBetree.Step.QueryStep_q b@@107))
         (= (|PagedBetree.Step#Equal| a@@157 b@@107)
            (|PagedBetree.QueryReceipt#Equal|
              (PagedBetree.Step.receipt a@@157)
              (PagedBetree.Step.receipt b@@107))))
     :pattern ((|PagedBetree.Step#Equal| a@@157 b@@107)
               (PagedBetree.Step.QueryStep_q a@@157))
     :pattern ((|PagedBetree.Step#Equal| a@@157 b@@107)
               (PagedBetree.Step.QueryStep_q b@@107))
     :skolemid |3398|
     :qid |unknown.0:0|)))
(assert (forall ((a@@158 T@U) (b@@108 T@U))
  (! (=> (and (= (type a@@158) DatatypeTypeType)
              (= (type b@@108) DatatypeTypeType)
              (PagedBetree.Step.PutStep_q a@@158)
              (PagedBetree.Step.PutStep_q b@@108))
         (= (|PagedBetree.Step#Equal| a@@158 b@@108) true))
     :pattern ((|PagedBetree.Step#Equal| a@@158 b@@108)
               (PagedBetree.Step.PutStep_q a@@158))
     :pattern ((|PagedBetree.Step#Equal| a@@158 b@@108)
               (PagedBetree.Step.PutStep_q b@@108))
     :skolemid |3399|
     :qid |unknown.0:0|)))
(assert (forall ((a@@159 T@U) (b@@109 T@U))
  (! (=> (and (= (type a@@159) DatatypeTypeType)
              (= (type b@@109) DatatypeTypeType)
              (PagedBetree.Step.QueryEndLsnStep_q a@@159)
              (PagedBetree.Step.QueryEndLsnStep_q b@@109))
         (= (|PagedBetree.Step#Equal| a@@159 b@@109) true))
     :pattern ((|PagedBetree.Step#Equal| a@@159 b@@109)
               (PagedBetree.Step.QueryEndLsnStep_q a@@159))
     :pattern ((|PagedBetree.Step#Equal| a@@159 b@@109)
               (PagedBetree.Step.QueryEndLsnStep_q b@@109))
     :skolemid |3400|
     :qid |unknown.0:0|)))
(assert (forall ((a@@160 T@U) (b@@110 T@U))
  (! (=> (and (= (type a@@160) DatatypeTypeType)
              (= (type b@@110) DatatypeTypeType)
              (PagedBetree.Step.FreezeAsStep_q a@@160)
              (PagedBetree.Step.FreezeAsStep_q b@@110))
         (= (|PagedBetree.Step#Equal| a@@160 b@@110) true))
     :pattern ((|PagedBetree.Step#Equal| a@@160 b@@110)
               (PagedBetree.Step.FreezeAsStep_q a@@160))
     :pattern ((|PagedBetree.Step#Equal| a@@160 b@@110)
               (PagedBetree.Step.FreezeAsStep_q b@@110))
     :skolemid |3401|
     :qid |unknown.0:0|)))
(assert (forall ((a@@161 T@U) (b@@111 T@U))
  (! (=> (and (= (type a@@161) DatatypeTypeType)
              (= (type b@@111) DatatypeTypeType)
              (PagedBetree.Step.InternalGrowStep_q a@@161)
              (PagedBetree.Step.InternalGrowStep_q b@@111))
         (= (|PagedBetree.Step#Equal| a@@161 b@@111) true))
     :pattern ((|PagedBetree.Step#Equal| a@@161 b@@111)
               (PagedBetree.Step.InternalGrowStep_q a@@161))
     :pattern ((|PagedBetree.Step#Equal| a@@161 b@@111)
               (PagedBetree.Step.InternalGrowStep_q b@@111))
     :skolemid |3402|
     :qid |unknown.0:0|)))
(assert (forall ((a@@162 T@U) (b@@112 T@U))
  (! (let ((a!1 (= (|PagedBetree.Step#Equal| a@@162 b@@112)
                   (and (|PagedBetree.Path#Equal|
                          (PagedBetree.Step.path a@@162)
                          (PagedBetree.Step.path b@@112))
                        (|ISet#Equal| (PagedBetree.Step.leftKeys a@@162)
                                      (PagedBetree.Step.leftKeys b@@112))
                        (|ISet#Equal| (PagedBetree.Step.rightKeys a@@162)
                                      (PagedBetree.Step.rightKeys b@@112))))))
       (=> (and (= (type a@@162) DatatypeTypeType)
                (= (type b@@112) DatatypeTypeType)
                (PagedBetree.Step.InternalSplitStep_q a@@162)
                (PagedBetree.Step.InternalSplitStep_q b@@112))
           a!1))
     :pattern ((|PagedBetree.Step#Equal| a@@162 b@@112)
               (PagedBetree.Step.InternalSplitStep_q a@@162))
     :pattern ((|PagedBetree.Step#Equal| a@@162 b@@112)
               (PagedBetree.Step.InternalSplitStep_q b@@112))
     :skolemid |3403|
     :qid |unknown.0:0|)))
(assert (forall ((a@@163 T@U) (b@@113 T@U))
  (! (=> (and (= (type a@@163) DatatypeTypeType)
              (= (type b@@113) DatatypeTypeType)
              (PagedBetree.Step.InternalFlushMemtableStep_q a@@163)
              (PagedBetree.Step.InternalFlushMemtableStep_q b@@113))
         (= (|PagedBetree.Step#Equal| a@@163 b@@113) true))
     :pattern ((|PagedBetree.Step#Equal| a@@163 b@@113)
               (PagedBetree.Step.InternalFlushMemtableStep_q a@@163))
     :pattern ((|PagedBetree.Step#Equal| a@@163 b@@113)
               (PagedBetree.Step.InternalFlushMemtableStep_q b@@113))
     :skolemid |3404|
     :qid |unknown.0:0|)))
(assert (forall ((a@@164 T@U) (b@@114 T@U))
  (! (let ((a!1 (= (|PagedBetree.Step#Equal| a@@164 b@@114)
                   (and (|PagedBetree.Path#Equal|
                          (PagedBetree.Step.path a@@164)
                          (PagedBetree.Step.path b@@114))
                        (|ISet#Equal| (PagedBetree.Step.downKeys a@@164)
                                      (PagedBetree.Step.downKeys b@@114))))))
       (=> (and (= (type a@@164) DatatypeTypeType)
                (= (type b@@114) DatatypeTypeType)
                (PagedBetree.Step.InternalFlushStep_q a@@164)
                (PagedBetree.Step.InternalFlushStep_q b@@114))
           a!1))
     :pattern ((|PagedBetree.Step#Equal| a@@164 b@@114)
               (PagedBetree.Step.InternalFlushStep_q a@@164))
     :pattern ((|PagedBetree.Step#Equal| a@@164 b@@114)
               (PagedBetree.Step.InternalFlushStep_q b@@114))
     :skolemid |3405|
     :qid |unknown.0:0|)))
(assert (forall ((a@@165 T@U) (b@@115 T@U))
  (! (let ((a!1 (= (|PagedBetree.Step#Equal| a@@165 b@@115)
                   (and (|PagedBetree.Path#Equal|
                          (PagedBetree.Step.path a@@165)
                          (PagedBetree.Step.path b@@115))
                        (|Buffers.BufferStack#Equal|
                          (PagedBetree.Step.compactedBuffers a@@165)
                          (PagedBetree.Step.compactedBuffers b@@115))))))
       (=> (and (= (type a@@165) DatatypeTypeType)
                (= (type b@@115) DatatypeTypeType)
                (PagedBetree.Step.InternalCompactStep_q a@@165)
                (PagedBetree.Step.InternalCompactStep_q b@@115))
           a!1))
     :pattern ((|PagedBetree.Step#Equal| a@@165 b@@115)
               (PagedBetree.Step.InternalCompactStep_q a@@165))
     :pattern ((|PagedBetree.Step#Equal| a@@165 b@@115)
               (PagedBetree.Step.InternalCompactStep_q b@@115))
     :skolemid |3406|
     :qid |unknown.0:0|)))
(assert (forall ((a@@166 T@U) (b@@116 T@U))
  (! (=> (and (= (type a@@166) DatatypeTypeType)
              (= (type b@@116) DatatypeTypeType))
         (= (|PagedBetree.Step#Equal| a@@166 b@@116) (= a@@166 b@@116)))
     :pattern ((|PagedBetree.Step#Equal| a@@166 b@@116))
     :skolemid |3407|
     :qid |unknown.0:0|)))
(assert (let ((a!1 (forall ((this@@244 T@U))
             (! (=> (and (= (type this@@244) DatatypeTypeType)
                         (or (|PagedBetree.Step.WF#canCall| this@@244)
                             ($Is this@@244 Tclass.PagedBetree.Step)))
                    true)
                :pattern ((PagedBetree.Step.WF this@@244))
                :skolemid |3408|
                :qid |PagedBetreeidfy.434:15|))))
  (=> true a!1)))
(assert (forall ((this@@245 T@U))
  (! (=> (and (= (type this@@245) DatatypeTypeType)
              ($Is this@@245 Tclass.PagedBetree.Step))
         (= (|PagedBetree.Step.WF#requires| this@@245) true))
     :pattern ((|PagedBetree.Step.WF#requires| this@@245))
     :skolemid |3409|
     :qid |PagedBetreeidfy.434:15|)))
(assert (let ((a!1 (forall ((this@@246 T@U))
             (! (let ((a!1 (|Buffers.BufferStack.Equivalent#canCall|
                             (PagedBetree.BetreeNode.buffers
                               (PagedBetree.Path.Target
                                 ($LS $LZ)
                                 (PagedBetree.Step.path this@@246)))
                             (PagedBetree.Step.compactedBuffers this@@246)))
                      (a!10 (Buffers.BufferStack.Equivalent
                              (PagedBetree.BetreeNode.buffers
                                (PagedBetree.Path.Target
                                  ($LS $LZ)
                                  (PagedBetree.Step.path this@@246)))
                              (PagedBetree.Step.compactedBuffers this@@246))))
                (let ((a!2 (=> (PagedBetree.BetreeNode.BetreeNode_q
                                 (PagedBetree.Path.Target
                                   ($LS $LZ)
                                   (PagedBetree.Step.path this@@246)))
                               (and (|PagedBetree.Path.Target#canCall|
                                      (PagedBetree.Step.path this@@246))
                                    a!1)))
                      (a!11 (and (PagedBetree.Path.Valid
                                   ($LS $LZ)
                                   (PagedBetree.Step.path this@@246))
                                 (PagedBetree.BetreeNode.BetreeNode_q
                                   (PagedBetree.Path.Target
                                     ($LS $LZ)
                                     (PagedBetree.Step.path this@@246)))
                                 a!10)))
                (let ((a!3 (=> (PagedBetree.Path.Valid
                                 ($LS $LZ)
                                 (PagedBetree.Step.path this@@246))
                               (and (|PagedBetree.Path.Target#canCall|
                                      (PagedBetree.Step.path this@@246))
                                    a!2)))
                      (a!12 (ite (PagedBetree.Step.InternalFlushMemtableStep_q
                                   this@@246)
                                 true
                                 (ite (PagedBetree.Step.InternalFlushStep_q
                                        this@@246)
                                      (PagedBetree.Path.Valid
                                        ($LS $LZ)
                                        (PagedBetree.Step.path this@@246))
                                      a!11))))
                (let ((a!4 (=> (not (PagedBetree.Step.InternalFlushStep_q
                                      this@@246))
                               (and (|PagedBetree.Path.Valid#canCall|
                                      (PagedBetree.Step.path this@@246))
                                    a!3)))
                      (a!13 (ite (PagedBetree.Step.InternalGrowStep_q this@@246)
                                 true
                                 (ite (PagedBetree.Step.InternalSplitStep_q
                                        this@@246)
                                      (PagedBetree.Path.Valid
                                        ($LS $LZ)
                                        (PagedBetree.Step.path this@@246))
                                      a!12))))
                (let ((a!5 (and (=> (PagedBetree.Step.InternalFlushStep_q
                                      this@@246)
                                    (|PagedBetree.Path.Valid#canCall|
                                      (PagedBetree.Step.path this@@246)))
                                a!4))
                      (a!14 (ite (PagedBetree.Step.PutStep_q this@@246)
                                 true
                                 (ite (PagedBetree.Step.QueryEndLsnStep_q
                                        this@@246)
                                      true
                                      (ite (PagedBetree.Step.FreezeAsStep_q
                                             this@@246)
                                           true
                                           a!13)))))
                (let ((a!6 (=> (not (PagedBetree.Step.InternalSplitStep_q
                                      this@@246))
                               (=> (not (PagedBetree.Step.InternalFlushMemtableStep_q
                                          this@@246))
                                   a!5))))
                (let ((a!7 (and (=> (PagedBetree.Step.InternalSplitStep_q
                                      this@@246)
                                    (|PagedBetree.Path.Valid#canCall|
                                      (PagedBetree.Step.path this@@246)))
                                a!6)))
                (let ((a!8 (=> (not (PagedBetree.Step.FreezeAsStep_q this@@246))
                               (=> (not (PagedBetree.Step.InternalGrowStep_q
                                          this@@246))
                                   a!7))))
                (let ((a!9 (=> (not (PagedBetree.Step.PutStep_q this@@246))
                               (=> (not (PagedBetree.Step.QueryEndLsnStep_q
                                          this@@246))
                                   a!8))))
                (let ((a!15 (and (=> (not (PagedBetree.Step.QueryStep_q
                                            this@@246))
                                     a!9)
                                 (= (PagedBetree.Step.WF this@@246)
                                    (ite (PagedBetree.Step.QueryStep_q
                                           this@@246)
                                         true
                                         a!14)))))
                  (=> (and (= (type this@@246) DatatypeTypeType)
                           (or (|PagedBetree.Step.WF#canCall| this@@246)
                               ($Is this@@246 Tclass.PagedBetree.Step)))
                      a!15)))))))))))
                :pattern ((PagedBetree.Step.WF this@@246))
                :skolemid |3410|
                :qid |PagedBetreeidfy.434:15|))))
  (=> true a!1)))
(assert (=> true
    (forall ((this@@247 T@U))
      (! (let ((a!1 (and (= (type this@@247) DatatypeTypeType)
                         (or (|PagedBetree.Step.WF#canCall| (Lit this@@247))
                             ($Is this@@247 Tclass.PagedBetree.Step))))
               (a!2 (Lit (bool_2_U (PagedBetree.Step.QueryStep_q
                                     (Lit this@@247)))))
               (a!3 (Lit (bool_2_U (PagedBetree.Step.PutStep_q (Lit this@@247)))))
               (a!4 (Lit (bool_2_U (PagedBetree.Step.QueryEndLsnStep_q
                                     (Lit this@@247)))))
               (a!5 (Lit (bool_2_U (PagedBetree.Step.FreezeAsStep_q
                                     (Lit this@@247)))))
               (a!6 (Lit (bool_2_U (PagedBetree.Step.InternalGrowStep_q
                                     (Lit this@@247)))))
               (a!7 (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q
                                     (Lit this@@247)))))
               (a!8 (|PagedBetree.Path.Valid#canCall|
                      (Lit (PagedBetree.Step.path (Lit this@@247)))))
               (a!9 (Lit (bool_2_U (PagedBetree.Step.InternalFlushMemtableStep_q
                                     (Lit this@@247)))))
               (a!10 (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q
                                      (Lit this@@247)))))
               (a!11 (PagedBetree.Path.Valid
                       ($LS $LZ)
                       (Lit (PagedBetree.Step.path (Lit this@@247)))))
               (a!12 (|PagedBetree.Path.Target#canCall|
                       (Lit (PagedBetree.Step.path (Lit this@@247)))))
               (a!13 (PagedBetree.Path.Target
                       ($LS $LZ)
                       (Lit (PagedBetree.Step.path (Lit this@@247))))))
         (let ((a!14 (|Buffers.BufferStack.Equivalent#canCall|
                       (PagedBetree.BetreeNode.buffers a!13)
                       (Lit (PagedBetree.Step.compactedBuffers (Lit this@@247)))))
               (a!21 (Buffers.BufferStack.Equivalent
                       (Lit (PagedBetree.BetreeNode.buffers (Lit a!13)))
                       (Lit (PagedBetree.Step.compactedBuffers (Lit this@@247))))))
         (let ((a!15 (=> a!11
                         (and a!12
                              (=> (PagedBetree.BetreeNode.BetreeNode_q a!13)
                                  (and a!12 a!14)))))
               (a!22 (bool_2_U (and a!11
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      (Lit a!13))
                                    a!21))))
         (let ((a!16 (and (=> (U_2_bool a!10) a!8)
                          (=> (not (U_2_bool a!10)) (and a!8 a!15))))
               (a!23 (ite (PagedBetree.Step.InternalFlushStep_q (Lit this@@247))
                          (U_2_bool (Lit (bool_2_U a!11)))
                          (U_2_bool (Lit a!22)))))
         (let ((a!17 (=> (not (U_2_bool a!7)) (=> (not (U_2_bool a!9)) a!16)))
               (a!24 (ite (PagedBetree.Step.InternalSplitStep_q (Lit this@@247))
                          (U_2_bool (Lit (bool_2_U a!11)))
                          (ite (PagedBetree.Step.InternalFlushMemtableStep_q
                                 (Lit this@@247))
                               true
                               a!23))))
         (let ((a!18 (=> (not (U_2_bool a!6))
                         (and (=> (U_2_bool a!7) a!8) a!17)))
               (a!25 (ite (PagedBetree.Step.FreezeAsStep_q (Lit this@@247))
                          true
                          (ite (PagedBetree.Step.InternalGrowStep_q
                                 (Lit this@@247))
                               true
                               a!24))))
         (let ((a!19 (=> (not (U_2_bool a!4)) (=> (not (U_2_bool a!5)) a!18)))
               (a!26 (ite (PagedBetree.Step.PutStep_q (Lit this@@247))
                          true
                          (ite (PagedBetree.Step.QueryEndLsnStep_q
                                 (Lit this@@247))
                               true
                               a!25))))
         (let ((a!20 (=> (not (U_2_bool a!2)) (=> (not (U_2_bool a!3)) a!19)))
               (a!27 (= (PagedBetree.Step.WF (Lit this@@247))
                        (ite (PagedBetree.Step.QueryStep_q (Lit this@@247))
                             true
                             a!26))))
           (=> a!1 (and a!20 a!27))))))))))
         :pattern ((PagedBetree.Step.WF (Lit this@@247)))
         :weight 3
         :skolemid |3411|
         :qid |PagedBetreeidfy.434:15|))))
(assert (= (type Tclass.PagedBetree.__default) TyType))
(assert (= (Tag Tclass.PagedBetree.__default) Tagclass.PagedBetree.__default))
(assert (= (TagFamily Tclass.PagedBetree.__default) tytagFamily$_default))
(assert (forall ((bx@@163 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@163)) bx@@163)
                     ($Is ($Unbox refType bx@@163) Tclass.PagedBetree.__default))))
       (=> (and (= (type bx@@163) BoxType)
                ($IsBox bx@@163 Tclass.PagedBetree.__default))
           a!1))
     :pattern (($IsBox bx@@163 Tclass.PagedBetree.__default))
     :skolemid |3412|
     :qid |unknown.0:0|)))
(assert (forall (($o@@51 T@U))
  (! (let ((a!1 (= ($Is $o@@51 Tclass.PagedBetree.__default)
                   (or (= $o@@51 null)
                       (= (dtype $o@@51) Tclass.PagedBetree.__default)))))
       (=> (= (type $o@@51) refType) a!1))
     :pattern (($Is $o@@51 Tclass.PagedBetree.__default))
     :skolemid |3413|
     :qid |unknown.0:0|)))
(assert (forall (($o@@52 T@U) ($h@@158 T@U))
  (! (let ((a!1 (or (= $o@@52 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@158 $o@@52)
                                              alloc)))))
       (=> (and (= (type $o@@52) refType)
                (= (type $h@@158) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@52 Tclass.PagedBetree.__default $h@@158) a!1)))
     :pattern (($IsAlloc $o@@52 Tclass.PagedBetree.__default $h@@158))
     :skolemid |3414|
     :qid |unknown.0:0|)))
(assert (= (type PagedBetree.__default.EmptyImage) DatatypeTypeType))
(assert (=> true
    (=> true
        ($Is PagedBetree.__default.EmptyImage
             (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)))))
(assert (= |PagedBetree.__default.EmptyImage#requires| true))
(assert (let ((a!1 (Lit (|#StampedMod.Stamped.Stamped|
                  ($Box (Lit |#PagedBetree.BetreeNode.Nil|))
                  (LitInt 0)))))
  (=> true (=> true (= PagedBetree.__default.EmptyImage a!1)))))
(assert (let ((a!1 (Lit (|#StampedMod.Stamped.Stamped|
                  ($Box (Lit |#PagedBetree.BetreeNode.Nil|))
                  (LitInt 0)))))
  (=> true (=> true (= PagedBetree.__default.EmptyImage a!1)))))
(assert (forall ((arg0@@597 T@U))
  (! (= (type (PagedBetree.__default.ConstantChildMap arg0@@597))
        DatatypeTypeType)
     :pattern ((PagedBetree.__default.ConstantChildMap arg0@@597))
     :qid |funType:PagedBetree.__default.ConstantChildMap|)))
(assert (let ((a!1 (forall ((|target#0| T@U))
             (! (let ((a!1 (or (|PagedBetree.__default.ConstantChildMap#canCall|
                                 |target#0|)
                               (and ($Is |target#0|
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |target#0|)))))
                  (=> (and (= (type |target#0|) DatatypeTypeType) a!1)
                      (and (PagedBetree.ChildMap.WF
                             ($LS $LZ)
                             (PagedBetree.__default.ConstantChildMap |target#0|))
                           ($Is (PagedBetree.__default.ConstantChildMap
                                  |target#0|)
                                Tclass.PagedBetree.ChildMap))))
                :pattern ((PagedBetree.__default.ConstantChildMap |target#0|))
                :skolemid |3415|
                :qid |PagedBetreeidfy.55:29|))))
  (=> true a!1)))
(assert (forall ((|target#0@@0| T@U))
  (! (=> (and (= (type |target#0@@0|) DatatypeTypeType)
              ($Is |target#0@@0| Tclass.PagedBetree.BetreeNode))
         (= (|PagedBetree.__default.ConstantChildMap#requires| |target#0@@0|)
            (PagedBetree.BetreeNode.WF ($LS $LZ) |target#0@@0|)))
     :pattern ((|PagedBetree.__default.ConstantChildMap#requires| |target#0@@0|))
     :skolemid |3416|
     :qid |PagedBetreeidfy.55:29|)))
(assert (let ((a!1 (forall ((|target#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetree.__default.ConstantChildMap#canCall|
                                 |target#0@@1|)
                               (and ($Is |target#0@@1|
                                         Tclass.PagedBetree.BetreeNode)
                                    (PagedBetree.BetreeNode.WF
                                      ($LS $LZ)
                                      |target#0@@1|))))
                      (a!2 (forall ((|key#0@@73| T@U))
                             (! (=> (and (= (type |key#0@@73|)
                                            (SeqType BoxType))
                                         ($Is |key#0@@73| Tclass.KeyType.Key))
                                    (|Buffers.__default.AnyKey#canCall|
                                      |key#0@@73|))
                                :pattern ((Buffers.__default.AnyKey |key#0@@73|))
                                :skolemid |3417|
                                :qid |PagedBetreeidfy.59:22|)))
                      (a!3 (|#PagedBetree.ChildMap.ChildMap|
                             (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                          (|lambda#101| ($Box |target#0@@1|))
                                          (TIMap Tclass.KeyType.Key
                                                 Tclass.PagedBetree.BetreeNode)))))
                  (=> (and (= (type |target#0@@1|) DatatypeTypeType) a!1)
                      (and a!2
                           (= (PagedBetree.__default.ConstantChildMap
                                |target#0@@1|)
                              a!3))))
                :pattern ((PagedBetree.__default.ConstantChildMap |target#0@@1|))
                :skolemid |3418|
                :qid |PagedBetreeidfy.55:29|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|target#0@@2| T@U))
      (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                     ($LS $LZ)
                                     (Lit |target#0@@2|)))))
               (a!3 (forall ((|key#0@@74| T@U))
                      (! (=> (and (= (type |key#0@@74|) (SeqType BoxType))
                                  ($Is |key#0@@74| Tclass.KeyType.Key))
                             (|Buffers.__default.AnyKey#canCall| |key#0@@74|))
                         :pattern ((Buffers.__default.AnyKey |key#0@@74|))
                         :skolemid |3419|
                         :qid |PagedBetreeidfy.59:22|)))
               (a!4 (|IMap#Glue| (|lambda#242| Tclass.KeyType.Key)
                                 (|lambda#101| ($Box (Lit |target#0@@2|)))
                                 (TIMap Tclass.KeyType.Key
                                        Tclass.PagedBetree.BetreeNode))))
         (let ((a!2 (and (= (type |target#0@@2|) DatatypeTypeType)
                         (or (|PagedBetree.__default.ConstantChildMap#canCall|
                               (Lit |target#0@@2|))
                             (and ($Is |target#0@@2|
                                       Tclass.PagedBetree.BetreeNode)
                                  (U_2_bool a!1)))))
               (a!5 (and a!3
                         (= (PagedBetree.__default.ConstantChildMap
                              (Lit |target#0@@2|))
                            (|#PagedBetree.ChildMap.ChildMap| a!4)))))
           (=> a!2 a!5)))
         :pattern ((PagedBetree.__default.ConstantChildMap (Lit |target#0@@2|)))
         :weight 3
         :skolemid |3420|
         :qid |PagedBetreeidfy.55:29|))))
(assert (= (type PagedBetree.__default.EmptyChildMap) DatatypeTypeType))
(assert (=> true
    (=> true
        ($Is PagedBetree.__default.EmptyChildMap Tclass.PagedBetree.ChildMap))))
(assert (= |PagedBetree.__default.EmptyChildMap#requires| true))
(assert (let ((a!1 (= PagedBetree.__default.EmptyChildMap
              (Lit (PagedBetree.__default.ConstantChildMap
                     (Lit |#PagedBetree.BetreeNode.Nil|))))))
(let ((a!2 (=> true
               (and (|PagedBetree.__default.ConstantChildMap#canCall|
                      (Lit |#PagedBetree.BetreeNode.Nil|))
                    a!1))))
  (=> true a!2))))
(assert (let ((a!1 (=> true
               (and (PagedBetree.BetreeNode.WF
                      ($LS $LZ)
                      PagedBetree.__default.EmptyRoot)
                    ($Is PagedBetree.__default.EmptyRoot
                         Tclass.PagedBetree.BetreeNode)))))
  (=> true a!1)))
(assert (= |PagedBetree.__default.EmptyRoot#requires| true))
(assert (let ((a!1 (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType))))))
(let ((a!2 (|#PagedBetree.BetreeNode.BetreeNode|
             a!1
             (Lit (PagedBetree.__default.ConstantChildMap
                    (Lit |#PagedBetree.BetreeNode.Nil|))))))
(let ((a!3 (=> true
               (and (|PagedBetree.__default.ConstantChildMap#canCall|
                      (Lit |#PagedBetree.BetreeNode.Nil|))
                    (= PagedBetree.__default.EmptyRoot (Lit a!2))))))
  (=> true a!3)))))
(assert (=> true
    (forall ((|v#0@@40| T@U) (|v'#0| T@U) (|lbl#0@@3| T@U) (|receipt#0@@4| T@U))
      (! (let ((a!1 (and (= (type |v#0@@40|) DatatypeTypeType)
                         (= (type |v'#0|) DatatypeTypeType)
                         (= (type |lbl#0@@3|) DatatypeTypeType)
                         (= (type |receipt#0@@4|) DatatypeTypeType)
                         (or (|PagedBetree.__default.Query#canCall|
                               |v#0@@40|
                               |v'#0|
                               |lbl#0@@3|
                               |receipt#0@@4|)
                             (and ($Is |v#0@@40| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@3|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |receipt#0@@4|
                                       Tclass.PagedBetree.QueryReceipt))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.Query
                     |v#0@@40|
                     |v'#0|
                     |lbl#0@@3|
                     |receipt#0@@4|))
         :skolemid |3421|
         :qid |PagedBetreeidfy.253:19|))))
(assert (forall ((|v#0@@41| T@U) (|v'#0@@0| T@U) (|lbl#0@@4| T@U) (|receipt#0@@5| T@U))
  (! (=> (and (= (type |v#0@@41|) DatatypeTypeType)
              (= (type |v'#0@@0|) DatatypeTypeType)
              (= (type |lbl#0@@4|) DatatypeTypeType)
              (= (type |receipt#0@@5|) DatatypeTypeType)
              ($Is |v#0@@41| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@0| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@4| Tclass.PagedBetree.TransitionLabel)
              ($Is |receipt#0@@5| Tclass.PagedBetree.QueryReceipt))
         (= (|PagedBetree.__default.Query#requires|
              |v#0@@41|
              |v'#0@@0|
              |lbl#0@@4|
              |receipt#0@@5|)
            true))
     :pattern ((|PagedBetree.__default.Query#requires|
                 |v#0@@41|
                 |v'#0@@0|
                 |lbl#0@@4|
                 |receipt#0@@5|))
     :skolemid |3422|
     :qid |PagedBetreeidfy.253:19|)))
(assert (let ((a!1 (forall ((|v#0@@42| T@U)
                    (|v'#0@@1| T@U)
                    (|lbl#0@@5| T@U)
                    (|receipt#0@@6| T@U))
             (! (let ((a!1 (and (= (type |v#0@@42|) DatatypeTypeType)
                                (= (type |v'#0@@1|) DatatypeTypeType)
                                (= (type |lbl#0@@5|) DatatypeTypeType)
                                (= (type |receipt#0@@6|) DatatypeTypeType)
                                (or (|PagedBetree.__default.Query#canCall|
                                      |v#0@@42|
                                      |v'#0@@1|
                                      |lbl#0@@5|
                                      |receipt#0@@6|)
                                    (and ($Is |v#0@@42|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@1|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@5|
                                              Tclass.PagedBetree.TransitionLabel)
                                         ($Is |receipt#0@@6|
                                              Tclass.PagedBetree.QueryReceipt)))))
                      (a!2 (|$IsA#ValueMessage.Message|
                             (ValueMessage.__default.Merge
                               (MemtableMod.Memtable.Query
                                 (PagedBetree.Variables.memtable |v#0@@42|)
                                 (PagedBetree.TransitionLabel.key |lbl#0@@5|))
                               (PagedBetree.QueryReceipt.Result |receipt#0@@6|))))
                      (a!3 (|ValueMessage.Message#Equal|
                             (|#ValueMessage.Message.Define|
                               (PagedBetree.TransitionLabel.value |lbl#0@@5|))
                             (ValueMessage.__default.Merge
                               (MemtableMod.Memtable.Query
                                 (PagedBetree.Variables.memtable |v#0@@42|)
                                 (PagedBetree.TransitionLabel.key |lbl#0@@5|))
                               (PagedBetree.QueryReceipt.Result |receipt#0@@6|)))))
                (let ((a!4 (and a!2
                                (PagedBetree.Variables.Variables_q |v#0@@42|)
                                (|MemtableMod.Memtable.Query#canCall|
                                  (PagedBetree.Variables.memtable |v#0@@42|)
                                  (PagedBetree.TransitionLabel.key |lbl#0@@5|))
                                (|PagedBetree.QueryReceipt.Result#canCall|
                                  |receipt#0@@6|)
                                (|ValueMessage.__default.Merge#canCall|
                                  (MemtableMod.Memtable.Query
                                    (PagedBetree.Variables.memtable |v#0@@42|)
                                    (PagedBetree.TransitionLabel.key |lbl#0@@5|))
                                  (PagedBetree.QueryReceipt.Result
                                    |receipt#0@@6|))
                                (=> a!3
                                    (and (|$IsA#PagedBetree.Variables|
                                           |v'#0@@1|)
                                         (|$IsA#PagedBetree.Variables|
                                           |v#0@@42|)))))
                      (a!8 (and (PagedBetree.TransitionLabel.QueryLabel_q
                                  |lbl#0@@5|)
                                (= (PagedBetree.TransitionLabel.endLsn
                                     |lbl#0@@5|)
                                   (MemtableMod.Memtable.seqEnd
                                     (PagedBetree.Variables.memtable |v#0@@42|)))
                                (PagedBetree.QueryReceipt.ValidFor
                                  |receipt#0@@6|
                                  (PagedBetree.Variables.root |v#0@@42|)
                                  (PagedBetree.TransitionLabel.key |lbl#0@@5|))
                                a!3
                                (|PagedBetree.Variables#Equal|
                                  |v'#0@@1|
                                  |v#0@@42|))))
                (let ((a!5 (and (PagedBetree.Variables.Variables_q |v#0@@42|)
                                (|PagedBetree.QueryReceipt.ValidFor#canCall|
                                  |receipt#0@@6|
                                  (PagedBetree.Variables.root |v#0@@42|)
                                  (PagedBetree.TransitionLabel.key |lbl#0@@5|))
                                (=> (PagedBetree.QueryReceipt.ValidFor
                                      |receipt#0@@6|
                                      (PagedBetree.Variables.root |v#0@@42|)
                                      (PagedBetree.TransitionLabel.key
                                        |lbl#0@@5|))
                                    a!4))))
                (let ((a!6 (=> (= (PagedBetree.TransitionLabel.endLsn
                                    |lbl#0@@5|)
                                  (MemtableMod.Memtable.seqEnd
                                    (PagedBetree.Variables.memtable |v#0@@42|)))
                               a!5)))
                (let ((a!7 (=> (PagedBetree.TransitionLabel.QueryLabel_q
                                 |lbl#0@@5|)
                               (and (PagedBetree.Variables.Variables_q
                                      |v#0@@42|)
                                    (MemtableMod.Memtable.Memtable_q
                                      (PagedBetree.Variables.memtable |v#0@@42|))
                                    a!6))))
                  (=> a!1
                      (and a!7
                           (= (PagedBetree.__default.Query
                                |v#0@@42|
                                |v'#0@@1|
                                |lbl#0@@5|
                                |receipt#0@@6|)
                              a!8))))))))
                :pattern ((PagedBetree.__default.Query
                            |v#0@@42|
                            |v'#0@@1|
                            |lbl#0@@5|
                            |receipt#0@@6|))
                :skolemid |3423|
                :qid |PagedBetreeidfy.253:19|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@43| T@U)
             (|v'#0@@2| T@U)
             (|lbl#0@@6| T@U)
             (|receipt#0@@7| T@U))
      (! (let ((a!1 (and (= (type |v#0@@43|) DatatypeTypeType)
                         (= (type |v'#0@@2|) DatatypeTypeType)
                         (= (type |lbl#0@@6|) DatatypeTypeType)
                         (= (type |receipt#0@@7|) DatatypeTypeType)
                         (or (|PagedBetree.__default.Query#canCall|
                               (Lit |v#0@@43|)
                               (Lit |v'#0@@2|)
                               (Lit |lbl#0@@6|)
                               (Lit |receipt#0@@7|))
                             (and ($Is |v#0@@43| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@2| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@6|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |receipt#0@@7|
                                       Tclass.PagedBetree.QueryReceipt)))))
               (a!2 (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryLabel_q
                                     (Lit |lbl#0@@6|)))))
               (a!3 (MemtableMod.Memtable.Memtable_q
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@43|)))))
               (a!4 (MemtableMod.Memtable.seqEnd
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@43|)))))
               (a!6 (|PagedBetree.QueryReceipt.ValidFor#canCall|
                      (Lit |receipt#0@@7|)
                      (Lit (PagedBetree.Variables.root (Lit |v#0@@43|)))
                      (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@6|)))))
               (a!7 (PagedBetree.QueryReceipt.ValidFor
                      (Lit |receipt#0@@7|)
                      (Lit (PagedBetree.Variables.root (Lit |v#0@@43|)))
                      (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@6|)))))
               (a!8 (MemtableMod.Memtable.Query
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@43|)))
                      (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@6|)))))
               (a!10 (|MemtableMod.Memtable.Query#canCall|
                       (Lit (PagedBetree.Variables.memtable (Lit |v#0@@43|)))
                       (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@6|)))))
               (a!12 (|#ValueMessage.Message.Define|
                       (Lit (PagedBetree.TransitionLabel.value (Lit |lbl#0@@6|))))))
         (let ((a!5 (= (LitInt (PagedBetree.TransitionLabel.endLsn
                                 (Lit |lbl#0@@6|)))
                       (LitInt a!4)))
               (a!9 (ValueMessage.__default.Merge
                      (Lit a!8)
                      (Lit (PagedBetree.QueryReceipt.Result
                             (Lit |receipt#0@@7|)))))
               (a!11 (|ValueMessage.__default.Merge#canCall|
                       (Lit a!8)
                       (Lit (PagedBetree.QueryReceipt.Result
                              (Lit |receipt#0@@7|))))))
         (let ((a!13 (=> (|ValueMessage.Message#Equal| a!12 a!9)
                         (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@2|))
                              (|$IsA#PagedBetree.Variables| (Lit |v#0@@43|)))))
               (a!17 (= (PagedBetree.__default.Query
                          (Lit |v#0@@43|)
                          (Lit |v'#0@@2|)
                          (Lit |lbl#0@@6|)
                          (Lit |receipt#0@@7|))
                        (and (PagedBetree.TransitionLabel.QueryLabel_q
                               (Lit |lbl#0@@6|))
                             a!5
                             a!7
                             (|ValueMessage.Message#Equal| a!12 a!9)
                             (|PagedBetree.Variables#Equal| |v'#0@@2| |v#0@@43|)))))
         (let ((a!14 (=> (U_2_bool (Lit (bool_2_U a!7)))
                         (and (|$IsA#ValueMessage.Message| (Lit a!9))
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@43|))
                              a!10
                              (|PagedBetree.QueryReceipt.Result#canCall|
                                (Lit |receipt#0@@7|))
                              a!11
                              a!13))))
         (let ((a!15 (=> a!5
                         (and (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@43|))
                              a!6
                              a!14))))
         (let ((a!16 (=> (U_2_bool a!2)
                         (and (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@43|))
                              a!3
                              a!15))))
           (=> a!1 (and a!16 a!17))))))))
         :pattern ((PagedBetree.__default.Query
                     (Lit |v#0@@43|)
                     (Lit |v'#0@@2|)
                     (Lit |lbl#0@@6|)
                     (Lit |receipt#0@@7|)))
         :weight 3
         :skolemid |3424|
         :qid |PagedBetreeidfy.253:19|))))
(assert (=> true
    (forall ((|v#0@@44| T@U) (|v'#0@@3| T@U) (|lbl#0@@7| T@U))
      (! (let ((a!1 (and (= (type |v#0@@44|) DatatypeTypeType)
                         (= (type |v'#0@@3|) DatatypeTypeType)
                         (= (type |lbl#0@@7|) DatatypeTypeType)
                         (or (|PagedBetree.__default.Put#canCall|
                               |v#0@@44|
                               |v'#0@@3|
                               |lbl#0@@7|)
                             (and ($Is |v#0@@44| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@3| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@7|
                                       Tclass.PagedBetree.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.Put |v#0@@44| |v'#0@@3| |lbl#0@@7|))
         :skolemid |3425|
         :qid |PagedBetreeidfy.262:17|))))
(assert (forall ((|v#0@@45| T@U) (|v'#0@@4| T@U) (|lbl#0@@8| T@U))
  (! (=> (and (= (type |v#0@@45|) DatatypeTypeType)
              (= (type |v'#0@@4|) DatatypeTypeType)
              (= (type |lbl#0@@8|) DatatypeTypeType)
              ($Is |v#0@@45| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@4| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@8| Tclass.PagedBetree.TransitionLabel))
         (= (|PagedBetree.__default.Put#requires|
              |v#0@@45|
              |v'#0@@4|
              |lbl#0@@8|)
            true))
     :pattern ((|PagedBetree.__default.Put#requires|
                 |v#0@@45|
                 |v'#0@@4|
                 |lbl#0@@8|))
     :skolemid |3426|
     :qid |PagedBetreeidfy.262:17|)))
(assert (let ((a!1 (forall ((|v#0@@46| T@U) (|v'#0@@5| T@U) (|lbl#0@@9| T@U))
             (! (let ((a!1 (and (= (type |v#0@@46|) DatatypeTypeType)
                                (= (type |v'#0@@5|) DatatypeTypeType)
                                (= (type |lbl#0@@9|) DatatypeTypeType)
                                (or (|PagedBetree.__default.Put#canCall|
                                      |v#0@@46|
                                      |v'#0@@5|
                                      |lbl#0@@9|)
                                    (and ($Is |v#0@@46|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@5|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@9|
                                              Tclass.PagedBetree.TransitionLabel)))))
                      (a!2 (|#PagedBetree.Variables.Variables|
                             (MemtableMod.Memtable.ApplyPuts
                               ($LS $LZ)
                               (PagedBetree.Variables.memtable |v#0@@46|)
                               (PagedBetree.TransitionLabel.puts |lbl#0@@9|))
                             (PagedBetree.Variables.root |v#0@@46|))))
                (let ((a!3 (=> (= (MsgHistoryMod.MsgHistory.seqStart
                                    (PagedBetree.TransitionLabel.puts
                                      |lbl#0@@9|))
                                  (MemtableMod.Memtable.seqEnd
                                    (PagedBetree.Variables.memtable |v#0@@46|)))
                               (and (|$IsA#PagedBetree.Variables| |v'#0@@5|)
                                    (|$IsA#PagedBetree.Variables| a!2)
                                    (PagedBetree.Variables.Variables_q
                                      |v#0@@46|)
                                    (|MemtableMod.Memtable.ApplyPuts#canCall|
                                      (PagedBetree.Variables.memtable |v#0@@46|)
                                      (PagedBetree.TransitionLabel.puts
                                        |lbl#0@@9|))
                                    (PagedBetree.Variables.Variables_q
                                      |v#0@@46|))))
                      (a!6 (and (PagedBetree.TransitionLabel.PutLabel_q
                                  |lbl#0@@9|)
                                (MsgHistoryMod.MsgHistory.WF
                                  (PagedBetree.TransitionLabel.puts |lbl#0@@9|))
                                (= (MsgHistoryMod.MsgHistory.seqStart
                                     (PagedBetree.TransitionLabel.puts
                                       |lbl#0@@9|))
                                   (MemtableMod.Memtable.seqEnd
                                     (PagedBetree.Variables.memtable |v#0@@46|)))
                                (|PagedBetree.Variables#Equal| |v'#0@@5| a!2))))
                (let ((a!4 (=> (MsgHistoryMod.MsgHistory.WF
                                 (PagedBetree.TransitionLabel.puts |lbl#0@@9|))
                               (and (MsgHistoryMod.MsgHistory.MsgHistory_q
                                      (PagedBetree.TransitionLabel.puts
                                        |lbl#0@@9|))
                                    (PagedBetree.Variables.Variables_q
                                      |v#0@@46|)
                                    (MemtableMod.Memtable.Memtable_q
                                      (PagedBetree.Variables.memtable |v#0@@46|))
                                    a!3))))
                (let ((a!5 (=> (PagedBetree.TransitionLabel.PutLabel_q
                                 |lbl#0@@9|)
                               (and (|MsgHistoryMod.MsgHistory.WF#canCall|
                                      (PagedBetree.TransitionLabel.puts
                                        |lbl#0@@9|))
                                    a!4))))
                  (=> a!1
                      (and a!5
                           (= (PagedBetree.__default.Put
                                |v#0@@46|
                                |v'#0@@5|
                                |lbl#0@@9|)
                              a!6)))))))
                :pattern ((PagedBetree.__default.Put
                            |v#0@@46|
                            |v'#0@@5|
                            |lbl#0@@9|))
                :skolemid |3427|
                :qid |PagedBetreeidfy.262:17|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@47| T@U) (|v'#0@@6| T@U) (|lbl#0@@10| T@U))
             (! (let ((a!1 (and (= (type |v#0@@47|) DatatypeTypeType)
                                (= (type |v'#0@@6|) DatatypeTypeType)
                                (= (type |lbl#0@@10|) DatatypeTypeType)
                                (or (|PagedBetree.__default.Put#canCall|
                                      (Lit |v#0@@47|)
                                      (Lit |v'#0@@6|)
                                      (Lit |lbl#0@@10|))
                                    (and ($Is |v#0@@47|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@6|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@10|
                                              Tclass.PagedBetree.TransitionLabel)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.TransitionLabel.PutLabel_q
                                            (Lit |lbl#0@@10|)))))
                      (a!3 (|MsgHistoryMod.MsgHistory.WF#canCall|
                             (Lit (PagedBetree.TransitionLabel.puts
                                    (Lit |lbl#0@@10|)))))
                      (a!4 (MsgHistoryMod.MsgHistory.WF
                             (Lit (PagedBetree.TransitionLabel.puts
                                    (Lit |lbl#0@@10|)))))
                      (a!5 (MsgHistoryMod.MsgHistory.MsgHistory_q
                             (Lit (PagedBetree.TransitionLabel.puts
                                    (Lit |lbl#0@@10|)))))
                      (a!6 (MemtableMod.Memtable.Memtable_q
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@47|)))))
                      (a!7 (MsgHistoryMod.MsgHistory.seqStart
                             (Lit (PagedBetree.TransitionLabel.puts
                                    (Lit |lbl#0@@10|)))))
                      (a!8 (MemtableMod.Memtable.seqEnd
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@47|)))))
                      (a!9 (MemtableMod.Memtable.ApplyPuts
                             ($LS $LZ)
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@47|)))
                             (Lit (PagedBetree.TransitionLabel.puts
                                    (Lit |lbl#0@@10|)))))
                      (a!11 (|MemtableMod.Memtable.ApplyPuts#canCall|
                              (Lit (PagedBetree.Variables.memtable
                                     (Lit |v#0@@47|)))
                              (Lit (PagedBetree.TransitionLabel.puts
                                     (Lit |lbl#0@@10|))))))
                (let ((a!10 (|#PagedBetree.Variables.Variables|
                              (Lit a!9)
                              (Lit (PagedBetree.Variables.root (Lit |v#0@@47|))))))
                (let ((a!12 (=> (= (LitInt a!7) (LitInt a!8))
                                (and (|$IsA#PagedBetree.Variables|
                                       (Lit |v'#0@@6|))
                                     (|$IsA#PagedBetree.Variables| (Lit a!10))
                                     (PagedBetree.Variables.Variables_q
                                       (Lit |v#0@@47|))
                                     a!11
                                     (PagedBetree.Variables.Variables_q
                                       (Lit |v#0@@47|)))))
                      (a!14 (= (PagedBetree.__default.Put
                                 (Lit |v#0@@47|)
                                 (Lit |v'#0@@6|)
                                 (Lit |lbl#0@@10|))
                               (and (PagedBetree.TransitionLabel.PutLabel_q
                                      (Lit |lbl#0@@10|))
                                    a!4
                                    (= (LitInt a!7) (LitInt a!8))
                                    (|PagedBetree.Variables#Equal|
                                      |v'#0@@6|
                                      (Lit a!10))))))
                (let ((a!13 (=> (U_2_bool (Lit (bool_2_U a!4)))
                                (and a!5
                                     (PagedBetree.Variables.Variables_q
                                       (Lit |v#0@@47|))
                                     a!6
                                     a!12))))
                  (=> a!1 (and (=> (U_2_bool a!2) (and a!3 a!13)) a!14))))))
                :pattern ((PagedBetree.__default.Put
                            (Lit |v#0@@47|)
                            (Lit |v'#0@@6|)
                            (Lit |lbl#0@@10|)))
                :weight 3
                :skolemid |3428|
                :qid |PagedBetreeidfy.262:17|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@48| T@U) (|v'#0@@7| T@U) (|lbl#0@@11| T@U))
      (! (let ((a!1 (and (= (type |v#0@@48|) DatatypeTypeType)
                         (= (type |v'#0@@7|) DatatypeTypeType)
                         (= (type |lbl#0@@11|) DatatypeTypeType)
                         (or (|PagedBetree.__default.QueryEndLsn#canCall|
                               |v#0@@48|
                               |v'#0@@7|
                               |lbl#0@@11|)
                             (and ($Is |v#0@@48| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@7| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@11|
                                       Tclass.PagedBetree.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.QueryEndLsn
                     |v#0@@48|
                     |v'#0@@7|
                     |lbl#0@@11|))
         :skolemid |3429|
         :qid |PagedBetreeidfy.272:25|))))
(assert (forall ((|v#0@@49| T@U) (|v'#0@@8| T@U) (|lbl#0@@12| T@U))
  (! (=> (and (= (type |v#0@@49|) DatatypeTypeType)
              (= (type |v'#0@@8|) DatatypeTypeType)
              (= (type |lbl#0@@12|) DatatypeTypeType)
              ($Is |v#0@@49| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@8| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@12| Tclass.PagedBetree.TransitionLabel))
         (= (|PagedBetree.__default.QueryEndLsn#requires|
              |v#0@@49|
              |v'#0@@8|
              |lbl#0@@12|)
            true))
     :pattern ((|PagedBetree.__default.QueryEndLsn#requires|
                 |v#0@@49|
                 |v'#0@@8|
                 |lbl#0@@12|))
     :skolemid |3430|
     :qid |PagedBetreeidfy.272:25|)))
(assert (let ((a!1 (forall ((|v#0@@50| T@U) (|v'#0@@9| T@U) (|lbl#0@@13| T@U))
             (! (let ((a!1 (and (= (type |v#0@@50|) DatatypeTypeType)
                                (= (type |v'#0@@9|) DatatypeTypeType)
                                (= (type |lbl#0@@13|) DatatypeTypeType)
                                (or (|PagedBetree.__default.QueryEndLsn#canCall|
                                      |v#0@@50|
                                      |v'#0@@9|
                                      |lbl#0@@13|)
                                    (and ($Is |v#0@@50|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@9|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@13|
                                              Tclass.PagedBetree.TransitionLabel)))))
                      (a!2 (=> (= (PagedBetree.TransitionLabel.endLsn
                                    |lbl#0@@13|)
                                  (MemtableMod.Memtable.seqEnd
                                    (PagedBetree.Variables.memtable |v#0@@50|)))
                               (and (|$IsA#PagedBetree.Variables| |v'#0@@9|)
                                    (|$IsA#PagedBetree.Variables| |v#0@@50|))))
                      (a!4 (and (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                                  |lbl#0@@13|)
                                (= (PagedBetree.TransitionLabel.endLsn
                                     |lbl#0@@13|)
                                   (MemtableMod.Memtable.seqEnd
                                     (PagedBetree.Variables.memtable |v#0@@50|)))
                                (|PagedBetree.Variables#Equal|
                                  |v'#0@@9|
                                  |v#0@@50|))))
                (let ((a!3 (=> (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                                 |lbl#0@@13|)
                               (and (PagedBetree.Variables.Variables_q
                                      |v#0@@50|)
                                    (MemtableMod.Memtable.Memtable_q
                                      (PagedBetree.Variables.memtable |v#0@@50|))
                                    a!2))))
                  (=> a!1
                      (and a!3
                           (= (PagedBetree.__default.QueryEndLsn
                                |v#0@@50|
                                |v'#0@@9|
                                |lbl#0@@13|)
                              a!4)))))
                :pattern ((PagedBetree.__default.QueryEndLsn
                            |v#0@@50|
                            |v'#0@@9|
                            |lbl#0@@13|))
                :skolemid |3431|
                :qid |PagedBetreeidfy.272:25|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@51| T@U) (|v'#0@@10| T@U) (|lbl#0@@14| T@U))
      (! (let ((a!1 (and (= (type |v#0@@51|) DatatypeTypeType)
                         (= (type |v'#0@@10|) DatatypeTypeType)
                         (= (type |lbl#0@@14|) DatatypeTypeType)
                         (or (|PagedBetree.__default.QueryEndLsn#canCall|
                               (Lit |v#0@@51|)
                               (Lit |v'#0@@10|)
                               (Lit |lbl#0@@14|))
                             (and ($Is |v#0@@51| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@10| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@14|
                                       Tclass.PagedBetree.TransitionLabel)))))
               (a!2 (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                                     (Lit |lbl#0@@14|)))))
               (a!3 (MemtableMod.Memtable.Memtable_q
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@51|)))))
               (a!4 (MemtableMod.Memtable.seqEnd
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@51|))))))
         (let ((a!5 (= (LitInt (PagedBetree.TransitionLabel.endLsn
                                 (Lit |lbl#0@@14|)))
                       (LitInt a!4))))
         (let ((a!6 (=> a!5
                        (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@10|))
                             (|$IsA#PagedBetree.Variables| (Lit |v#0@@51|)))))
               (a!8 (= (PagedBetree.__default.QueryEndLsn
                         (Lit |v#0@@51|)
                         (Lit |v'#0@@10|)
                         (Lit |lbl#0@@14|))
                       (and (PagedBetree.TransitionLabel.QueryEndLsnLabel_q
                              (Lit |lbl#0@@14|))
                            a!5
                            (|PagedBetree.Variables#Equal| |v'#0@@10| |v#0@@51|)))))
         (let ((a!7 (=> (U_2_bool a!2)
                        (and (PagedBetree.Variables.Variables_q (Lit |v#0@@51|))
                             a!3
                             a!6))))
           (=> a!1 (and a!7 a!8))))))
         :pattern ((PagedBetree.__default.QueryEndLsn
                     (Lit |v#0@@51|)
                     (Lit |v'#0@@10|)
                     (Lit |lbl#0@@14|)))
         :weight 3
         :skolemid |3432|
         :qid |PagedBetreeidfy.272:25|))))
(assert (=> true
    (forall ((|v#0@@52| T@U) (|v'#0@@11| T@U) (|lbl#0@@15| T@U))
      (! (let ((a!1 (and (= (type |v#0@@52|) DatatypeTypeType)
                         (= (type |v'#0@@11|) DatatypeTypeType)
                         (= (type |lbl#0@@15|) DatatypeTypeType)
                         (or (|PagedBetree.__default.FreezeAs#canCall|
                               |v#0@@52|
                               |v'#0@@11|
                               |lbl#0@@15|)
                             (and ($Is |v#0@@52| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@11| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@15|
                                       Tclass.PagedBetree.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.FreezeAs
                     |v#0@@52|
                     |v'#0@@11|
                     |lbl#0@@15|))
         :skolemid |3433|
         :qid |PagedBetreeidfy.279:22|))))
(assert (forall ((|v#0@@53| T@U) (|v'#0@@12| T@U) (|lbl#0@@16| T@U))
  (! (=> (and (= (type |v#0@@53|) DatatypeTypeType)
              (= (type |v'#0@@12|) DatatypeTypeType)
              (= (type |lbl#0@@16|) DatatypeTypeType)
              ($Is |v#0@@53| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@12| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@16| Tclass.PagedBetree.TransitionLabel))
         (= (|PagedBetree.__default.FreezeAs#requires|
              |v#0@@53|
              |v'#0@@12|
              |lbl#0@@16|)
            true))
     :pattern ((|PagedBetree.__default.FreezeAs#requires|
                 |v#0@@53|
                 |v'#0@@12|
                 |lbl#0@@16|))
     :skolemid |3434|
     :qid |PagedBetreeidfy.279:22|)))
(assert (=> true
    (forall ((|v#0@@54| T@U) (|v'#0@@13| T@U) (|lbl#0@@17| T@U))
      (! (let ((a!1 (and (= (type |v#0@@54|) DatatypeTypeType)
                         (= (type |v'#0@@13|) DatatypeTypeType)
                         (= (type |lbl#0@@17|) DatatypeTypeType)
                         (or (|PagedBetree.__default.FreezeAs#canCall|
                               |v#0@@54|
                               |v'#0@@13|
                               |lbl#0@@17|)
                             (and ($Is |v#0@@54| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@13| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@17|
                                       Tclass.PagedBetree.TransitionLabel)))))
               (a!2 (|StampedMod.Stamped#Equal|
                      (PagedBetree.TransitionLabel.stampedBetree |lbl#0@@17|)
                      (|#StampedMod.Stamped.Stamped|
                        ($Box (PagedBetree.Variables.root |v#0@@54|))
                        (MemtableMod.Memtable.seqEnd
                          (PagedBetree.Variables.memtable |v#0@@54|))))))
         (let ((a!3 (and (|$IsA#StampedMod.Stamped|
                           (PagedBetree.TransitionLabel.stampedBetree
                             |lbl#0@@17|))
                         (PagedBetree.Variables.Variables_q |v#0@@54|)
                         (PagedBetree.Variables.Variables_q |v#0@@54|)
                         (MemtableMod.Memtable.Memtable_q
                           (PagedBetree.Variables.memtable |v#0@@54|))
                         (=> a!2
                             (and (|$IsA#PagedBetree.Variables| |v'#0@@13|)
                                  (|$IsA#PagedBetree.Variables| |v#0@@54|)))))
               (a!6 (= (PagedBetree.__default.FreezeAs
                         |v#0@@54|
                         |v'#0@@13|
                         |lbl#0@@17|)
                       (and (PagedBetree.TransitionLabel.FreezeAsLabel_q
                              |lbl#0@@17|)
                            (PagedBetree.Variables.WF |v#0@@54|)
                            (MemtableMod.Memtable.IsEmpty
                              (PagedBetree.Variables.memtable |v#0@@54|))
                            a!2
                            (|PagedBetree.Variables#Equal| |v'#0@@13| |v#0@@54|)))))
         (let ((a!4 (and (PagedBetree.Variables.Variables_q |v#0@@54|)
                         (|MemtableMod.Memtable.IsEmpty#canCall|
                           (PagedBetree.Variables.memtable |v#0@@54|))
                         (=> (MemtableMod.Memtable.IsEmpty
                               (PagedBetree.Variables.memtable |v#0@@54|))
                             a!3))))
         (let ((a!5 (=> (PagedBetree.TransitionLabel.FreezeAsLabel_q
                          |lbl#0@@17|)
                        (and (|PagedBetree.Variables.WF#canCall| |v#0@@54|)
                             (=> (PagedBetree.Variables.WF |v#0@@54|) a!4)))))
           (=> a!1 (and a!5 a!6))))))
         :pattern ((PagedBetree.__default.FreezeAs
                     |v#0@@54|
                     |v'#0@@13|
                     |lbl#0@@17|))
         :skolemid |3435|
         :qid |PagedBetreeidfy.279:22|))))
(assert (=> true
    (forall ((|v#0@@55| T@U) (|v'#0@@14| T@U) (|lbl#0@@18| T@U))
      (! (let ((a!1 (and (= (type |v#0@@55|) DatatypeTypeType)
                         (= (type |v'#0@@14|) DatatypeTypeType)
                         (= (type |lbl#0@@18|) DatatypeTypeType)
                         (or (|PagedBetree.__default.FreezeAs#canCall|
                               (Lit |v#0@@55|)
                               (Lit |v'#0@@14|)
                               (Lit |lbl#0@@18|))
                             (and ($Is |v#0@@55| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@14| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@18|
                                       Tclass.PagedBetree.TransitionLabel)))))
               (a!2 (Lit (bool_2_U (PagedBetree.TransitionLabel.FreezeAsLabel_q
                                     (Lit |lbl#0@@18|)))))
               (a!3 (Lit (bool_2_U (PagedBetree.Variables.WF (Lit |v#0@@55|)))))
               (a!4 (|MemtableMod.Memtable.IsEmpty#canCall|
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@55|)))))
               (a!5 (MemtableMod.Memtable.IsEmpty
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@55|)))))
               (a!6 (|$IsA#StampedMod.Stamped|
                      (Lit (PagedBetree.TransitionLabel.stampedBetree
                             (Lit |lbl#0@@18|)))))
               (a!7 (MemtableMod.Memtable.Memtable_q
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@55|)))))
               (a!8 ($Box (Lit (PagedBetree.Variables.root (Lit |v#0@@55|)))))
               (a!9 (MemtableMod.Memtable.seqEnd
                      (Lit (PagedBetree.Variables.memtable (Lit |v#0@@55|))))))
         (let ((a!10 (=> (|StampedMod.Stamped#Equal|
                           (PagedBetree.TransitionLabel.stampedBetree
                             (Lit |lbl#0@@18|))
                           (|#StampedMod.Stamped.Stamped| a!8 (LitInt a!9)))
                         (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@14|))
                              (|$IsA#PagedBetree.Variables| (Lit |v#0@@55|)))))
               (a!14 (and (PagedBetree.TransitionLabel.FreezeAsLabel_q
                            (Lit |lbl#0@@18|))
                          (PagedBetree.Variables.WF (Lit |v#0@@55|))
                          a!5
                          (|StampedMod.Stamped#Equal|
                            (PagedBetree.TransitionLabel.stampedBetree
                              (Lit |lbl#0@@18|))
                            (|#StampedMod.Stamped.Stamped| a!8 (LitInt a!9)))
                          (|PagedBetree.Variables#Equal| |v'#0@@14| |v#0@@55|))))
         (let ((a!11 (=> (U_2_bool (Lit (bool_2_U a!5)))
                         (and a!6
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@55|))
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@55|))
                              a!7
                              a!10))))
         (let ((a!12 (=> (U_2_bool a!3)
                         (and (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@55|))
                              a!4
                              a!11))))
         (let ((a!13 (=> (U_2_bool a!2)
                         (and (|PagedBetree.Variables.WF#canCall|
                                (Lit |v#0@@55|))
                              a!12))))
         (let ((a!15 (and a!13
                          (= (PagedBetree.__default.FreezeAs
                               (Lit |v#0@@55|)
                               (Lit |v'#0@@14|)
                               (Lit |lbl#0@@18|))
                             a!14))))
           (=> a!1 a!15)))))))
         :pattern ((PagedBetree.__default.FreezeAs
                     (Lit |v#0@@55|)
                     (Lit |v'#0@@14|)
                     (Lit |lbl#0@@18|)))
         :weight 3
         :skolemid |3436|
         :qid |PagedBetreeidfy.279:22|))))
(assert (=> true
    (forall ((|v#0@@56| T@U) (|v'#0@@15| T@U) (|lbl#0@@19| T@U))
      (! (let ((a!1 (and (= (type |v#0@@56|) DatatypeTypeType)
                         (= (type |v'#0@@15|) DatatypeTypeType)
                         (= (type |lbl#0@@19|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalFlushMemtable#canCall|
                               |v#0@@56|
                               |v'#0@@15|
                               |lbl#0@@19|)
                             (and ($Is |v#0@@56| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@15| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@19|
                                       Tclass.PagedBetree.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.InternalFlushMemtable
                     |v#0@@56|
                     |v'#0@@15|
                     |lbl#0@@19|))
         :skolemid |3437|
         :qid |PagedBetreeidfy.289:35|))))
(assert (forall ((|v#0@@57| T@U) (|v'#0@@16| T@U) (|lbl#0@@20| T@U))
  (! (=> (and (= (type |v#0@@57|) DatatypeTypeType)
              (= (type |v'#0@@16|) DatatypeTypeType)
              (= (type |lbl#0@@20|) DatatypeTypeType)
              ($Is |v#0@@57| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@16| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@20| Tclass.PagedBetree.TransitionLabel))
         (= (|PagedBetree.__default.InternalFlushMemtable#requires|
              |v#0@@57|
              |v'#0@@16|
              |lbl#0@@20|)
            true))
     :pattern ((|PagedBetree.__default.InternalFlushMemtable#requires|
                 |v#0@@57|
                 |v'#0@@16|
                 |lbl#0@@20|))
     :skolemid |3438|
     :qid |PagedBetreeidfy.289:35|)))
(assert (=> true
    (forall ((|v#0@@58| T@U) (|v'#0@@17| T@U) (|lbl#0@@21| T@U))
      (! (let ((a!1 (and (= (type |v#0@@58|) DatatypeTypeType)
                         (= (type |v'#0@@17|) DatatypeTypeType)
                         (= (type |lbl#0@@21|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalFlushMemtable#canCall|
                               |v#0@@58|
                               |v'#0@@17|
                               |lbl#0@@21|)
                             (and ($Is |v#0@@58| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@17| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@21|
                                       Tclass.PagedBetree.TransitionLabel)))))
               (a!2 ($Unbox DatatypeTypeType
                            (StampedMod.Stamped.value
                              (PagedBetree.BetreeNode.PushMemtable
                                (PagedBetree.Variables.root |v#0@@58|)
                                (PagedBetree.Variables.memtable |v#0@@58|))))))
         (let ((a!3 (|$IsA#PagedBetree.Variables|
                      (|#PagedBetree.Variables.Variables|
                        (MemtableMod.Memtable.Drain
                          (PagedBetree.Variables.memtable |v#0@@58|))
                        a!2)))
               (a!7 (|PagedBetree.Variables#Equal|
                      |v'#0@@17|
                      (|#PagedBetree.Variables.Variables|
                        (MemtableMod.Memtable.Drain
                          (PagedBetree.Variables.memtable |v#0@@58|))
                        a!2))))
         (let ((a!4 (and (|$IsA#PagedBetree.Variables| |v'#0@@17|)
                         a!3
                         (PagedBetree.Variables.Variables_q |v#0@@58|)
                         (PagedBetree.Variables.Variables_q |v#0@@58|)
                         (|PagedBetree.BetreeNode.PushMemtable#canCall|
                           (PagedBetree.Variables.root |v#0@@58|)
                           (PagedBetree.Variables.memtable |v#0@@58|))
                         (StampedMod.Stamped.Stamped_q
                           (PagedBetree.BetreeNode.PushMemtable
                             (PagedBetree.Variables.root |v#0@@58|)
                             (PagedBetree.Variables.memtable |v#0@@58|)))
                         (PagedBetree.Variables.Variables_q |v#0@@58|)
                         (|MemtableMod.Memtable.Drain#canCall|
                           (PagedBetree.Variables.memtable |v#0@@58|)))))
         (let ((a!5 (=> (U_2_bool (Lit (bool_2_U true))) a!4)))
         (let ((a!6 (=> (PagedBetree.TransitionLabel.InternalLabel_q
                          |lbl#0@@21|)
                        (and (PagedBetree.Variables.Variables_q |v#0@@58|)
                             (MemtableMod.Memtable.Memtable_q
                               (PagedBetree.Variables.memtable |v#0@@58|))
                             a!5))))
         (let ((a!8 (and (|PagedBetree.Variables.WF#canCall| |v#0@@58|)
                         (=> (PagedBetree.Variables.WF |v#0@@58|) a!6)
                         (= (PagedBetree.__default.InternalFlushMemtable
                              |v#0@@58|
                              |v'#0@@17|
                              |lbl#0@@21|)
                            (and (PagedBetree.Variables.WF |v#0@@58|)
                                 (PagedBetree.TransitionLabel.InternalLabel_q
                                   |lbl#0@@21|)
                                 true
                                 a!7)))))
           (=> a!1 a!8)))))))
         :pattern ((PagedBetree.__default.InternalFlushMemtable
                     |v#0@@58|
                     |v'#0@@17|
                     |lbl#0@@21|))
         :skolemid |3439|
         :qid |PagedBetreeidfy.289:35|))))
(assert (let ((a!1 (forall ((|v#0@@59| T@U) (|v'#0@@18| T@U) (|lbl#0@@22| T@U))
             (! (let ((a!1 (and (= (type |v#0@@59|) DatatypeTypeType)
                                (= (type |v'#0@@18|) DatatypeTypeType)
                                (= (type |lbl#0@@22|) DatatypeTypeType)
                                (or (|PagedBetree.__default.InternalFlushMemtable#canCall|
                                      (Lit |v#0@@59|)
                                      (Lit |v'#0@@18|)
                                      (Lit |lbl#0@@22|))
                                    (and ($Is |v#0@@59|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@18|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@22|
                                              Tclass.PagedBetree.TransitionLabel)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.Variables.WF
                                            (Lit |v#0@@59|)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q
                                            (Lit |lbl#0@@22|)))))
                      (a!4 (MemtableMod.Memtable.Memtable_q
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@59|)))))
                      (a!5 (MemtableMod.Memtable.Drain
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@59|)))))
                      (a!6 (PagedBetree.BetreeNode.PushMemtable
                             (Lit (PagedBetree.Variables.root (Lit |v#0@@59|)))
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@59|)))))
                      (a!9 (|PagedBetree.BetreeNode.PushMemtable#canCall|
                             (Lit (PagedBetree.Variables.root (Lit |v#0@@59|)))
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@59|)))))
                      (a!10 (|MemtableMod.Memtable.Drain#canCall|
                              (Lit (PagedBetree.Variables.memtable
                                     (Lit |v#0@@59|))))))
                (let ((a!7 (Lit ($Unbox DatatypeTypeType
                                        (StampedMod.Stamped.value (Lit a!6))))))
                (let ((a!8 (|$IsA#PagedBetree.Variables|
                             (Lit (|#PagedBetree.Variables.Variables|
                                    (Lit a!5)
                                    a!7))))
                      (a!13 (|PagedBetree.Variables#Equal|
                              |v'#0@@18|
                              (Lit (|#PagedBetree.Variables.Variables|
                                     (Lit a!5)
                                     a!7)))))
                (let ((a!11 (=> (U_2_bool (Lit (bool_2_U true)))
                                (and (|$IsA#PagedBetree.Variables|
                                       (Lit |v'#0@@18|))
                                     a!8
                                     (PagedBetree.Variables.Variables_q
                                       (Lit |v#0@@59|))
                                     (PagedBetree.Variables.Variables_q
                                       (Lit |v#0@@59|))
                                     a!9
                                     (StampedMod.Stamped.Stamped_q (Lit a!6))
                                     (PagedBetree.Variables.Variables_q
                                       (Lit |v#0@@59|))
                                     a!10)))
                      (a!14 (= (PagedBetree.__default.InternalFlushMemtable
                                 (Lit |v#0@@59|)
                                 (Lit |v'#0@@18|)
                                 (Lit |lbl#0@@22|))
                               (and (PagedBetree.Variables.WF (Lit |v#0@@59|))
                                    (PagedBetree.TransitionLabel.InternalLabel_q
                                      (Lit |lbl#0@@22|))
                                    true
                                    a!13))))
                (let ((a!12 (=> (U_2_bool a!3)
                                (and (PagedBetree.Variables.Variables_q
                                       (Lit |v#0@@59|))
                                     a!4
                                     a!11))))
                  (=> a!1
                      (and (|PagedBetree.Variables.WF#canCall| (Lit |v#0@@59|))
                           (=> (U_2_bool a!2) a!12)
                           a!14)))))))
                :pattern ((PagedBetree.__default.InternalFlushMemtable
                            (Lit |v#0@@59|)
                            (Lit |v'#0@@18|)
                            (Lit |lbl#0@@22|)))
                :weight 3
                :skolemid |3440|
                :qid |PagedBetreeidfy.289:35|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@60| T@U) (|v'#0@@19| T@U) (|lbl#0@@23| T@U))
      (! (let ((a!1 (and (= (type |v#0@@60|) DatatypeTypeType)
                         (= (type |v'#0@@19|) DatatypeTypeType)
                         (= (type |lbl#0@@23|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalGrow#canCall|
                               |v#0@@60|
                               |v'#0@@19|
                               |lbl#0@@23|)
                             (and ($Is |v#0@@60| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@19| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@23|
                                       Tclass.PagedBetree.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.InternalGrow
                     |v#0@@60|
                     |v'#0@@19|
                     |lbl#0@@23|))
         :skolemid |3441|
         :qid |PagedBetreeidfy.366:26|))))
(assert (forall ((|v#0@@61| T@U) (|v'#0@@20| T@U) (|lbl#0@@24| T@U))
  (! (=> (and (= (type |v#0@@61|) DatatypeTypeType)
              (= (type |v'#0@@20|) DatatypeTypeType)
              (= (type |lbl#0@@24|) DatatypeTypeType)
              ($Is |v#0@@61| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@20| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@24| Tclass.PagedBetree.TransitionLabel))
         (= (|PagedBetree.__default.InternalGrow#requires|
              |v#0@@61|
              |v'#0@@20|
              |lbl#0@@24|)
            true))
     :pattern ((|PagedBetree.__default.InternalGrow#requires|
                 |v#0@@61|
                 |v'#0@@20|
                 |lbl#0@@24|))
     :skolemid |3442|
     :qid |PagedBetreeidfy.366:26|)))
(assert (=> true
    (forall ((|v#0@@62| T@U) (|v'#0@@21| T@U) (|lbl#0@@25| T@U))
      (! (let ((a!1 (and (= (type |v#0@@62|) DatatypeTypeType)
                         (= (type |v'#0@@21|) DatatypeTypeType)
                         (= (type |lbl#0@@25|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalGrow#canCall|
                               |v#0@@62|
                               |v'#0@@21|
                               |lbl#0@@25|)
                             (and ($Is |v#0@@62| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@21| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@25|
                                       Tclass.PagedBetree.TransitionLabel)))))
               (a!2 (Lit (|#Buffers.BufferStack.BufferStack|
                           (Lit (|Seq#Empty| BoxType))))))
         (let ((a!3 (|#PagedBetree.Variables.Variables|
                      (PagedBetree.Variables.memtable |v#0@@62|)
                      (|#PagedBetree.BetreeNode.BetreeNode|
                        a!2
                        (PagedBetree.__default.ConstantChildMap
                          (PagedBetree.Variables.root |v#0@@62|))))))
         (let ((a!4 (=> (PagedBetree.TransitionLabel.InternalLabel_q
                          |lbl#0@@25|)
                        (and (|$IsA#PagedBetree.Variables| |v'#0@@21|)
                             (|$IsA#PagedBetree.Variables| a!3)
                             (PagedBetree.Variables.Variables_q |v#0@@62|)
                             (|PagedBetree.__default.ConstantChildMap#canCall|
                               (PagedBetree.Variables.root |v#0@@62|))
                             (PagedBetree.Variables.Variables_q |v#0@@62|)))))
         (let ((a!5 (and (|PagedBetree.Variables.WF#canCall| |v#0@@62|)
                         (=> (PagedBetree.Variables.WF |v#0@@62|) a!4)
                         (= (PagedBetree.__default.InternalGrow
                              |v#0@@62|
                              |v'#0@@21|
                              |lbl#0@@25|)
                            (and (PagedBetree.Variables.WF |v#0@@62|)
                                 (PagedBetree.TransitionLabel.InternalLabel_q
                                   |lbl#0@@25|)
                                 (|PagedBetree.Variables#Equal| |v'#0@@21| a!3))))))
           (=> a!1 a!5)))))
         :pattern ((PagedBetree.__default.InternalGrow
                     |v#0@@62|
                     |v'#0@@21|
                     |lbl#0@@25|))
         :skolemid |3443|
         :qid |PagedBetreeidfy.366:26|))))
(assert (let ((a!1 (forall ((|v#0@@63| T@U) (|v'#0@@22| T@U) (|lbl#0@@26| T@U))
             (! (let ((a!1 (and (= (type |v#0@@63|) DatatypeTypeType)
                                (= (type |v'#0@@22|) DatatypeTypeType)
                                (= (type |lbl#0@@26|) DatatypeTypeType)
                                (or (|PagedBetree.__default.InternalGrow#canCall|
                                      (Lit |v#0@@63|)
                                      (Lit |v'#0@@22|)
                                      (Lit |lbl#0@@26|))
                                    (and ($Is |v#0@@63|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@22|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@26|
                                              Tclass.PagedBetree.TransitionLabel)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.Variables.WF
                                            (Lit |v#0@@63|)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q
                                            (Lit |lbl#0@@26|)))))
                      (a!4 (Lit (|#Buffers.BufferStack.BufferStack|
                                  (Lit (|Seq#Empty| BoxType)))))
                      (a!5 (PagedBetree.__default.ConstantChildMap
                             (Lit (PagedBetree.Variables.root (Lit |v#0@@63|)))))
                      (a!7 (|PagedBetree.__default.ConstantChildMap#canCall|
                             (Lit (PagedBetree.Variables.root (Lit |v#0@@63|))))))
                (let ((a!6 (|#PagedBetree.Variables.Variables|
                             (Lit (PagedBetree.Variables.memtable
                                    (Lit |v#0@@63|)))
                             (Lit (|#PagedBetree.BetreeNode.BetreeNode|
                                    a!4
                                    (Lit a!5))))))
                (let ((a!8 (=> (U_2_bool a!3)
                               (and (|$IsA#PagedBetree.Variables|
                                      (Lit |v'#0@@22|))
                                    (|$IsA#PagedBetree.Variables| (Lit a!6))
                                    (PagedBetree.Variables.Variables_q
                                      (Lit |v#0@@63|))
                                    a!7
                                    (PagedBetree.Variables.Variables_q
                                      (Lit |v#0@@63|)))))
                      (a!9 (= (PagedBetree.__default.InternalGrow
                                (Lit |v#0@@63|)
                                (Lit |v'#0@@22|)
                                (Lit |lbl#0@@26|))
                              (and (PagedBetree.Variables.WF (Lit |v#0@@63|))
                                   (PagedBetree.TransitionLabel.InternalLabel_q
                                     (Lit |lbl#0@@26|))
                                   (|PagedBetree.Variables#Equal|
                                     |v'#0@@22|
                                     (Lit a!6))))))
                  (=> a!1
                      (and (|PagedBetree.Variables.WF#canCall| (Lit |v#0@@63|))
                           (=> (U_2_bool a!2) a!8)
                           a!9)))))
                :pattern ((PagedBetree.__default.InternalGrow
                            (Lit |v#0@@63|)
                            (Lit |v'#0@@22|)
                            (Lit |lbl#0@@26|)))
                :weight 3
                :skolemid |3444|
                :qid |PagedBetreeidfy.366:26|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@64| T@U) (|v'#0@@23| T@U) (|lbl#0@@27| T@U) (|step#0| T@U))
      (! (let ((a!1 (and (= (type |v#0@@64|) DatatypeTypeType)
                         (= (type |v'#0@@23|) DatatypeTypeType)
                         (= (type |lbl#0@@27|) DatatypeTypeType)
                         (= (type |step#0|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalSplit#canCall|
                               |v#0@@64|
                               |v'#0@@23|
                               |lbl#0@@27|
                               |step#0|)
                             (and ($Is |v#0@@64| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@23| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@27|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0| Tclass.PagedBetree.Step))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.InternalSplit
                     |v#0@@64|
                     |v'#0@@23|
                     |lbl#0@@27|
                     |step#0|))
         :skolemid |3445|
         :qid |PagedBetreeidfy.375:27|))))
(assert (forall ((|v#0@@65| T@U) (|v'#0@@24| T@U) (|lbl#0@@28| T@U) (|step#0@@0| T@U))
  (! (=> (and (= (type |v#0@@65|) DatatypeTypeType)
              (= (type |v'#0@@24|) DatatypeTypeType)
              (= (type |lbl#0@@28|) DatatypeTypeType)
              (= (type |step#0@@0|) DatatypeTypeType)
              ($Is |v#0@@65| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@24| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@28| Tclass.PagedBetree.TransitionLabel)
              ($Is |step#0@@0| Tclass.PagedBetree.Step))
         (= (|PagedBetree.__default.InternalSplit#requires|
              |v#0@@65|
              |v'#0@@24|
              |lbl#0@@28|
              |step#0@@0|)
            true))
     :pattern ((|PagedBetree.__default.InternalSplit#requires|
                 |v#0@@65|
                 |v'#0@@24|
                 |lbl#0@@28|
                 |step#0@@0|))
     :skolemid |3446|
     :qid |PagedBetreeidfy.375:27|)))
(assert (=> true
    (forall ((|v#0@@66| T@U)
             (|v'#0@@25| T@U)
             (|lbl#0@@29| T@U)
             (|step#0@@1| T@U))
      (! (let ((a!1 (and (= (type |v#0@@66|) DatatypeTypeType)
                         (= (type |v'#0@@25|) DatatypeTypeType)
                         (= (type |lbl#0@@29|) DatatypeTypeType)
                         (= (type |step#0@@1|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalSplit#canCall|
                               |v#0@@66|
                               |v'#0@@25|
                               |lbl#0@@29|
                               |step#0@@1|)
                             (and ($Is |v#0@@66| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@25| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@29|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@1| Tclass.PagedBetree.Step)))))
               (a!2 (PagedBetree.BetreeNode.Split
                      (PagedBetree.Path.Target
                        ($LS $LZ)
                        (PagedBetree.Step.path |step#0@@1|))
                      (PagedBetree.Step.leftKeys |step#0@@1|)
                      (PagedBetree.Step.rightKeys |step#0@@1|))))
         (let ((a!3 (|$IsA#PagedBetree.Variables|
                      (|#PagedBetree.Variables.Variables|
                        (PagedBetree.Variables.memtable |v#0@@66|)
                        (PagedBetree.Path.Substitute
                          ($LS $LZ)
                          (PagedBetree.Step.path |step#0@@1|)
                          a!2))))
               (a!8 (|PagedBetree.Variables#Equal|
                      |v'#0@@25|
                      (|#PagedBetree.Variables.Variables|
                        (PagedBetree.Variables.memtable |v#0@@66|)
                        (PagedBetree.Path.Substitute
                          ($LS $LZ)
                          (PagedBetree.Step.path |step#0@@1|)
                          a!2)))))
         (let ((a!4 (and (|$IsA#PagedBetree.Variables| |v'#0@@25|)
                         a!3
                         (|PagedBetree.Path.Target#canCall|
                           (PagedBetree.Step.path |step#0@@1|))
                         (|PagedBetree.BetreeNode.Split#canCall|
                           (PagedBetree.Path.Target
                             ($LS $LZ)
                             (PagedBetree.Step.path |step#0@@1|))
                           (PagedBetree.Step.leftKeys |step#0@@1|)
                           (PagedBetree.Step.rightKeys |step#0@@1|))
                         (|PagedBetree.Path.Substitute#canCall|
                           (PagedBetree.Step.path |step#0@@1|)
                           a!2)
                         (PagedBetree.Variables.Variables_q |v#0@@66|)))
               (a!9 (and (PagedBetree.TransitionLabel.InternalLabel_q
                           |lbl#0@@29|)
                         (PagedBetree.Step.InternalSplitStep_q |step#0@@1|)
                         (PagedBetree.Path.Valid
                           ($LS $LZ)
                           (PagedBetree.Step.path |step#0@@1|))
                         (|PagedBetree.BetreeNode#Equal|
                           (PagedBetree.Path.node
                             (PagedBetree.Step.path |step#0@@1|))
                           (PagedBetree.Variables.root |v#0@@66|))
                         a!8)))
         (let ((a!5 (=> (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.Path.node
                            (PagedBetree.Step.path |step#0@@1|))
                          (PagedBetree.Variables.root |v#0@@66|))
                        a!4)))
         (let ((a!6 (and (|$IsA#PagedBetree.BetreeNode|
                           (PagedBetree.Path.node
                             (PagedBetree.Step.path |step#0@@1|)))
                         (|$IsA#PagedBetree.BetreeNode|
                           (PagedBetree.Variables.root |v#0@@66|))
                         (PagedBetree.Path.Path_q
                           (PagedBetree.Step.path |step#0@@1|))
                         (PagedBetree.Variables.Variables_q |v#0@@66|)
                         a!5)))
         (let ((a!7 (and (|PagedBetree.Path.Valid#canCall|
                           (PagedBetree.Step.path |step#0@@1|))
                         (=> (PagedBetree.Path.Valid
                               ($LS $LZ)
                               (PagedBetree.Step.path |step#0@@1|))
                             a!6))))
         (let ((a!10 (and (=> (PagedBetree.TransitionLabel.InternalLabel_q
                                |lbl#0@@29|)
                              (=> (PagedBetree.Step.InternalSplitStep_q
                                    |step#0@@1|)
                                  a!7))
                          (= (PagedBetree.__default.InternalSplit
                               |v#0@@66|
                               |v'#0@@25|
                               |lbl#0@@29|
                               |step#0@@1|)
                             a!9))))
           (=> a!1 a!10))))))))
         :pattern ((PagedBetree.__default.InternalSplit
                     |v#0@@66|
                     |v'#0@@25|
                     |lbl#0@@29|
                     |step#0@@1|))
         :skolemid |3447|
         :qid |PagedBetreeidfy.375:27|))))
(assert (=> true
    (forall ((|v#0@@67| T@U)
             (|v'#0@@26| T@U)
             (|lbl#0@@30| T@U)
             (|step#0@@2| T@U))
      (! (let ((a!1 (and (= (type |v#0@@67|) DatatypeTypeType)
                         (= (type |v'#0@@26|) DatatypeTypeType)
                         (= (type |lbl#0@@30|) DatatypeTypeType)
                         (= (type |step#0@@2|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalSplit#canCall|
                               (Lit |v#0@@67|)
                               (Lit |v'#0@@26|)
                               (Lit |lbl#0@@30|)
                               (Lit |step#0@@2|))
                             (and ($Is |v#0@@67| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@26| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@30|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@2| Tclass.PagedBetree.Step)))))
               (a!2 (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q
                                     (Lit |lbl#0@@30|)))))
               (a!3 (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q
                                     (Lit |step#0@@2|)))))
               (a!4 (|PagedBetree.Path.Valid#canCall|
                      (Lit (PagedBetree.Step.path (Lit |step#0@@2|)))))
               (a!5 (PagedBetree.Path.Valid
                      ($LS $LZ)
                      (Lit (PagedBetree.Step.path (Lit |step#0@@2|)))))
               (a!6 (PagedBetree.Path.node
                      (Lit (PagedBetree.Step.path (Lit |step#0@@2|)))))
               (a!7 (|$IsA#PagedBetree.BetreeNode|
                      (Lit (PagedBetree.Variables.root (Lit |v#0@@67|)))))
               (a!8 (PagedBetree.Path.Path_q
                      (Lit (PagedBetree.Step.path (Lit |step#0@@2|)))))
               (a!9 (PagedBetree.Path.Target
                      ($LS $LZ)
                      (Lit (PagedBetree.Step.path (Lit |step#0@@2|)))))
               (a!13 (|PagedBetree.Path.Target#canCall|
                       (Lit (PagedBetree.Step.path (Lit |step#0@@2|))))))
         (let ((a!10 (PagedBetree.BetreeNode.Split
                       (Lit a!9)
                       (Lit (PagedBetree.Step.leftKeys (Lit |step#0@@2|)))
                       (Lit (PagedBetree.Step.rightKeys (Lit |step#0@@2|)))))
               (a!14 (|PagedBetree.BetreeNode.Split#canCall|
                       (Lit a!9)
                       (Lit (PagedBetree.Step.leftKeys (Lit |step#0@@2|)))
                       (Lit (PagedBetree.Step.rightKeys (Lit |step#0@@2|))))))
         (let ((a!11 (PagedBetree.Path.Substitute
                       ($LS $LZ)
                       (Lit (PagedBetree.Step.path (Lit |step#0@@2|)))
                       (Lit a!10)))
               (a!15 (|PagedBetree.Path.Substitute#canCall|
                       (Lit (PagedBetree.Step.path (Lit |step#0@@2|)))
                       (Lit a!10))))
         (let ((a!12 (|#PagedBetree.Variables.Variables|
                       (Lit (PagedBetree.Variables.memtable (Lit |v#0@@67|)))
                       (Lit a!11))))
         (let ((a!16 (=> (|PagedBetree.BetreeNode#Equal|
                           a!6
                           (PagedBetree.Variables.root (Lit |v#0@@67|)))
                         (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@26|))
                              (|$IsA#PagedBetree.Variables| (Lit a!12))
                              a!13
                              a!14
                              a!15
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@67|)))))
               (a!18 (and (PagedBetree.TransitionLabel.InternalLabel_q
                            (Lit |lbl#0@@30|))
                          (PagedBetree.Step.InternalSplitStep_q
                            (Lit |step#0@@2|))
                          a!5
                          (|PagedBetree.BetreeNode#Equal|
                            a!6
                            (PagedBetree.Variables.root (Lit |v#0@@67|)))
                          (|PagedBetree.Variables#Equal| |v'#0@@26| (Lit a!12)))))
         (let ((a!17 (=> (U_2_bool (Lit (bool_2_U a!5)))
                         (and (|$IsA#PagedBetree.BetreeNode| (Lit a!6))
                              a!7
                              a!8
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@67|))
                              a!16))))
         (let ((a!19 (and (=> (U_2_bool a!2) (=> (U_2_bool a!3) (and a!4 a!17)))
                          (= (PagedBetree.__default.InternalSplit
                               (Lit |v#0@@67|)
                               (Lit |v'#0@@26|)
                               (Lit |lbl#0@@30|)
                               (Lit |step#0@@2|))
                             a!18))))
           (=> a!1 a!19))))))))
         :pattern ((PagedBetree.__default.InternalSplit
                     (Lit |v#0@@67|)
                     (Lit |v'#0@@26|)
                     (Lit |lbl#0@@30|)
                     (Lit |step#0@@2|)))
         :weight 3
         :skolemid |3448|
         :qid |PagedBetreeidfy.375:27|))))
(assert (=> true
    (forall ((|v#0@@68| T@U)
             (|v'#0@@27| T@U)
             (|lbl#0@@31| T@U)
             (|step#0@@3| T@U))
      (! (let ((a!1 (and (= (type |v#0@@68|) DatatypeTypeType)
                         (= (type |v'#0@@27|) DatatypeTypeType)
                         (= (type |lbl#0@@31|) DatatypeTypeType)
                         (= (type |step#0@@3|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalFlush#canCall|
                               |v#0@@68|
                               |v'#0@@27|
                               |lbl#0@@31|
                               |step#0@@3|)
                             (and ($Is |v#0@@68| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@27| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@31|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@3| Tclass.PagedBetree.Step))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.InternalFlush
                     |v#0@@68|
                     |v'#0@@27|
                     |lbl#0@@31|
                     |step#0@@3|))
         :skolemid |3449|
         :qid |PagedBetreeidfy.386:27|))))
(assert (forall ((|v#0@@69| T@U) (|v'#0@@28| T@U) (|lbl#0@@32| T@U) (|step#0@@4| T@U))
  (! (=> (and (= (type |v#0@@69|) DatatypeTypeType)
              (= (type |v'#0@@28|) DatatypeTypeType)
              (= (type |lbl#0@@32|) DatatypeTypeType)
              (= (type |step#0@@4|) DatatypeTypeType)
              ($Is |v#0@@69| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@28| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@32| Tclass.PagedBetree.TransitionLabel)
              ($Is |step#0@@4| Tclass.PagedBetree.Step))
         (= (|PagedBetree.__default.InternalFlush#requires|
              |v#0@@69|
              |v'#0@@28|
              |lbl#0@@32|
              |step#0@@4|)
            true))
     :pattern ((|PagedBetree.__default.InternalFlush#requires|
                 |v#0@@69|
                 |v'#0@@28|
                 |lbl#0@@32|
                 |step#0@@4|))
     :skolemid |3450|
     :qid |PagedBetreeidfy.386:27|)))
(assert (=> true
    (forall ((|v#0@@70| T@U)
             (|v'#0@@29| T@U)
             (|lbl#0@@33| T@U)
             (|step#0@@5| T@U))
      (! (let ((a!1 (and (= (type |v#0@@70|) DatatypeTypeType)
                         (= (type |v'#0@@29|) DatatypeTypeType)
                         (= (type |lbl#0@@33|) DatatypeTypeType)
                         (= (type |step#0@@5|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalFlush#canCall|
                               |v#0@@70|
                               |v'#0@@29|
                               |lbl#0@@33|
                               |step#0@@5|)
                             (and ($Is |v#0@@70| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@29| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@33|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@5| Tclass.PagedBetree.Step)))))
               (a!2 (PagedBetree.Path.Substitute
                      ($LS $LZ)
                      (PagedBetree.Step.path |step#0@@5|)
                      (PagedBetree.BetreeNode.Flush
                        (PagedBetree.Path.Target
                          ($LS $LZ)
                          (PagedBetree.Step.path |step#0@@5|))
                        (PagedBetree.Step.downKeys |step#0@@5|))))
               (a!3 (|PagedBetree.Path.Substitute#canCall|
                      (PagedBetree.Step.path |step#0@@5|)
                      (PagedBetree.BetreeNode.Flush
                        (PagedBetree.Path.Target
                          ($LS $LZ)
                          (PagedBetree.Step.path |step#0@@5|))
                        (PagedBetree.Step.downKeys |step#0@@5|)))))
         (let ((a!4 (and (|$IsA#PagedBetree.Variables| |v'#0@@29|)
                         (|$IsA#PagedBetree.Variables|
                           (|#PagedBetree.Variables.Variables|
                             (PagedBetree.Variables.memtable |v#0@@70|)
                             a!2))
                         (|PagedBetree.Path.Target#canCall|
                           (PagedBetree.Step.path |step#0@@5|))
                         (|PagedBetree.BetreeNode.Flush#canCall|
                           (PagedBetree.Path.Target
                             ($LS $LZ)
                             (PagedBetree.Step.path |step#0@@5|))
                           (PagedBetree.Step.downKeys |step#0@@5|))
                         a!3
                         (PagedBetree.Variables.Variables_q |v#0@@70|)))
               (a!8 (and (PagedBetree.TransitionLabel.InternalLabel_q
                           |lbl#0@@33|)
                         (PagedBetree.Step.InternalFlushStep_q |step#0@@5|)
                         (PagedBetree.Path.Valid
                           ($LS $LZ)
                           (PagedBetree.Step.path |step#0@@5|))
                         (|PagedBetree.BetreeNode#Equal|
                           (PagedBetree.Path.node
                             (PagedBetree.Step.path |step#0@@5|))
                           (PagedBetree.Variables.root |v#0@@70|))
                         (|PagedBetree.Variables#Equal|
                           |v'#0@@29|
                           (|#PagedBetree.Variables.Variables|
                             (PagedBetree.Variables.memtable |v#0@@70|)
                             a!2)))))
         (let ((a!5 (=> (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.Path.node
                            (PagedBetree.Step.path |step#0@@5|))
                          (PagedBetree.Variables.root |v#0@@70|))
                        a!4)))
         (let ((a!6 (and (|$IsA#PagedBetree.BetreeNode|
                           (PagedBetree.Path.node
                             (PagedBetree.Step.path |step#0@@5|)))
                         (|$IsA#PagedBetree.BetreeNode|
                           (PagedBetree.Variables.root |v#0@@70|))
                         (PagedBetree.Path.Path_q
                           (PagedBetree.Step.path |step#0@@5|))
                         (PagedBetree.Variables.Variables_q |v#0@@70|)
                         a!5)))
         (let ((a!7 (and (|PagedBetree.Path.Valid#canCall|
                           (PagedBetree.Step.path |step#0@@5|))
                         (=> (PagedBetree.Path.Valid
                               ($LS $LZ)
                               (PagedBetree.Step.path |step#0@@5|))
                             a!6))))
         (let ((a!9 (and (=> (PagedBetree.TransitionLabel.InternalLabel_q
                               |lbl#0@@33|)
                             (=> (PagedBetree.Step.InternalFlushStep_q
                                   |step#0@@5|)
                                 a!7))
                         (= (PagedBetree.__default.InternalFlush
                              |v#0@@70|
                              |v'#0@@29|
                              |lbl#0@@33|
                              |step#0@@5|)
                            a!8))))
           (=> a!1 a!9)))))))
         :pattern ((PagedBetree.__default.InternalFlush
                     |v#0@@70|
                     |v'#0@@29|
                     |lbl#0@@33|
                     |step#0@@5|))
         :skolemid |3451|
         :qid |PagedBetreeidfy.386:27|))))
(assert (=> true
    (forall ((|v#0@@71| T@U)
             (|v'#0@@30| T@U)
             (|lbl#0@@34| T@U)
             (|step#0@@6| T@U))
      (! (let ((a!1 (and (= (type |v#0@@71|) DatatypeTypeType)
                         (= (type |v'#0@@30|) DatatypeTypeType)
                         (= (type |lbl#0@@34|) DatatypeTypeType)
                         (= (type |step#0@@6|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalFlush#canCall|
                               (Lit |v#0@@71|)
                               (Lit |v'#0@@30|)
                               (Lit |lbl#0@@34|)
                               (Lit |step#0@@6|))
                             (and ($Is |v#0@@71| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@30| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@34|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@6| Tclass.PagedBetree.Step)))))
               (a!2 (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q
                                     (Lit |lbl#0@@34|)))))
               (a!3 (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q
                                     (Lit |step#0@@6|)))))
               (a!4 (|PagedBetree.Path.Valid#canCall|
                      (Lit (PagedBetree.Step.path (Lit |step#0@@6|)))))
               (a!5 (PagedBetree.Path.Valid
                      ($LS $LZ)
                      (Lit (PagedBetree.Step.path (Lit |step#0@@6|)))))
               (a!6 (PagedBetree.Path.node
                      (Lit (PagedBetree.Step.path (Lit |step#0@@6|)))))
               (a!7 (|$IsA#PagedBetree.BetreeNode|
                      (Lit (PagedBetree.Variables.root (Lit |v#0@@71|)))))
               (a!8 (PagedBetree.Path.Path_q
                      (Lit (PagedBetree.Step.path (Lit |step#0@@6|)))))
               (a!9 (PagedBetree.Path.Target
                      ($LS $LZ)
                      (Lit (PagedBetree.Step.path (Lit |step#0@@6|)))))
               (a!13 (|PagedBetree.Path.Target#canCall|
                       (Lit (PagedBetree.Step.path (Lit |step#0@@6|))))))
         (let ((a!10 (PagedBetree.BetreeNode.Flush
                       (Lit a!9)
                       (Lit (PagedBetree.Step.downKeys (Lit |step#0@@6|)))))
               (a!14 (|PagedBetree.BetreeNode.Flush#canCall|
                       (Lit a!9)
                       (Lit (PagedBetree.Step.downKeys (Lit |step#0@@6|))))))
         (let ((a!11 (PagedBetree.Path.Substitute
                       ($LS $LZ)
                       (Lit (PagedBetree.Step.path (Lit |step#0@@6|)))
                       (Lit a!10)))
               (a!15 (|PagedBetree.Path.Substitute#canCall|
                       (Lit (PagedBetree.Step.path (Lit |step#0@@6|)))
                       (Lit a!10))))
         (let ((a!12 (|#PagedBetree.Variables.Variables|
                       (Lit (PagedBetree.Variables.memtable (Lit |v#0@@71|)))
                       (Lit a!11))))
         (let ((a!16 (=> (|PagedBetree.BetreeNode#Equal|
                           a!6
                           (PagedBetree.Variables.root (Lit |v#0@@71|)))
                         (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@30|))
                              (|$IsA#PagedBetree.Variables| (Lit a!12))
                              a!13
                              a!14
                              a!15
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@71|)))))
               (a!18 (and (PagedBetree.TransitionLabel.InternalLabel_q
                            (Lit |lbl#0@@34|))
                          (PagedBetree.Step.InternalFlushStep_q
                            (Lit |step#0@@6|))
                          a!5
                          (|PagedBetree.BetreeNode#Equal|
                            a!6
                            (PagedBetree.Variables.root (Lit |v#0@@71|)))
                          (|PagedBetree.Variables#Equal| |v'#0@@30| (Lit a!12)))))
         (let ((a!17 (=> (U_2_bool (Lit (bool_2_U a!5)))
                         (and (|$IsA#PagedBetree.BetreeNode| (Lit a!6))
                              a!7
                              a!8
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@71|))
                              a!16))))
         (let ((a!19 (and (=> (U_2_bool a!2) (=> (U_2_bool a!3) (and a!4 a!17)))
                          (= (PagedBetree.__default.InternalFlush
                               (Lit |v#0@@71|)
                               (Lit |v'#0@@30|)
                               (Lit |lbl#0@@34|)
                               (Lit |step#0@@6|))
                             a!18))))
           (=> a!1 a!19))))))))
         :pattern ((PagedBetree.__default.InternalFlush
                     (Lit |v#0@@71|)
                     (Lit |v'#0@@30|)
                     (Lit |lbl#0@@34|)
                     (Lit |step#0@@6|)))
         :weight 3
         :skolemid |3452|
         :qid |PagedBetreeidfy.386:27|))))
(assert (forall ((arg0@@598 T@U) (arg1@@303 T@U))
  (! (= (type (PagedBetree.__default.CompactedNode arg0@@598 arg1@@303))
        DatatypeTypeType)
     :pattern ((PagedBetree.__default.CompactedNode arg0@@598 arg1@@303))
     :qid |funType:PagedBetree.__default.CompactedNode|)))
(assert (let ((a!1 (forall ((|original#0| T@U) (|newBufs#0| T@U))
             (! (let ((a!1 (or (|PagedBetree.__default.CompactedNode#canCall|
                                 |original#0|
                                 |newBufs#0|)
                               (and ($Is |original#0|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |newBufs#0| Tclass.Buffers.BufferStack)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      |original#0|)
                                    (Buffers.BufferStack.Equivalent
                                      (PagedBetree.BetreeNode.buffers
                                        |original#0|)
                                      |newBufs#0|)))))
                  (=> (and (= (type |original#0|) DatatypeTypeType)
                           (= (type |newBufs#0|) DatatypeTypeType)
                           a!1)
                      ($Is (PagedBetree.__default.CompactedNode
                             |original#0|
                             |newBufs#0|)
                           Tclass.PagedBetree.BetreeNode)))
                :pattern ((PagedBetree.__default.CompactedNode
                            |original#0|
                            |newBufs#0|))
                :skolemid |3453|
                :qid |PagedBetreeidfy.397:26|))))
  (=> true a!1)))
(assert (forall ((|original#0@@0| T@U) (|newBufs#0@@0| T@U))
  (! (let ((a!1 (= (|PagedBetree.__default.CompactedNode#requires|
                     |original#0@@0|
                     |newBufs#0@@0|)
                   (and (PagedBetree.BetreeNode.BetreeNode_q |original#0@@0|)
                        (Buffers.BufferStack.Equivalent
                          (PagedBetree.BetreeNode.buffers |original#0@@0|)
                          |newBufs#0@@0|)))))
       (=> (and (= (type |original#0@@0|) DatatypeTypeType)
                (= (type |newBufs#0@@0|) DatatypeTypeType)
                ($Is |original#0@@0| Tclass.PagedBetree.BetreeNode)
                ($Is |newBufs#0@@0| Tclass.Buffers.BufferStack))
           a!1))
     :pattern ((|PagedBetree.__default.CompactedNode#requires|
                 |original#0@@0|
                 |newBufs#0@@0|))
     :skolemid |3454|
     :qid |PagedBetreeidfy.397:26|)))
(assert (let ((a!1 (forall ((|original#0@@1| T@U) (|newBufs#0@@1| T@U))
             (! (let ((a!1 (or (|PagedBetree.__default.CompactedNode#canCall|
                                 |original#0@@1|
                                 |newBufs#0@@1|)
                               (and ($Is |original#0@@1|
                                         Tclass.PagedBetree.BetreeNode)
                                    ($Is |newBufs#0@@1|
                                         Tclass.Buffers.BufferStack)
                                    (PagedBetree.BetreeNode.BetreeNode_q
                                      |original#0@@1|)
                                    (Buffers.BufferStack.Equivalent
                                      (PagedBetree.BetreeNode.buffers
                                        |original#0@@1|)
                                      |newBufs#0@@1|)))))
                  (=> (and (= (type |original#0@@1|) DatatypeTypeType)
                           (= (type |newBufs#0@@1|) DatatypeTypeType)
                           a!1)
                      (= (PagedBetree.__default.CompactedNode
                           |original#0@@1|
                           |newBufs#0@@1|)
                         (|#PagedBetree.BetreeNode.BetreeNode|
                           |newBufs#0@@1|
                           (PagedBetree.BetreeNode.children |original#0@@1|)))))
                :pattern ((PagedBetree.__default.CompactedNode
                            |original#0@@1|
                            |newBufs#0@@1|))
                :skolemid |3455|
                :qid |PagedBetreeidfy.397:26|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|original#0@@2| T@U) (|newBufs#0@@2| T@U))
             (! (let ((a!1 (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q
                                            (Lit |original#0@@2|)))))
                      (a!2 (Buffers.BufferStack.Equivalent
                             (Lit (PagedBetree.BetreeNode.buffers
                                    (Lit |original#0@@2|)))
                             (Lit |newBufs#0@@2|)))
                      (a!5 (|#PagedBetree.BetreeNode.BetreeNode|
                             (Lit |newBufs#0@@2|)
                             (Lit (PagedBetree.BetreeNode.children
                                    (Lit |original#0@@2|))))))
                (let ((a!3 (and ($Is |original#0@@2|
                                     Tclass.PagedBetree.BetreeNode)
                                ($Is |newBufs#0@@2| Tclass.Buffers.BufferStack)
                                (U_2_bool a!1)
                                (U_2_bool (Lit (bool_2_U a!2))))))
                (let ((a!4 (and (= (type |original#0@@2|) DatatypeTypeType)
                                (= (type |newBufs#0@@2|) DatatypeTypeType)
                                (or (|PagedBetree.__default.CompactedNode#canCall|
                                      (Lit |original#0@@2|)
                                      (Lit |newBufs#0@@2|))
                                    a!3))))
                  (=> a!4
                      (= (PagedBetree.__default.CompactedNode
                           (Lit |original#0@@2|)
                           (Lit |newBufs#0@@2|))
                         (Lit a!5))))))
                :pattern ((PagedBetree.__default.CompactedNode
                            (Lit |original#0@@2|)
                            (Lit |newBufs#0@@2|)))
                :weight 3
                :skolemid |3456|
                :qid |PagedBetreeidfy.397:26|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@72| T@U)
             (|v'#0@@31| T@U)
             (|lbl#0@@35| T@U)
             (|step#0@@7| T@U))
      (! (let ((a!1 (and (= (type |v#0@@72|) DatatypeTypeType)
                         (= (type |v'#0@@31|) DatatypeTypeType)
                         (= (type |lbl#0@@35|) DatatypeTypeType)
                         (= (type |step#0@@7|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalCompact#canCall|
                               |v#0@@72|
                               |v'#0@@31|
                               |lbl#0@@35|
                               |step#0@@7|)
                             (and ($Is |v#0@@72| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@31| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@35|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@7| Tclass.PagedBetree.Step)
                                  (PagedBetree.Step.WF |step#0@@7|))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.InternalCompact
                     |v#0@@72|
                     |v'#0@@31|
                     |lbl#0@@35|
                     |step#0@@7|))
         :skolemid |3457|
         :qid |PagedBetreeidfy.404:29|))))
(assert (forall ((|v#0@@73| T@U) (|v'#0@@32| T@U) (|lbl#0@@36| T@U) (|step#0@@8| T@U))
  (! (=> (and (= (type |v#0@@73|) DatatypeTypeType)
              (= (type |v'#0@@32|) DatatypeTypeType)
              (= (type |lbl#0@@36|) DatatypeTypeType)
              (= (type |step#0@@8|) DatatypeTypeType)
              ($Is |v#0@@73| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@32| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@36| Tclass.PagedBetree.TransitionLabel)
              ($Is |step#0@@8| Tclass.PagedBetree.Step))
         (= (|PagedBetree.__default.InternalCompact#requires|
              |v#0@@73|
              |v'#0@@32|
              |lbl#0@@36|
              |step#0@@8|)
            (PagedBetree.Step.WF |step#0@@8|)))
     :pattern ((|PagedBetree.__default.InternalCompact#requires|
                 |v#0@@73|
                 |v'#0@@32|
                 |lbl#0@@36|
                 |step#0@@8|))
     :skolemid |3458|
     :qid |PagedBetreeidfy.404:29|)))
(assert (=> true
    (forall ((|v#0@@74| T@U)
             (|v'#0@@33| T@U)
             (|lbl#0@@37| T@U)
             (|step#0@@9| T@U))
      (! (let ((a!1 (and (= (type |v#0@@74|) DatatypeTypeType)
                         (= (type |v'#0@@33|) DatatypeTypeType)
                         (= (type |lbl#0@@37|) DatatypeTypeType)
                         (= (type |step#0@@9|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalCompact#canCall|
                               |v#0@@74|
                               |v'#0@@33|
                               |lbl#0@@37|
                               |step#0@@9|)
                             (and ($Is |v#0@@74| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@33| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@37|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@9| Tclass.PagedBetree.Step)
                                  (PagedBetree.Step.WF |step#0@@9|)))))
               (a!2 (PagedBetree.Path.Substitute
                      ($LS $LZ)
                      (PagedBetree.Step.path |step#0@@9|)
                      (PagedBetree.__default.CompactedNode
                        (PagedBetree.Path.Target
                          ($LS $LZ)
                          (PagedBetree.Step.path |step#0@@9|))
                        (PagedBetree.Step.compactedBuffers |step#0@@9|))))
               (a!3 (|PagedBetree.Path.Substitute#canCall|
                      (PagedBetree.Step.path |step#0@@9|)
                      (PagedBetree.__default.CompactedNode
                        (PagedBetree.Path.Target
                          ($LS $LZ)
                          (PagedBetree.Step.path |step#0@@9|))
                        (PagedBetree.Step.compactedBuffers |step#0@@9|)))))
         (let ((a!4 (and (|$IsA#PagedBetree.Variables| |v'#0@@33|)
                         (|$IsA#PagedBetree.Variables|
                           (|#PagedBetree.Variables.Variables|
                             (PagedBetree.Variables.memtable |v#0@@74|)
                             a!2))
                         (|PagedBetree.Path.Target#canCall|
                           (PagedBetree.Step.path |step#0@@9|))
                         (|PagedBetree.__default.CompactedNode#canCall|
                           (PagedBetree.Path.Target
                             ($LS $LZ)
                             (PagedBetree.Step.path |step#0@@9|))
                           (PagedBetree.Step.compactedBuffers |step#0@@9|))
                         a!3
                         (PagedBetree.Variables.Variables_q |v#0@@74|)))
               (a!7 (and (PagedBetree.TransitionLabel.InternalLabel_q
                           |lbl#0@@37|)
                         (PagedBetree.Step.InternalCompactStep_q |step#0@@9|)
                         (|PagedBetree.BetreeNode#Equal|
                           (PagedBetree.Path.node
                             (PagedBetree.Step.path |step#0@@9|))
                           (PagedBetree.Variables.root |v#0@@74|))
                         (|PagedBetree.Variables#Equal|
                           |v'#0@@33|
                           (|#PagedBetree.Variables.Variables|
                             (PagedBetree.Variables.memtable |v#0@@74|)
                             a!2)))))
         (let ((a!5 (=> (|PagedBetree.BetreeNode#Equal|
                          (PagedBetree.Path.node
                            (PagedBetree.Step.path |step#0@@9|))
                          (PagedBetree.Variables.root |v#0@@74|))
                        a!4)))
         (let ((a!6 (and (|$IsA#PagedBetree.BetreeNode|
                           (PagedBetree.Path.node
                             (PagedBetree.Step.path |step#0@@9|)))
                         (|$IsA#PagedBetree.BetreeNode|
                           (PagedBetree.Variables.root |v#0@@74|))
                         (PagedBetree.Path.Path_q
                           (PagedBetree.Step.path |step#0@@9|))
                         (PagedBetree.Variables.Variables_q |v#0@@74|)
                         a!5)))
         (let ((a!8 (and (=> (PagedBetree.TransitionLabel.InternalLabel_q
                               |lbl#0@@37|)
                             (=> (PagedBetree.Step.InternalCompactStep_q
                                   |step#0@@9|)
                                 a!6))
                         (= (PagedBetree.__default.InternalCompact
                              |v#0@@74|
                              |v'#0@@33|
                              |lbl#0@@37|
                              |step#0@@9|)
                            a!7))))
           (=> a!1 a!8))))))
         :pattern ((PagedBetree.__default.InternalCompact
                     |v#0@@74|
                     |v'#0@@33|
                     |lbl#0@@37|
                     |step#0@@9|))
         :skolemid |3459|
         :qid |PagedBetreeidfy.404:29|))))
(assert (=> true
    (forall ((|v#0@@75| T@U)
             (|v'#0@@34| T@U)
             (|lbl#0@@38| T@U)
             (|step#0@@10| T@U))
      (! (let ((a!1 (Lit (bool_2_U (PagedBetree.Step.WF (Lit |step#0@@10|)))))
               (a!3 (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q
                                     (Lit |lbl#0@@38|)))))
               (a!4 (Lit (bool_2_U (PagedBetree.Step.InternalCompactStep_q
                                     (Lit |step#0@@10|)))))
               (a!5 (PagedBetree.Path.node
                      (Lit (PagedBetree.Step.path (Lit |step#0@@10|)))))
               (a!6 (|$IsA#PagedBetree.BetreeNode|
                      (Lit (PagedBetree.Variables.root (Lit |v#0@@75|)))))
               (a!7 (PagedBetree.Path.Path_q
                      (Lit (PagedBetree.Step.path (Lit |step#0@@10|)))))
               (a!8 (PagedBetree.Path.Target
                      ($LS $LZ)
                      (Lit (PagedBetree.Step.path (Lit |step#0@@10|)))))
               (a!12 (|PagedBetree.Path.Target#canCall|
                       (Lit (PagedBetree.Step.path (Lit |step#0@@10|))))))
         (let ((a!2 (and (= (type |v#0@@75|) DatatypeTypeType)
                         (= (type |v'#0@@34|) DatatypeTypeType)
                         (= (type |lbl#0@@38|) DatatypeTypeType)
                         (= (type |step#0@@10|) DatatypeTypeType)
                         (or (|PagedBetree.__default.InternalCompact#canCall|
                               (Lit |v#0@@75|)
                               (Lit |v'#0@@34|)
                               (Lit |lbl#0@@38|)
                               (Lit |step#0@@10|))
                             (and ($Is |v#0@@75| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@34| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@38|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@10| Tclass.PagedBetree.Step)
                                  (U_2_bool a!1)))))
               (a!9 (PagedBetree.__default.CompactedNode
                      (Lit a!8)
                      (Lit (PagedBetree.Step.compactedBuffers
                             (Lit |step#0@@10|)))))
               (a!13 (|PagedBetree.__default.CompactedNode#canCall|
                       (Lit a!8)
                       (Lit (PagedBetree.Step.compactedBuffers
                              (Lit |step#0@@10|))))))
         (let ((a!10 (PagedBetree.Path.Substitute
                       ($LS $LZ)
                       (Lit (PagedBetree.Step.path (Lit |step#0@@10|)))
                       (Lit a!9)))
               (a!14 (|PagedBetree.Path.Substitute#canCall|
                       (Lit (PagedBetree.Step.path (Lit |step#0@@10|)))
                       (Lit a!9))))
         (let ((a!11 (|#PagedBetree.Variables.Variables|
                       (Lit (PagedBetree.Variables.memtable (Lit |v#0@@75|)))
                       (Lit a!10))))
         (let ((a!15 (=> (|PagedBetree.BetreeNode#Equal|
                           a!5
                           (PagedBetree.Variables.root (Lit |v#0@@75|)))
                         (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@34|))
                              (|$IsA#PagedBetree.Variables| (Lit a!11))
                              a!12
                              a!13
                              a!14
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@75|)))))
               (a!17 (and (PagedBetree.TransitionLabel.InternalLabel_q
                            (Lit |lbl#0@@38|))
                          (PagedBetree.Step.InternalCompactStep_q
                            (Lit |step#0@@10|))
                          (|PagedBetree.BetreeNode#Equal|
                            a!5
                            (PagedBetree.Variables.root (Lit |v#0@@75|)))
                          (|PagedBetree.Variables#Equal| |v'#0@@34| (Lit a!11)))))
         (let ((a!16 (=> (U_2_bool a!4)
                         (and (|$IsA#PagedBetree.BetreeNode| (Lit a!5))
                              a!6
                              a!7
                              (PagedBetree.Variables.Variables_q
                                (Lit |v#0@@75|))
                              a!15))))
         (let ((a!18 (and (=> (U_2_bool a!3) a!16)
                          (= (PagedBetree.__default.InternalCompact
                               (Lit |v#0@@75|)
                               (Lit |v'#0@@34|)
                               (Lit |lbl#0@@38|)
                               (Lit |step#0@@10|))
                             a!17))))
           (=> a!2 a!18))))))))
         :pattern ((PagedBetree.__default.InternalCompact
                     (Lit |v#0@@75|)
                     (Lit |v'#0@@34|)
                     (Lit |lbl#0@@38|)
                     (Lit |step#0@@10|)))
         :weight 3
         :skolemid |3460|
         :qid |PagedBetreeidfy.404:29|))))
(assert (let ((a!1 (forall ((|v#0@@76| T@U) (|stampedBetree#0@@4| T@U))
             (! (let ((a!1 (or (|PagedBetree.__default.Init#canCall|
                                 |v#0@@76|
                                 |stampedBetree#0@@4|)
                               (and ($Is |v#0@@76| Tclass.PagedBetree.Variables)
                                    ($Is |stampedBetree#0@@4|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.PagedBetree.BetreeNode))))))
                  (=> (and (= (type |v#0@@76|) DatatypeTypeType)
                           (= (type |stampedBetree#0@@4|) DatatypeTypeType)
                           a!1)
                      true))
                :pattern ((PagedBetree.__default.Init
                            |v#0@@76|
                            |stampedBetree#0@@4|))
                :skolemid |3461|
                :qid |PagedBetreeidfy.417:18|))))
  (=> true a!1)))
(assert (forall ((|v#0@@77| T@U) (|stampedBetree#0@@5| T@U))
  (! (=> (and (= (type |v#0@@77|) DatatypeTypeType)
              (= (type |stampedBetree#0@@5|) DatatypeTypeType)
              ($Is |v#0@@77| Tclass.PagedBetree.Variables)
              ($Is |stampedBetree#0@@5|
                   (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)))
         (= (|PagedBetree.__default.Init#requires|
              |v#0@@77|
              |stampedBetree#0@@5|)
            true))
     :pattern ((|PagedBetree.__default.Init#requires|
                 |v#0@@77|
                 |stampedBetree#0@@5|))
     :skolemid |3462|
     :qid |PagedBetreeidfy.417:18|)))
(assert (let ((a!1 (forall ((|v#0@@78| T@U) (|stampedBetree#0@@6| T@U))
             (! (let ((a!1 (or (|PagedBetree.__default.Init#canCall|
                                 |v#0@@78|
                                 |stampedBetree#0@@6|)
                               (and ($Is |v#0@@78| Tclass.PagedBetree.Variables)
                                    ($Is |stampedBetree#0@@6|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.PagedBetree.BetreeNode)))))
                      (a!2 (=> (PagedBetree.BetreeNode.WF
                                 ($LS $LZ)
                                 ($Unbox DatatypeTypeType
                                         (StampedMod.Stamped.value
                                           |stampedBetree#0@@6|)))
                               (and (|$IsA#PagedBetree.Variables| |v#0@@78|)
                                    (StampedMod.Stamped.Stamped_q
                                      |stampedBetree#0@@6|)
                                    (|MemtableMod.__default.EmptyMemtable#canCall|
                                      (StampedMod.Stamped.seqEnd
                                        |stampedBetree#0@@6|))
                                    (StampedMod.Stamped.Stamped_q
                                      |stampedBetree#0@@6|))))
                      (a!3 (|PagedBetree.Variables#Equal|
                             |v#0@@78|
                             (|#PagedBetree.Variables.Variables|
                               (MemtableMod.__default.EmptyMemtable
                                 (StampedMod.Stamped.seqEnd
                                   |stampedBetree#0@@6|))
                               ($Unbox DatatypeTypeType
                                       (StampedMod.Stamped.value
                                         |stampedBetree#0@@6|))))))
                (let ((a!4 (and (PagedBetree.BetreeNode.WF
                                  ($LS $LZ)
                                  ($Unbox DatatypeTypeType
                                          (StampedMod.Stamped.value
                                            |stampedBetree#0@@6|)))
                                a!3)))
                (let ((a!5 (and (StampedMod.Stamped.Stamped_q
                                  |stampedBetree#0@@6|)
                                (|PagedBetree.BetreeNode.WF#canCall|
                                  ($Unbox DatatypeTypeType
                                          (StampedMod.Stamped.value
                                            |stampedBetree#0@@6|)))
                                a!2
                                (= (PagedBetree.__default.Init
                                     |v#0@@78|
                                     |stampedBetree#0@@6|)
                                   a!4))))
                  (=> (and (= (type |v#0@@78|) DatatypeTypeType)
                           (= (type |stampedBetree#0@@6|) DatatypeTypeType)
                           a!1)
                      a!5))))
                :pattern ((PagedBetree.__default.Init
                            |v#0@@78|
                            |stampedBetree#0@@6|))
                :skolemid |3463|
                :qid |PagedBetreeidfy.417:18|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@79| T@U) (|stampedBetree#0@@7| T@U))
             (! (let ((a!1 (or (|PagedBetree.__default.Init#canCall|
                                 (Lit |v#0@@79|)
                                 (Lit |stampedBetree#0@@7|))
                               (and ($Is |v#0@@79| Tclass.PagedBetree.Variables)
                                    ($Is |stampedBetree#0@@7|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.PagedBetree.BetreeNode)))))
                      (a!2 (Lit ($Unbox DatatypeTypeType
                                        (StampedMod.Stamped.value
                                          (Lit |stampedBetree#0@@7|)))))
                      (a!4 (|MemtableMod.__default.EmptyMemtable#canCall|
                             (LitInt (StampedMod.Stamped.seqEnd
                                       (Lit |stampedBetree#0@@7|)))))
                      (a!6 (MemtableMod.__default.EmptyMemtable
                             (LitInt (StampedMod.Stamped.seqEnd
                                       (Lit |stampedBetree#0@@7|))))))
                (let ((a!3 (Lit (bool_2_U (PagedBetree.BetreeNode.WF
                                            ($LS $LZ)
                                            a!2))))
                      (a!7 (and (PagedBetree.BetreeNode.WF ($LS $LZ) a!2)
                                (|PagedBetree.Variables#Equal|
                                  |v#0@@79|
                                  (|#PagedBetree.Variables.Variables|
                                    (Lit a!6)
                                    a!2)))))
                (let ((a!5 (=> (U_2_bool a!3)
                               (and (|$IsA#PagedBetree.Variables|
                                      (Lit |v#0@@79|))
                                    (StampedMod.Stamped.Stamped_q
                                      (Lit |stampedBetree#0@@7|))
                                    a!4
                                    (StampedMod.Stamped.Stamped_q
                                      (Lit |stampedBetree#0@@7|))))))
                (let ((a!8 (and (StampedMod.Stamped.Stamped_q
                                  (Lit |stampedBetree#0@@7|))
                                (|PagedBetree.BetreeNode.WF#canCall| a!2)
                                a!5
                                (= (PagedBetree.__default.Init
                                     (Lit |v#0@@79|)
                                     (Lit |stampedBetree#0@@7|))
                                   a!7))))
                  (=> (and (= (type |v#0@@79|) DatatypeTypeType)
                           (= (type |stampedBetree#0@@7|) DatatypeTypeType)
                           a!1)
                      a!8)))))
                :pattern ((PagedBetree.__default.Init
                            (Lit |v#0@@79|)
                            (Lit |stampedBetree#0@@7|)))
                :weight 3
                :skolemid |3464|
                :qid |PagedBetreeidfy.417:18|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@80| T@U)
             (|v'#0@@35| T@U)
             (|lbl#0@@39| T@U)
             (|step#0@@11| T@U))
      (! (let ((a!1 (and (= (type |v#0@@80|) DatatypeTypeType)
                         (= (type |v'#0@@35|) DatatypeTypeType)
                         (= (type |lbl#0@@39|) DatatypeTypeType)
                         (= (type |step#0@@11|) DatatypeTypeType)
                         (or (|PagedBetree.__default.NextStep#canCall|
                               |v#0@@80|
                               |v'#0@@35|
                               |lbl#0@@39|
                               |step#0@@11|)
                             (and ($Is |v#0@@80| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@35| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@39|
                                       Tclass.PagedBetree.TransitionLabel)
                                  ($Is |step#0@@11| Tclass.PagedBetree.Step))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.NextStep
                     |v#0@@80|
                     |v'#0@@35|
                     |lbl#0@@39|
                     |step#0@@11|))
         :skolemid |3465|
         :qid |PagedBetreeidfy.447:22|))))
(assert (forall ((|v#0@@81| T@U) (|v'#0@@36| T@U) (|lbl#0@@40| T@U) (|step#0@@12| T@U))
  (! (=> (and (= (type |v#0@@81|) DatatypeTypeType)
              (= (type |v'#0@@36|) DatatypeTypeType)
              (= (type |lbl#0@@40|) DatatypeTypeType)
              (= (type |step#0@@12|) DatatypeTypeType)
              ($Is |v#0@@81| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@36| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@40| Tclass.PagedBetree.TransitionLabel)
              ($Is |step#0@@12| Tclass.PagedBetree.Step))
         (= (|PagedBetree.__default.NextStep#requires|
              |v#0@@81|
              |v'#0@@36|
              |lbl#0@@40|
              |step#0@@12|)
            true))
     :pattern ((|PagedBetree.__default.NextStep#requires|
                 |v#0@@81|
                 |v'#0@@36|
                 |lbl#0@@40|
                 |step#0@@12|))
     :skolemid |3466|
     :qid |PagedBetreeidfy.447:22|)))
(assert (let ((a!1 (forall ((|v#0@@82| T@U)
                    (|v'#0@@37| T@U)
                    (|lbl#0@@41| T@U)
                    (|step#0@@13| T@U))
             (! (let ((a!1 (and (= (type |v#0@@82|) DatatypeTypeType)
                                (= (type |v'#0@@37|) DatatypeTypeType)
                                (= (type |lbl#0@@41|) DatatypeTypeType)
                                (= (type |step#0@@13|) DatatypeTypeType)
                                (or (|PagedBetree.__default.NextStep#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|
                                      |step#0@@13|)
                                    (and ($Is |v#0@@82|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@37|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@41|
                                              Tclass.PagedBetree.TransitionLabel)
                                         ($Is |step#0@@13|
                                              Tclass.PagedBetree.Step)))))
                      (a!2 (and (=> (PagedBetree.Step.InternalFlushStep_q
                                      |step#0@@13|)
                                    (|PagedBetree.__default.InternalFlush#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|
                                      |step#0@@13|))
                                (=> (not (PagedBetree.Step.InternalFlushStep_q
                                           |step#0@@13|))
                                    (|PagedBetree.__default.InternalCompact#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|
                                      |step#0@@13|))))
                      (a!10 (ite (PagedBetree.Step.InternalSplitStep_q
                                   |step#0@@13|)
                                 (PagedBetree.__default.InternalSplit
                                   |v#0@@82|
                                   |v'#0@@37|
                                   |lbl#0@@41|
                                   |step#0@@13|)
                                 (ite (PagedBetree.Step.InternalFlushMemtableStep_q
                                        |step#0@@13|)
                                      (PagedBetree.__default.InternalFlushMemtable
                                        |v#0@@82|
                                        |v'#0@@37|
                                        |lbl#0@@41|)
                                      (ite (PagedBetree.Step.InternalFlushStep_q
                                             |step#0@@13|)
                                           (PagedBetree.__default.InternalFlush
                                             |v#0@@82|
                                             |v'#0@@37|
                                             |lbl#0@@41|
                                             |step#0@@13|)
                                           (PagedBetree.__default.InternalCompact
                                             |v#0@@82|
                                             |v'#0@@37|
                                             |lbl#0@@41|
                                             |step#0@@13|))))))
                (let ((a!3 (and (=> (PagedBetree.Step.InternalFlushMemtableStep_q
                                      |step#0@@13|)
                                    (|PagedBetree.__default.InternalFlushMemtable#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|))
                                (=> (not (PagedBetree.Step.InternalFlushMemtableStep_q
                                           |step#0@@13|))
                                    a!2)))
                      (a!11 (ite (PagedBetree.Step.QueryEndLsnStep_q
                                   |step#0@@13|)
                                 (PagedBetree.__default.QueryEndLsn
                                   |v#0@@82|
                                   |v'#0@@37|
                                   |lbl#0@@41|)
                                 (ite (PagedBetree.Step.FreezeAsStep_q
                                        |step#0@@13|)
                                      (PagedBetree.__default.FreezeAs
                                        |v#0@@82|
                                        |v'#0@@37|
                                        |lbl#0@@41|)
                                      (ite (PagedBetree.Step.InternalGrowStep_q
                                             |step#0@@13|)
                                           (PagedBetree.__default.InternalGrow
                                             |v#0@@82|
                                             |v'#0@@37|
                                             |lbl#0@@41|)
                                           a!10)))))
                (let ((a!4 (and (=> (PagedBetree.Step.InternalSplitStep_q
                                      |step#0@@13|)
                                    (|PagedBetree.__default.InternalSplit#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|
                                      |step#0@@13|))
                                (=> (not (PagedBetree.Step.InternalSplitStep_q
                                           |step#0@@13|))
                                    a!3)))
                      (a!12 (and (PagedBetree.Step.WF |step#0@@13|)
                                 (ite (PagedBetree.Step.QueryStep_q
                                        |step#0@@13|)
                                      (PagedBetree.__default.Query
                                        |v#0@@82|
                                        |v'#0@@37|
                                        |lbl#0@@41|
                                        (PagedBetree.Step.receipt |step#0@@13|))
                                      (ite (PagedBetree.Step.PutStep_q
                                             |step#0@@13|)
                                           (PagedBetree.__default.Put
                                             |v#0@@82|
                                             |v'#0@@37|
                                             |lbl#0@@41|)
                                           a!11)))))
                (let ((a!5 (and (=> (PagedBetree.Step.InternalGrowStep_q
                                      |step#0@@13|)
                                    (|PagedBetree.__default.InternalGrow#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|))
                                (=> (not (PagedBetree.Step.InternalGrowStep_q
                                           |step#0@@13|))
                                    a!4))))
                (let ((a!6 (and (=> (PagedBetree.Step.FreezeAsStep_q
                                      |step#0@@13|)
                                    (|PagedBetree.__default.FreezeAs#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|))
                                (=> (not (PagedBetree.Step.FreezeAsStep_q
                                           |step#0@@13|))
                                    a!5))))
                (let ((a!7 (and (=> (PagedBetree.Step.QueryEndLsnStep_q
                                      |step#0@@13|)
                                    (|PagedBetree.__default.QueryEndLsn#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|))
                                (=> (not (PagedBetree.Step.QueryEndLsnStep_q
                                           |step#0@@13|))
                                    a!6))))
                (let ((a!8 (and (=> (PagedBetree.Step.PutStep_q |step#0@@13|)
                                    (|PagedBetree.__default.Put#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|))
                                (=> (not (PagedBetree.Step.PutStep_q
                                           |step#0@@13|))
                                    a!7))))
                (let ((a!9 (and (=> (PagedBetree.Step.QueryStep_q |step#0@@13|)
                                    (|PagedBetree.__default.Query#canCall|
                                      |v#0@@82|
                                      |v'#0@@37|
                                      |lbl#0@@41|
                                      (PagedBetree.Step.receipt |step#0@@13|)))
                                (=> (not (PagedBetree.Step.QueryStep_q
                                           |step#0@@13|))
                                    a!8))))
                  (=> a!1
                      (and (|PagedBetree.Step.WF#canCall| |step#0@@13|)
                           (=> (PagedBetree.Step.WF |step#0@@13|) a!9)
                           (= (PagedBetree.__default.NextStep
                                |v#0@@82|
                                |v'#0@@37|
                                |lbl#0@@41|
                                |step#0@@13|)
                              a!12)))))))))))
                :pattern ((PagedBetree.__default.NextStep
                            |v#0@@82|
                            |v'#0@@37|
                            |lbl#0@@41|
                            |step#0@@13|))
                :skolemid |3467|
                :qid |PagedBetreeidfy.447:22|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@83| T@U)
                    (|v'#0@@38| T@U)
                    (|lbl#0@@42| T@U)
                    (|step#0@@14| T@U))
             (! (let ((a!1 (and (= (type |v#0@@83|) DatatypeTypeType)
                                (= (type |v'#0@@38|) DatatypeTypeType)
                                (= (type |lbl#0@@42|) DatatypeTypeType)
                                (= (type |step#0@@14|) DatatypeTypeType)
                                (or (|PagedBetree.__default.NextStep#canCall|
                                      (Lit |v#0@@83|)
                                      (Lit |v'#0@@38|)
                                      (Lit |lbl#0@@42|)
                                      (Lit |step#0@@14|))
                                    (and ($Is |v#0@@83|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@38|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@42|
                                              Tclass.PagedBetree.TransitionLabel)
                                         ($Is |step#0@@14|
                                              Tclass.PagedBetree.Step)))))
                      (a!2 (Lit (bool_2_U (PagedBetree.Step.WF
                                            (Lit |step#0@@14|)))))
                      (a!3 (Lit (bool_2_U (PagedBetree.Step.QueryStep_q
                                            (Lit |step#0@@14|)))))
                      (a!4 (|PagedBetree.__default.Query#canCall|
                             (Lit |v#0@@83|)
                             (Lit |v'#0@@38|)
                             (Lit |lbl#0@@42|)
                             (Lit (PagedBetree.Step.receipt (Lit |step#0@@14|)))))
                      (a!5 (Lit (bool_2_U (PagedBetree.Step.PutStep_q
                                            (Lit |step#0@@14|)))))
                      (a!6 (Lit (bool_2_U (PagedBetree.Step.QueryEndLsnStep_q
                                            (Lit |step#0@@14|)))))
                      (a!7 (Lit (bool_2_U (PagedBetree.Step.FreezeAsStep_q
                                            (Lit |step#0@@14|)))))
                      (a!8 (Lit (bool_2_U (PagedBetree.Step.InternalGrowStep_q
                                            (Lit |step#0@@14|)))))
                      (a!9 (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q
                                            (Lit |step#0@@14|)))))
                      (a!10 (Lit (bool_2_U (PagedBetree.Step.InternalFlushMemtableStep_q
                                             (Lit |step#0@@14|)))))
                      (a!11 (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q
                                             (Lit |step#0@@14|)))))
                      (a!20 (PagedBetree.__default.Query
                              (Lit |v#0@@83|)
                              (Lit |v'#0@@38|)
                              (Lit |lbl#0@@42|)
                              (Lit (PagedBetree.Step.receipt (Lit |step#0@@14|)))))
                      (a!21 (ite (PagedBetree.Step.InternalFlushMemtableStep_q
                                   (Lit |step#0@@14|))
                                 (PagedBetree.__default.InternalFlushMemtable
                                   (Lit |v#0@@83|)
                                   (Lit |v'#0@@38|)
                                   (Lit |lbl#0@@42|))
                                 (ite (PagedBetree.Step.InternalFlushStep_q
                                        (Lit |step#0@@14|))
                                      (PagedBetree.__default.InternalFlush
                                        (Lit |v#0@@83|)
                                        (Lit |v'#0@@38|)
                                        (Lit |lbl#0@@42|)
                                        (Lit |step#0@@14|))
                                      (PagedBetree.__default.InternalCompact
                                        (Lit |v#0@@83|)
                                        (Lit |v'#0@@38|)
                                        (Lit |lbl#0@@42|)
                                        (Lit |step#0@@14|))))))
                (let ((a!12 (and (=> (U_2_bool a!11)
                                     (|PagedBetree.__default.InternalFlush#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)
                                       (Lit |step#0@@14|)))
                                 (=> (not (U_2_bool a!11))
                                     (|PagedBetree.__default.InternalCompact#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)
                                       (Lit |step#0@@14|)))))
                      (a!22 (ite (PagedBetree.Step.InternalGrowStep_q
                                   (Lit |step#0@@14|))
                                 (PagedBetree.__default.InternalGrow
                                   (Lit |v#0@@83|)
                                   (Lit |v'#0@@38|)
                                   (Lit |lbl#0@@42|))
                                 (ite (PagedBetree.Step.InternalSplitStep_q
                                        (Lit |step#0@@14|))
                                      (PagedBetree.__default.InternalSplit
                                        (Lit |v#0@@83|)
                                        (Lit |v'#0@@38|)
                                        (Lit |lbl#0@@42|)
                                        (Lit |step#0@@14|))
                                      a!21))))
                (let ((a!13 (and (=> (U_2_bool a!10)
                                     (|PagedBetree.__default.InternalFlushMemtable#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)))
                                 (=> (not (U_2_bool a!10)) a!12)))
                      (a!23 (ite (PagedBetree.Step.QueryEndLsnStep_q
                                   (Lit |step#0@@14|))
                                 (PagedBetree.__default.QueryEndLsn
                                   (Lit |v#0@@83|)
                                   (Lit |v'#0@@38|)
                                   (Lit |lbl#0@@42|))
                                 (ite (PagedBetree.Step.FreezeAsStep_q
                                        (Lit |step#0@@14|))
                                      (PagedBetree.__default.FreezeAs
                                        (Lit |v#0@@83|)
                                        (Lit |v'#0@@38|)
                                        (Lit |lbl#0@@42|))
                                      a!22))))
                (let ((a!14 (and (=> (U_2_bool a!9)
                                     (|PagedBetree.__default.InternalSplit#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)
                                       (Lit |step#0@@14|)))
                                 (=> (not (U_2_bool a!9)) a!13)))
                      (a!24 (ite (PagedBetree.Step.QueryStep_q
                                   (Lit |step#0@@14|))
                                 (U_2_bool (Lit (bool_2_U a!20)))
                                 (ite (PagedBetree.Step.PutStep_q
                                        (Lit |step#0@@14|))
                                      (PagedBetree.__default.Put
                                        (Lit |v#0@@83|)
                                        (Lit |v'#0@@38|)
                                        (Lit |lbl#0@@42|))
                                      a!23))))
                (let ((a!15 (and (=> (U_2_bool a!8)
                                     (|PagedBetree.__default.InternalGrow#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)))
                                 (=> (not (U_2_bool a!8)) a!14)))
                      (a!25 (= (PagedBetree.__default.NextStep
                                 (Lit |v#0@@83|)
                                 (Lit |v'#0@@38|)
                                 (Lit |lbl#0@@42|)
                                 (Lit |step#0@@14|))
                               (and (PagedBetree.Step.WF (Lit |step#0@@14|))
                                    a!24))))
                (let ((a!16 (and (=> (U_2_bool a!7)
                                     (|PagedBetree.__default.FreezeAs#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)))
                                 (=> (not (U_2_bool a!7)) a!15))))
                (let ((a!17 (and (=> (U_2_bool a!6)
                                     (|PagedBetree.__default.QueryEndLsn#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)))
                                 (=> (not (U_2_bool a!6)) a!16))))
                (let ((a!18 (and (=> (U_2_bool a!5)
                                     (|PagedBetree.__default.Put#canCall|
                                       (Lit |v#0@@83|)
                                       (Lit |v'#0@@38|)
                                       (Lit |lbl#0@@42|)))
                                 (=> (not (U_2_bool a!5)) a!17))))
                (let ((a!19 (and (=> (U_2_bool a!3) a!4)
                                 (=> (not (U_2_bool a!3)) a!18))))
                  (=> a!1
                      (and (|PagedBetree.Step.WF#canCall| (Lit |step#0@@14|))
                           (=> (U_2_bool a!2) a!19)
                           a!25)))))))))))
                :pattern ((PagedBetree.__default.NextStep
                            (Lit |v#0@@83|)
                            (Lit |v'#0@@38|)
                            (Lit |lbl#0@@42|)
                            (Lit |step#0@@14|)))
                :weight 3
                :skolemid |3468|
                :qid |PagedBetreeidfy.447:22|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@84| T@U) (|v'#0@@39| T@U) (|lbl#0@@43| T@U))
      (! (let ((a!1 (and (= (type |v#0@@84|) DatatypeTypeType)
                         (= (type |v'#0@@39|) DatatypeTypeType)
                         (= (type |lbl#0@@43|) DatatypeTypeType)
                         (or (|PagedBetree.__default.Next#canCall|
                               |v#0@@84|
                               |v'#0@@39|
                               |lbl#0@@43|)
                             (and ($Is |v#0@@84| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@39| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@43|
                                       Tclass.PagedBetree.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((PagedBetree.__default.Next |v#0@@84| |v'#0@@39| |lbl#0@@43|))
         :skolemid |3469|
         :qid |PagedBetreeidfy.463:18|))))
(assert (forall ((|v#0@@85| T@U) (|v'#0@@40| T@U) (|lbl#0@@44| T@U))
  (! (=> (and (= (type |v#0@@85|) DatatypeTypeType)
              (= (type |v'#0@@40|) DatatypeTypeType)
              (= (type |lbl#0@@44|) DatatypeTypeType)
              ($Is |v#0@@85| Tclass.PagedBetree.Variables)
              ($Is |v'#0@@40| Tclass.PagedBetree.Variables)
              ($Is |lbl#0@@44| Tclass.PagedBetree.TransitionLabel))
         (= (|PagedBetree.__default.Next#requires|
              |v#0@@85|
              |v'#0@@40|
              |lbl#0@@44|)
            true))
     :pattern ((|PagedBetree.__default.Next#requires|
                 |v#0@@85|
                 |v'#0@@40|
                 |lbl#0@@44|))
     :skolemid |3470|
     :qid |PagedBetreeidfy.463:18|)))
(assert (let ((a!1 (forall ((|v#0@@86| T@U) (|v'#0@@41| T@U) (|lbl#0@@45| T@U))
             (! (let ((a!1 (and (= (type |v#0@@86|) DatatypeTypeType)
                                (= (type |v'#0@@41|) DatatypeTypeType)
                                (= (type |lbl#0@@45|) DatatypeTypeType)
                                (or (|PagedBetree.__default.Next#canCall|
                                      |v#0@@86|
                                      |v'#0@@41|
                                      |lbl#0@@45|)
                                    (and ($Is |v#0@@86|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |v'#0@@41|
                                              Tclass.PagedBetree.Variables)
                                         ($Is |lbl#0@@45|
                                              Tclass.PagedBetree.TransitionLabel)))))
                      (a!2 (forall ((|step#0@@15| T@U))
                             (! (=> (and (= (type |step#0@@15|)
                                            DatatypeTypeType)
                                         ($Is |step#0@@15|
                                              Tclass.PagedBetree.Step))
                                    (|PagedBetree.__default.NextStep#canCall|
                                      |v#0@@86|
                                      |v'#0@@41|
                                      |lbl#0@@45|
                                      |step#0@@15|))
                                :pattern ((PagedBetree.__default.NextStep
                                            |v#0@@86|
                                            |v'#0@@41|
                                            |lbl#0@@45|
                                            |step#0@@15|))
                                :skolemid |3472|
                                :qid |PagedBetreeidfy.464:12|)))
                      (a!3 (exists ((|step#0@@16| T@U))
                             (! (and (= (type |step#0@@16|) DatatypeTypeType)
                                     ($Is |step#0@@16| Tclass.PagedBetree.Step)
                                     (PagedBetree.__default.NextStep
                                       |v#0@@86|
                                       |v'#0@@41|
                                       |lbl#0@@45|
                                       |step#0@@16|))
                                :pattern ((PagedBetree.__default.NextStep
                                            |v#0@@86|
                                            |v'#0@@41|
                                            |lbl#0@@45|
                                            |step#0@@16|))
                                :skolemid |3471|
                                :qid |PagedBetreeidfy.464:12|))))
                  (=> a!1
                      (and a!2
                           (= (PagedBetree.__default.Next
                                |v#0@@86|
                                |v'#0@@41|
                                |lbl#0@@45|)
                              a!3))))
                :pattern ((PagedBetree.__default.Next
                            |v#0@@86|
                            |v'#0@@41|
                            |lbl#0@@45|))
                :skolemid |3473|
                :qid |PagedBetreeidfy.463:18|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@87| T@U) (|v'#0@@42| T@U) (|lbl#0@@46| T@U))
      (! (let ((a!1 (and (= (type |v#0@@87|) DatatypeTypeType)
                         (= (type |v'#0@@42|) DatatypeTypeType)
                         (= (type |lbl#0@@46|) DatatypeTypeType)
                         (or (|PagedBetree.__default.Next#canCall|
                               (Lit |v#0@@87|)
                               (Lit |v'#0@@42|)
                               (Lit |lbl#0@@46|))
                             (and ($Is |v#0@@87| Tclass.PagedBetree.Variables)
                                  ($Is |v'#0@@42| Tclass.PagedBetree.Variables)
                                  ($Is |lbl#0@@46|
                                       Tclass.PagedBetree.TransitionLabel)))))
               (a!2 (forall ((|step#1| T@U))
                      (! (=> (and (= (type |step#1|) DatatypeTypeType)
                                  ($Is |step#1| Tclass.PagedBetree.Step))
                             (|PagedBetree.__default.NextStep#canCall|
                               (Lit |v#0@@87|)
                               (Lit |v'#0@@42|)
                               (Lit |lbl#0@@46|)
                               |step#1|))
                         :pattern ((PagedBetree.__default.NextStep
                                     |v#0@@87|
                                     |v'#0@@42|
                                     |lbl#0@@46|
                                     |step#1|))
                         :skolemid |3475|
                         :qid |PagedBetreeidfy.464:12|)))
               (a!3 (exists ((|step#1@@0| T@U))
                      (! (and (= (type |step#1@@0|) DatatypeTypeType)
                              ($Is |step#1@@0| Tclass.PagedBetree.Step)
                              (PagedBetree.__default.NextStep
                                (Lit |v#0@@87|)
                                (Lit |v'#0@@42|)
                                (Lit |lbl#0@@46|)
                                |step#1@@0|))
                         :pattern ((PagedBetree.__default.NextStep
                                     |v#0@@87|
                                     |v'#0@@42|
                                     |lbl#0@@46|
                                     |step#1@@0|))
                         :skolemid |3474|
                         :qid |PagedBetreeidfy.464:12|))))
         (let ((a!4 (and a!2
                         (= (PagedBetree.__default.Next
                              (Lit |v#0@@87|)
                              (Lit |v'#0@@42|)
                              (Lit |lbl#0@@46|))
                            a!3))))
           (=> a!1 a!4)))
         :pattern ((PagedBetree.__default.Next
                     (Lit |v#0@@87|)
                     (Lit |v'#0@@42|)
                     (Lit |lbl#0@@46|)))
         :weight 3
         :skolemid |3476|
         :qid |PagedBetreeidfy.463:18|))))
(assert (forall ((|a#0#0#0@@12| Int) (|a#0#1#0@@8| T@U) (|a#0#2#0@@2| T@U))
  (! (=> (and (= (type |a#0#1#0@@8|) (SeqType BoxType))
              (= (type |a#0#2#0@@2|) (SeqType BoxType)))
         (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.QueryLabel|
                              |a#0#0#0@@12|
                              |a#0#1#0@@8|
                              |a#0#2#0@@2|))
            |##AbstractMap.TransitionLabel.QueryLabel|))
     :pattern ((|#AbstractMap.TransitionLabel.QueryLabel|
                 |a#0#0#0@@12|
                 |a#0#1#0@@8|
                 |a#0#2#0@@2|))
     :skolemid |3477|
     :qid |AbstractMapidfy.16:18|)))
(assert (forall ((d@@162 T@U))
  (! (=> (= (type d@@162) DatatypeTypeType)
         (= (AbstractMap.TransitionLabel.QueryLabel_q d@@162)
            (= (DatatypeCtorId d@@162)
               |##AbstractMap.TransitionLabel.QueryLabel|)))
     :pattern ((AbstractMap.TransitionLabel.QueryLabel_q d@@162))
     :skolemid |3478|
     :qid |unknown.0:0|)))
(assert (forall ((d@@163 T@U))
  (! (let ((a!1 (exists ((|a#1#0#0@@12| Int)
                         (|a#1#1#0@@8| T@U)
                         (|a#1#2#0@@2| T@U))
                  (! (and (= (type |a#1#1#0@@8|) (SeqType BoxType))
                          (= (type |a#1#2#0@@2|) (SeqType BoxType))
                          (= d@@163
                             (|#AbstractMap.TransitionLabel.QueryLabel|
                               |a#1#0#0@@12|
                               |a#1#1#0@@8|
                               |a#1#2#0@@2|)))
                     :no-pattern (type |a#1#1#0@@8|)
                     :no-pattern (type |a#1#2#0@@2|)
                     :no-pattern (U_2_int |a#1#1#0@@8|)
                     :no-pattern (U_2_bool |a#1#1#0@@8|)
                     :no-pattern (U_2_int |a#1#2#0@@2|)
                     :no-pattern (U_2_bool |a#1#2#0@@2|)
                     :skolemid |3479|
                     :qid |AbstractMapidfy.16:18|))))
       (=> (and (= (type d@@163) DatatypeTypeType)
                (AbstractMap.TransitionLabel.QueryLabel_q d@@163))
           a!1))
     :pattern ((AbstractMap.TransitionLabel.QueryLabel_q d@@163))
     :skolemid |3480|
     :qid |unknown.0:0|)))
(assert (forall ((|a#2#0#0@@12| Int) (|a#2#1#0@@8| T@U) (|a#2#2#0@@2| T@U))
  (! (let ((a!1 (= ($Is (|#AbstractMap.TransitionLabel.QueryLabel|
                          |a#2#0#0@@12|
                          |a#2#1#0@@8|
                          |a#2#2#0@@2|)
                        Tclass.AbstractMap.TransitionLabel)
                   (and ($Is (int_2_U |a#2#0#0@@12|) Tclass._System.nat)
                        ($Is |a#2#1#0@@8| Tclass.KeyType.Key)
                        ($Is |a#2#2#0@@2| Tclass.ValueType.Value)))))
       (=> (and (= (type |a#2#1#0@@8|) (SeqType BoxType))
                (= (type |a#2#2#0@@2|) (SeqType BoxType)))
           a!1))
     :pattern (($Is (|#AbstractMap.TransitionLabel.QueryLabel|
                      |a#2#0#0@@12|
                      |a#2#1#0@@8|
                      |a#2#2#0@@2|)
                    Tclass.AbstractMap.TransitionLabel))
     :skolemid |3481|
     :qid |AbstractMapidfy.16:18|)))
(assert (forall ((|a#3#0#0@@12| Int)
         (|a#3#1#0@@8| T@U)
         (|a#3#2#0@@2| T@U)
         ($h@@159 T@U))
  (! (let ((a!1 (= ($IsAlloc (|#AbstractMap.TransitionLabel.QueryLabel|
                               |a#3#0#0@@12|
                               |a#3#1#0@@8|
                               |a#3#2#0@@2|)
                             Tclass.AbstractMap.TransitionLabel
                             $h@@159)
                   (and ($IsAlloc (int_2_U |a#3#0#0@@12|)
                                  Tclass._System.nat
                                  $h@@159)
                        ($IsAlloc |a#3#1#0@@8| Tclass.KeyType.Key $h@@159)
                        ($IsAlloc |a#3#2#0@@2| Tclass.ValueType.Value $h@@159)))))
       (=> (and (= (type |a#3#1#0@@8|) (SeqType BoxType))
                (= (type |a#3#2#0@@2|) (SeqType BoxType))
                (= (type $h@@159) (MapType0Type refType MapType1Type))
                ($IsGoodHeap $h@@159))
           a!1))
     :pattern (($IsAlloc (|#AbstractMap.TransitionLabel.QueryLabel|
                           |a#3#0#0@@12|
                           |a#3#1#0@@8|
                           |a#3#2#0@@2|)
                         Tclass.AbstractMap.TransitionLabel
                         $h@@159))
     :skolemid |3482|
     :qid |AbstractMapidfy.16:18|)))
(assert (forall ((d@@164 T@U) ($h@@160 T@U))
  (! (=> (and (= (type d@@164) DatatypeTypeType)
              (= (type $h@@160) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@160)
              (AbstractMap.TransitionLabel.QueryLabel_q d@@164)
              ($IsAlloc d@@164 Tclass.AbstractMap.TransitionLabel $h@@160))
         ($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@164))
                   Tclass._System.nat
                   $h@@160))
     :pattern (($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@164))
                         Tclass._System.nat
                         $h@@160))
     :skolemid |3483|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@599 T@U))
  (! (= (type (AbstractMap.TransitionLabel.key arg0@@599)) (SeqType BoxType))
     :pattern ((AbstractMap.TransitionLabel.key arg0@@599))
     :qid |funType:AbstractMap.TransitionLabel.key|)))
(assert (forall ((d@@165 T@U) ($h@@161 T@U))
  (! (=> (and (= (type d@@165) DatatypeTypeType)
              (= (type $h@@161) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@161)
              (AbstractMap.TransitionLabel.QueryLabel_q d@@165)
              ($IsAlloc d@@165 Tclass.AbstractMap.TransitionLabel $h@@161))
         ($IsAlloc (AbstractMap.TransitionLabel.key d@@165)
                   Tclass.KeyType.Key
                   $h@@161))
     :pattern (($IsAlloc (AbstractMap.TransitionLabel.key d@@165)
                         Tclass.KeyType.Key
                         $h@@161))
     :skolemid |3484|
     :qid |unknown.0:0|)))
(assert (forall ((arg0@@600 T@U))
  (! (= (type (AbstractMap.TransitionLabel.value arg0@@600)) (SeqType BoxType))
     :pattern ((AbstractMap.TransitionLabel.value arg0@@600))
     :qid |funType:AbstractMap.TransitionLabel.value|)))
(assert (forall ((d@@166 T@U) ($h@@162 T@U))
  (! (=> (and (= (type d@@166) DatatypeTypeType)
              (= (type $h@@162) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@162)
              (AbstractMap.TransitionLabel.QueryLabel_q d@@166)
              ($IsAlloc d@@166 Tclass.AbstractMap.TransitionLabel $h@@162))
         ($IsAlloc (AbstractMap.TransitionLabel.value d@@166)
                   Tclass.ValueType.Value
                   $h@@162))
     :pattern (($IsAlloc (AbstractMap.TransitionLabel.value d@@166)
                         Tclass.ValueType.Value
                         $h@@162))
     :skolemid |3485|
     :qid |unknown.0:0|)))
(assert (forall ((|a#4#0#0@@12| Int) (|a#4#1#0@@8| T@U) (|a#4#2#0@@2| T@U))
  (! (=> (and (= (type |a#4#1#0@@8|) (SeqType BoxType))
              (= (type |a#4#2#0@@2|) (SeqType BoxType)))
         (= (|#AbstractMap.TransitionLabel.QueryLabel|
              (LitInt |a#4#0#0@@12|)
              (Lit |a#4#1#0@@8|)
              (Lit |a#4#2#0@@2|))
            (Lit (|#AbstractMap.TransitionLabel.QueryLabel|
                   |a#4#0#0@@12|
                   |a#4#1#0@@8|
                   |a#4#2#0@@2|))))
     :pattern ((|#AbstractMap.TransitionLabel.QueryLabel|
                 (LitInt |a#4#0#0@@12|)
                 (Lit |a#4#1#0@@8|)
                 (Lit |a#4#2#0@@2|)))
     :skolemid |3486|
     :qid |AbstractMapidfy.16:18|)))
(assert (forall ((|a#5#0#0@@14| Int) (|a#5#1#0@@9| T@U) (|a#5#2#0@@2| T@U))
  (! (=> (and (= (type |a#5#1#0@@9|) (SeqType BoxType))
              (= (type |a#5#2#0@@2|) (SeqType BoxType)))
         (= (AbstractMap.TransitionLabel.endLsn
              (|#AbstractMap.TransitionLabel.QueryLabel|
                |a#5#0#0@@14|
                |a#5#1#0@@9|
                |a#5#2#0@@2|))
            |a#5#0#0@@14|))
     :pattern ((|#AbstractMap.TransitionLabel.QueryLabel|
                 |a#5#0#0@@14|
                 |a#5#1#0@@9|
                 |a#5#2#0@@2|))
     :skolemid |3487|
     :qid |AbstractMapidfy.16:18|)))
(assert (forall ((|a#6#0#0@@14| Int) (|a#6#1#0@@9| T@U) (|a#6#2#0@@2| T@U))
  (! (=> (and (= (type |a#6#1#0@@9|) (SeqType BoxType))
              (= (type |a#6#2#0@@2|) (SeqType BoxType)))
         (= (AbstractMap.TransitionLabel.key
              (|#AbstractMap.TransitionLabel.QueryLabel|
                |a#6#0#0@@14|
                |a#6#1#0@@9|
                |a#6#2#0@@2|))
            |a#6#1#0@@9|))
     :pattern ((|#AbstractMap.TransitionLabel.QueryLabel|
                 |a#6#0#0@@14|
                 |a#6#1#0@@9|
                 |a#6#2#0@@2|))
     :skolemid |3488|
     :qid |AbstractMapidfy.16:18|)))
(assert (forall ((|a#7#0#0@@13| Int) (|a#7#1#0@@9| T@U) (|a#7#2#0@@2| T@U))
  (! (=> (and (= (type |a#7#1#0@@9|) (SeqType BoxType))
              (= (type |a#7#2#0@@2|) (SeqType BoxType)))
         (= (AbstractMap.TransitionLabel.value
              (|#AbstractMap.TransitionLabel.QueryLabel|
                |a#7#0#0@@13|
                |a#7#1#0@@9|
                |a#7#2#0@@2|))
            |a#7#2#0@@2|))
     :pattern ((|#AbstractMap.TransitionLabel.QueryLabel|
                 |a#7#0#0@@13|
                 |a#7#1#0@@9|
                 |a#7#2#0@@2|))
     :skolemid |3489|
     :qid |AbstractMapidfy.16:18|)))
(assert (forall ((|a#8#0#0@@10| T@U))
  (! (=> (= (type |a#8#0#0@@10|) DatatypeTypeType)
         (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.PutLabel|
                              |a#8#0#0@@10|))
            |##AbstractMap.TransitionLabel.PutLabel|))
     :pattern ((|#AbstractMap.TransitionLabel.PutLabel| |a#8#0#0@@10|))
     :skolemid |3490|
     :qid |AbstractMapidfy.17:16|)))
(assert (forall ((d@@167 T@U))
  (! (=> (= (type d@@167) DatatypeTypeType)
         (= (AbstractMap.TransitionLabel.PutLabel_q d@@167)
            (= (DatatypeCtorId d@@167) |##AbstractMap.TransitionLabel.PutLabel|)))
     :pattern ((AbstractMap.TransitionLabel.PutLabel_q d@@167))
     :skolemid |3491|
     :qid |unknown.0:0|)))
(assert (forall ((d@@168 T@U))
  (! (let ((a!1 (exists ((|a#9#0#0@@6| T@U))
                  (! (and (= (type |a#9#0#0@@6|) DatatypeTypeType)
                          (= d@@168
                             (|#AbstractMap.TransitionLabel.PutLabel|
                               |a#9#0#0@@6|)))
                     :no-pattern (type |a#9#0#0@@6|)
                     :no-pattern (U_2_int |a#9#0#0@@6|)
                     :no-pattern (U_2_bool |a#9#0#0@@6|)
                     :skolemid |3492|
                     :qid |AbstractMapidfy.17:16|))))
       (=> (and (= (type d@@168) DatatypeTypeType)
                (AbstractMap.TransitionLabel.PutLabel_q d@@168))
           a!1))
     :pattern ((AbstractMap.TransitionLabel.PutLabel_q d@@168))
     :skolemid |3493|
     :qid |unknown.0:0|)))
(assert (forall ((|a#10#0#0@@6| T@U))
  (! (=> (= (type |a#10#0#0@@6|) DatatypeTypeType)
         (= ($Is (|#AbstractMap.TransitionLabel.PutLabel| |a#10#0#0@@6|)
                 Tclass.AbstractMap.TransitionLabel)
            ($Is |a#10#0#0@@6| Tclass.MsgHistoryMod.MsgHistory)))
     :pattern (($Is (|#AbstractMap.TransitionLabel.PutLabel| |a#10#0#0@@6|)
                    Tclass.AbstractMap.TransitionLabel))
     :skolemid |3494|
     :qid |AbstractMapidfy.17:16|)))
(assert (forall ((|a#11#0#0@@4| T@U) ($h@@163 T@U))
  (! (=> (and (= (type |a#11#0#0@@4|) DatatypeTypeType)
              (= (type $h@@163) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@163))
         (= ($IsAlloc (|#AbstractMap.TransitionLabel.PutLabel| |a#11#0#0@@4|)
                      Tclass.AbstractMap.TransitionLabel
                      $h@@163)
            ($IsAlloc |a#11#0#0@@4| Tclass.MsgHistoryMod.MsgHistory $h@@163)))
     :pattern (($IsAlloc (|#AbstractMap.TransitionLabel.PutLabel| |a#11#0#0@@4|)
                         Tclass.AbstractMap.TransitionLabel
                         $h@@163))
     :skolemid |3495|
     :qid |AbstractMapidfy.17:16|)))
(assert (forall ((arg0@@601 T@U))
  (! (= (type (AbstractMap.TransitionLabel.puts arg0@@601)) DatatypeTypeType)
     :pattern ((AbstractMap.TransitionLabel.puts arg0@@601))
     :qid |funType:AbstractMap.TransitionLabel.puts|)))
(assert (forall ((d@@169 T@U) ($h@@164 T@U))
  (! (=> (and (= (type d@@169) DatatypeTypeType)
              (= (type $h@@164) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@164)
              (AbstractMap.TransitionLabel.PutLabel_q d@@169)
              ($IsAlloc d@@169 Tclass.AbstractMap.TransitionLabel $h@@164))
         ($IsAlloc (AbstractMap.TransitionLabel.puts d@@169)
                   Tclass.MsgHistoryMod.MsgHistory
                   $h@@164))
     :pattern (($IsAlloc (AbstractMap.TransitionLabel.puts d@@169)
                         Tclass.MsgHistoryMod.MsgHistory
                         $h@@164))
     :skolemid |3496|
     :qid |unknown.0:0|)))
(assert (forall ((|a#12#0#0@@3| T@U))
  (! (=> (= (type |a#12#0#0@@3|) DatatypeTypeType)
         (= (|#AbstractMap.TransitionLabel.PutLabel| (Lit |a#12#0#0@@3|))
            (Lit (|#AbstractMap.TransitionLabel.PutLabel| |a#12#0#0@@3|))))
     :pattern ((|#AbstractMap.TransitionLabel.PutLabel| (Lit |a#12#0#0@@3|)))
     :skolemid |3497|
     :qid |AbstractMapidfy.17:16|)))
(assert (forall ((|a#13#0#0@@2| T@U))
  (! (=> (= (type |a#13#0#0@@2|) DatatypeTypeType)
         (= (AbstractMap.TransitionLabel.puts
              (|#AbstractMap.TransitionLabel.PutLabel| |a#13#0#0@@2|))
            |a#13#0#0@@2|))
     :pattern ((|#AbstractMap.TransitionLabel.PutLabel| |a#13#0#0@@2|))
     :skolemid |3498|
     :qid |AbstractMapidfy.17:16|)))
(assert (forall ((|a#14#0#0@@2| T@U))
  (! (=> (= (type |a#14#0#0@@2|) DatatypeTypeType)
         (< (DtRank |a#14#0#0@@2|)
            (DtRank (|#AbstractMap.TransitionLabel.PutLabel| |a#14#0#0@@2|))))
     :pattern ((|#AbstractMap.TransitionLabel.PutLabel| |a#14#0#0@@2|))
     :skolemid |3499|
     :qid |AbstractMapidfy.17:16|)))
(assert (forall ((|a#15#0#0@@2| Int))
  (! (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                          |a#15#0#0@@2|))
        |##AbstractMap.TransitionLabel.QueryEndLsnLabel|)
     :pattern ((|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#15#0#0@@2|))
     :skolemid |3500|
     :qid |AbstractMapidfy.18:24|)))
(assert (forall ((d@@170 T@U))
  (! (=> (= (type d@@170) DatatypeTypeType)
         (= (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@170)
            (= (DatatypeCtorId d@@170)
               |##AbstractMap.TransitionLabel.QueryEndLsnLabel|)))
     :pattern ((AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@170))
     :skolemid |3501|
     :qid |unknown.0:0|)))
(assert (forall ((d@@171 T@U))
  (! (=> (and (= (type d@@171) DatatypeTypeType)
              (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@171))
         (exists ((|a#16#0#0@@2| Int))
           (! (= d@@171
                 (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#16#0#0@@2|))
              :skolemid |3502|
              :qid |AbstractMapidfy.18:24|)))
     :pattern ((AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@171))
     :skolemid |3503|
     :qid |unknown.0:0|)))
(assert (forall ((|a#17#0#0@@2| Int))
  (! (= ($Is (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#17#0#0@@2|)
             Tclass.AbstractMap.TransitionLabel)
        ($Is (int_2_U |a#17#0#0@@2|) Tclass._System.nat))
     :pattern (($Is (|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                      |a#17#0#0@@2|)
                    Tclass.AbstractMap.TransitionLabel))
     :skolemid |3504|
     :qid |AbstractMapidfy.18:24|)))
(assert (forall ((|a#18#0#0@@1| Int) ($h@@165 T@U))
  (! (=> (and (= (type $h@@165) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@165))
         (= ($IsAlloc (|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                        |a#18#0#0@@1|)
                      Tclass.AbstractMap.TransitionLabel
                      $h@@165)
            ($IsAlloc (int_2_U |a#18#0#0@@1|) Tclass._System.nat $h@@165)))
     :pattern (($IsAlloc (|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                           |a#18#0#0@@1|)
                         Tclass.AbstractMap.TransitionLabel
                         $h@@165))
     :skolemid |3505|
     :qid |AbstractMapidfy.18:24|)))
(assert (forall ((d@@172 T@U) ($h@@166 T@U))
  (! (=> (and (= (type d@@172) DatatypeTypeType)
              (= (type $h@@166) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@166)
              (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@172)
              ($IsAlloc d@@172 Tclass.AbstractMap.TransitionLabel $h@@166))
         ($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@172))
                   Tclass._System.nat
                   $h@@166))
     :pattern (($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@172))
                         Tclass._System.nat
                         $h@@166))
     :skolemid |3506|
     :qid |unknown.0:0|)))
(assert (forall ((|a#19#0#0@@1| Int))
  (! (= (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| (LitInt |a#19#0#0@@1|))
        (Lit (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#19#0#0@@1|)))
     :pattern ((|#AbstractMap.TransitionLabel.QueryEndLsnLabel|
                 (LitInt |a#19#0#0@@1|)))
     :skolemid |3507|
     :qid |AbstractMapidfy.18:24|)))
(assert (forall ((|a#20#0#0@@1| Int))
  (! (= (AbstractMap.TransitionLabel.endLsn
          (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@1|))
        |a#20#0#0@@1|)
     :pattern ((|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@1|))
     :skolemid |3508|
     :qid |AbstractMapidfy.18:24|)))
(assert (forall ((|a#21#0#0@@1| T@U))
  (! (=> (= (type |a#21#0#0@@1|) DatatypeTypeType)
         (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.FreezeAsLabel|
                              |a#21#0#0@@1|))
            |##AbstractMap.TransitionLabel.FreezeAsLabel|))
     :pattern ((|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#21#0#0@@1|))
     :skolemid |3509|
     :qid |AbstractMapidfy.19:21|)))
(assert (forall ((d@@173 T@U))
  (! (=> (= (type d@@173) DatatypeTypeType)
         (= (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@173)
            (= (DatatypeCtorId d@@173)
               |##AbstractMap.TransitionLabel.FreezeAsLabel|)))
     :pattern ((AbstractMap.TransitionLabel.FreezeAsLabel_q d@@173))
     :skolemid |3510|
     :qid |unknown.0:0|)))
(assert (forall ((d@@174 T@U))
  (! (let ((a!1 (exists ((|a#22#0#0@@1| T@U))
                  (! (and (= (type |a#22#0#0@@1|) DatatypeTypeType)
                          (= d@@174
                             (|#AbstractMap.TransitionLabel.FreezeAsLabel|
                               |a#22#0#0@@1|)))
                     :no-pattern (type |a#22#0#0@@1|)
                     :no-pattern (U_2_int |a#22#0#0@@1|)
                     :no-pattern (U_2_bool |a#22#0#0@@1|)
                     :skolemid |3511|
                     :qid |AbstractMapidfy.19:21|))))
       (=> (and (= (type d@@174) DatatypeTypeType)
                (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@174))
           a!1))
     :pattern ((AbstractMap.TransitionLabel.FreezeAsLabel_q d@@174))
     :skolemid |3512|
     :qid |unknown.0:0|)))
(assert (forall ((|a#23#0#0@@0| T@U))
  (! (=> (= (type |a#23#0#0@@0|) DatatypeTypeType)
         (= ($Is (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#23#0#0@@0|)
                 Tclass.AbstractMap.TransitionLabel)
            ($Is |a#23#0#0@@0|
                 (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))
     :pattern (($Is (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#23#0#0@@0|)
                    Tclass.AbstractMap.TransitionLabel))
     :skolemid |3513|
     :qid |AbstractMapidfy.19:21|)))
(assert (forall ((|a#24#0#0@@0| T@U) ($h@@167 T@U))
  (! (=> (and (= (type |a#24#0#0@@0|) DatatypeTypeType)
              (= (type $h@@167) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@167))
         (= ($IsAlloc (|#AbstractMap.TransitionLabel.FreezeAsLabel|
                        |a#24#0#0@@0|)
                      Tclass.AbstractMap.TransitionLabel
                      $h@@167)
            ($IsAlloc |a#24#0#0@@0|
                      (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)
                      $h@@167)))
     :pattern (($IsAlloc (|#AbstractMap.TransitionLabel.FreezeAsLabel|
                           |a#24#0#0@@0|)
                         Tclass.AbstractMap.TransitionLabel
                         $h@@167))
     :skolemid |3514|
     :qid |AbstractMapidfy.19:21|)))
(assert (forall ((arg0@@602 T@U))
  (! (= (type (AbstractMap.TransitionLabel.stampedMap arg0@@602))
        DatatypeTypeType)
     :pattern ((AbstractMap.TransitionLabel.stampedMap arg0@@602))
     :qid |funType:AbstractMap.TransitionLabel.stampedMap|)))
(assert (forall ((d@@175 T@U) ($h@@168 T@U))
  (! (=> (and (= (type d@@175) DatatypeTypeType)
              (= (type $h@@168) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@168)
              (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@175)
              ($IsAlloc d@@175 Tclass.AbstractMap.TransitionLabel $h@@168))
         ($IsAlloc (AbstractMap.TransitionLabel.stampedMap d@@175)
                   (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)
                   $h@@168))
     :pattern (($IsAlloc (AbstractMap.TransitionLabel.stampedMap d@@175)
                         (Tclass.StampedMod.Stamped
                           Tclass.TotalKMMapMod.TotalMap)
                         $h@@168))
     :skolemid |3515|
     :qid |unknown.0:0|)))
(assert (forall ((|a#25#0#0@@0| T@U))
  (! (=> (= (type |a#25#0#0@@0|) DatatypeTypeType)
         (= (|#AbstractMap.TransitionLabel.FreezeAsLabel| (Lit |a#25#0#0@@0|))
            (Lit (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#25#0#0@@0|))))
     :pattern ((|#AbstractMap.TransitionLabel.FreezeAsLabel|
                 (Lit |a#25#0#0@@0|)))
     :skolemid |3516|
     :qid |AbstractMapidfy.19:21|)))
(assert (forall ((|a#26#0#0@@0| T@U))
  (! (=> (= (type |a#26#0#0@@0|) DatatypeTypeType)
         (= (AbstractMap.TransitionLabel.stampedMap
              (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#26#0#0@@0|))
            |a#26#0#0@@0|))
     :pattern ((|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#26#0#0@@0|))
     :skolemid |3517|
     :qid |AbstractMapidfy.19:21|)))
(assert (forall ((|a#27#0#0@@1| T@U))
  (! (=> (= (type |a#27#0#0@@1|) DatatypeTypeType)
         (< (DtRank |a#27#0#0@@1|)
            (DtRank (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#27#0#0@@1|))))
     :pattern ((|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#27#0#0@@1|))
     :skolemid |3518|
     :qid |AbstractMapidfy.19:21|)))
(assert (= (DatatypeCtorId |#AbstractMap.TransitionLabel.InternalLabel|)
   |##AbstractMap.TransitionLabel.InternalLabel|))
(assert (forall ((d@@176 T@U))
  (! (=> (= (type d@@176) DatatypeTypeType)
         (= (AbstractMap.TransitionLabel.InternalLabel_q d@@176)
            (= (DatatypeCtorId d@@176)
               |##AbstractMap.TransitionLabel.InternalLabel|)))
     :pattern ((AbstractMap.TransitionLabel.InternalLabel_q d@@176))
     :skolemid |3519|
     :qid |unknown.0:0|)))
(assert (forall ((d@@177 T@U))
  (! (=> (and (= (type d@@177) DatatypeTypeType)
              (AbstractMap.TransitionLabel.InternalLabel_q d@@177))
         (= d@@177 |#AbstractMap.TransitionLabel.InternalLabel|))
     :pattern ((AbstractMap.TransitionLabel.InternalLabel_q d@@177))
     :skolemid |3520|
     :qid |unknown.0:0|)))
(assert ($Is |#AbstractMap.TransitionLabel.InternalLabel|
     Tclass.AbstractMap.TransitionLabel))
(assert (forall (($h@@169 T@U))
  (! (=> (and (= (type $h@@169) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@169))
         ($IsAlloc |#AbstractMap.TransitionLabel.InternalLabel|
                   Tclass.AbstractMap.TransitionLabel
                   $h@@169))
     :pattern (($IsAlloc |#AbstractMap.TransitionLabel.InternalLabel|
                         Tclass.AbstractMap.TransitionLabel
                         $h@@169))
     :skolemid |3521|
     :qid |DafnyPreludebpl.545:12|)))
(assert (= |#AbstractMap.TransitionLabel.InternalLabel|
   (Lit |#AbstractMap.TransitionLabel.InternalLabel|)))
(assert (forall ((d@@178 T@U))
  (! (=> (and (= (type d@@178) DatatypeTypeType)
              (|$IsA#AbstractMap.TransitionLabel| d@@178))
         (or (AbstractMap.TransitionLabel.QueryLabel_q d@@178)
             (AbstractMap.TransitionLabel.PutLabel_q d@@178)
             (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@178)
             (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@178)
             (AbstractMap.TransitionLabel.InternalLabel_q d@@178)))
     :pattern ((|$IsA#AbstractMap.TransitionLabel| d@@178))
     :skolemid |3522|
     :qid |unknown.0:0|)))
(assert (forall ((d@@179 T@U))
  (! (=> (and (= (type d@@179) DatatypeTypeType)
              ($Is d@@179 Tclass.AbstractMap.TransitionLabel))
         (or (AbstractMap.TransitionLabel.QueryLabel_q d@@179)
             (AbstractMap.TransitionLabel.PutLabel_q d@@179)
             (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@179)
             (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@179)
             (AbstractMap.TransitionLabel.InternalLabel_q d@@179)))
     :pattern ((AbstractMap.TransitionLabel.InternalLabel_q d@@179)
               ($Is d@@179 Tclass.AbstractMap.TransitionLabel))
     :pattern ((AbstractMap.TransitionLabel.FreezeAsLabel_q d@@179)
               ($Is d@@179 Tclass.AbstractMap.TransitionLabel))
     :pattern ((AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@179)
               ($Is d@@179 Tclass.AbstractMap.TransitionLabel))
     :pattern ((AbstractMap.TransitionLabel.PutLabel_q d@@179)
               ($Is d@@179 Tclass.AbstractMap.TransitionLabel))
     :pattern ((AbstractMap.TransitionLabel.QueryLabel_q d@@179)
               ($Is d@@179 Tclass.AbstractMap.TransitionLabel))
     :skolemid |3523|
     :qid |unknown.0:0|)))
(assert (forall ((a@@167 T@U) (b@@117 T@U))
  (! (let ((a!1 (= (|AbstractMap.TransitionLabel#Equal| a@@167 b@@117)
                   (and (= (AbstractMap.TransitionLabel.endLsn a@@167)
                           (AbstractMap.TransitionLabel.endLsn b@@117))
                        (|Seq#Equal| (AbstractMap.TransitionLabel.key a@@167)
                                     (AbstractMap.TransitionLabel.key b@@117))
                        (|Seq#Equal| (AbstractMap.TransitionLabel.value a@@167)
                                     (AbstractMap.TransitionLabel.value b@@117))))))
       (=> (and (= (type a@@167) DatatypeTypeType)
                (= (type b@@117) DatatypeTypeType)
                (AbstractMap.TransitionLabel.QueryLabel_q a@@167)
                (AbstractMap.TransitionLabel.QueryLabel_q b@@117))
           a!1))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@167 b@@117)
               (AbstractMap.TransitionLabel.QueryLabel_q a@@167))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@167 b@@117)
               (AbstractMap.TransitionLabel.QueryLabel_q b@@117))
     :skolemid |3524|
     :qid |unknown.0:0|)))
(assert (forall ((a@@168 T@U) (b@@118 T@U))
  (! (=> (and (= (type a@@168) DatatypeTypeType)
              (= (type b@@118) DatatypeTypeType)
              (AbstractMap.TransitionLabel.PutLabel_q a@@168)
              (AbstractMap.TransitionLabel.PutLabel_q b@@118))
         (= (|AbstractMap.TransitionLabel#Equal| a@@168 b@@118)
            (|MsgHistoryMod.MsgHistory#Equal|
              (AbstractMap.TransitionLabel.puts a@@168)
              (AbstractMap.TransitionLabel.puts b@@118))))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@168 b@@118)
               (AbstractMap.TransitionLabel.PutLabel_q a@@168))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@168 b@@118)
               (AbstractMap.TransitionLabel.PutLabel_q b@@118))
     :skolemid |3525|
     :qid |unknown.0:0|)))
(assert (forall ((a@@169 T@U) (b@@119 T@U))
  (! (=> (and (= (type a@@169) DatatypeTypeType)
              (= (type b@@119) DatatypeTypeType)
              (AbstractMap.TransitionLabel.QueryEndLsnLabel_q a@@169)
              (AbstractMap.TransitionLabel.QueryEndLsnLabel_q b@@119))
         (= (|AbstractMap.TransitionLabel#Equal| a@@169 b@@119)
            (= (AbstractMap.TransitionLabel.endLsn a@@169)
               (AbstractMap.TransitionLabel.endLsn b@@119))))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@169 b@@119)
               (AbstractMap.TransitionLabel.QueryEndLsnLabel_q a@@169))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@169 b@@119)
               (AbstractMap.TransitionLabel.QueryEndLsnLabel_q b@@119))
     :skolemid |3526|
     :qid |unknown.0:0|)))
(assert (forall ((a@@170 T@U) (b@@120 T@U))
  (! (=> (and (= (type a@@170) DatatypeTypeType)
              (= (type b@@120) DatatypeTypeType)
              (AbstractMap.TransitionLabel.FreezeAsLabel_q a@@170)
              (AbstractMap.TransitionLabel.FreezeAsLabel_q b@@120))
         (= (|AbstractMap.TransitionLabel#Equal| a@@170 b@@120)
            (|StampedMod.Stamped#Equal|
              (AbstractMap.TransitionLabel.stampedMap a@@170)
              (AbstractMap.TransitionLabel.stampedMap b@@120))))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@170 b@@120)
               (AbstractMap.TransitionLabel.FreezeAsLabel_q a@@170))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@170 b@@120)
               (AbstractMap.TransitionLabel.FreezeAsLabel_q b@@120))
     :skolemid |3527|
     :qid |unknown.0:0|)))
(assert (forall ((a@@171 T@U) (b@@121 T@U))
  (! (=> (and (= (type a@@171) DatatypeTypeType)
              (= (type b@@121) DatatypeTypeType)
              (AbstractMap.TransitionLabel.InternalLabel_q a@@171)
              (AbstractMap.TransitionLabel.InternalLabel_q b@@121))
         (= (|AbstractMap.TransitionLabel#Equal| a@@171 b@@121) true))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@171 b@@121)
               (AbstractMap.TransitionLabel.InternalLabel_q a@@171))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@171 b@@121)
               (AbstractMap.TransitionLabel.InternalLabel_q b@@121))
     :skolemid |3528|
     :qid |unknown.0:0|)))
(assert (forall ((a@@172 T@U) (b@@122 T@U))
  (! (=> (and (= (type a@@172) DatatypeTypeType)
              (= (type b@@122) DatatypeTypeType))
         (= (|AbstractMap.TransitionLabel#Equal| a@@172 b@@122)
            (= a@@172 b@@122)))
     :pattern ((|AbstractMap.TransitionLabel#Equal| a@@172 b@@122))
     :skolemid |3529|
     :qid |unknown.0:0|)))
(assert (forall ((|a#33#0#0@@1| T@U))
  (! (=> (= (type |a#33#0#0@@1|) DatatypeTypeType)
         (= (DatatypeCtorId (|#AbstractMap.Variables.Variables| |a#33#0#0@@1|))
            |##AbstractMap.Variables.Variables|))
     :pattern ((|#AbstractMap.Variables.Variables| |a#33#0#0@@1|))
     :skolemid |3530|
     :qid |AbstractMapidfy.22:34|)))
(assert (forall ((d@@180 T@U))
  (! (=> (= (type d@@180) DatatypeTypeType)
         (= (AbstractMap.Variables.Variables_q d@@180)
            (= (DatatypeCtorId d@@180) |##AbstractMap.Variables.Variables|)))
     :pattern ((AbstractMap.Variables.Variables_q d@@180))
     :skolemid |3531|
     :qid |unknown.0:0|)))
(assert (forall ((d@@181 T@U))
  (! (let ((a!1 (exists ((|a#34#0#0@@1| T@U))
                  (! (and (= (type |a#34#0#0@@1|) DatatypeTypeType)
                          (= d@@181
                             (|#AbstractMap.Variables.Variables| |a#34#0#0@@1|)))
                     :no-pattern (type |a#34#0#0@@1|)
                     :no-pattern (U_2_int |a#34#0#0@@1|)
                     :no-pattern (U_2_bool |a#34#0#0@@1|)
                     :skolemid |3532|
                     :qid |AbstractMapidfy.22:34|))))
       (=> (and (= (type d@@181) DatatypeTypeType)
                (AbstractMap.Variables.Variables_q d@@181))
           a!1))
     :pattern ((AbstractMap.Variables.Variables_q d@@181))
     :skolemid |3533|
     :qid |unknown.0:0|)))
(assert (forall ((|a#35#0#0@@1| T@U))
  (! (=> (= (type |a#35#0#0@@1|) DatatypeTypeType)
         (= ($Is (|#AbstractMap.Variables.Variables| |a#35#0#0@@1|)
                 Tclass.AbstractMap.Variables)
            ($Is |a#35#0#0@@1|
                 (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))
     :pattern (($Is (|#AbstractMap.Variables.Variables| |a#35#0#0@@1|)
                    Tclass.AbstractMap.Variables))
     :skolemid |3534|
     :qid |AbstractMapidfy.22:34|)))
(assert (forall ((|a#36#0#0@@1| T@U) ($h@@170 T@U))
  (! (=> (and (= (type |a#36#0#0@@1|) DatatypeTypeType)
              (= (type $h@@170) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@170))
         (= ($IsAlloc (|#AbstractMap.Variables.Variables| |a#36#0#0@@1|)
                      Tclass.AbstractMap.Variables
                      $h@@170)
            ($IsAlloc |a#36#0#0@@1|
                      (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)
                      $h@@170)))
     :pattern (($IsAlloc (|#AbstractMap.Variables.Variables| |a#36#0#0@@1|)
                         Tclass.AbstractMap.Variables
                         $h@@170))
     :skolemid |3535|
     :qid |AbstractMapidfy.22:34|)))
(assert (forall ((arg0@@603 T@U))
  (! (= (type (AbstractMap.Variables.stampedMap arg0@@603)) DatatypeTypeType)
     :pattern ((AbstractMap.Variables.stampedMap arg0@@603))
     :qid |funType:AbstractMap.Variables.stampedMap|)))
(assert (forall ((d@@182 T@U) ($h@@171 T@U))
  (! (=> (and (= (type d@@182) DatatypeTypeType)
              (= (type $h@@171) (MapType0Type refType MapType1Type))
              ($IsGoodHeap $h@@171)
              (AbstractMap.Variables.Variables_q d@@182)
              ($IsAlloc d@@182 Tclass.AbstractMap.Variables $h@@171))
         ($IsAlloc (AbstractMap.Variables.stampedMap d@@182)
                   (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)
                   $h@@171))
     :pattern (($IsAlloc (AbstractMap.Variables.stampedMap d@@182)
                         (Tclass.StampedMod.Stamped
                           Tclass.TotalKMMapMod.TotalMap)
                         $h@@171))
     :skolemid |3536|
     :qid |unknown.0:0|)))
(assert (forall ((|a#37#0#0@@1| T@U))
  (! (=> (= (type |a#37#0#0@@1|) DatatypeTypeType)
         (= (|#AbstractMap.Variables.Variables| (Lit |a#37#0#0@@1|))
            (Lit (|#AbstractMap.Variables.Variables| |a#37#0#0@@1|))))
     :pattern ((|#AbstractMap.Variables.Variables| (Lit |a#37#0#0@@1|)))
     :skolemid |3537|
     :qid |AbstractMapidfy.22:34|)))
(assert (forall ((|a#38#0#0@@0| T@U))
  (! (=> (= (type |a#38#0#0@@0|) DatatypeTypeType)
         (= (AbstractMap.Variables.stampedMap
              (|#AbstractMap.Variables.Variables| |a#38#0#0@@0|))
            |a#38#0#0@@0|))
     :pattern ((|#AbstractMap.Variables.Variables| |a#38#0#0@@0|))
     :skolemid |3538|
     :qid |AbstractMapidfy.22:34|)))
(assert (forall ((|a#39#0#0@@0| T@U))
  (! (=> (= (type |a#39#0#0@@0|) DatatypeTypeType)
         (< (DtRank |a#39#0#0@@0|)
            (DtRank (|#AbstractMap.Variables.Variables| |a#39#0#0@@0|))))
     :pattern ((|#AbstractMap.Variables.Variables| |a#39#0#0@@0|))
     :skolemid |3539|
     :qid |AbstractMapidfy.22:34|)))
(assert (forall ((d@@183 T@U))
  (! (=> (and (= (type d@@183) DatatypeTypeType)
              (|$IsA#AbstractMap.Variables| d@@183))
         (AbstractMap.Variables.Variables_q d@@183))
     :pattern ((|$IsA#AbstractMap.Variables| d@@183))
     :skolemid |3540|
     :qid |unknown.0:0|)))
(assert (forall ((d@@184 T@U))
  (! (=> (and (= (type d@@184) DatatypeTypeType)
              ($Is d@@184 Tclass.AbstractMap.Variables))
         (AbstractMap.Variables.Variables_q d@@184))
     :pattern ((AbstractMap.Variables.Variables_q d@@184)
               ($Is d@@184 Tclass.AbstractMap.Variables))
     :skolemid |3541|
     :qid |unknown.0:0|)))
(assert (forall ((a@@173 T@U) (b@@123 T@U))
  (! (=> (and (= (type a@@173) DatatypeTypeType)
              (= (type b@@123) DatatypeTypeType)
              true)
         (= (|AbstractMap.Variables#Equal| a@@173 b@@123)
            (|StampedMod.Stamped#Equal|
              (AbstractMap.Variables.stampedMap a@@173)
              (AbstractMap.Variables.stampedMap b@@123))))
     :pattern ((|AbstractMap.Variables#Equal| a@@173 b@@123))
     :skolemid |3542|
     :qid |unknown.0:0|)))
(assert (forall ((a@@174 T@U) (b@@124 T@U))
  (! (=> (and (= (type a@@174) DatatypeTypeType)
              (= (type b@@124) DatatypeTypeType))
         (= (|AbstractMap.Variables#Equal| a@@174 b@@124) (= a@@174 b@@124)))
     :pattern ((|AbstractMap.Variables#Equal| a@@174 b@@124))
     :skolemid |3543|
     :qid |unknown.0:0|)))
(assert (= (type Tclass.AbstractMap.__default) TyType))
(assert (= (Tag Tclass.AbstractMap.__default) Tagclass.AbstractMap.__default))
(assert (= (TagFamily Tclass.AbstractMap.__default) tytagFamily$_default))
(assert (forall ((bx@@164 T@U))
  (! (let ((a!1 (and (= ($Box ($Unbox refType bx@@164)) bx@@164)
                     ($Is ($Unbox refType bx@@164) Tclass.AbstractMap.__default))))
       (=> (and (= (type bx@@164) BoxType)
                ($IsBox bx@@164 Tclass.AbstractMap.__default))
           a!1))
     :pattern (($IsBox bx@@164 Tclass.AbstractMap.__default))
     :skolemid |3544|
     :qid |unknown.0:0|)))
(assert (forall (($o@@53 T@U))
  (! (let ((a!1 (= ($Is $o@@53 Tclass.AbstractMap.__default)
                   (or (= $o@@53 null)
                       (= (dtype $o@@53) Tclass.AbstractMap.__default)))))
       (=> (= (type $o@@53) refType) a!1))
     :pattern (($Is $o@@53 Tclass.AbstractMap.__default))
     :skolemid |3545|
     :qid |unknown.0:0|)))
(assert (forall (($o@@54 T@U) ($h@@172 T@U))
  (! (let ((a!1 (or (= $o@@54 null)
                    (U_2_bool (MapType1Select (MapType0Select $h@@172 $o@@54)
                                              alloc)))))
       (=> (and (= (type $o@@54) refType)
                (= (type $h@@172) (MapType0Type refType MapType1Type)))
           (= ($IsAlloc $o@@54 Tclass.AbstractMap.__default $h@@172) a!1)))
     :pattern (($IsAlloc $o@@54 Tclass.AbstractMap.__default $h@@172))
     :skolemid |3546|
     :qid |unknown.0:0|)))
(assert (=> true
    (forall ((|v#0@@88| T@U) (|v'#0@@43| T@U) (|lbl#0@@47| T@U))
      (! (let ((a!1 (and (= (type |v#0@@88|) DatatypeTypeType)
                         (= (type |v'#0@@43|) DatatypeTypeType)
                         (= (type |lbl#0@@47|) DatatypeTypeType)
                         (or (|AbstractMap.__default.Query#canCall|
                               |v#0@@88|
                               |v'#0@@43|
                               |lbl#0@@47|)
                             (and ($Is |v#0@@88| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@43| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@47|
                                       Tclass.AbstractMap.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((AbstractMap.__default.Query
                     |v#0@@88|
                     |v'#0@@43|
                     |lbl#0@@47|))
         :skolemid |3547|
         :qid |AbstractMapidfy.25:19|))))
(assert (forall ((|v#0@@89| T@U) (|v'#0@@44| T@U) (|lbl#0@@48| T@U))
  (! (=> (and (= (type |v#0@@89|) DatatypeTypeType)
              (= (type |v'#0@@44|) DatatypeTypeType)
              (= (type |lbl#0@@48|) DatatypeTypeType)
              ($Is |v#0@@89| Tclass.AbstractMap.Variables)
              ($Is |v'#0@@44| Tclass.AbstractMap.Variables)
              ($Is |lbl#0@@48| Tclass.AbstractMap.TransitionLabel))
         (= (|AbstractMap.__default.Query#requires|
              |v#0@@89|
              |v'#0@@44|
              |lbl#0@@48|)
            true))
     :pattern ((|AbstractMap.__default.Query#requires|
                 |v#0@@89|
                 |v'#0@@44|
                 |lbl#0@@48|))
     :skolemid |3548|
     :qid |AbstractMapidfy.25:19|)))
(assert (let ((a!1 (forall ((|v#0@@90| T@U) (|v'#0@@45| T@U) (|lbl#0@@49| T@U))
             (! (let ((a!1 (and (= (type |v#0@@90|) DatatypeTypeType)
                                (= (type |v'#0@@45|) DatatypeTypeType)
                                (= (type |lbl#0@@49|) DatatypeTypeType)
                                (or (|AbstractMap.__default.Query#canCall|
                                      |v#0@@90|
                                      |v'#0@@45|
                                      |lbl#0@@49|)
                                    (and ($Is |v#0@@90|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |v'#0@@45|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |lbl#0@@49|
                                              Tclass.AbstractMap.TransitionLabel)))))
                      (a!2 (|IMap#Elements| ($Unbox (IMapType BoxType BoxType)
                                                    (StampedMod.Stamped.value
                                                      (AbstractMap.Variables.stampedMap
                                                        |v#0@@90|))))))
                (let ((a!3 ($Unbox DatatypeTypeType
                                   (MapType0Select a!2
                                                   ($Box (AbstractMap.TransitionLabel.key
                                                           |lbl#0@@49|))))))
                (let ((a!4 (and (and (AbstractMap.Variables.Variables_q
                                       |v#0@@90|)
                                     (StampedMod.Stamped.Stamped_q
                                       (AbstractMap.Variables.stampedMap
                                         |v#0@@90|)))
                                (=> (|Seq#Equal| (AbstractMap.TransitionLabel.value
                                                   |lbl#0@@49|)
                                                 (ValueMessage.Message.value
                                                   a!3))
                                    (and (|$IsA#AbstractMap.Variables|
                                           |v'#0@@45|)
                                         (|$IsA#AbstractMap.Variables|
                                           |v#0@@90|)))))
                      (a!7 (and (AbstractMap.TransitionLabel.QueryLabel_q
                                  |lbl#0@@49|)
                                (= (AbstractMap.TransitionLabel.endLsn
                                     |lbl#0@@49|)
                                   (StampedMod.Stamped.seqEnd
                                     (AbstractMap.Variables.stampedMap
                                       |v#0@@90|)))
                                (|Seq#Equal| (AbstractMap.TransitionLabel.value
                                               |lbl#0@@49|)
                                             (ValueMessage.Message.value a!3))
                                (|AbstractMap.Variables#Equal|
                                  |v'#0@@45|
                                  |v#0@@90|))))
                (let ((a!5 (=> (= (AbstractMap.TransitionLabel.endLsn
                                    |lbl#0@@49|)
                                  (StampedMod.Stamped.seqEnd
                                    (AbstractMap.Variables.stampedMap |v#0@@90|)))
                               a!4)))
                (let ((a!6 (and (and (AbstractMap.Variables.Variables_q
                                       |v#0@@90|)
                                     (StampedMod.Stamped.Stamped_q
                                       (AbstractMap.Variables.stampedMap
                                         |v#0@@90|)))
                                a!5)))
                  (=> a!1
                      (and (=> (AbstractMap.TransitionLabel.QueryLabel_q
                                 |lbl#0@@49|)
                               a!6)
                           (= (AbstractMap.__default.Query
                                |v#0@@90|
                                |v'#0@@45|
                                |lbl#0@@49|)
                              a!7))))))))
                :pattern ((AbstractMap.__default.Query
                            |v#0@@90|
                            |v'#0@@45|
                            |lbl#0@@49|))
                :skolemid |3549|
                :qid |AbstractMapidfy.25:19|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@91| T@U) (|v'#0@@46| T@U) (|lbl#0@@50| T@U))
             (! (let ((a!1 (and (= (type |v#0@@91|) DatatypeTypeType)
                                (= (type |v'#0@@46|) DatatypeTypeType)
                                (= (type |lbl#0@@50|) DatatypeTypeType)
                                (or (|AbstractMap.__default.Query#canCall|
                                      (Lit |v#0@@91|)
                                      (Lit |v'#0@@46|)
                                      (Lit |lbl#0@@50|))
                                    (and ($Is |v#0@@91|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |v'#0@@46|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |lbl#0@@50|
                                              Tclass.AbstractMap.TransitionLabel)))))
                      (a!2 (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryLabel_q
                                            (Lit |lbl#0@@50|)))))
                      (a!3 (StampedMod.Stamped.Stamped_q
                             (Lit (AbstractMap.Variables.stampedMap
                                    (Lit |v#0@@91|)))))
                      (a!4 (StampedMod.Stamped.seqEnd
                             (Lit (AbstractMap.Variables.stampedMap
                                    (Lit |v#0@@91|)))))
                      (a!6 (StampedMod.Stamped.value
                             (Lit (AbstractMap.Variables.stampedMap
                                    (Lit |v#0@@91|)))))
                      (a!8 ($Box (Lit (AbstractMap.TransitionLabel.key
                                        (Lit |lbl#0@@50|))))))
                (let ((a!5 (= (LitInt (AbstractMap.TransitionLabel.endLsn
                                        (Lit |lbl#0@@50|)))
                              (LitInt a!4)))
                      (a!7 (|IMap#Elements| (Lit ($Unbox (IMapType BoxType
                                                                   BoxType)
                                                         a!6)))))
                (let ((a!9 (|Seq#Equal| (AbstractMap.TransitionLabel.value
                                          (Lit |lbl#0@@50|))
                                        (ValueMessage.Message.value
                                          ($Unbox DatatypeTypeType
                                                  (MapType0Select a!7 a!8))))))
                (let ((a!10 (=> a!9
                                (and (|$IsA#AbstractMap.Variables|
                                       (Lit |v'#0@@46|))
                                     (|$IsA#AbstractMap.Variables|
                                       (Lit |v#0@@91|)))))
                      (a!13 (= (AbstractMap.__default.Query
                                 (Lit |v#0@@91|)
                                 (Lit |v'#0@@46|)
                                 (Lit |lbl#0@@50|))
                               (and (AbstractMap.TransitionLabel.QueryLabel_q
                                      (Lit |lbl#0@@50|))
                                    a!5
                                    a!9
                                    (|AbstractMap.Variables#Equal|
                                      |v'#0@@46|
                                      |v#0@@91|)))))
                (let ((a!11 (and (and (AbstractMap.Variables.Variables_q
                                        (Lit |v#0@@91|))
                                      a!3)
                                 a!10)))
                (let ((a!12 (and (and (AbstractMap.Variables.Variables_q
                                        (Lit |v#0@@91|))
                                      a!3)
                                 (=> a!5 a!11))))
                  (=> a!1 (and (=> (U_2_bool a!2) a!12) a!13))))))))
                :pattern ((AbstractMap.__default.Query
                            (Lit |v#0@@91|)
                            (Lit |v'#0@@46|)
                            (Lit |lbl#0@@50|)))
                :weight 3
                :skolemid |3550|
                :qid |AbstractMapidfy.25:19|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@92| T@U) (|v'#0@@47| T@U) (|lbl#0@@51| T@U))
      (! (let ((a!1 (and (= (type |v#0@@92|) DatatypeTypeType)
                         (= (type |v'#0@@47|) DatatypeTypeType)
                         (= (type |lbl#0@@51|) DatatypeTypeType)
                         (or (|AbstractMap.__default.Put#canCall|
                               |v#0@@92|
                               |v'#0@@47|
                               |lbl#0@@51|)
                             (and ($Is |v#0@@92| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@47| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@51|
                                       Tclass.AbstractMap.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((AbstractMap.__default.Put |v#0@@92| |v'#0@@47| |lbl#0@@51|))
         :skolemid |3551|
         :qid |AbstractMapidfy.34:17|))))
(assert (forall ((|v#0@@93| T@U) (|v'#0@@48| T@U) (|lbl#0@@52| T@U))
  (! (=> (and (= (type |v#0@@93|) DatatypeTypeType)
              (= (type |v'#0@@48|) DatatypeTypeType)
              (= (type |lbl#0@@52|) DatatypeTypeType)
              ($Is |v#0@@93| Tclass.AbstractMap.Variables)
              ($Is |v'#0@@48| Tclass.AbstractMap.Variables)
              ($Is |lbl#0@@52| Tclass.AbstractMap.TransitionLabel))
         (= (|AbstractMap.__default.Put#requires|
              |v#0@@93|
              |v'#0@@48|
              |lbl#0@@52|)
            true))
     :pattern ((|AbstractMap.__default.Put#requires|
                 |v#0@@93|
                 |v'#0@@48|
                 |lbl#0@@52|))
     :skolemid |3552|
     :qid |AbstractMapidfy.34:17|)))
(assert (let ((a!1 (forall ((|v#0@@94| T@U) (|v'#0@@49| T@U) (|lbl#0@@53| T@U))
             (! (let ((a!1 (and (= (type |v#0@@94|) DatatypeTypeType)
                                (= (type |v'#0@@49|) DatatypeTypeType)
                                (= (type |lbl#0@@53|) DatatypeTypeType)
                                (or (|AbstractMap.__default.Put#canCall|
                                      |v#0@@94|
                                      |v'#0@@49|
                                      |lbl#0@@53|)
                                    (and ($Is |v#0@@94|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |v'#0@@49|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |lbl#0@@53|
                                              Tclass.AbstractMap.TransitionLabel)))))
                      (a!2 (and (|$IsA#StampedMod.Stamped|
                                  (AbstractMap.Variables.stampedMap |v'#0@@49|))
                                (|$IsA#StampedMod.Stamped|
                                  (MsgHistoryMod.__default.MapPlusHistory
                                    (AbstractMap.Variables.stampedMap |v#0@@94|)
                                    (AbstractMap.TransitionLabel.puts
                                      |lbl#0@@53|)))
                                (AbstractMap.Variables.Variables_q |v'#0@@49|)
                                (AbstractMap.Variables.Variables_q |v#0@@94|)
                                (|MsgHistoryMod.__default.MapPlusHistory#canCall|
                                  (AbstractMap.Variables.stampedMap |v#0@@94|)
                                  (AbstractMap.TransitionLabel.puts |lbl#0@@53|))))
                      (a!6 (and (AbstractMap.TransitionLabel.PutLabel_q
                                  |lbl#0@@53|)
                                (MsgHistoryMod.MsgHistory.WF
                                  (AbstractMap.TransitionLabel.puts |lbl#0@@53|))
                                (MsgHistoryMod.MsgHistory.CanFollow
                                  (AbstractMap.TransitionLabel.puts |lbl#0@@53|)
                                  (StampedMod.Stamped.seqEnd
                                    (AbstractMap.Variables.stampedMap |v#0@@94|)))
                                (|StampedMod.Stamped#Equal|
                                  (AbstractMap.Variables.stampedMap |v'#0@@49|)
                                  (MsgHistoryMod.__default.MapPlusHistory
                                    (AbstractMap.Variables.stampedMap |v#0@@94|)
                                    (AbstractMap.TransitionLabel.puts
                                      |lbl#0@@53|))))))
                (let ((a!3 (=> (MsgHistoryMod.MsgHistory.CanFollow
                                 (AbstractMap.TransitionLabel.puts |lbl#0@@53|)
                                 (StampedMod.Stamped.seqEnd
                                   (AbstractMap.Variables.stampedMap |v#0@@94|)))
                               a!2)))
                (let ((a!4 (and (AbstractMap.Variables.Variables_q |v#0@@94|)
                                (StampedMod.Stamped.Stamped_q
                                  (AbstractMap.Variables.stampedMap |v#0@@94|))
                                (|MsgHistoryMod.MsgHistory.CanFollow#canCall|
                                  (AbstractMap.TransitionLabel.puts |lbl#0@@53|)
                                  (StampedMod.Stamped.seqEnd
                                    (AbstractMap.Variables.stampedMap |v#0@@94|)))
                                a!3)))
                (let ((a!5 (and (|MsgHistoryMod.MsgHistory.WF#canCall|
                                  (AbstractMap.TransitionLabel.puts |lbl#0@@53|))
                                (=> (MsgHistoryMod.MsgHistory.WF
                                      (AbstractMap.TransitionLabel.puts
                                        |lbl#0@@53|))
                                    a!4))))
                  (=> a!1
                      (and (=> (AbstractMap.TransitionLabel.PutLabel_q
                                 |lbl#0@@53|)
                               a!5)
                           (= (AbstractMap.__default.Put
                                |v#0@@94|
                                |v'#0@@49|
                                |lbl#0@@53|)
                              a!6)))))))
                :pattern ((AbstractMap.__default.Put
                            |v#0@@94|
                            |v'#0@@49|
                            |lbl#0@@53|))
                :skolemid |3553|
                :qid |AbstractMapidfy.34:17|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@95| T@U) (|v'#0@@50| T@U) (|lbl#0@@54| T@U))
      (! (let ((a!1 (and (= (type |v#0@@95|) DatatypeTypeType)
                         (= (type |v'#0@@50|) DatatypeTypeType)
                         (= (type |lbl#0@@54|) DatatypeTypeType)
                         (or (|AbstractMap.__default.Put#canCall|
                               (Lit |v#0@@95|)
                               (Lit |v'#0@@50|)
                               (Lit |lbl#0@@54|))
                             (and ($Is |v#0@@95| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@50| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@54|
                                       Tclass.AbstractMap.TransitionLabel)))))
               (a!2 (Lit (bool_2_U (AbstractMap.TransitionLabel.PutLabel_q
                                     (Lit |lbl#0@@54|)))))
               (a!3 (|MsgHistoryMod.MsgHistory.WF#canCall|
                      (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@54|)))))
               (a!4 (MsgHistoryMod.MsgHistory.WF
                      (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@54|)))))
               (a!5 (StampedMod.Stamped.Stamped_q
                      (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@95|)))))
               (a!6 (StampedMod.Stamped.seqEnd
                      (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@95|)))))
               (a!9 (|$IsA#StampedMod.Stamped|
                      (Lit (AbstractMap.Variables.stampedMap (Lit |v'#0@@50|)))))
               (a!10 (MsgHistoryMod.__default.MapPlusHistory
                       (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@95|)))
                       (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@54|)))))
               (a!11 (|MsgHistoryMod.__default.MapPlusHistory#canCall|
                       (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@95|)))
                       (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@54|))))))
         (let ((a!7 (|MsgHistoryMod.MsgHistory.CanFollow#canCall|
                      (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@54|)))
                      (LitInt a!6)))
               (a!8 (MsgHistoryMod.MsgHistory.CanFollow
                      (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@54|)))
                      (LitInt a!6))))
         (let ((a!12 (=> (U_2_bool (Lit (bool_2_U a!8)))
                         (and a!9
                              (|$IsA#StampedMod.Stamped| (Lit a!10))
                              (AbstractMap.Variables.Variables_q
                                (Lit |v'#0@@50|))
                              (AbstractMap.Variables.Variables_q
                                (Lit |v#0@@95|))
                              a!11)))
               (a!14 (and (AbstractMap.TransitionLabel.PutLabel_q
                            (Lit |lbl#0@@54|))
                          a!4
                          a!8
                          (|StampedMod.Stamped#Equal|
                            (AbstractMap.Variables.stampedMap (Lit |v'#0@@50|))
                            a!10))))
         (let ((a!13 (=> (U_2_bool (Lit (bool_2_U a!4)))
                         (and (AbstractMap.Variables.Variables_q
                                (Lit |v#0@@95|))
                              a!5
                              a!7
                              a!12))))
         (let ((a!15 (and (=> (U_2_bool a!2) (and a!3 a!13))
                          (= (AbstractMap.__default.Put
                               (Lit |v#0@@95|)
                               (Lit |v'#0@@50|)
                               (Lit |lbl#0@@54|))
                             a!14))))
           (=> a!1 a!15))))))
         :pattern ((AbstractMap.__default.Put
                     (Lit |v#0@@95|)
                     (Lit |v'#0@@50|)
                     (Lit |lbl#0@@54|)))
         :weight 3
         :skolemid |3554|
         :qid |AbstractMapidfy.34:17|))))
(assert (=> true
    (forall ((|v#0@@96| T@U) (|v'#0@@51| T@U) (|lbl#0@@55| T@U))
      (! (let ((a!1 (and (= (type |v#0@@96|) DatatypeTypeType)
                         (= (type |v'#0@@51|) DatatypeTypeType)
                         (= (type |lbl#0@@55|) DatatypeTypeType)
                         (or (|AbstractMap.__default.QueryEndLsn#canCall|
                               |v#0@@96|
                               |v'#0@@51|
                               |lbl#0@@55|)
                             (and ($Is |v#0@@96| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@51| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@55|
                                       Tclass.AbstractMap.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((AbstractMap.__default.QueryEndLsn
                     |v#0@@96|
                     |v'#0@@51|
                     |lbl#0@@55|))
         :skolemid |3555|
         :qid |AbstractMapidfy.42:25|))))
(assert (forall ((|v#0@@97| T@U) (|v'#0@@52| T@U) (|lbl#0@@56| T@U))
  (! (=> (and (= (type |v#0@@97|) DatatypeTypeType)
              (= (type |v'#0@@52|) DatatypeTypeType)
              (= (type |lbl#0@@56|) DatatypeTypeType)
              ($Is |v#0@@97| Tclass.AbstractMap.Variables)
              ($Is |v'#0@@52| Tclass.AbstractMap.Variables)
              ($Is |lbl#0@@56| Tclass.AbstractMap.TransitionLabel))
         (= (|AbstractMap.__default.QueryEndLsn#requires|
              |v#0@@97|
              |v'#0@@52|
              |lbl#0@@56|)
            true))
     :pattern ((|AbstractMap.__default.QueryEndLsn#requires|
                 |v#0@@97|
                 |v'#0@@52|
                 |lbl#0@@56|))
     :skolemid |3556|
     :qid |AbstractMapidfy.42:25|)))
(assert (let ((a!1 (forall ((|v#0@@98| T@U) (|v'#0@@53| T@U) (|lbl#0@@57| T@U))
             (! (let ((a!1 (and (= (type |v#0@@98|) DatatypeTypeType)
                                (= (type |v'#0@@53|) DatatypeTypeType)
                                (= (type |lbl#0@@57|) DatatypeTypeType)
                                (or (|AbstractMap.__default.QueryEndLsn#canCall|
                                      |v#0@@98|
                                      |v'#0@@53|
                                      |lbl#0@@57|)
                                    (and ($Is |v#0@@98|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |v'#0@@53|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |lbl#0@@57|
                                              Tclass.AbstractMap.TransitionLabel)))))
                      (a!2 (=> (= (AbstractMap.TransitionLabel.endLsn
                                    |lbl#0@@57|)
                                  (StampedMod.Stamped.seqEnd
                                    (AbstractMap.Variables.stampedMap |v#0@@98|)))
                               (and (|$IsA#AbstractMap.Variables| |v'#0@@53|)
                                    (|$IsA#AbstractMap.Variables| |v#0@@98|))))
                      (a!4 (and (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                                  |lbl#0@@57|)
                                (= (AbstractMap.TransitionLabel.endLsn
                                     |lbl#0@@57|)
                                   (StampedMod.Stamped.seqEnd
                                     (AbstractMap.Variables.stampedMap
                                       |v#0@@98|)))
                                (|AbstractMap.Variables#Equal|
                                  |v'#0@@53|
                                  |v#0@@98|))))
                (let ((a!3 (=> (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                                 |lbl#0@@57|)
                               (and (AbstractMap.Variables.Variables_q
                                      |v#0@@98|)
                                    (StampedMod.Stamped.Stamped_q
                                      (AbstractMap.Variables.stampedMap
                                        |v#0@@98|))
                                    a!2))))
                  (=> a!1
                      (and a!3
                           (= (AbstractMap.__default.QueryEndLsn
                                |v#0@@98|
                                |v'#0@@53|
                                |lbl#0@@57|)
                              a!4)))))
                :pattern ((AbstractMap.__default.QueryEndLsn
                            |v#0@@98|
                            |v'#0@@53|
                            |lbl#0@@57|))
                :skolemid |3557|
                :qid |AbstractMapidfy.42:25|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@99| T@U) (|v'#0@@54| T@U) (|lbl#0@@58| T@U))
      (! (let ((a!1 (and (= (type |v#0@@99|) DatatypeTypeType)
                         (= (type |v'#0@@54|) DatatypeTypeType)
                         (= (type |lbl#0@@58|) DatatypeTypeType)
                         (or (|AbstractMap.__default.QueryEndLsn#canCall|
                               (Lit |v#0@@99|)
                               (Lit |v'#0@@54|)
                               (Lit |lbl#0@@58|))
                             (and ($Is |v#0@@99| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@54| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@58|
                                       Tclass.AbstractMap.TransitionLabel)))))
               (a!2 (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                                     (Lit |lbl#0@@58|)))))
               (a!3 (StampedMod.Stamped.Stamped_q
                      (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@99|)))))
               (a!4 (StampedMod.Stamped.seqEnd
                      (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@99|))))))
         (let ((a!5 (= (LitInt (AbstractMap.TransitionLabel.endLsn
                                 (Lit |lbl#0@@58|)))
                       (LitInt a!4))))
         (let ((a!6 (=> a!5
                        (and (|$IsA#AbstractMap.Variables| (Lit |v'#0@@54|))
                             (|$IsA#AbstractMap.Variables| (Lit |v#0@@99|)))))
               (a!8 (= (AbstractMap.__default.QueryEndLsn
                         (Lit |v#0@@99|)
                         (Lit |v'#0@@54|)
                         (Lit |lbl#0@@58|))
                       (and (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                              (Lit |lbl#0@@58|))
                            a!5
                            (|AbstractMap.Variables#Equal| |v'#0@@54| |v#0@@99|)))))
         (let ((a!7 (=> (U_2_bool a!2)
                        (and (AbstractMap.Variables.Variables_q (Lit |v#0@@99|))
                             a!3
                             a!6))))
           (=> a!1 (and a!7 a!8))))))
         :pattern ((AbstractMap.__default.QueryEndLsn
                     (Lit |v#0@@99|)
                     (Lit |v'#0@@54|)
                     (Lit |lbl#0@@58|)))
         :weight 3
         :skolemid |3558|
         :qid |AbstractMapidfy.42:25|))))
(assert (=> true
    (forall ((|v#0@@100| T@U) (|v'#0@@55| T@U) (|lbl#0@@59| T@U))
      (! (let ((a!1 (and (= (type |v#0@@100|) DatatypeTypeType)
                         (= (type |v'#0@@55|) DatatypeTypeType)
                         (= (type |lbl#0@@59|) DatatypeTypeType)
                         (or (|AbstractMap.__default.FreezeAs#canCall|
                               |v#0@@100|
                               |v'#0@@55|
                               |lbl#0@@59|)
                             (and ($Is |v#0@@100| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@55| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@59|
                                       Tclass.AbstractMap.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((AbstractMap.__default.FreezeAs
                     |v#0@@100|
                     |v'#0@@55|
                     |lbl#0@@59|))
         :skolemid |3559|
         :qid |AbstractMapidfy.49:22|))))
(assert (forall ((|v#0@@101| T@U) (|v'#0@@56| T@U) (|lbl#0@@60| T@U))
  (! (=> (and (= (type |v#0@@101|) DatatypeTypeType)
              (= (type |v'#0@@56|) DatatypeTypeType)
              (= (type |lbl#0@@60|) DatatypeTypeType)
              ($Is |v#0@@101| Tclass.AbstractMap.Variables)
              ($Is |v'#0@@56| Tclass.AbstractMap.Variables)
              ($Is |lbl#0@@60| Tclass.AbstractMap.TransitionLabel))
         (= (|AbstractMap.__default.FreezeAs#requires|
              |v#0@@101|
              |v'#0@@56|
              |lbl#0@@60|)
            true))
     :pattern ((|AbstractMap.__default.FreezeAs#requires|
                 |v#0@@101|
                 |v'#0@@56|
                 |lbl#0@@60|))
     :skolemid |3560|
     :qid |AbstractMapidfy.49:22|)))
(assert (let ((a!1 (forall ((|v#0@@102| T@U) (|v'#0@@57| T@U) (|lbl#0@@61| T@U))
             (! (let ((a!1 (and (= (type |v#0@@102|) DatatypeTypeType)
                                (= (type |v'#0@@57|) DatatypeTypeType)
                                (= (type |lbl#0@@61|) DatatypeTypeType)
                                (or (|AbstractMap.__default.FreezeAs#canCall|
                                      |v#0@@102|
                                      |v'#0@@57|
                                      |lbl#0@@61|)
                                    (and ($Is |v#0@@102|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |v'#0@@57|
                                              Tclass.AbstractMap.Variables)
                                         ($Is |lbl#0@@61|
                                              Tclass.AbstractMap.TransitionLabel)))))
                      (a!2 (and (|$IsA#StampedMod.Stamped|
                                  (AbstractMap.TransitionLabel.stampedMap
                                    |lbl#0@@61|))
                                (|$IsA#StampedMod.Stamped|
                                  (AbstractMap.Variables.stampedMap |v#0@@102|))
                                (AbstractMap.Variables.Variables_q |v#0@@102|)
                                (=> (|StampedMod.Stamped#Equal|
                                      (AbstractMap.TransitionLabel.stampedMap
                                        |lbl#0@@61|)
                                      (AbstractMap.Variables.stampedMap
                                        |v#0@@102|))
                                    (and (|$IsA#AbstractMap.Variables|
                                           |v'#0@@57|)
                                         (|$IsA#AbstractMap.Variables|
                                           |v#0@@102|)))))
                      (a!3 (= (AbstractMap.__default.FreezeAs
                                |v#0@@102|
                                |v'#0@@57|
                                |lbl#0@@61|)
                              (and (AbstractMap.TransitionLabel.FreezeAsLabel_q
                                     |lbl#0@@61|)
                                   (|StampedMod.Stamped#Equal|
                                     (AbstractMap.TransitionLabel.stampedMap
                                       |lbl#0@@61|)
                                     (AbstractMap.Variables.stampedMap
                                       |v#0@@102|))
                                   (|AbstractMap.Variables#Equal|
                                     |v'#0@@57|
                                     |v#0@@102|)))))
                  (=> a!1
                      (and (=> (AbstractMap.TransitionLabel.FreezeAsLabel_q
                                 |lbl#0@@61|)
                               a!2)
                           a!3)))
                :pattern ((AbstractMap.__default.FreezeAs
                            |v#0@@102|
                            |v'#0@@57|
                            |lbl#0@@61|))
                :skolemid |3561|
                :qid |AbstractMapidfy.49:22|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@103| T@U) (|v'#0@@58| T@U) (|lbl#0@@62| T@U))
      (! (let ((a!1 (and (= (type |v#0@@103|) DatatypeTypeType)
                         (= (type |v'#0@@58|) DatatypeTypeType)
                         (= (type |lbl#0@@62|) DatatypeTypeType)
                         (or (|AbstractMap.__default.FreezeAs#canCall|
                               (Lit |v#0@@103|)
                               (Lit |v'#0@@58|)
                               (Lit |lbl#0@@62|))
                             (and ($Is |v#0@@103| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@58| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@62|
                                       Tclass.AbstractMap.TransitionLabel)))))
               (a!2 (Lit (bool_2_U (AbstractMap.TransitionLabel.FreezeAsLabel_q
                                     (Lit |lbl#0@@62|)))))
               (a!3 (|$IsA#StampedMod.Stamped|
                      (Lit (AbstractMap.TransitionLabel.stampedMap
                             (Lit |lbl#0@@62|)))))
               (a!4 (|$IsA#StampedMod.Stamped|
                      (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@103|)))))
               (a!5 (=> (|StampedMod.Stamped#Equal|
                          (AbstractMap.TransitionLabel.stampedMap
                            (Lit |lbl#0@@62|))
                          (AbstractMap.Variables.stampedMap (Lit |v#0@@103|)))
                        (and (|$IsA#AbstractMap.Variables| (Lit |v'#0@@58|))
                             (|$IsA#AbstractMap.Variables| (Lit |v#0@@103|)))))
               (a!7 (and (AbstractMap.TransitionLabel.FreezeAsLabel_q
                           (Lit |lbl#0@@62|))
                         (|StampedMod.Stamped#Equal|
                           (AbstractMap.TransitionLabel.stampedMap
                             (Lit |lbl#0@@62|))
                           (AbstractMap.Variables.stampedMap (Lit |v#0@@103|)))
                         (|AbstractMap.Variables#Equal| |v'#0@@58| |v#0@@103|))))
         (let ((a!6 (=> (U_2_bool a!2)
                        (and a!3
                             a!4
                             (AbstractMap.Variables.Variables_q
                               (Lit |v#0@@103|))
                             a!5))))
         (let ((a!8 (and a!6
                         (= (AbstractMap.__default.FreezeAs
                              (Lit |v#0@@103|)
                              (Lit |v'#0@@58|)
                              (Lit |lbl#0@@62|))
                            a!7))))
           (=> a!1 a!8))))
         :pattern ((AbstractMap.__default.FreezeAs
                     (Lit |v#0@@103|)
                     (Lit |v'#0@@58|)
                     (Lit |lbl#0@@62|)))
         :weight 3
         :skolemid |3562|
         :qid |AbstractMapidfy.49:22|))))
(assert (let ((a!1 (forall ((|v#0@@104| T@U) (|persistentMap#0| T@U))
             (! (let ((a!1 (or (|AbstractMap.__default.Init#canCall|
                                 |v#0@@104|
                                 |persistentMap#0|)
                               (and ($Is |v#0@@104|
                                         Tclass.AbstractMap.Variables)
                                    ($Is |persistentMap#0|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap))))))
                  (=> (and (= (type |v#0@@104|) DatatypeTypeType)
                           (= (type |persistentMap#0|) DatatypeTypeType)
                           a!1)
                      true))
                :pattern ((AbstractMap.__default.Init
                            |v#0@@104|
                            |persistentMap#0|))
                :skolemid |3563|
                :qid |AbstractMapidfy.57:18|))))
  (=> true a!1)))
(assert (forall ((|v#0@@105| T@U) (|persistentMap#0@@0| T@U))
  (! (=> (and (= (type |v#0@@105|) DatatypeTypeType)
              (= (type |persistentMap#0@@0|) DatatypeTypeType)
              ($Is |v#0@@105| Tclass.AbstractMap.Variables)
              ($Is |persistentMap#0@@0|
                   (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))
         (= (|AbstractMap.__default.Init#requires|
              |v#0@@105|
              |persistentMap#0@@0|)
            true))
     :pattern ((|AbstractMap.__default.Init#requires|
                 |v#0@@105|
                 |persistentMap#0@@0|))
     :skolemid |3564|
     :qid |AbstractMapidfy.57:18|)))
(assert (let ((a!1 (forall ((|v#0@@106| T@U) (|persistentMap#0@@1| T@U))
             (! (let ((a!1 (or (|AbstractMap.__default.Init#canCall|
                                 |v#0@@106|
                                 |persistentMap#0@@1|)
                               (and ($Is |v#0@@106|
                                         Tclass.AbstractMap.Variables)
                                    ($Is |persistentMap#0@@1|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap)))))
                      (a!2 (and (|$IsA#AbstractMap.Variables| |v#0@@106|)
                                (= (AbstractMap.__default.Init
                                     |v#0@@106|
                                     |persistentMap#0@@1|)
                                   (|AbstractMap.Variables#Equal|
                                     |v#0@@106|
                                     (|#AbstractMap.Variables.Variables|
                                       |persistentMap#0@@1|))))))
                  (=> (and (= (type |v#0@@106|) DatatypeTypeType)
                           (= (type |persistentMap#0@@1|) DatatypeTypeType)
                           a!1)
                      a!2))
                :pattern ((AbstractMap.__default.Init
                            |v#0@@106|
                            |persistentMap#0@@1|))
                :skolemid |3565|
                :qid |AbstractMapidfy.57:18|))))
  (=> true a!1)))
(assert (let ((a!1 (forall ((|v#0@@107| T@U) (|persistentMap#0@@2| T@U))
             (! (let ((a!1 (or (|AbstractMap.__default.Init#canCall|
                                 (Lit |v#0@@107|)
                                 (Lit |persistentMap#0@@2|))
                               (and ($Is |v#0@@107|
                                         Tclass.AbstractMap.Variables)
                                    ($Is |persistentMap#0@@2|
                                         (Tclass.StampedMod.Stamped
                                           Tclass.TotalKMMapMod.TotalMap)))))
                      (a!2 (= (AbstractMap.__default.Init
                                (Lit |v#0@@107|)
                                (Lit |persistentMap#0@@2|))
                              (|AbstractMap.Variables#Equal|
                                |v#0@@107|
                                (|#AbstractMap.Variables.Variables|
                                  (Lit |persistentMap#0@@2|))))))
                  (=> (and (= (type |v#0@@107|) DatatypeTypeType)
                           (= (type |persistentMap#0@@2|) DatatypeTypeType)
                           a!1)
                      (and (|$IsA#AbstractMap.Variables| (Lit |v#0@@107|)) a!2)))
                :pattern ((AbstractMap.__default.Init
                            (Lit |v#0@@107|)
                            (Lit |persistentMap#0@@2|)))
                :weight 3
                :skolemid |3566|
                :qid |AbstractMapidfy.57:18|))))
  (=> true a!1)))
(assert (=> true
    (forall ((|v#0@@108| T@U) (|v'#0@@59| T@U) (|lbl#0@@63| T@U))
      (! (let ((a!1 (and (= (type |v#0@@108|) DatatypeTypeType)
                         (= (type |v'#0@@59|) DatatypeTypeType)
                         (= (type |lbl#0@@63|) DatatypeTypeType)
                         (or (|AbstractMap.__default.Next#canCall|
                               |v#0@@108|
                               |v'#0@@59|
                               |lbl#0@@63|)
                             (and ($Is |v#0@@108| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@59| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@63|
                                       Tclass.AbstractMap.TransitionLabel))))))
           (=> a!1 true))
         :pattern ((AbstractMap.__default.Next
                     |v#0@@108|
                     |v'#0@@59|
                     |lbl#0@@63|))
         :skolemid |3567|
         :qid |AbstractMapidfy.62:18|))))
(assert (forall ((|v#0@@109| T@U) (|v'#0@@60| T@U) (|lbl#0@@64| T@U))
  (! (=> (and (= (type |v#0@@109|) DatatypeTypeType)
              (= (type |v'#0@@60|) DatatypeTypeType)
              (= (type |lbl#0@@64|) DatatypeTypeType)
              ($Is |v#0@@109| Tclass.AbstractMap.Variables)
              ($Is |v'#0@@60| Tclass.AbstractMap.Variables)
              ($Is |lbl#0@@64| Tclass.AbstractMap.TransitionLabel))
         (= (|AbstractMap.__default.Next#requires|
              |v#0@@109|
              |v'#0@@60|
              |lbl#0@@64|)
            true))
     :pattern ((|AbstractMap.__default.Next#requires|
                 |v#0@@109|
                 |v'#0@@60|
                 |lbl#0@@64|))
     :skolemid |3568|
     :qid |AbstractMapidfy.62:18|)))
(assert (=> true
    (forall ((|v#0@@110| T@U) (|v'#0@@61| T@U) (|lbl#0@@65| T@U))
      (! (let ((a!1 (and (= (type |v#0@@110|) DatatypeTypeType)
                         (= (type |v'#0@@61|) DatatypeTypeType)
                         (= (type |lbl#0@@65|) DatatypeTypeType)
                         (or (|AbstractMap.__default.Next#canCall|
                               |v#0@@110|
                               |v'#0@@61|
                               |lbl#0@@65|)
                             (and ($Is |v#0@@110| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@61| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@65|
                                       Tclass.AbstractMap.TransitionLabel)))))
               (a!2 (and (=> (AbstractMap.TransitionLabel.FreezeAsLabel_q
                               |lbl#0@@65|)
                             (|AbstractMap.__default.FreezeAs#canCall|
                               |v#0@@110|
                               |v'#0@@61|
                               |lbl#0@@65|))
                         (=> (not (AbstractMap.TransitionLabel.FreezeAsLabel_q
                                    |lbl#0@@65|))
                             (and (|$IsA#AbstractMap.Variables| |v#0@@110|)
                                  (|$IsA#AbstractMap.Variables| |v'#0@@61|)))))
               (a!5 (ite (AbstractMap.TransitionLabel.PutLabel_q |lbl#0@@65|)
                         (AbstractMap.__default.Put
                           |v#0@@110|
                           |v'#0@@61|
                           |lbl#0@@65|)
                         (ite (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                                |lbl#0@@65|)
                              (AbstractMap.__default.QueryEndLsn
                                |v#0@@110|
                                |v'#0@@61|
                                |lbl#0@@65|)
                              (ite (AbstractMap.TransitionLabel.FreezeAsLabel_q
                                     |lbl#0@@65|)
                                   (AbstractMap.__default.FreezeAs
                                     |v#0@@110|
                                     |v'#0@@61|
                                     |lbl#0@@65|)
                                   (|AbstractMap.Variables#Equal|
                                     |v#0@@110|
                                     |v'#0@@61|))))))
         (let ((a!3 (and (=> (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                               |lbl#0@@65|)
                             (|AbstractMap.__default.QueryEndLsn#canCall|
                               |v#0@@110|
                               |v'#0@@61|
                               |lbl#0@@65|))
                         (=> (not (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                                    |lbl#0@@65|))
                             a!2))))
         (let ((a!4 (and (=> (AbstractMap.TransitionLabel.PutLabel_q
                               |lbl#0@@65|)
                             (|AbstractMap.__default.Put#canCall|
                               |v#0@@110|
                               |v'#0@@61|
                               |lbl#0@@65|))
                         (=> (not (AbstractMap.TransitionLabel.PutLabel_q
                                    |lbl#0@@65|))
                             a!3))))
         (let ((a!6 (and (=> (AbstractMap.TransitionLabel.QueryLabel_q
                               |lbl#0@@65|)
                             (|AbstractMap.__default.Query#canCall|
                               |v#0@@110|
                               |v'#0@@61|
                               |lbl#0@@65|))
                         (=> (not (AbstractMap.TransitionLabel.QueryLabel_q
                                    |lbl#0@@65|))
                             a!4)
                         (= (AbstractMap.__default.Next
                              |v#0@@110|
                              |v'#0@@61|
                              |lbl#0@@65|)
                            (ite (AbstractMap.TransitionLabel.QueryLabel_q
                                   |lbl#0@@65|)
                                 (AbstractMap.__default.Query
                                   |v#0@@110|
                                   |v'#0@@61|
                                   |lbl#0@@65|)
                                 a!5)))))
           (=> a!1 a!6)))))
         :pattern ((AbstractMap.__default.Next
                     |v#0@@110|
                     |v'#0@@61|
                     |lbl#0@@65|))
         :skolemid |3569|
         :qid |AbstractMapidfy.62:18|))))
(assert (=> true
    (forall ((|v#0@@111| T@U) (|v'#0@@62| T@U) (|lbl#0@@66| T@U))
      (! (let ((a!1 (and (= (type |v#0@@111|) DatatypeTypeType)
                         (= (type |v'#0@@62|) DatatypeTypeType)
                         (= (type |lbl#0@@66|) DatatypeTypeType)
                         (or (|AbstractMap.__default.Next#canCall|
                               (Lit |v#0@@111|)
                               (Lit |v'#0@@62|)
                               (Lit |lbl#0@@66|))
                             (and ($Is |v#0@@111| Tclass.AbstractMap.Variables)
                                  ($Is |v'#0@@62| Tclass.AbstractMap.Variables)
                                  ($Is |lbl#0@@66|
                                       Tclass.AbstractMap.TransitionLabel)))))
               (a!2 (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryLabel_q
                                     (Lit |lbl#0@@66|)))))
               (a!3 (Lit (bool_2_U (AbstractMap.TransitionLabel.PutLabel_q
                                     (Lit |lbl#0@@66|)))))
               (a!4 (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                                     (Lit |lbl#0@@66|)))))
               (a!5 (Lit (bool_2_U (AbstractMap.TransitionLabel.FreezeAsLabel_q
                                     (Lit |lbl#0@@66|)))))
               (a!10 (ite (AbstractMap.TransitionLabel.QueryEndLsnLabel_q
                            (Lit |lbl#0@@66|))
                          (AbstractMap.__default.QueryEndLsn
                            (Lit |v#0@@111|)
                            (Lit |v'#0@@62|)
                            (Lit |lbl#0@@66|))
                          (ite (AbstractMap.TransitionLabel.FreezeAsLabel_q
                                 (Lit |lbl#0@@66|))
                               (AbstractMap.__default.FreezeAs
                                 (Lit |v#0@@111|)
                                 (Lit |v'#0@@62|)
                                 (Lit |lbl#0@@66|))
                               (|AbstractMap.Variables#Equal|
                                 |v#0@@111|
                                 |v'#0@@62|)))))
         (let ((a!6 (=> (not (U_2_bool a!5))
                        (and (|$IsA#AbstractMap.Variables| (Lit |v#0@@111|))
                             (|$IsA#AbstractMap.Variables| (Lit |v'#0@@62|)))))
               (a!11 (ite (AbstractMap.TransitionLabel.QueryLabel_q
                            (Lit |lbl#0@@66|))
                          (AbstractMap.__default.Query
                            (Lit |v#0@@111|)
                            (Lit |v'#0@@62|)
                            (Lit |lbl#0@@66|))
                          (ite (AbstractMap.TransitionLabel.PutLabel_q
                                 (Lit |lbl#0@@66|))
                               (AbstractMap.__default.Put
                                 (Lit |v#0@@111|)
                                 (Lit |v'#0@@62|)
                                 (Lit |lbl#0@@66|))
                               a!10))))
         (let ((a!7 (and (=> (U_2_bool a!5)
                             (|AbstractMap.__default.FreezeAs#canCall|
                               (Lit |v#0@@111|)
                               (Lit |v'#0@@62|)
                               (Lit |lbl#0@@66|)))
                         a!6)))
         (let ((a!8 (and (=> (U_2_bool a!4)
                             (|AbstractMap.__default.QueryEndLsn#canCall|
                               (Lit |v#0@@111|)
                               (Lit |v'#0@@62|)
                               (Lit |lbl#0@@66|)))
                         (=> (not (U_2_bool a!4)) a!7))))
         (let ((a!9 (and (=> (U_2_bool a!3)
                             (|AbstractMap.__default.Put#canCall|
                               (Lit |v#0@@111|)
                               (Lit |v'#0@@62|)
                               (Lit |lbl#0@@66|)))
                         (=> (not (U_2_bool a!3)) a!8))))
         (let ((a!12 (and (=> (U_2_bool a!2)
                              (|AbstractMap.__default.Query#canCall|
                                (Lit |v#0@@111|)
                                (Lit |v'#0@@62|)
                                (Lit |lbl#0@@66|)))
                          (=> (not (U_2_bool a!2)) a!9)
                          (= (AbstractMap.__default.Next
                               (Lit |v#0@@111|)
                               (Lit |v'#0@@62|)
                               (Lit |lbl#0@@66|))
                             a!11))))
           (=> a!1 a!12)))))))
         :pattern ((AbstractMap.__default.Next
                     (Lit |v#0@@111|)
                     (Lit |v'#0@@62|)
                     (Lit |lbl#0@@66|)))
         :weight 3
         :skolemid |3570|
         :qid |AbstractMapidfy.62:18|))))
(assert (let ((a!1 (forall ((arg0@@604 T@T) (arg1@@304 T@T))
             (! (= (Ctor (MapType6Type arg0@@604 arg1@@304)) 28)
                :qid |ctor:MapType6Type|)))
      (a!2 (forall ((arg0@@605 T@T) (arg1@@305 T@T))
             (! (= (MapType6TypeInv0 (MapType6Type arg0@@605 arg1@@305))
                   arg0@@605)
                :pattern ((MapType6Type arg0@@605 arg1@@305))
                :qid |typeInv:MapType6TypeInv0|)))
      (a!3 (forall ((arg0@@606 T@T) (arg1@@306 T@T))
             (! (= (MapType6TypeInv1 (MapType6Type arg0@@606 arg1@@306))
                   arg1@@306)
                :pattern ((MapType6Type arg0@@606 arg1@@306))
                :qid |typeInv:MapType6TypeInv1|)))
      (a!4 (forall ((arg0@@607 T@U) (arg1@@307 T@U) (arg2@@170 T@U))
             (! (= (type (MapType6Select arg0@@607 arg1@@307 arg2@@170))
                   (MapType6TypeInv1 (type arg0@@607)))
                :pattern ((MapType6Select arg0@@607 arg1@@307 arg2@@170))
                :qid |funType:MapType6Select|)))
      (a!5 (forall ((arg0@@608 T@U)
                    (arg1@@308 T@U)
                    (arg2@@171 T@U)
                    (arg3@@98 T@U))
             (! (= (type (MapType6Store arg0@@608 arg1@@308 arg2@@171 arg3@@98))
                   (MapType6Type (type arg1@@308) (type arg3@@98)))
                :pattern ((MapType6Store arg0@@608 arg1@@308 arg2@@171 arg3@@98))
                :qid |funType:MapType6Store|)))
      (a!6 (forall ((m@@68 T@U) (x0@@27 T@U) (x1@@21 T@U) (val@@28 T@U))
             (! (=> (= (type val@@28) (MapType6TypeInv1 (type m@@68)))
                    (= (MapType6Select (MapType6Store m@@68
                                                      x0@@27
                                                      x1@@21
                                                      val@@28)
                                       x0@@27
                                       x1@@21)
                       val@@28))
                :weight 0
                :qid |mapAx0:MapType6Select|)))
      (a!7 (forall ((arg0@@609 T@U)
                    (arg1@@309 T@U)
                    (arg2@@172 T@U)
                    (arg3@@99 Bool))
             (! (= (type (|lambda#0| arg0@@609 arg1@@309 arg2@@172 arg3@@99))
                   (MapType6Type refType boolType))
                :pattern ((|lambda#0| arg0@@609 arg1@@309 arg2@@172 arg3@@99))
                :qid |funType:lambda#0|))))
  (and a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       (forall ((val@@29 T@U)
                (m@@69 T@U)
                (x0@@28 T@U)
                (x1@@22 T@U)
                (y0@@21 T@U)
                (y1@@17 T@U))
         (! (let ((a!1 (= (MapType6Select (MapType6Store m@@69
                                                         x0@@28
                                                         x1@@22
                                                         val@@29)
                                          y0@@21
                                          y1@@17)
                          (MapType6Select m@@69 y0@@21 y1@@17))))
              (or (= x0@@28 y0@@21) a!1))
            :weight 0
            :qid |mapAx1:MapType6Select:0|))
       (forall ((val@@30 T@U)
                (m@@70 T@U)
                (x0@@29 T@U)
                (x1@@23 T@U)
                (y0@@22 T@U)
                (y1@@18 T@U))
         (! (let ((a!1 (= (MapType6Select (MapType6Store m@@70
                                                         x0@@29
                                                         x1@@23
                                                         val@@30)
                                          y0@@22
                                          y1@@18)
                          (MapType6Select m@@70 y0@@22 y1@@18))))
              (or (= x1@@23 y1@@18) a!1))
            :weight 0
            :qid |mapAx1:MapType6Select:1|))
       (forall ((val@@31 T@U)
                (m@@71 T@U)
                (x0@@30 T@U)
                (x1@@24 T@U)
                (y0@@23 T@U)
                (y1@@19 T@U))
         (! (let ((a!1 (= (MapType6Select (MapType6Store m@@71
                                                         x0@@30
                                                         x1@@24
                                                         val@@31)
                                          y0@@23
                                          y1@@19)
                          (MapType6Select m@@71 y0@@23 y1@@19))))
              (or true a!1))
            :weight 0
            :qid |mapAx2:MapType6Select|))
       a!7)))
(assert (forall ((|l#0@@21| T@U)
         (|l#1| T@U)
         (|l#2| T@U)
         (|l#3| Bool)
         ($o@@55 T@U)
         ($f@@1 T@U))
  (! (let ((a!1 (= (type $f@@1) (FieldType (FieldTypeInv0 (type $f@@1)))))
           (a!2 (and (not (= $o@@55 |l#0@@21|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1| $o@@55)
                                               |l#2|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#0| |l#0@@21|
                                                         |l#1|
                                                         |l#2|
                                                         |l#3|)
                                             $o@@55
                                             $f@@1))
                   (=> a!2 |l#3|))))
       (=> (and (= (type |l#0@@21|) refType)
                (= (type |l#1|) (MapType0Type refType MapType1Type))
                (= (type |l#2|) (FieldType boolType))
                (= (type $o@@55) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#0| |l#0@@21| |l#1| |l#2| |l#3|)
                               $o@@55
                               $f@@1))
     :skolemid |3571|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@610 T@U) (arg1@@310 T@U) (arg2@@173 T@U) (arg3@@100 Bool))
  (! (= (type (|lambda#1| arg0@@610 arg1@@310 arg2@@173 arg3@@100))
        (MapType6Type refType boolType))
     :pattern ((|lambda#1| arg0@@610 arg1@@310 arg2@@173 arg3@@100))
     :qid |funType:lambda#1|)))
(assert (forall ((|l#0@@22| T@U)
         (|l#1@@0| T@U)
         (|l#2@@0| T@U)
         (|l#3@@0| Bool)
         ($o@@56 T@U)
         ($f@@2 T@U))
  (! (let ((a!1 (= (type $f@@2) (FieldType (FieldTypeInv0 (type $f@@2)))))
           (a!2 (and (not (= $o@@56 |l#0@@22|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@0| $o@@56)
                                               |l#2@@0|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#1| |l#0@@22|
                                                         |l#1@@0|
                                                         |l#2@@0|
                                                         |l#3@@0|)
                                             $o@@56
                                             $f@@2))
                   (=> a!2 |l#3@@0|))))
       (=> (and (= (type |l#0@@22|) refType)
                (= (type |l#1@@0|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@0|) (FieldType boolType))
                (= (type $o@@56) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#1| |l#0@@22| |l#1@@0| |l#2@@0| |l#3@@0|)
                               $o@@56
                               $f@@2))
     :skolemid |3572|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@611 T@U) (arg1@@311 T@U) (arg2@@174 T@U) (arg3@@101 Bool))
  (! (= (type (|lambda#2| arg0@@611 arg1@@311 arg2@@174 arg3@@101))
        (MapType6Type refType boolType))
     :pattern ((|lambda#2| arg0@@611 arg1@@311 arg2@@174 arg3@@101))
     :qid |funType:lambda#2|)))
(assert (forall ((|l#0@@23| T@U)
         (|l#1@@1| T@U)
         (|l#2@@1| T@U)
         (|l#3@@1| Bool)
         ($o@@57 T@U)
         ($f@@3 T@U))
  (! (let ((a!1 (= (type $f@@3) (FieldType (FieldTypeInv0 (type $f@@3)))))
           (a!2 (and (not (= $o@@57 |l#0@@23|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@1| $o@@57)
                                               |l#2@@1|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#2| |l#0@@23|
                                                         |l#1@@1|
                                                         |l#2@@1|
                                                         |l#3@@1|)
                                             $o@@57
                                             $f@@3))
                   (=> a!2 |l#3@@1|))))
       (=> (and (= (type |l#0@@23|) refType)
                (= (type |l#1@@1|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@1|) (FieldType boolType))
                (= (type $o@@57) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#2| |l#0@@23| |l#1@@1| |l#2@@1| |l#3@@1|)
                               $o@@57
                               $f@@3))
     :skolemid |3573|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@612 T@U) (arg1@@312 T@U) (arg2@@175 T@U) (arg3@@102 Bool))
  (! (= (type (|lambda#3| arg0@@612 arg1@@312 arg2@@175 arg3@@102))
        (MapType6Type refType boolType))
     :pattern ((|lambda#3| arg0@@612 arg1@@312 arg2@@175 arg3@@102))
     :qid |funType:lambda#3|)))
(assert (forall ((|l#0@@24| T@U)
         (|l#1@@2| T@U)
         (|l#2@@2| T@U)
         (|l#3@@2| Bool)
         ($o@@58 T@U)
         ($f@@4 T@U))
  (! (let ((a!1 (= (type $f@@4) (FieldType (FieldTypeInv0 (type $f@@4)))))
           (a!2 (and (not (= $o@@58 |l#0@@24|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@2| $o@@58)
                                               |l#2@@2|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#3| |l#0@@24|
                                                         |l#1@@2|
                                                         |l#2@@2|
                                                         |l#3@@2|)
                                             $o@@58
                                             $f@@4))
                   (=> a!2 |l#3@@2|))))
       (=> (and (= (type |l#0@@24|) refType)
                (= (type |l#1@@2|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@2|) (FieldType boolType))
                (= (type $o@@58) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#3| |l#0@@24| |l#1@@2| |l#2@@2| |l#3@@2|)
                               $o@@58
                               $f@@4))
     :skolemid |3574|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((|l#0@@25| T@U) (|$w#0| T@U))
  (! (let ((a!1 (and ($IsBox |$w#0| |l#0@@25|)
                     (TotalKMMapMod.__default.AnyKey
                       ($Unbox (SeqType BoxType) |$w#0|)))))
     (let ((a!2 (= (U_2_bool (MapType0Select (|lambda#4| |l#0@@25|) |$w#0|))
                   a!1)))
       (=> (and (= (type |l#0@@25|) TyType) (= (type |$w#0|) BoxType)) a!2)))
     :pattern ((MapType0Select (|lambda#4| |l#0@@25|) |$w#0|))
     :skolemid |3575|
     :qid |KeyTypesdfy.10:8|)))
(assert (forall ((|l#0@@26| T@U) (|$w#0@@0| T@U))
  (! (let ((a!1 ($Box (PagedBetreeRefinement.__default.INodeAt
                        |l#0@@26|
                        ($Unbox (SeqType BoxType) |$w#0@@0|)))))
       (=> (and (= (type |l#0@@26|) DatatypeTypeType)
                (= (type |$w#0@@0|) BoxType))
           (= (MapType0Select (|lambda#5| |l#0@@26|) |$w#0@@0|) a!1)))
     :pattern ((MapType0Select (|lambda#5| |l#0@@26|) |$w#0@@0|))
     :skolemid |3576|
     :qid |PagedBetreeRefinementidfy.51:28|)))
(assert (forall ((arg0@@613 T@U) (arg1@@313 T@U) (arg2@@176 T@U) (arg3@@103 Bool))
  (! (= (type (|lambda#8| arg0@@613 arg1@@313 arg2@@176 arg3@@103))
        (MapType6Type refType boolType))
     :pattern ((|lambda#8| arg0@@613 arg1@@313 arg2@@176 arg3@@103))
     :qid |funType:lambda#8|)))
(assert (forall ((|l#0@@27| T@U)
         (|l#1@@3| T@U)
         (|l#2@@3| T@U)
         (|l#3@@3| Bool)
         ($o@@59 T@U)
         ($f@@5 T@U))
  (! (let ((a!1 (= (type $f@@5) (FieldType (FieldTypeInv0 (type $f@@5)))))
           (a!2 (and (not (= $o@@59 |l#0@@27|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@3| $o@@59)
                                               |l#2@@3|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#8| |l#0@@27|
                                                         |l#1@@3|
                                                         |l#2@@3|
                                                         |l#3@@3|)
                                             $o@@59
                                             $f@@5))
                   (=> a!2 |l#3@@3|))))
       (=> (and (= (type |l#0@@27|) refType)
                (= (type |l#1@@3|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@3|) (FieldType boolType))
                (= (type $o@@59) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#8| |l#0@@27| |l#1@@3| |l#2@@3| |l#3@@3|)
                               $o@@59
                               $f@@5))
     :skolemid |3577|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@614 T@U) (arg1@@314 T@U) (arg2@@177 T@U) (arg3@@104 Bool))
  (! (= (type (|lambda#9| arg0@@614 arg1@@314 arg2@@177 arg3@@104))
        (MapType6Type refType boolType))
     :pattern ((|lambda#9| arg0@@614 arg1@@314 arg2@@177 arg3@@104))
     :qid |funType:lambda#9|)))
(assert (forall ((|l#0@@28| T@U)
         (|l#1@@4| T@U)
         (|l#2@@4| T@U)
         (|l#3@@4| Bool)
         ($o@@60 T@U)
         ($f@@6 T@U))
  (! (let ((a!1 (= (type $f@@6) (FieldType (FieldTypeInv0 (type $f@@6)))))
           (a!2 (and (not (= $o@@60 |l#0@@28|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@4| $o@@60)
                                               |l#2@@4|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#9| |l#0@@28|
                                                         |l#1@@4|
                                                         |l#2@@4|
                                                         |l#3@@4|)
                                             $o@@60
                                             $f@@6))
                   (=> a!2 |l#3@@4|))))
       (=> (and (= (type |l#0@@28|) refType)
                (= (type |l#1@@4|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@4|) (FieldType boolType))
                (= (type $o@@60) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#9| |l#0@@28| |l#1@@4| |l#2@@4| |l#3@@4|)
                               $o@@60
                               $f@@6))
     :skolemid |3578|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@615 T@U) (arg1@@315 T@U) (arg2@@178 T@U) (arg3@@105 Bool))
  (! (= (type (|lambda#12| arg0@@615 arg1@@315 arg2@@178 arg3@@105))
        (MapType6Type refType boolType))
     :pattern ((|lambda#12| arg0@@615 arg1@@315 arg2@@178 arg3@@105))
     :qid |funType:lambda#12|)))
(assert (forall ((|l#0@@29| T@U)
         (|l#1@@5| T@U)
         (|l#2@@5| T@U)
         (|l#3@@5| Bool)
         ($o@@61 T@U)
         ($f@@7 T@U))
  (! (let ((a!1 (= (type $f@@7) (FieldType (FieldTypeInv0 (type $f@@7)))))
           (a!2 (and (not (= $o@@61 |l#0@@29|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@5| $o@@61)
                                               |l#2@@5|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#12| |l#0@@29|
                                                          |l#1@@5|
                                                          |l#2@@5|
                                                          |l#3@@5|)
                                             $o@@61
                                             $f@@7))
                   (=> a!2 |l#3@@5|))))
       (=> (and (= (type |l#0@@29|) refType)
                (= (type |l#1@@5|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@5|) (FieldType boolType))
                (= (type $o@@61) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#12| |l#0@@29|
                                            |l#1@@5|
                                            |l#2@@5|
                                            |l#3@@5|)
                               $o@@61
                               $f@@7))
     :skolemid |3579|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@616 T@U) (arg1@@316 T@U) (arg2@@179 T@U) (arg3@@106 Bool))
  (! (= (type (|lambda#13| arg0@@616 arg1@@316 arg2@@179 arg3@@106))
        (MapType6Type refType boolType))
     :pattern ((|lambda#13| arg0@@616 arg1@@316 arg2@@179 arg3@@106))
     :qid |funType:lambda#13|)))
(assert (forall ((|l#0@@30| T@U)
         (|l#1@@6| T@U)
         (|l#2@@6| T@U)
         (|l#3@@6| Bool)
         ($o@@62 T@U)
         ($f@@8 T@U))
  (! (let ((a!1 (= (type $f@@8) (FieldType (FieldTypeInv0 (type $f@@8)))))
           (a!2 (and (not (= $o@@62 |l#0@@30|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@6| $o@@62)
                                               |l#2@@6|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#13| |l#0@@30|
                                                          |l#1@@6|
                                                          |l#2@@6|
                                                          |l#3@@6|)
                                             $o@@62
                                             $f@@8))
                   (=> a!2 |l#3@@6|))))
       (=> (and (= (type |l#0@@30|) refType)
                (= (type |l#1@@6|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@6|) (FieldType boolType))
                (= (type $o@@62) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#13| |l#0@@30|
                                            |l#1@@6|
                                            |l#2@@6|
                                            |l#3@@6|)
                               $o@@62
                               $f@@8))
     :skolemid |3580|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@617 T@U) (arg1@@317 T@U) (arg2@@180 T@U) (arg3@@107 Bool))
  (! (= (type (|lambda#14| arg0@@617 arg1@@317 arg2@@180 arg3@@107))
        (MapType6Type refType boolType))
     :pattern ((|lambda#14| arg0@@617 arg1@@317 arg2@@180 arg3@@107))
     :qid |funType:lambda#14|)))
(assert (forall ((|l#0@@31| T@U)
         (|l#1@@7| T@U)
         (|l#2@@7| T@U)
         (|l#3@@7| Bool)
         ($o@@63 T@U)
         ($f@@9 T@U))
  (! (let ((a!1 (= (type $f@@9) (FieldType (FieldTypeInv0 (type $f@@9)))))
           (a!2 (and (not (= $o@@63 |l#0@@31|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@7| $o@@63)
                                               |l#2@@7|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#14| |l#0@@31|
                                                          |l#1@@7|
                                                          |l#2@@7|
                                                          |l#3@@7|)
                                             $o@@63
                                             $f@@9))
                   (=> a!2 |l#3@@7|))))
       (=> (and (= (type |l#0@@31|) refType)
                (= (type |l#1@@7|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@7|) (FieldType boolType))
                (= (type $o@@63) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#14| |l#0@@31|
                                            |l#1@@7|
                                            |l#2@@7|
                                            |l#3@@7|)
                               $o@@63
                               $f@@9))
     :skolemid |3581|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@618 T@U) (arg1@@318 T@U) (arg2@@181 T@U) (arg3@@108 Bool))
  (! (= (type (|lambda#15| arg0@@618 arg1@@318 arg2@@181 arg3@@108))
        (MapType6Type refType boolType))
     :pattern ((|lambda#15| arg0@@618 arg1@@318 arg2@@181 arg3@@108))
     :qid |funType:lambda#15|)))
(assert (forall ((|l#0@@32| T@U)
         (|l#1@@8| T@U)
         (|l#2@@8| T@U)
         (|l#3@@8| Bool)
         ($o@@64 T@U)
         ($f@@10 T@U))
  (! (let ((a!1 (= (type $f@@10) (FieldType (FieldTypeInv0 (type $f@@10)))))
           (a!2 (and (not (= $o@@64 |l#0@@32|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@8| $o@@64)
                                               |l#2@@8|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#15| |l#0@@32|
                                                          |l#1@@8|
                                                          |l#2@@8|
                                                          |l#3@@8|)
                                             $o@@64
                                             $f@@10))
                   (=> a!2 |l#3@@8|))))
       (=> (and (= (type |l#0@@32|) refType)
                (= (type |l#1@@8|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@8|) (FieldType boolType))
                (= (type $o@@64) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#15| |l#0@@32|
                                            |l#1@@8|
                                            |l#2@@8|
                                            |l#3@@8|)
                               $o@@64
                               $f@@10))
     :skolemid |3582|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@619 T@U) (arg1@@319 T@U) (arg2@@182 T@U) (arg3@@109 Bool))
  (! (= (type (|lambda#16| arg0@@619 arg1@@319 arg2@@182 arg3@@109))
        (MapType6Type refType boolType))
     :pattern ((|lambda#16| arg0@@619 arg1@@319 arg2@@182 arg3@@109))
     :qid |funType:lambda#16|)))
(assert (forall ((|l#0@@33| T@U)
         (|l#1@@9| T@U)
         (|l#2@@9| T@U)
         (|l#3@@9| Bool)
         ($o@@65 T@U)
         ($f@@11 T@U))
  (! (let ((a!1 (= (type $f@@11) (FieldType (FieldTypeInv0 (type $f@@11)))))
           (a!2 (and (not (= $o@@65 |l#0@@33|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@9| $o@@65)
                                               |l#2@@9|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#16| |l#0@@33|
                                                          |l#1@@9|
                                                          |l#2@@9|
                                                          |l#3@@9|)
                                             $o@@65
                                             $f@@11))
                   (=> a!2 |l#3@@9|))))
       (=> (and (= (type |l#0@@33|) refType)
                (= (type |l#1@@9|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@9|) (FieldType boolType))
                (= (type $o@@65) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#16| |l#0@@33|
                                            |l#1@@9|
                                            |l#2@@9|
                                            |l#3@@9|)
                               $o@@65
                               $f@@11))
     :skolemid |3583|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@620 T@U) (arg1@@320 T@U) (arg2@@183 T@U) (arg3@@110 Bool))
  (! (= (type (|lambda#17| arg0@@620 arg1@@320 arg2@@183 arg3@@110))
        (MapType6Type refType boolType))
     :pattern ((|lambda#17| arg0@@620 arg1@@320 arg2@@183 arg3@@110))
     :qid |funType:lambda#17|)))
(assert (forall ((|l#0@@34| T@U)
         (|l#1@@10| T@U)
         (|l#2@@10| T@U)
         (|l#3@@10| Bool)
         ($o@@66 T@U)
         ($f@@12 T@U))
  (! (let ((a!1 (= (type $f@@12) (FieldType (FieldTypeInv0 (type $f@@12)))))
           (a!2 (and (not (= $o@@66 |l#0@@34|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@10| $o@@66)
                                               |l#2@@10|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#17| |l#0@@34|
                                                          |l#1@@10|
                                                          |l#2@@10|
                                                          |l#3@@10|)
                                             $o@@66
                                             $f@@12))
                   (=> a!2 |l#3@@10|))))
       (=> (and (= (type |l#0@@34|) refType)
                (= (type |l#1@@10|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@10|) (FieldType boolType))
                (= (type $o@@66) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#17| |l#0@@34|
                                            |l#1@@10|
                                            |l#2@@10|
                                            |l#3@@10|)
                               $o@@66
                               $f@@12))
     :skolemid |3584|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@621 T@U) (arg1@@321 T@U) (arg2@@184 T@U) (arg3@@111 Bool))
  (! (= (type (|lambda#18| arg0@@621 arg1@@321 arg2@@184 arg3@@111))
        (MapType6Type refType boolType))
     :pattern ((|lambda#18| arg0@@621 arg1@@321 arg2@@184 arg3@@111))
     :qid |funType:lambda#18|)))
(assert (forall ((|l#0@@35| T@U)
         (|l#1@@11| T@U)
         (|l#2@@11| T@U)
         (|l#3@@11| Bool)
         ($o@@67 T@U)
         ($f@@13 T@U))
  (! (let ((a!1 (= (type $f@@13) (FieldType (FieldTypeInv0 (type $f@@13)))))
           (a!2 (and (not (= $o@@67 |l#0@@35|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@11| $o@@67)
                                               |l#2@@11|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#18| |l#0@@35|
                                                          |l#1@@11|
                                                          |l#2@@11|
                                                          |l#3@@11|)
                                             $o@@67
                                             $f@@13))
                   (=> a!2 |l#3@@11|))))
       (=> (and (= (type |l#0@@35|) refType)
                (= (type |l#1@@11|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@11|) (FieldType boolType))
                (= (type $o@@67) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#18| |l#0@@35|
                                            |l#1@@11|
                                            |l#2@@11|
                                            |l#3@@11|)
                               $o@@67
                               $f@@13))
     :skolemid |3585|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@622 T@U) (arg1@@322 T@U) (arg2@@185 T@U) (arg3@@112 Bool))
  (! (= (type (|lambda#19| arg0@@622 arg1@@322 arg2@@185 arg3@@112))
        (MapType6Type refType boolType))
     :pattern ((|lambda#19| arg0@@622 arg1@@322 arg2@@185 arg3@@112))
     :qid |funType:lambda#19|)))
(assert (forall ((|l#0@@36| T@U)
         (|l#1@@12| T@U)
         (|l#2@@12| T@U)
         (|l#3@@12| Bool)
         ($o@@68 T@U)
         ($f@@14 T@U))
  (! (let ((a!1 (= (type $f@@14) (FieldType (FieldTypeInv0 (type $f@@14)))))
           (a!2 (and (not (= $o@@68 |l#0@@36|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@12| $o@@68)
                                               |l#2@@12|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#19| |l#0@@36|
                                                          |l#1@@12|
                                                          |l#2@@12|
                                                          |l#3@@12|)
                                             $o@@68
                                             $f@@14))
                   (=> a!2 |l#3@@12|))))
       (=> (and (= (type |l#0@@36|) refType)
                (= (type |l#1@@12|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@12|) (FieldType boolType))
                (= (type $o@@68) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#19| |l#0@@36|
                                            |l#1@@12|
                                            |l#2@@12|
                                            |l#3@@12|)
                               $o@@68
                               $f@@14))
     :skolemid |3586|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@623 T@U) (arg1@@323 T@U) (arg2@@186 T@U) (arg3@@113 Bool))
  (! (= (type (|lambda#20| arg0@@623 arg1@@323 arg2@@186 arg3@@113))
        (MapType6Type refType boolType))
     :pattern ((|lambda#20| arg0@@623 arg1@@323 arg2@@186 arg3@@113))
     :qid |funType:lambda#20|)))
(assert (forall ((|l#0@@37| T@U)
         (|l#1@@13| T@U)
         (|l#2@@13| T@U)
         (|l#3@@13| Bool)
         ($o@@69 T@U)
         ($f@@15 T@U))
  (! (let ((a!1 (= (type $f@@15) (FieldType (FieldTypeInv0 (type $f@@15)))))
           (a!2 (and (not (= $o@@69 |l#0@@37|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@13| $o@@69)
                                               |l#2@@13|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#20| |l#0@@37|
                                                          |l#1@@13|
                                                          |l#2@@13|
                                                          |l#3@@13|)
                                             $o@@69
                                             $f@@15))
                   (=> a!2 |l#3@@13|))))
       (=> (and (= (type |l#0@@37|) refType)
                (= (type |l#1@@13|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@13|) (FieldType boolType))
                (= (type $o@@69) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#20| |l#0@@37|
                                            |l#1@@13|
                                            |l#2@@13|
                                            |l#3@@13|)
                               $o@@69
                               $f@@15))
     :skolemid |3587|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@624 T@U) (arg1@@324 T@U) (arg2@@187 T@U) (arg3@@114 Bool))
  (! (= (type (|lambda#21| arg0@@624 arg1@@324 arg2@@187 arg3@@114))
        (MapType6Type refType boolType))
     :pattern ((|lambda#21| arg0@@624 arg1@@324 arg2@@187 arg3@@114))
     :qid |funType:lambda#21|)))
(assert (forall ((|l#0@@38| T@U)
         (|l#1@@14| T@U)
         (|l#2@@14| T@U)
         (|l#3@@14| Bool)
         ($o@@70 T@U)
         ($f@@16 T@U))
  (! (let ((a!1 (= (type $f@@16) (FieldType (FieldTypeInv0 (type $f@@16)))))
           (a!2 (and (not (= $o@@70 |l#0@@38|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@14| $o@@70)
                                               |l#2@@14|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#21| |l#0@@38|
                                                          |l#1@@14|
                                                          |l#2@@14|
                                                          |l#3@@14|)
                                             $o@@70
                                             $f@@16))
                   (=> a!2 |l#3@@14|))))
       (=> (and (= (type |l#0@@38|) refType)
                (= (type |l#1@@14|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@14|) (FieldType boolType))
                (= (type $o@@70) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#21| |l#0@@38|
                                            |l#1@@14|
                                            |l#2@@14|
                                            |l#3@@14|)
                               $o@@70
                               $f@@16))
     :skolemid |3588|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((|l#0@@39| T@U) (|l#1@@15| T@U) (|$w#0@@1| T@U))
  (! (let ((a!1 (ValueMessage.__default.Merge
                  (MemtableMod.Memtable.Get
                    |l#0@@39|
                    ($Unbox (SeqType BoxType) |$w#0@@1|))
                  ($Unbox DatatypeTypeType (MapType0Select |l#1@@15| |$w#0@@1|)))))
       (=> (and (= (type |l#0@@39|) DatatypeTypeType)
                (= (type |l#1@@15|) (MapType0Type BoxType BoxType))
                (= (type |$w#0@@1|) BoxType))
           (= (MapType0Select (|lambda#23| |l#0@@39| |l#1@@15|) |$w#0@@1|)
              ($Box a!1))))
     :pattern ((MapType0Select (|lambda#23| |l#0@@39| |l#1@@15|) |$w#0@@1|))
     :skolemid |3589|
     :qid |PagedBetreeRefinementidfy.115:31|)))
(assert (forall ((arg0@@625 T@U) (arg1@@325 T@U) (arg2@@188 T@U) (arg3@@115 Bool))
  (! (= (type (|lambda#28| arg0@@625 arg1@@325 arg2@@188 arg3@@115))
        (MapType6Type refType boolType))
     :pattern ((|lambda#28| arg0@@625 arg1@@325 arg2@@188 arg3@@115))
     :qid |funType:lambda#28|)))
(assert (forall ((|l#0@@40| T@U)
         (|l#1@@16| T@U)
         (|l#2@@15| T@U)
         (|l#3@@15| Bool)
         ($o@@71 T@U)
         ($f@@17 T@U))
  (! (let ((a!1 (= (type $f@@17) (FieldType (FieldTypeInv0 (type $f@@17)))))
           (a!2 (and (not (= $o@@71 |l#0@@40|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@16| $o@@71)
                                               |l#2@@15|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#28| |l#0@@40|
                                                          |l#1@@16|
                                                          |l#2@@15|
                                                          |l#3@@15|)
                                             $o@@71
                                             $f@@17))
                   (=> a!2 |l#3@@15|))))
       (=> (and (= (type |l#0@@40|) refType)
                (= (type |l#1@@16|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@15|) (FieldType boolType))
                (= (type $o@@71) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#28| |l#0@@40|
                                            |l#1@@16|
                                            |l#2@@15|
                                            |l#3@@15|)
                               $o@@71
                               $f@@17))
     :skolemid |3590|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@626 T@U) (arg1@@326 T@U) (arg2@@189 T@U) (arg3@@116 Bool))
  (! (= (type (|lambda#29| arg0@@626 arg1@@326 arg2@@189 arg3@@116))
        (MapType6Type refType boolType))
     :pattern ((|lambda#29| arg0@@626 arg1@@326 arg2@@189 arg3@@116))
     :qid |funType:lambda#29|)))
(assert (forall ((|l#0@@41| T@U)
         (|l#1@@17| T@U)
         (|l#2@@16| T@U)
         (|l#3@@16| Bool)
         ($o@@72 T@U)
         ($f@@18 T@U))
  (! (let ((a!1 (= (type $f@@18) (FieldType (FieldTypeInv0 (type $f@@18)))))
           (a!2 (and (not (= $o@@72 |l#0@@41|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@17| $o@@72)
                                               |l#2@@16|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#29| |l#0@@41|
                                                          |l#1@@17|
                                                          |l#2@@16|
                                                          |l#3@@16|)
                                             $o@@72
                                             $f@@18))
                   (=> a!2 |l#3@@16|))))
       (=> (and (= (type |l#0@@41|) refType)
                (= (type |l#1@@17|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@16|) (FieldType boolType))
                (= (type $o@@72) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#29| |l#0@@41|
                                            |l#1@@17|
                                            |l#2@@16|
                                            |l#3@@16|)
                               $o@@72
                               $f@@18))
     :skolemid |3591|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@627 T@U) (arg1@@327 T@U) (arg2@@190 T@U) (arg3@@117 Bool))
  (! (= (type (|lambda#32| arg0@@627 arg1@@327 arg2@@190 arg3@@117))
        (MapType6Type refType boolType))
     :pattern ((|lambda#32| arg0@@627 arg1@@327 arg2@@190 arg3@@117))
     :qid |funType:lambda#32|)))
(assert (forall ((|l#0@@42| T@U)
         (|l#1@@18| T@U)
         (|l#2@@17| T@U)
         (|l#3@@17| Bool)
         ($o@@73 T@U)
         ($f@@19 T@U))
  (! (let ((a!1 (= (type $f@@19) (FieldType (FieldTypeInv0 (type $f@@19)))))
           (a!2 (and (not (= $o@@73 |l#0@@42|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@18| $o@@73)
                                               |l#2@@17|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#32| |l#0@@42|
                                                          |l#1@@18|
                                                          |l#2@@17|
                                                          |l#3@@17|)
                                             $o@@73
                                             $f@@19))
                   (=> a!2 |l#3@@17|))))
       (=> (and (= (type |l#0@@42|) refType)
                (= (type |l#1@@18|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@17|) (FieldType boolType))
                (= (type $o@@73) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#32| |l#0@@42|
                                            |l#1@@18|
                                            |l#2@@17|
                                            |l#3@@17|)
                               $o@@73
                               $f@@19))
     :skolemid |3592|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@628 T@U) (arg1@@328 T@U) (arg2@@191 T@U) (arg3@@118 Bool))
  (! (= (type (|lambda#33| arg0@@628 arg1@@328 arg2@@191 arg3@@118))
        (MapType6Type refType boolType))
     :pattern ((|lambda#33| arg0@@628 arg1@@328 arg2@@191 arg3@@118))
     :qid |funType:lambda#33|)))
(assert (forall ((|l#0@@43| T@U)
         (|l#1@@19| T@U)
         (|l#2@@18| T@U)
         (|l#3@@18| Bool)
         ($o@@74 T@U)
         ($f@@20 T@U))
  (! (let ((a!1 (= (type $f@@20) (FieldType (FieldTypeInv0 (type $f@@20)))))
           (a!2 (and (not (= $o@@74 |l#0@@43|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@19| $o@@74)
                                               |l#2@@18|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#33| |l#0@@43|
                                                          |l#1@@19|
                                                          |l#2@@18|
                                                          |l#3@@18|)
                                             $o@@74
                                             $f@@20))
                   (=> a!2 |l#3@@18|))))
       (=> (and (= (type |l#0@@43|) refType)
                (= (type |l#1@@19|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@18|) (FieldType boolType))
                (= (type $o@@74) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#33| |l#0@@43|
                                            |l#1@@19|
                                            |l#2@@18|
                                            |l#3@@18|)
                               $o@@74
                               $f@@20))
     :skolemid |3593|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@629 T@U) (arg1@@329 T@U) (arg2@@192 T@U) (arg3@@119 Bool))
  (! (= (type (|lambda#34| arg0@@629 arg1@@329 arg2@@192 arg3@@119))
        (MapType6Type refType boolType))
     :pattern ((|lambda#34| arg0@@629 arg1@@329 arg2@@192 arg3@@119))
     :qid |funType:lambda#34|)))
(assert (forall ((|l#0@@44| T@U)
         (|l#1@@20| T@U)
         (|l#2@@19| T@U)
         (|l#3@@19| Bool)
         ($o@@75 T@U)
         ($f@@21 T@U))
  (! (let ((a!1 (= (type $f@@21) (FieldType (FieldTypeInv0 (type $f@@21)))))
           (a!2 (and (not (= $o@@75 |l#0@@44|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@20| $o@@75)
                                               |l#2@@19|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#34| |l#0@@44|
                                                          |l#1@@20|
                                                          |l#2@@19|
                                                          |l#3@@19|)
                                             $o@@75
                                             $f@@21))
                   (=> a!2 |l#3@@19|))))
       (=> (and (= (type |l#0@@44|) refType)
                (= (type |l#1@@20|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@19|) (FieldType boolType))
                (= (type $o@@75) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#34| |l#0@@44|
                                            |l#1@@20|
                                            |l#2@@19|
                                            |l#3@@19|)
                               $o@@75
                               $f@@21))
     :skolemid |3594|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@630 T@U) (arg1@@330 T@U) (arg2@@193 T@U) (arg3@@120 Bool))
  (! (= (type (|lambda#35| arg0@@630 arg1@@330 arg2@@193 arg3@@120))
        (MapType6Type refType boolType))
     :pattern ((|lambda#35| arg0@@630 arg1@@330 arg2@@193 arg3@@120))
     :qid |funType:lambda#35|)))
(assert (forall ((|l#0@@45| T@U)
         (|l#1@@21| T@U)
         (|l#2@@20| T@U)
         (|l#3@@20| Bool)
         ($o@@76 T@U)
         ($f@@22 T@U))
  (! (let ((a!1 (= (type $f@@22) (FieldType (FieldTypeInv0 (type $f@@22)))))
           (a!2 (and (not (= $o@@76 |l#0@@45|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@21| $o@@76)
                                               |l#2@@20|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#35| |l#0@@45|
                                                          |l#1@@21|
                                                          |l#2@@20|
                                                          |l#3@@20|)
                                             $o@@76
                                             $f@@22))
                   (=> a!2 |l#3@@20|))))
       (=> (and (= (type |l#0@@45|) refType)
                (= (type |l#1@@21|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@20|) (FieldType boolType))
                (= (type $o@@76) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#35| |l#0@@45|
                                            |l#1@@21|
                                            |l#2@@20|
                                            |l#3@@20|)
                               $o@@76
                               $f@@22))
     :skolemid |3595|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@631 T@U) (arg1@@331 T@U) (arg2@@194 T@U) (arg3@@121 Bool))
  (! (= (type (|lambda#36| arg0@@631 arg1@@331 arg2@@194 arg3@@121))
        (MapType6Type refType boolType))
     :pattern ((|lambda#36| arg0@@631 arg1@@331 arg2@@194 arg3@@121))
     :qid |funType:lambda#36|)))
(assert (forall ((|l#0@@46| T@U)
         (|l#1@@22| T@U)
         (|l#2@@21| T@U)
         (|l#3@@21| Bool)
         ($o@@77 T@U)
         ($f@@23 T@U))
  (! (let ((a!1 (= (type $f@@23) (FieldType (FieldTypeInv0 (type $f@@23)))))
           (a!2 (and (not (= $o@@77 |l#0@@46|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@22| $o@@77)
                                               |l#2@@21|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#36| |l#0@@46|
                                                          |l#1@@22|
                                                          |l#2@@21|
                                                          |l#3@@21|)
                                             $o@@77
                                             $f@@23))
                   (=> a!2 |l#3@@21|))))
       (=> (and (= (type |l#0@@46|) refType)
                (= (type |l#1@@22|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@21|) (FieldType boolType))
                (= (type $o@@77) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#36| |l#0@@46|
                                            |l#1@@22|
                                            |l#2@@21|
                                            |l#3@@21|)
                               $o@@77
                               $f@@23))
     :skolemid |3596|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@632 T@U) (arg1@@332 T@U) (arg2@@195 T@U) (arg3@@122 Bool))
  (! (= (type (|lambda#37| arg0@@632 arg1@@332 arg2@@195 arg3@@122))
        (MapType6Type refType boolType))
     :pattern ((|lambda#37| arg0@@632 arg1@@332 arg2@@195 arg3@@122))
     :qid |funType:lambda#37|)))
(assert (forall ((|l#0@@47| T@U)
         (|l#1@@23| T@U)
         (|l#2@@22| T@U)
         (|l#3@@22| Bool)
         ($o@@78 T@U)
         ($f@@24 T@U))
  (! (let ((a!1 (= (type $f@@24) (FieldType (FieldTypeInv0 (type $f@@24)))))
           (a!2 (and (not (= $o@@78 |l#0@@47|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@23| $o@@78)
                                               |l#2@@22|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#37| |l#0@@47|
                                                          |l#1@@23|
                                                          |l#2@@22|
                                                          |l#3@@22|)
                                             $o@@78
                                             $f@@24))
                   (=> a!2 |l#3@@22|))))
       (=> (and (= (type |l#0@@47|) refType)
                (= (type |l#1@@23|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@22|) (FieldType boolType))
                (= (type $o@@78) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#37| |l#0@@47|
                                            |l#1@@23|
                                            |l#2@@22|
                                            |l#3@@22|)
                               $o@@78
                               $f@@24))
     :skolemid |3597|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@633 T@U) (arg1@@333 T@U) (arg2@@196 T@U) (arg3@@123 Bool))
  (! (= (type (|lambda#38| arg0@@633 arg1@@333 arg2@@196 arg3@@123))
        (MapType6Type refType boolType))
     :pattern ((|lambda#38| arg0@@633 arg1@@333 arg2@@196 arg3@@123))
     :qid |funType:lambda#38|)))
(assert (forall ((|l#0@@48| T@U)
         (|l#1@@24| T@U)
         (|l#2@@23| T@U)
         (|l#3@@23| Bool)
         ($o@@79 T@U)
         ($f@@25 T@U))
  (! (let ((a!1 (= (type $f@@25) (FieldType (FieldTypeInv0 (type $f@@25)))))
           (a!2 (and (not (= $o@@79 |l#0@@48|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@24| $o@@79)
                                               |l#2@@23|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#38| |l#0@@48|
                                                          |l#1@@24|
                                                          |l#2@@23|
                                                          |l#3@@23|)
                                             $o@@79
                                             $f@@25))
                   (=> a!2 |l#3@@23|))))
       (=> (and (= (type |l#0@@48|) refType)
                (= (type |l#1@@24|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@23|) (FieldType boolType))
                (= (type $o@@79) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#38| |l#0@@48|
                                            |l#1@@24|
                                            |l#2@@23|
                                            |l#3@@23|)
                               $o@@79
                               $f@@25))
     :skolemid |3598|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@634 T@U) (arg1@@334 T@U) (arg2@@197 T@U) (arg3@@124 Bool))
  (! (= (type (|lambda#39| arg0@@634 arg1@@334 arg2@@197 arg3@@124))
        (MapType6Type refType boolType))
     :pattern ((|lambda#39| arg0@@634 arg1@@334 arg2@@197 arg3@@124))
     :qid |funType:lambda#39|)))
(assert (forall ((|l#0@@49| T@U)
         (|l#1@@25| T@U)
         (|l#2@@24| T@U)
         (|l#3@@24| Bool)
         ($o@@80 T@U)
         ($f@@26 T@U))
  (! (let ((a!1 (= (type $f@@26) (FieldType (FieldTypeInv0 (type $f@@26)))))
           (a!2 (and (not (= $o@@80 |l#0@@49|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@25| $o@@80)
                                               |l#2@@24|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#39| |l#0@@49|
                                                          |l#1@@25|
                                                          |l#2@@24|
                                                          |l#3@@24|)
                                             $o@@80
                                             $f@@26))
                   (=> a!2 |l#3@@24|))))
       (=> (and (= (type |l#0@@49|) refType)
                (= (type |l#1@@25|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@24|) (FieldType boolType))
                (= (type $o@@80) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#39| |l#0@@49|
                                            |l#1@@25|
                                            |l#2@@24|
                                            |l#3@@24|)
                               $o@@80
                               $f@@26))
     :skolemid |3599|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@635 T@U) (arg1@@335 T@U) (arg2@@198 T@U) (arg3@@125 Bool))
  (! (= (type (|lambda#40| arg0@@635 arg1@@335 arg2@@198 arg3@@125))
        (MapType6Type refType boolType))
     :pattern ((|lambda#40| arg0@@635 arg1@@335 arg2@@198 arg3@@125))
     :qid |funType:lambda#40|)))
(assert (forall ((|l#0@@50| T@U)
         (|l#1@@26| T@U)
         (|l#2@@25| T@U)
         (|l#3@@25| Bool)
         ($o@@81 T@U)
         ($f@@27 T@U))
  (! (let ((a!1 (= (type $f@@27) (FieldType (FieldTypeInv0 (type $f@@27)))))
           (a!2 (and (not (= $o@@81 |l#0@@50|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@26| $o@@81)
                                               |l#2@@25|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#40| |l#0@@50|
                                                          |l#1@@26|
                                                          |l#2@@25|
                                                          |l#3@@25|)
                                             $o@@81
                                             $f@@27))
                   (=> a!2 |l#3@@25|))))
       (=> (and (= (type |l#0@@50|) refType)
                (= (type |l#1@@26|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@25|) (FieldType boolType))
                (= (type $o@@81) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#40| |l#0@@50|
                                            |l#1@@26|
                                            |l#2@@25|
                                            |l#3@@25|)
                               $o@@81
                               $f@@27))
     :skolemid |3600|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@636 T@U) (arg1@@336 T@U) (arg2@@199 T@U) (arg3@@126 Bool))
  (! (= (type (|lambda#41| arg0@@636 arg1@@336 arg2@@199 arg3@@126))
        (MapType6Type refType boolType))
     :pattern ((|lambda#41| arg0@@636 arg1@@336 arg2@@199 arg3@@126))
     :qid |funType:lambda#41|)))
(assert (forall ((|l#0@@51| T@U)
         (|l#1@@27| T@U)
         (|l#2@@26| T@U)
         (|l#3@@26| Bool)
         ($o@@82 T@U)
         ($f@@28 T@U))
  (! (let ((a!1 (= (type $f@@28) (FieldType (FieldTypeInv0 (type $f@@28)))))
           (a!2 (and (not (= $o@@82 |l#0@@51|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@27| $o@@82)
                                               |l#2@@26|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#41| |l#0@@51|
                                                          |l#1@@27|
                                                          |l#2@@26|
                                                          |l#3@@26|)
                                             $o@@82
                                             $f@@28))
                   (=> a!2 |l#3@@26|))))
       (=> (and (= (type |l#0@@51|) refType)
                (= (type |l#1@@27|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@26|) (FieldType boolType))
                (= (type $o@@82) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#41| |l#0@@51|
                                            |l#1@@27|
                                            |l#2@@26|
                                            |l#3@@26|)
                               $o@@82
                               $f@@28))
     :skolemid |3601|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@637 T@U) (arg1@@337 T@U) (arg2@@200 T@U) (arg3@@127 Bool))
  (! (= (type (|lambda#42| arg0@@637 arg1@@337 arg2@@200 arg3@@127))
        (MapType6Type refType boolType))
     :pattern ((|lambda#42| arg0@@637 arg1@@337 arg2@@200 arg3@@127))
     :qid |funType:lambda#42|)))
(assert (forall ((|l#0@@52| T@U)
         (|l#1@@28| T@U)
         (|l#2@@27| T@U)
         (|l#3@@27| Bool)
         ($o@@83 T@U)
         ($f@@29 T@U))
  (! (let ((a!1 (= (type $f@@29) (FieldType (FieldTypeInv0 (type $f@@29)))))
           (a!2 (and (not (= $o@@83 |l#0@@52|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@28| $o@@83)
                                               |l#2@@27|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#42| |l#0@@52|
                                                          |l#1@@28|
                                                          |l#2@@27|
                                                          |l#3@@27|)
                                             $o@@83
                                             $f@@29))
                   (=> a!2 |l#3@@27|))))
       (=> (and (= (type |l#0@@52|) refType)
                (= (type |l#1@@28|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@27|) (FieldType boolType))
                (= (type $o@@83) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#42| |l#0@@52|
                                            |l#1@@28|
                                            |l#2@@27|
                                            |l#3@@27|)
                               $o@@83
                               $f@@29))
     :skolemid |3602|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@638 T@U) (arg1@@338 T@U) (arg2@@201 T@U) (arg3@@128 Bool))
  (! (= (type (|lambda#43| arg0@@638 arg1@@338 arg2@@201 arg3@@128))
        (MapType6Type refType boolType))
     :pattern ((|lambda#43| arg0@@638 arg1@@338 arg2@@201 arg3@@128))
     :qid |funType:lambda#43|)))
(assert (forall ((|l#0@@53| T@U)
         (|l#1@@29| T@U)
         (|l#2@@28| T@U)
         (|l#3@@28| Bool)
         ($o@@84 T@U)
         ($f@@30 T@U))
  (! (let ((a!1 (= (type $f@@30) (FieldType (FieldTypeInv0 (type $f@@30)))))
           (a!2 (and (not (= $o@@84 |l#0@@53|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@29| $o@@84)
                                               |l#2@@28|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#43| |l#0@@53|
                                                          |l#1@@29|
                                                          |l#2@@28|
                                                          |l#3@@28|)
                                             $o@@84
                                             $f@@30))
                   (=> a!2 |l#3@@28|))))
       (=> (and (= (type |l#0@@53|) refType)
                (= (type |l#1@@29|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@28|) (FieldType boolType))
                (= (type $o@@84) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#43| |l#0@@53|
                                            |l#1@@29|
                                            |l#2@@28|
                                            |l#3@@28|)
                               $o@@84
                               $f@@30))
     :skolemid |3603|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@639 T@U) (arg1@@339 T@U) (arg2@@202 T@U) (arg3@@129 Bool))
  (! (= (type (|lambda#44| arg0@@639 arg1@@339 arg2@@202 arg3@@129))
        (MapType6Type refType boolType))
     :pattern ((|lambda#44| arg0@@639 arg1@@339 arg2@@202 arg3@@129))
     :qid |funType:lambda#44|)))
(assert (forall ((|l#0@@54| T@U)
         (|l#1@@30| T@U)
         (|l#2@@29| T@U)
         (|l#3@@29| Bool)
         ($o@@85 T@U)
         ($f@@31 T@U))
  (! (let ((a!1 (= (type $f@@31) (FieldType (FieldTypeInv0 (type $f@@31)))))
           (a!2 (and (not (= $o@@85 |l#0@@54|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@30| $o@@85)
                                               |l#2@@29|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#44| |l#0@@54|
                                                          |l#1@@30|
                                                          |l#2@@29|
                                                          |l#3@@29|)
                                             $o@@85
                                             $f@@31))
                   (=> a!2 |l#3@@29|))))
       (=> (and (= (type |l#0@@54|) refType)
                (= (type |l#1@@30|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@29|) (FieldType boolType))
                (= (type $o@@85) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#44| |l#0@@54|
                                            |l#1@@30|
                                            |l#2@@29|
                                            |l#3@@29|)
                               $o@@85
                               $f@@31))
     :skolemid |3604|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@640 T@U) (arg1@@340 T@U) (arg2@@203 T@U) (arg3@@130 Bool))
  (! (= (type (|lambda#45| arg0@@640 arg1@@340 arg2@@203 arg3@@130))
        (MapType6Type refType boolType))
     :pattern ((|lambda#45| arg0@@640 arg1@@340 arg2@@203 arg3@@130))
     :qid |funType:lambda#45|)))
(assert (forall ((|l#0@@55| T@U)
         (|l#1@@31| T@U)
         (|l#2@@30| T@U)
         (|l#3@@30| Bool)
         ($o@@86 T@U)
         ($f@@32 T@U))
  (! (let ((a!1 (= (type $f@@32) (FieldType (FieldTypeInv0 (type $f@@32)))))
           (a!2 (and (not (= $o@@86 |l#0@@55|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@31| $o@@86)
                                               |l#2@@30|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#45| |l#0@@55|
                                                          |l#1@@31|
                                                          |l#2@@30|
                                                          |l#3@@30|)
                                             $o@@86
                                             $f@@32))
                   (=> a!2 |l#3@@30|))))
       (=> (and (= (type |l#0@@55|) refType)
                (= (type |l#1@@31|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@30|) (FieldType boolType))
                (= (type $o@@86) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#45| |l#0@@55|
                                            |l#1@@31|
                                            |l#2@@30|
                                            |l#3@@30|)
                               $o@@86
                               $f@@32))
     :skolemid |3605|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@641 T@U) (arg1@@341 T@U) (arg2@@204 T@U) (arg3@@131 Bool))
  (! (= (type (|lambda#46| arg0@@641 arg1@@341 arg2@@204 arg3@@131))
        (MapType6Type refType boolType))
     :pattern ((|lambda#46| arg0@@641 arg1@@341 arg2@@204 arg3@@131))
     :qid |funType:lambda#46|)))
(assert (forall ((|l#0@@56| T@U)
         (|l#1@@32| T@U)
         (|l#2@@31| T@U)
         (|l#3@@31| Bool)
         ($o@@87 T@U)
         ($f@@33 T@U))
  (! (let ((a!1 (= (type $f@@33) (FieldType (FieldTypeInv0 (type $f@@33)))))
           (a!2 (and (not (= $o@@87 |l#0@@56|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@32| $o@@87)
                                               |l#2@@31|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#46| |l#0@@56|
                                                          |l#1@@32|
                                                          |l#2@@31|
                                                          |l#3@@31|)
                                             $o@@87
                                             $f@@33))
                   (=> a!2 |l#3@@31|))))
       (=> (and (= (type |l#0@@56|) refType)
                (= (type |l#1@@32|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@31|) (FieldType boolType))
                (= (type $o@@87) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#46| |l#0@@56|
                                            |l#1@@32|
                                            |l#2@@31|
                                            |l#3@@31|)
                               $o@@87
                               $f@@33))
     :skolemid |3606|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@642 T@U) (arg1@@342 T@U) (arg2@@205 T@U) (arg3@@132 Bool))
  (! (= (type (|lambda#47| arg0@@642 arg1@@342 arg2@@205 arg3@@132))
        (MapType6Type refType boolType))
     :pattern ((|lambda#47| arg0@@642 arg1@@342 arg2@@205 arg3@@132))
     :qid |funType:lambda#47|)))
(assert (forall ((|l#0@@57| T@U)
         (|l#1@@33| T@U)
         (|l#2@@32| T@U)
         (|l#3@@32| Bool)
         ($o@@88 T@U)
         ($f@@34 T@U))
  (! (let ((a!1 (= (type $f@@34) (FieldType (FieldTypeInv0 (type $f@@34)))))
           (a!2 (and (not (= $o@@88 |l#0@@57|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@33| $o@@88)
                                               |l#2@@32|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#47| |l#0@@57|
                                                          |l#1@@33|
                                                          |l#2@@32|
                                                          |l#3@@32|)
                                             $o@@88
                                             $f@@34))
                   (=> a!2 |l#3@@32|))))
       (=> (and (= (type |l#0@@57|) refType)
                (= (type |l#1@@33|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@32|) (FieldType boolType))
                (= (type $o@@88) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#47| |l#0@@57|
                                            |l#1@@33|
                                            |l#2@@32|
                                            |l#3@@32|)
                               $o@@88
                               $f@@34))
     :skolemid |3607|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@643 T@U) (arg1@@343 T@U) (arg2@@206 T@U) (arg3@@133 Bool))
  (! (= (type (|lambda#48| arg0@@643 arg1@@343 arg2@@206 arg3@@133))
        (MapType6Type refType boolType))
     :pattern ((|lambda#48| arg0@@643 arg1@@343 arg2@@206 arg3@@133))
     :qid |funType:lambda#48|)))
(assert (forall ((|l#0@@58| T@U)
         (|l#1@@34| T@U)
         (|l#2@@33| T@U)
         (|l#3@@33| Bool)
         ($o@@89 T@U)
         ($f@@35 T@U))
  (! (let ((a!1 (= (type $f@@35) (FieldType (FieldTypeInv0 (type $f@@35)))))
           (a!2 (and (not (= $o@@89 |l#0@@58|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@34| $o@@89)
                                               |l#2@@33|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#48| |l#0@@58|
                                                          |l#1@@34|
                                                          |l#2@@33|
                                                          |l#3@@33|)
                                             $o@@89
                                             $f@@35))
                   (=> a!2 |l#3@@33|))))
       (=> (and (= (type |l#0@@58|) refType)
                (= (type |l#1@@34|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@33|) (FieldType boolType))
                (= (type $o@@89) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#48| |l#0@@58|
                                            |l#1@@34|
                                            |l#2@@33|
                                            |l#3@@33|)
                               $o@@89
                               $f@@35))
     :skolemid |3608|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@644 T@U) (arg1@@344 T@U) (arg2@@207 T@U) (arg3@@134 Bool))
  (! (= (type (|lambda#49| arg0@@644 arg1@@344 arg2@@207 arg3@@134))
        (MapType6Type refType boolType))
     :pattern ((|lambda#49| arg0@@644 arg1@@344 arg2@@207 arg3@@134))
     :qid |funType:lambda#49|)))
(assert (forall ((|l#0@@59| T@U)
         (|l#1@@35| T@U)
         (|l#2@@34| T@U)
         (|l#3@@34| Bool)
         ($o@@90 T@U)
         ($f@@36 T@U))
  (! (let ((a!1 (= (type $f@@36) (FieldType (FieldTypeInv0 (type $f@@36)))))
           (a!2 (and (not (= $o@@90 |l#0@@59|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@35| $o@@90)
                                               |l#2@@34|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#49| |l#0@@59|
                                                          |l#1@@35|
                                                          |l#2@@34|
                                                          |l#3@@34|)
                                             $o@@90
                                             $f@@36))
                   (=> a!2 |l#3@@34|))))
       (=> (and (= (type |l#0@@59|) refType)
                (= (type |l#1@@35|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@34|) (FieldType boolType))
                (= (type $o@@90) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#49| |l#0@@59|
                                            |l#1@@35|
                                            |l#2@@34|
                                            |l#3@@34|)
                               $o@@90
                               $f@@36))
     :skolemid |3609|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@645 T@U) (arg1@@345 T@U) (arg2@@208 T@U) (arg3@@135 Bool))
  (! (= (type (|lambda#50| arg0@@645 arg1@@345 arg2@@208 arg3@@135))
        (MapType6Type refType boolType))
     :pattern ((|lambda#50| arg0@@645 arg1@@345 arg2@@208 arg3@@135))
     :qid |funType:lambda#50|)))
(assert (forall ((|l#0@@60| T@U)
         (|l#1@@36| T@U)
         (|l#2@@35| T@U)
         (|l#3@@35| Bool)
         ($o@@91 T@U)
         ($f@@37 T@U))
  (! (let ((a!1 (= (type $f@@37) (FieldType (FieldTypeInv0 (type $f@@37)))))
           (a!2 (and (not (= $o@@91 |l#0@@60|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@36| $o@@91)
                                               |l#2@@35|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#50| |l#0@@60|
                                                          |l#1@@36|
                                                          |l#2@@35|
                                                          |l#3@@35|)
                                             $o@@91
                                             $f@@37))
                   (=> a!2 |l#3@@35|))))
       (=> (and (= (type |l#0@@60|) refType)
                (= (type |l#1@@36|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@35|) (FieldType boolType))
                (= (type $o@@91) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#50| |l#0@@60|
                                            |l#1@@36|
                                            |l#2@@35|
                                            |l#3@@35|)
                               $o@@91
                               $f@@37))
     :skolemid |3610|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@646 T@U) (arg1@@346 T@U) (arg2@@209 T@U) (arg3@@136 Bool))
  (! (= (type (|lambda#51| arg0@@646 arg1@@346 arg2@@209 arg3@@136))
        (MapType6Type refType boolType))
     :pattern ((|lambda#51| arg0@@646 arg1@@346 arg2@@209 arg3@@136))
     :qid |funType:lambda#51|)))
(assert (forall ((|l#0@@61| T@U)
         (|l#1@@37| T@U)
         (|l#2@@36| T@U)
         (|l#3@@36| Bool)
         ($o@@92 T@U)
         ($f@@38 T@U))
  (! (let ((a!1 (= (type $f@@38) (FieldType (FieldTypeInv0 (type $f@@38)))))
           (a!2 (and (not (= $o@@92 |l#0@@61|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@37| $o@@92)
                                               |l#2@@36|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#51| |l#0@@61|
                                                          |l#1@@37|
                                                          |l#2@@36|
                                                          |l#3@@36|)
                                             $o@@92
                                             $f@@38))
                   (=> a!2 |l#3@@36|))))
       (=> (and (= (type |l#0@@61|) refType)
                (= (type |l#1@@37|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@36|) (FieldType boolType))
                (= (type $o@@92) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#51| |l#0@@61|
                                            |l#1@@37|
                                            |l#2@@36|
                                            |l#3@@36|)
                               $o@@92
                               $f@@38))
     :skolemid |3611|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@647 T@U) (arg1@@347 T@U) (arg2@@210 T@U) (arg3@@137 Bool))
  (! (= (type (|lambda#52| arg0@@647 arg1@@347 arg2@@210 arg3@@137))
        (MapType6Type refType boolType))
     :pattern ((|lambda#52| arg0@@647 arg1@@347 arg2@@210 arg3@@137))
     :qid |funType:lambda#52|)))
(assert (forall ((|l#0@@62| T@U)
         (|l#1@@38| T@U)
         (|l#2@@37| T@U)
         (|l#3@@37| Bool)
         ($o@@93 T@U)
         ($f@@39 T@U))
  (! (let ((a!1 (= (type $f@@39) (FieldType (FieldTypeInv0 (type $f@@39)))))
           (a!2 (and (not (= $o@@93 |l#0@@62|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@38| $o@@93)
                                               |l#2@@37|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#52| |l#0@@62|
                                                          |l#1@@38|
                                                          |l#2@@37|
                                                          |l#3@@37|)
                                             $o@@93
                                             $f@@39))
                   (=> a!2 |l#3@@37|))))
       (=> (and (= (type |l#0@@62|) refType)
                (= (type |l#1@@38|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@37|) (FieldType boolType))
                (= (type $o@@93) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#52| |l#0@@62|
                                            |l#1@@38|
                                            |l#2@@37|
                                            |l#3@@37|)
                               $o@@93
                               $f@@39))
     :skolemid |3612|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@648 T@U) (arg1@@348 T@U) (arg2@@211 T@U) (arg3@@138 Bool))
  (! (= (type (|lambda#53| arg0@@648 arg1@@348 arg2@@211 arg3@@138))
        (MapType6Type refType boolType))
     :pattern ((|lambda#53| arg0@@648 arg1@@348 arg2@@211 arg3@@138))
     :qid |funType:lambda#53|)))
(assert (forall ((|l#0@@63| T@U)
         (|l#1@@39| T@U)
         (|l#2@@38| T@U)
         (|l#3@@38| Bool)
         ($o@@94 T@U)
         ($f@@40 T@U))
  (! (let ((a!1 (= (type $f@@40) (FieldType (FieldTypeInv0 (type $f@@40)))))
           (a!2 (and (not (= $o@@94 |l#0@@63|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@39| $o@@94)
                                               |l#2@@38|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#53| |l#0@@63|
                                                          |l#1@@39|
                                                          |l#2@@38|
                                                          |l#3@@38|)
                                             $o@@94
                                             $f@@40))
                   (=> a!2 |l#3@@38|))))
       (=> (and (= (type |l#0@@63|) refType)
                (= (type |l#1@@39|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@38|) (FieldType boolType))
                (= (type $o@@94) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#53| |l#0@@63|
                                            |l#1@@39|
                                            |l#2@@38|
                                            |l#3@@38|)
                               $o@@94
                               $f@@40))
     :skolemid |3613|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@649 T@U) (arg1@@349 T@U) (arg2@@212 T@U) (arg3@@139 Bool))
  (! (= (type (|lambda#54| arg0@@649 arg1@@349 arg2@@212 arg3@@139))
        (MapType6Type refType boolType))
     :pattern ((|lambda#54| arg0@@649 arg1@@349 arg2@@212 arg3@@139))
     :qid |funType:lambda#54|)))
(assert (forall ((|l#0@@64| T@U)
         (|l#1@@40| T@U)
         (|l#2@@39| T@U)
         (|l#3@@39| Bool)
         ($o@@95 T@U)
         ($f@@41 T@U))
  (! (let ((a!1 (= (type $f@@41) (FieldType (FieldTypeInv0 (type $f@@41)))))
           (a!2 (and (not (= $o@@95 |l#0@@64|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@40| $o@@95)
                                               |l#2@@39|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#54| |l#0@@64|
                                                          |l#1@@40|
                                                          |l#2@@39|
                                                          |l#3@@39|)
                                             $o@@95
                                             $f@@41))
                   (=> a!2 |l#3@@39|))))
       (=> (and (= (type |l#0@@64|) refType)
                (= (type |l#1@@40|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@39|) (FieldType boolType))
                (= (type $o@@95) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#54| |l#0@@64|
                                            |l#1@@40|
                                            |l#2@@39|
                                            |l#3@@39|)
                               $o@@95
                               $f@@41))
     :skolemid |3614|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@650 T@U) (arg1@@350 T@U) (arg2@@213 T@U) (arg3@@140 Bool))
  (! (= (type (|lambda#55| arg0@@650 arg1@@350 arg2@@213 arg3@@140))
        (MapType6Type refType boolType))
     :pattern ((|lambda#55| arg0@@650 arg1@@350 arg2@@213 arg3@@140))
     :qid |funType:lambda#55|)))
(assert (forall ((|l#0@@65| T@U)
         (|l#1@@41| T@U)
         (|l#2@@40| T@U)
         (|l#3@@40| Bool)
         ($o@@96 T@U)
         ($f@@42 T@U))
  (! (let ((a!1 (= (type $f@@42) (FieldType (FieldTypeInv0 (type $f@@42)))))
           (a!2 (and (not (= $o@@96 |l#0@@65|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@41| $o@@96)
                                               |l#2@@40|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#55| |l#0@@65|
                                                          |l#1@@41|
                                                          |l#2@@40|
                                                          |l#3@@40|)
                                             $o@@96
                                             $f@@42))
                   (=> a!2 |l#3@@40|))))
       (=> (and (= (type |l#0@@65|) refType)
                (= (type |l#1@@41|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@40|) (FieldType boolType))
                (= (type $o@@96) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#55| |l#0@@65|
                                            |l#1@@41|
                                            |l#2@@40|
                                            |l#3@@40|)
                               $o@@96
                               $f@@42))
     :skolemid |3615|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@651 T@U) (arg1@@351 T@U) (arg2@@214 T@U) (arg3@@141 Bool))
  (! (= (type (|lambda#56| arg0@@651 arg1@@351 arg2@@214 arg3@@141))
        (MapType6Type refType boolType))
     :pattern ((|lambda#56| arg0@@651 arg1@@351 arg2@@214 arg3@@141))
     :qid |funType:lambda#56|)))
(assert (forall ((|l#0@@66| T@U)
         (|l#1@@42| T@U)
         (|l#2@@41| T@U)
         (|l#3@@41| Bool)
         ($o@@97 T@U)
         ($f@@43 T@U))
  (! (let ((a!1 (= (type $f@@43) (FieldType (FieldTypeInv0 (type $f@@43)))))
           (a!2 (and (not (= $o@@97 |l#0@@66|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@42| $o@@97)
                                               |l#2@@41|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#56| |l#0@@66|
                                                          |l#1@@42|
                                                          |l#2@@41|
                                                          |l#3@@41|)
                                             $o@@97
                                             $f@@43))
                   (=> a!2 |l#3@@41|))))
       (=> (and (= (type |l#0@@66|) refType)
                (= (type |l#1@@42|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@41|) (FieldType boolType))
                (= (type $o@@97) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#56| |l#0@@66|
                                            |l#1@@42|
                                            |l#2@@41|
                                            |l#3@@41|)
                               $o@@97
                               $f@@43))
     :skolemid |3616|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@652 T@U) (arg1@@352 T@U) (arg2@@215 T@U) (arg3@@142 Bool))
  (! (= (type (|lambda#57| arg0@@652 arg1@@352 arg2@@215 arg3@@142))
        (MapType6Type refType boolType))
     :pattern ((|lambda#57| arg0@@652 arg1@@352 arg2@@215 arg3@@142))
     :qid |funType:lambda#57|)))
(assert (forall ((|l#0@@67| T@U)
         (|l#1@@43| T@U)
         (|l#2@@42| T@U)
         (|l#3@@42| Bool)
         ($o@@98 T@U)
         ($f@@44 T@U))
  (! (let ((a!1 (= (type $f@@44) (FieldType (FieldTypeInv0 (type $f@@44)))))
           (a!2 (and (not (= $o@@98 |l#0@@67|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@43| $o@@98)
                                               |l#2@@42|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#57| |l#0@@67|
                                                          |l#1@@43|
                                                          |l#2@@42|
                                                          |l#3@@42|)
                                             $o@@98
                                             $f@@44))
                   (=> a!2 |l#3@@42|))))
       (=> (and (= (type |l#0@@67|) refType)
                (= (type |l#1@@43|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@42|) (FieldType boolType))
                (= (type $o@@98) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#57| |l#0@@67|
                                            |l#1@@43|
                                            |l#2@@42|
                                            |l#3@@42|)
                               $o@@98
                               $f@@44))
     :skolemid |3617|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@653 T@U) (arg1@@353 T@U) (arg2@@216 T@U) (arg3@@143 Bool))
  (! (= (type (|lambda#58| arg0@@653 arg1@@353 arg2@@216 arg3@@143))
        (MapType6Type refType boolType))
     :pattern ((|lambda#58| arg0@@653 arg1@@353 arg2@@216 arg3@@143))
     :qid |funType:lambda#58|)))
(assert (forall ((|l#0@@68| T@U)
         (|l#1@@44| T@U)
         (|l#2@@43| T@U)
         (|l#3@@43| Bool)
         ($o@@99 T@U)
         ($f@@45 T@U))
  (! (let ((a!1 (= (type $f@@45) (FieldType (FieldTypeInv0 (type $f@@45)))))
           (a!2 (and (not (= $o@@99 |l#0@@68|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@44| $o@@99)
                                               |l#2@@43|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#58| |l#0@@68|
                                                          |l#1@@44|
                                                          |l#2@@43|
                                                          |l#3@@43|)
                                             $o@@99
                                             $f@@45))
                   (=> a!2 |l#3@@43|))))
       (=> (and (= (type |l#0@@68|) refType)
                (= (type |l#1@@44|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@43|) (FieldType boolType))
                (= (type $o@@99) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#58| |l#0@@68|
                                            |l#1@@44|
                                            |l#2@@43|
                                            |l#3@@43|)
                               $o@@99
                               $f@@45))
     :skolemid |3618|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@654 T@U) (arg1@@354 T@U) (arg2@@217 T@U) (arg3@@144 Bool))
  (! (= (type (|lambda#59| arg0@@654 arg1@@354 arg2@@217 arg3@@144))
        (MapType6Type refType boolType))
     :pattern ((|lambda#59| arg0@@654 arg1@@354 arg2@@217 arg3@@144))
     :qid |funType:lambda#59|)))
(assert (forall ((|l#0@@69| T@U)
         (|l#1@@45| T@U)
         (|l#2@@44| T@U)
         (|l#3@@44| Bool)
         ($o@@100 T@U)
         ($f@@46 T@U))
  (! (let ((a!1 (= (type $f@@46) (FieldType (FieldTypeInv0 (type $f@@46)))))
           (a!2 (and (not (= $o@@100 |l#0@@69|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@45|
                                                               $o@@100)
                                               |l#2@@44|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#59| |l#0@@69|
                                                          |l#1@@45|
                                                          |l#2@@44|
                                                          |l#3@@44|)
                                             $o@@100
                                             $f@@46))
                   (=> a!2 |l#3@@44|))))
       (=> (and (= (type |l#0@@69|) refType)
                (= (type |l#1@@45|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@44|) (FieldType boolType))
                (= (type $o@@100) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#59| |l#0@@69|
                                            |l#1@@45|
                                            |l#2@@44|
                                            |l#3@@44|)
                               $o@@100
                               $f@@46))
     :skolemid |3619|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@655 T@U) (arg1@@355 T@U) (arg2@@218 T@U) (arg3@@145 Bool))
  (! (= (type (|lambda#60| arg0@@655 arg1@@355 arg2@@218 arg3@@145))
        (MapType6Type refType boolType))
     :pattern ((|lambda#60| arg0@@655 arg1@@355 arg2@@218 arg3@@145))
     :qid |funType:lambda#60|)))
(assert (forall ((|l#0@@70| T@U)
         (|l#1@@46| T@U)
         (|l#2@@45| T@U)
         (|l#3@@45| Bool)
         ($o@@101 T@U)
         ($f@@47 T@U))
  (! (let ((a!1 (= (type $f@@47) (FieldType (FieldTypeInv0 (type $f@@47)))))
           (a!2 (and (not (= $o@@101 |l#0@@70|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@46|
                                                               $o@@101)
                                               |l#2@@45|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#60| |l#0@@70|
                                                          |l#1@@46|
                                                          |l#2@@45|
                                                          |l#3@@45|)
                                             $o@@101
                                             $f@@47))
                   (=> a!2 |l#3@@45|))))
       (=> (and (= (type |l#0@@70|) refType)
                (= (type |l#1@@46|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@45|) (FieldType boolType))
                (= (type $o@@101) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#60| |l#0@@70|
                                            |l#1@@46|
                                            |l#2@@45|
                                            |l#3@@45|)
                               $o@@101
                               $f@@47))
     :skolemid |3620|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@656 T@U) (arg1@@356 T@U) (arg2@@219 T@U) (arg3@@146 Bool))
  (! (= (type (|lambda#61| arg0@@656 arg1@@356 arg2@@219 arg3@@146))
        (MapType6Type refType boolType))
     :pattern ((|lambda#61| arg0@@656 arg1@@356 arg2@@219 arg3@@146))
     :qid |funType:lambda#61|)))
(assert (forall ((|l#0@@71| T@U)
         (|l#1@@47| T@U)
         (|l#2@@46| T@U)
         (|l#3@@46| Bool)
         ($o@@102 T@U)
         ($f@@48 T@U))
  (! (let ((a!1 (= (type $f@@48) (FieldType (FieldTypeInv0 (type $f@@48)))))
           (a!2 (and (not (= $o@@102 |l#0@@71|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@47|
                                                               $o@@102)
                                               |l#2@@46|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#61| |l#0@@71|
                                                          |l#1@@47|
                                                          |l#2@@46|
                                                          |l#3@@46|)
                                             $o@@102
                                             $f@@48))
                   (=> a!2 |l#3@@46|))))
       (=> (and (= (type |l#0@@71|) refType)
                (= (type |l#1@@47|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@46|) (FieldType boolType))
                (= (type $o@@102) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#61| |l#0@@71|
                                            |l#1@@47|
                                            |l#2@@46|
                                            |l#3@@46|)
                               $o@@102
                               $f@@48))
     :skolemid |3621|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@657 T@U) (arg1@@357 T@U) (arg2@@220 T@U) (arg3@@147 Bool))
  (! (= (type (|lambda#62| arg0@@657 arg1@@357 arg2@@220 arg3@@147))
        (MapType6Type refType boolType))
     :pattern ((|lambda#62| arg0@@657 arg1@@357 arg2@@220 arg3@@147))
     :qid |funType:lambda#62|)))
(assert (forall ((|l#0@@72| T@U)
         (|l#1@@48| T@U)
         (|l#2@@47| T@U)
         (|l#3@@47| Bool)
         ($o@@103 T@U)
         ($f@@49 T@U))
  (! (let ((a!1 (= (type $f@@49) (FieldType (FieldTypeInv0 (type $f@@49)))))
           (a!2 (and (not (= $o@@103 |l#0@@72|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@48|
                                                               $o@@103)
                                               |l#2@@47|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#62| |l#0@@72|
                                                          |l#1@@48|
                                                          |l#2@@47|
                                                          |l#3@@47|)
                                             $o@@103
                                             $f@@49))
                   (=> a!2 |l#3@@47|))))
       (=> (and (= (type |l#0@@72|) refType)
                (= (type |l#1@@48|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@47|) (FieldType boolType))
                (= (type $o@@103) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#62| |l#0@@72|
                                            |l#1@@48|
                                            |l#2@@47|
                                            |l#3@@47|)
                               $o@@103
                               $f@@49))
     :skolemid |3622|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@658 T@U) (arg1@@358 T@U) (arg2@@221 T@U) (arg3@@148 Bool))
  (! (= (type (|lambda#63| arg0@@658 arg1@@358 arg2@@221 arg3@@148))
        (MapType6Type refType boolType))
     :pattern ((|lambda#63| arg0@@658 arg1@@358 arg2@@221 arg3@@148))
     :qid |funType:lambda#63|)))
(assert (forall ((|l#0@@73| T@U)
         (|l#1@@49| T@U)
         (|l#2@@48| T@U)
         (|l#3@@48| Bool)
         ($o@@104 T@U)
         ($f@@50 T@U))
  (! (let ((a!1 (= (type $f@@50) (FieldType (FieldTypeInv0 (type $f@@50)))))
           (a!2 (and (not (= $o@@104 |l#0@@73|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@49|
                                                               $o@@104)
                                               |l#2@@48|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#63| |l#0@@73|
                                                          |l#1@@49|
                                                          |l#2@@48|
                                                          |l#3@@48|)
                                             $o@@104
                                             $f@@50))
                   (=> a!2 |l#3@@48|))))
       (=> (and (= (type |l#0@@73|) refType)
                (= (type |l#1@@49|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@48|) (FieldType boolType))
                (= (type $o@@104) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#63| |l#0@@73|
                                            |l#1@@49|
                                            |l#2@@48|
                                            |l#3@@48|)
                               $o@@104
                               $f@@50))
     :skolemid |3623|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@659 T@U) (arg1@@359 T@U) (arg2@@222 T@U) (arg3@@149 Bool))
  (! (= (type (|lambda#64| arg0@@659 arg1@@359 arg2@@222 arg3@@149))
        (MapType6Type refType boolType))
     :pattern ((|lambda#64| arg0@@659 arg1@@359 arg2@@222 arg3@@149))
     :qid |funType:lambda#64|)))
(assert (forall ((|l#0@@74| T@U)
         (|l#1@@50| T@U)
         (|l#2@@49| T@U)
         (|l#3@@49| Bool)
         ($o@@105 T@U)
         ($f@@51 T@U))
  (! (let ((a!1 (= (type $f@@51) (FieldType (FieldTypeInv0 (type $f@@51)))))
           (a!2 (and (not (= $o@@105 |l#0@@74|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@50|
                                                               $o@@105)
                                               |l#2@@49|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#64| |l#0@@74|
                                                          |l#1@@50|
                                                          |l#2@@49|
                                                          |l#3@@49|)
                                             $o@@105
                                             $f@@51))
                   (=> a!2 |l#3@@49|))))
       (=> (and (= (type |l#0@@74|) refType)
                (= (type |l#1@@50|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@49|) (FieldType boolType))
                (= (type $o@@105) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#64| |l#0@@74|
                                            |l#1@@50|
                                            |l#2@@49|
                                            |l#3@@49|)
                               $o@@105
                               $f@@51))
     :skolemid |3624|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@660 T@U) (arg1@@360 T@U) (arg2@@223 T@U) (arg3@@150 Bool))
  (! (= (type (|lambda#65| arg0@@660 arg1@@360 arg2@@223 arg3@@150))
        (MapType6Type refType boolType))
     :pattern ((|lambda#65| arg0@@660 arg1@@360 arg2@@223 arg3@@150))
     :qid |funType:lambda#65|)))
(assert (forall ((|l#0@@75| T@U)
         (|l#1@@51| T@U)
         (|l#2@@50| T@U)
         (|l#3@@50| Bool)
         ($o@@106 T@U)
         ($f@@52 T@U))
  (! (let ((a!1 (= (type $f@@52) (FieldType (FieldTypeInv0 (type $f@@52)))))
           (a!2 (and (not (= $o@@106 |l#0@@75|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@51|
                                                               $o@@106)
                                               |l#2@@50|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#65| |l#0@@75|
                                                          |l#1@@51|
                                                          |l#2@@50|
                                                          |l#3@@50|)
                                             $o@@106
                                             $f@@52))
                   (=> a!2 |l#3@@50|))))
       (=> (and (= (type |l#0@@75|) refType)
                (= (type |l#1@@51|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@50|) (FieldType boolType))
                (= (type $o@@106) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#65| |l#0@@75|
                                            |l#1@@51|
                                            |l#2@@50|
                                            |l#3@@50|)
                               $o@@106
                               $f@@52))
     :skolemid |3625|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@661 T@U) (arg1@@361 T@U) (arg2@@224 T@U) (arg3@@151 Bool))
  (! (= (type (|lambda#66| arg0@@661 arg1@@361 arg2@@224 arg3@@151))
        (MapType6Type refType boolType))
     :pattern ((|lambda#66| arg0@@661 arg1@@361 arg2@@224 arg3@@151))
     :qid |funType:lambda#66|)))
(assert (forall ((|l#0@@76| T@U)
         (|l#1@@52| T@U)
         (|l#2@@51| T@U)
         (|l#3@@51| Bool)
         ($o@@107 T@U)
         ($f@@53 T@U))
  (! (let ((a!1 (= (type $f@@53) (FieldType (FieldTypeInv0 (type $f@@53)))))
           (a!2 (and (not (= $o@@107 |l#0@@76|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@52|
                                                               $o@@107)
                                               |l#2@@51|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#66| |l#0@@76|
                                                          |l#1@@52|
                                                          |l#2@@51|
                                                          |l#3@@51|)
                                             $o@@107
                                             $f@@53))
                   (=> a!2 |l#3@@51|))))
       (=> (and (= (type |l#0@@76|) refType)
                (= (type |l#1@@52|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@51|) (FieldType boolType))
                (= (type $o@@107) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#66| |l#0@@76|
                                            |l#1@@52|
                                            |l#2@@51|
                                            |l#3@@51|)
                               $o@@107
                               $f@@53))
     :skolemid |3626|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@662 T@U) (arg1@@362 T@U) (arg2@@225 T@U) (arg3@@152 Bool))
  (! (= (type (|lambda#67| arg0@@662 arg1@@362 arg2@@225 arg3@@152))
        (MapType6Type refType boolType))
     :pattern ((|lambda#67| arg0@@662 arg1@@362 arg2@@225 arg3@@152))
     :qid |funType:lambda#67|)))
(assert (forall ((|l#0@@77| T@U)
         (|l#1@@53| T@U)
         (|l#2@@52| T@U)
         (|l#3@@52| Bool)
         ($o@@108 T@U)
         ($f@@54 T@U))
  (! (let ((a!1 (= (type $f@@54) (FieldType (FieldTypeInv0 (type $f@@54)))))
           (a!2 (and (not (= $o@@108 |l#0@@77|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@53|
                                                               $o@@108)
                                               |l#2@@52|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#67| |l#0@@77|
                                                          |l#1@@53|
                                                          |l#2@@52|
                                                          |l#3@@52|)
                                             $o@@108
                                             $f@@54))
                   (=> a!2 |l#3@@52|))))
       (=> (and (= (type |l#0@@77|) refType)
                (= (type |l#1@@53|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@52|) (FieldType boolType))
                (= (type $o@@108) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#67| |l#0@@77|
                                            |l#1@@53|
                                            |l#2@@52|
                                            |l#3@@52|)
                               $o@@108
                               $f@@54))
     :skolemid |3627|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@663 T@U) (arg1@@363 T@U) (arg2@@226 T@U) (arg3@@153 Bool))
  (! (= (type (|lambda#68| arg0@@663 arg1@@363 arg2@@226 arg3@@153))
        (MapType6Type refType boolType))
     :pattern ((|lambda#68| arg0@@663 arg1@@363 arg2@@226 arg3@@153))
     :qid |funType:lambda#68|)))
(assert (forall ((|l#0@@78| T@U)
         (|l#1@@54| T@U)
         (|l#2@@53| T@U)
         (|l#3@@53| Bool)
         ($o@@109 T@U)
         ($f@@55 T@U))
  (! (let ((a!1 (= (type $f@@55) (FieldType (FieldTypeInv0 (type $f@@55)))))
           (a!2 (and (not (= $o@@109 |l#0@@78|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@54|
                                                               $o@@109)
                                               |l#2@@53|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#68| |l#0@@78|
                                                          |l#1@@54|
                                                          |l#2@@53|
                                                          |l#3@@53|)
                                             $o@@109
                                             $f@@55))
                   (=> a!2 |l#3@@53|))))
       (=> (and (= (type |l#0@@78|) refType)
                (= (type |l#1@@54|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@53|) (FieldType boolType))
                (= (type $o@@109) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#68| |l#0@@78|
                                            |l#1@@54|
                                            |l#2@@53|
                                            |l#3@@53|)
                               $o@@109
                               $f@@55))
     :skolemid |3628|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@664 T@U) (arg1@@364 T@U) (arg2@@227 T@U) (arg3@@154 Bool))
  (! (= (type (|lambda#69| arg0@@664 arg1@@364 arg2@@227 arg3@@154))
        (MapType6Type refType boolType))
     :pattern ((|lambda#69| arg0@@664 arg1@@364 arg2@@227 arg3@@154))
     :qid |funType:lambda#69|)))
(assert (forall ((|l#0@@79| T@U)
         (|l#1@@55| T@U)
         (|l#2@@54| T@U)
         (|l#3@@54| Bool)
         ($o@@110 T@U)
         ($f@@56 T@U))
  (! (let ((a!1 (= (type $f@@56) (FieldType (FieldTypeInv0 (type $f@@56)))))
           (a!2 (and (not (= $o@@110 |l#0@@79|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@55|
                                                               $o@@110)
                                               |l#2@@54|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#69| |l#0@@79|
                                                          |l#1@@55|
                                                          |l#2@@54|
                                                          |l#3@@54|)
                                             $o@@110
                                             $f@@56))
                   (=> a!2 |l#3@@54|))))
       (=> (and (= (type |l#0@@79|) refType)
                (= (type |l#1@@55|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@54|) (FieldType boolType))
                (= (type $o@@110) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#69| |l#0@@79|
                                            |l#1@@55|
                                            |l#2@@54|
                                            |l#3@@54|)
                               $o@@110
                               $f@@56))
     :skolemid |3629|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@665 T@U) (arg1@@365 T@U) (arg2@@228 T@U) (arg3@@155 Bool))
  (! (= (type (|lambda#70| arg0@@665 arg1@@365 arg2@@228 arg3@@155))
        (MapType6Type refType boolType))
     :pattern ((|lambda#70| arg0@@665 arg1@@365 arg2@@228 arg3@@155))
     :qid |funType:lambda#70|)))
(assert (forall ((|l#0@@80| T@U)
         (|l#1@@56| T@U)
         (|l#2@@55| T@U)
         (|l#3@@55| Bool)
         ($o@@111 T@U)
         ($f@@57 T@U))
  (! (let ((a!1 (= (type $f@@57) (FieldType (FieldTypeInv0 (type $f@@57)))))
           (a!2 (and (not (= $o@@111 |l#0@@80|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@56|
                                                               $o@@111)
                                               |l#2@@55|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#70| |l#0@@80|
                                                          |l#1@@56|
                                                          |l#2@@55|
                                                          |l#3@@55|)
                                             $o@@111
                                             $f@@57))
                   (=> a!2 |l#3@@55|))))
       (=> (and (= (type |l#0@@80|) refType)
                (= (type |l#1@@56|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@55|) (FieldType boolType))
                (= (type $o@@111) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#70| |l#0@@80|
                                            |l#1@@56|
                                            |l#2@@55|
                                            |l#3@@55|)
                               $o@@111
                               $f@@57))
     :skolemid |3630|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@666 T@U) (arg1@@366 T@U) (arg2@@229 T@U) (arg3@@156 Bool))
  (! (= (type (|lambda#71| arg0@@666 arg1@@366 arg2@@229 arg3@@156))
        (MapType6Type refType boolType))
     :pattern ((|lambda#71| arg0@@666 arg1@@366 arg2@@229 arg3@@156))
     :qid |funType:lambda#71|)))
(assert (forall ((|l#0@@81| T@U)
         (|l#1@@57| T@U)
         (|l#2@@56| T@U)
         (|l#3@@56| Bool)
         ($o@@112 T@U)
         ($f@@58 T@U))
  (! (let ((a!1 (= (type $f@@58) (FieldType (FieldTypeInv0 (type $f@@58)))))
           (a!2 (and (not (= $o@@112 |l#0@@81|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@57|
                                                               $o@@112)
                                               |l#2@@56|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#71| |l#0@@81|
                                                          |l#1@@57|
                                                          |l#2@@56|
                                                          |l#3@@56|)
                                             $o@@112
                                             $f@@58))
                   (=> a!2 |l#3@@56|))))
       (=> (and (= (type |l#0@@81|) refType)
                (= (type |l#1@@57|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@56|) (FieldType boolType))
                (= (type $o@@112) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#71| |l#0@@81|
                                            |l#1@@57|
                                            |l#2@@56|
                                            |l#3@@56|)
                               $o@@112
                               $f@@58))
     :skolemid |3631|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@667 T@U) (arg1@@367 T@U) (arg2@@230 T@U) (arg3@@157 Bool))
  (! (= (type (|lambda#72| arg0@@667 arg1@@367 arg2@@230 arg3@@157))
        (MapType6Type refType boolType))
     :pattern ((|lambda#72| arg0@@667 arg1@@367 arg2@@230 arg3@@157))
     :qid |funType:lambda#72|)))
(assert (forall ((|l#0@@82| T@U)
         (|l#1@@58| T@U)
         (|l#2@@57| T@U)
         (|l#3@@57| Bool)
         ($o@@113 T@U)
         ($f@@59 T@U))
  (! (let ((a!1 (= (type $f@@59) (FieldType (FieldTypeInv0 (type $f@@59)))))
           (a!2 (and (not (= $o@@113 |l#0@@82|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@58|
                                                               $o@@113)
                                               |l#2@@57|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#72| |l#0@@82|
                                                          |l#1@@58|
                                                          |l#2@@57|
                                                          |l#3@@57|)
                                             $o@@113
                                             $f@@59))
                   (=> a!2 |l#3@@57|))))
       (=> (and (= (type |l#0@@82|) refType)
                (= (type |l#1@@58|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@57|) (FieldType boolType))
                (= (type $o@@113) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#72| |l#0@@82|
                                            |l#1@@58|
                                            |l#2@@57|
                                            |l#3@@57|)
                               $o@@113
                               $f@@59))
     :skolemid |3632|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@668 T@U) (arg1@@368 T@U) (arg2@@231 T@U) (arg3@@158 Bool))
  (! (= (type (|lambda#73| arg0@@668 arg1@@368 arg2@@231 arg3@@158))
        (MapType6Type refType boolType))
     :pattern ((|lambda#73| arg0@@668 arg1@@368 arg2@@231 arg3@@158))
     :qid |funType:lambda#73|)))
(assert (forall ((|l#0@@83| T@U)
         (|l#1@@59| T@U)
         (|l#2@@58| T@U)
         (|l#3@@58| Bool)
         ($o@@114 T@U)
         ($f@@60 T@U))
  (! (let ((a!1 (= (type $f@@60) (FieldType (FieldTypeInv0 (type $f@@60)))))
           (a!2 (and (not (= $o@@114 |l#0@@83|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@59|
                                                               $o@@114)
                                               |l#2@@58|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#73| |l#0@@83|
                                                          |l#1@@59|
                                                          |l#2@@58|
                                                          |l#3@@58|)
                                             $o@@114
                                             $f@@60))
                   (=> a!2 |l#3@@58|))))
       (=> (and (= (type |l#0@@83|) refType)
                (= (type |l#1@@59|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@58|) (FieldType boolType))
                (= (type $o@@114) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#73| |l#0@@83|
                                            |l#1@@59|
                                            |l#2@@58|
                                            |l#3@@58|)
                               $o@@114
                               $f@@60))
     :skolemid |3633|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@669 T@U) (arg1@@369 T@U) (arg2@@232 T@U) (arg3@@159 Bool))
  (! (= (type (|lambda#74| arg0@@669 arg1@@369 arg2@@232 arg3@@159))
        (MapType6Type refType boolType))
     :pattern ((|lambda#74| arg0@@669 arg1@@369 arg2@@232 arg3@@159))
     :qid |funType:lambda#74|)))
(assert (forall ((|l#0@@84| T@U)
         (|l#1@@60| T@U)
         (|l#2@@59| T@U)
         (|l#3@@59| Bool)
         ($o@@115 T@U)
         ($f@@61 T@U))
  (! (let ((a!1 (= (type $f@@61) (FieldType (FieldTypeInv0 (type $f@@61)))))
           (a!2 (and (not (= $o@@115 |l#0@@84|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@60|
                                                               $o@@115)
                                               |l#2@@59|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#74| |l#0@@84|
                                                          |l#1@@60|
                                                          |l#2@@59|
                                                          |l#3@@59|)
                                             $o@@115
                                             $f@@61))
                   (=> a!2 |l#3@@59|))))
       (=> (and (= (type |l#0@@84|) refType)
                (= (type |l#1@@60|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@59|) (FieldType boolType))
                (= (type $o@@115) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#74| |l#0@@84|
                                            |l#1@@60|
                                            |l#2@@59|
                                            |l#3@@59|)
                               $o@@115
                               $f@@61))
     :skolemid |3634|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@670 T@U) (arg1@@370 T@U) (arg2@@233 T@U) (arg3@@160 Bool))
  (! (= (type (|lambda#75| arg0@@670 arg1@@370 arg2@@233 arg3@@160))
        (MapType6Type refType boolType))
     :pattern ((|lambda#75| arg0@@670 arg1@@370 arg2@@233 arg3@@160))
     :qid |funType:lambda#75|)))
(assert (forall ((|l#0@@85| T@U)
         (|l#1@@61| T@U)
         (|l#2@@60| T@U)
         (|l#3@@60| Bool)
         ($o@@116 T@U)
         ($f@@62 T@U))
  (! (let ((a!1 (= (type $f@@62) (FieldType (FieldTypeInv0 (type $f@@62)))))
           (a!2 (and (not (= $o@@116 |l#0@@85|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@61|
                                                               $o@@116)
                                               |l#2@@60|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#75| |l#0@@85|
                                                          |l#1@@61|
                                                          |l#2@@60|
                                                          |l#3@@60|)
                                             $o@@116
                                             $f@@62))
                   (=> a!2 |l#3@@60|))))
       (=> (and (= (type |l#0@@85|) refType)
                (= (type |l#1@@61|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@60|) (FieldType boolType))
                (= (type $o@@116) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#75| |l#0@@85|
                                            |l#1@@61|
                                            |l#2@@60|
                                            |l#3@@60|)
                               $o@@116
                               $f@@62))
     :skolemid |3635|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@671 T@U) (arg1@@371 T@U) (arg2@@234 T@U) (arg3@@161 Bool))
  (! (= (type (|lambda#76| arg0@@671 arg1@@371 arg2@@234 arg3@@161))
        (MapType6Type refType boolType))
     :pattern ((|lambda#76| arg0@@671 arg1@@371 arg2@@234 arg3@@161))
     :qid |funType:lambda#76|)))
(assert (forall ((|l#0@@86| T@U)
         (|l#1@@62| T@U)
         (|l#2@@61| T@U)
         (|l#3@@61| Bool)
         ($o@@117 T@U)
         ($f@@63 T@U))
  (! (let ((a!1 (= (type $f@@63) (FieldType (FieldTypeInv0 (type $f@@63)))))
           (a!2 (and (not (= $o@@117 |l#0@@86|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@62|
                                                               $o@@117)
                                               |l#2@@61|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#76| |l#0@@86|
                                                          |l#1@@62|
                                                          |l#2@@61|
                                                          |l#3@@61|)
                                             $o@@117
                                             $f@@63))
                   (=> a!2 |l#3@@61|))))
       (=> (and (= (type |l#0@@86|) refType)
                (= (type |l#1@@62|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@61|) (FieldType boolType))
                (= (type $o@@117) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#76| |l#0@@86|
                                            |l#1@@62|
                                            |l#2@@61|
                                            |l#3@@61|)
                               $o@@117
                               $f@@63))
     :skolemid |3636|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@672 T@U) (arg1@@372 T@U) (arg2@@235 T@U) (arg3@@162 Bool))
  (! (= (type (|lambda#77| arg0@@672 arg1@@372 arg2@@235 arg3@@162))
        (MapType6Type refType boolType))
     :pattern ((|lambda#77| arg0@@672 arg1@@372 arg2@@235 arg3@@162))
     :qid |funType:lambda#77|)))
(assert (forall ((|l#0@@87| T@U)
         (|l#1@@63| T@U)
         (|l#2@@62| T@U)
         (|l#3@@62| Bool)
         ($o@@118 T@U)
         ($f@@64 T@U))
  (! (let ((a!1 (= (type $f@@64) (FieldType (FieldTypeInv0 (type $f@@64)))))
           (a!2 (and (not (= $o@@118 |l#0@@87|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@63|
                                                               $o@@118)
                                               |l#2@@62|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#77| |l#0@@87|
                                                          |l#1@@63|
                                                          |l#2@@62|
                                                          |l#3@@62|)
                                             $o@@118
                                             $f@@64))
                   (=> a!2 |l#3@@62|))))
       (=> (and (= (type |l#0@@87|) refType)
                (= (type |l#1@@63|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@62|) (FieldType boolType))
                (= (type $o@@118) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#77| |l#0@@87|
                                            |l#1@@63|
                                            |l#2@@62|
                                            |l#3@@62|)
                               $o@@118
                               $f@@64))
     :skolemid |3637|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@673 T@U) (arg1@@373 T@U) (arg2@@236 T@U) (arg3@@163 Bool))
  (! (= (type (|lambda#78| arg0@@673 arg1@@373 arg2@@236 arg3@@163))
        (MapType6Type refType boolType))
     :pattern ((|lambda#78| arg0@@673 arg1@@373 arg2@@236 arg3@@163))
     :qid |funType:lambda#78|)))
(assert (forall ((|l#0@@88| T@U)
         (|l#1@@64| T@U)
         (|l#2@@63| T@U)
         (|l#3@@63| Bool)
         ($o@@119 T@U)
         ($f@@65 T@U))
  (! (let ((a!1 (= (type $f@@65) (FieldType (FieldTypeInv0 (type $f@@65)))))
           (a!2 (and (not (= $o@@119 |l#0@@88|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@64|
                                                               $o@@119)
                                               |l#2@@63|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#78| |l#0@@88|
                                                          |l#1@@64|
                                                          |l#2@@63|
                                                          |l#3@@63|)
                                             $o@@119
                                             $f@@65))
                   (=> a!2 |l#3@@63|))))
       (=> (and (= (type |l#0@@88|) refType)
                (= (type |l#1@@64|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@63|) (FieldType boolType))
                (= (type $o@@119) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#78| |l#0@@88|
                                            |l#1@@64|
                                            |l#2@@63|
                                            |l#3@@63|)
                               $o@@119
                               $f@@65))
     :skolemid |3638|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@674 T@U) (arg1@@374 T@U) (arg2@@237 T@U) (arg3@@164 Bool))
  (! (= (type (|lambda#79| arg0@@674 arg1@@374 arg2@@237 arg3@@164))
        (MapType6Type refType boolType))
     :pattern ((|lambda#79| arg0@@674 arg1@@374 arg2@@237 arg3@@164))
     :qid |funType:lambda#79|)))
(assert (forall ((|l#0@@89| T@U)
         (|l#1@@65| T@U)
         (|l#2@@64| T@U)
         (|l#3@@64| Bool)
         ($o@@120 T@U)
         ($f@@66 T@U))
  (! (let ((a!1 (= (type $f@@66) (FieldType (FieldTypeInv0 (type $f@@66)))))
           (a!2 (and (not (= $o@@120 |l#0@@89|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@65|
                                                               $o@@120)
                                               |l#2@@64|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#79| |l#0@@89|
                                                          |l#1@@65|
                                                          |l#2@@64|
                                                          |l#3@@64|)
                                             $o@@120
                                             $f@@66))
                   (=> a!2 |l#3@@64|))))
       (=> (and (= (type |l#0@@89|) refType)
                (= (type |l#1@@65|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@64|) (FieldType boolType))
                (= (type $o@@120) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#79| |l#0@@89|
                                            |l#1@@65|
                                            |l#2@@64|
                                            |l#3@@64|)
                               $o@@120
                               $f@@66))
     :skolemid |3639|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@675 T@U) (arg1@@375 T@U) (arg2@@238 T@U) (arg3@@165 Bool))
  (! (= (type (|lambda#80| arg0@@675 arg1@@375 arg2@@238 arg3@@165))
        (MapType6Type refType boolType))
     :pattern ((|lambda#80| arg0@@675 arg1@@375 arg2@@238 arg3@@165))
     :qid |funType:lambda#80|)))
(assert (forall ((|l#0@@90| T@U)
         (|l#1@@66| T@U)
         (|l#2@@65| T@U)
         (|l#3@@65| Bool)
         ($o@@121 T@U)
         ($f@@67 T@U))
  (! (let ((a!1 (= (type $f@@67) (FieldType (FieldTypeInv0 (type $f@@67)))))
           (a!2 (and (not (= $o@@121 |l#0@@90|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@66|
                                                               $o@@121)
                                               |l#2@@65|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#80| |l#0@@90|
                                                          |l#1@@66|
                                                          |l#2@@65|
                                                          |l#3@@65|)
                                             $o@@121
                                             $f@@67))
                   (=> a!2 |l#3@@65|))))
       (=> (and (= (type |l#0@@90|) refType)
                (= (type |l#1@@66|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@65|) (FieldType boolType))
                (= (type $o@@121) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#80| |l#0@@90|
                                            |l#1@@66|
                                            |l#2@@65|
                                            |l#3@@65|)
                               $o@@121
                               $f@@67))
     :skolemid |3640|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@676 T@U) (arg1@@376 T@U) (arg2@@239 T@U) (arg3@@166 Bool))
  (! (= (type (|lambda#81| arg0@@676 arg1@@376 arg2@@239 arg3@@166))
        (MapType6Type refType boolType))
     :pattern ((|lambda#81| arg0@@676 arg1@@376 arg2@@239 arg3@@166))
     :qid |funType:lambda#81|)))
(assert (forall ((|l#0@@91| T@U)
         (|l#1@@67| T@U)
         (|l#2@@66| T@U)
         (|l#3@@66| Bool)
         ($o@@122 T@U)
         ($f@@68 T@U))
  (! (let ((a!1 (= (type $f@@68) (FieldType (FieldTypeInv0 (type $f@@68)))))
           (a!2 (and (not (= $o@@122 |l#0@@91|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@67|
                                                               $o@@122)
                                               |l#2@@66|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#81| |l#0@@91|
                                                          |l#1@@67|
                                                          |l#2@@66|
                                                          |l#3@@66|)
                                             $o@@122
                                             $f@@68))
                   (=> a!2 |l#3@@66|))))
       (=> (and (= (type |l#0@@91|) refType)
                (= (type |l#1@@67|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@66|) (FieldType boolType))
                (= (type $o@@122) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#81| |l#0@@91|
                                            |l#1@@67|
                                            |l#2@@66|
                                            |l#3@@66|)
                               $o@@122
                               $f@@68))
     :skolemid |3641|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@677 T@U) (arg1@@377 T@U) (arg2@@240 T@U) (arg3@@167 Bool))
  (! (= (type (|lambda#82| arg0@@677 arg1@@377 arg2@@240 arg3@@167))
        (MapType6Type refType boolType))
     :pattern ((|lambda#82| arg0@@677 arg1@@377 arg2@@240 arg3@@167))
     :qid |funType:lambda#82|)))
(assert (forall ((|l#0@@92| T@U)
         (|l#1@@68| T@U)
         (|l#2@@67| T@U)
         (|l#3@@67| Bool)
         ($o@@123 T@U)
         ($f@@69 T@U))
  (! (let ((a!1 (= (type $f@@69) (FieldType (FieldTypeInv0 (type $f@@69)))))
           (a!2 (and (not (= $o@@123 |l#0@@92|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@68|
                                                               $o@@123)
                                               |l#2@@67|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#82| |l#0@@92|
                                                          |l#1@@68|
                                                          |l#2@@67|
                                                          |l#3@@67|)
                                             $o@@123
                                             $f@@69))
                   (=> a!2 |l#3@@67|))))
       (=> (and (= (type |l#0@@92|) refType)
                (= (type |l#1@@68|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@67|) (FieldType boolType))
                (= (type $o@@123) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#82| |l#0@@92|
                                            |l#1@@68|
                                            |l#2@@67|
                                            |l#3@@67|)
                               $o@@123
                               $f@@69))
     :skolemid |3642|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@678 T@U) (arg1@@378 T@U) (arg2@@241 T@U) (arg3@@168 Bool))
  (! (= (type (|lambda#83| arg0@@678 arg1@@378 arg2@@241 arg3@@168))
        (MapType6Type refType boolType))
     :pattern ((|lambda#83| arg0@@678 arg1@@378 arg2@@241 arg3@@168))
     :qid |funType:lambda#83|)))
(assert (forall ((|l#0@@93| T@U)
         (|l#1@@69| T@U)
         (|l#2@@68| T@U)
         (|l#3@@68| Bool)
         ($o@@124 T@U)
         ($f@@70 T@U))
  (! (let ((a!1 (= (type $f@@70) (FieldType (FieldTypeInv0 (type $f@@70)))))
           (a!2 (and (not (= $o@@124 |l#0@@93|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@69|
                                                               $o@@124)
                                               |l#2@@68|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#83| |l#0@@93|
                                                          |l#1@@69|
                                                          |l#2@@68|
                                                          |l#3@@68|)
                                             $o@@124
                                             $f@@70))
                   (=> a!2 |l#3@@68|))))
       (=> (and (= (type |l#0@@93|) refType)
                (= (type |l#1@@69|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@68|) (FieldType boolType))
                (= (type $o@@124) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#83| |l#0@@93|
                                            |l#1@@69|
                                            |l#2@@68|
                                            |l#3@@68|)
                               $o@@124
                               $f@@70))
     :skolemid |3643|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@679 T@U) (arg1@@379 T@U) (arg2@@242 T@U) (arg3@@169 Bool))
  (! (= (type (|lambda#84| arg0@@679 arg1@@379 arg2@@242 arg3@@169))
        (MapType6Type refType boolType))
     :pattern ((|lambda#84| arg0@@679 arg1@@379 arg2@@242 arg3@@169))
     :qid |funType:lambda#84|)))
(assert (forall ((|l#0@@94| T@U)
         (|l#1@@70| T@U)
         (|l#2@@69| T@U)
         (|l#3@@69| Bool)
         ($o@@125 T@U)
         ($f@@71 T@U))
  (! (let ((a!1 (= (type $f@@71) (FieldType (FieldTypeInv0 (type $f@@71)))))
           (a!2 (and (not (= $o@@125 |l#0@@94|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@70|
                                                               $o@@125)
                                               |l#2@@69|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#84| |l#0@@94|
                                                          |l#1@@70|
                                                          |l#2@@69|
                                                          |l#3@@69|)
                                             $o@@125
                                             $f@@71))
                   (=> a!2 |l#3@@69|))))
       (=> (and (= (type |l#0@@94|) refType)
                (= (type |l#1@@70|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@69|) (FieldType boolType))
                (= (type $o@@125) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#84| |l#0@@94|
                                            |l#1@@70|
                                            |l#2@@69|
                                            |l#3@@69|)
                               $o@@125
                               $f@@71))
     :skolemid |3644|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@680 T@U) (arg1@@380 T@U) (arg2@@243 T@U) (arg3@@170 Bool))
  (! (= (type (|lambda#85| arg0@@680 arg1@@380 arg2@@243 arg3@@170))
        (MapType6Type refType boolType))
     :pattern ((|lambda#85| arg0@@680 arg1@@380 arg2@@243 arg3@@170))
     :qid |funType:lambda#85|)))
(assert (forall ((|l#0@@95| T@U)
         (|l#1@@71| T@U)
         (|l#2@@70| T@U)
         (|l#3@@70| Bool)
         ($o@@126 T@U)
         ($f@@72 T@U))
  (! (let ((a!1 (= (type $f@@72) (FieldType (FieldTypeInv0 (type $f@@72)))))
           (a!2 (and (not (= $o@@126 |l#0@@95|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@71|
                                                               $o@@126)
                                               |l#2@@70|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#85| |l#0@@95|
                                                          |l#1@@71|
                                                          |l#2@@70|
                                                          |l#3@@70|)
                                             $o@@126
                                             $f@@72))
                   (=> a!2 |l#3@@70|))))
       (=> (and (= (type |l#0@@95|) refType)
                (= (type |l#1@@71|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@70|) (FieldType boolType))
                (= (type $o@@126) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#85| |l#0@@95|
                                            |l#1@@71|
                                            |l#2@@70|
                                            |l#3@@70|)
                               $o@@126
                               $f@@72))
     :skolemid |3645|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@681 T@U) (arg1@@381 T@U) (arg2@@244 T@U) (arg3@@171 Bool))
  (! (= (type (|lambda#86| arg0@@681 arg1@@381 arg2@@244 arg3@@171))
        (MapType6Type refType boolType))
     :pattern ((|lambda#86| arg0@@681 arg1@@381 arg2@@244 arg3@@171))
     :qid |funType:lambda#86|)))
(assert (forall ((|l#0@@96| T@U)
         (|l#1@@72| T@U)
         (|l#2@@71| T@U)
         (|l#3@@71| Bool)
         ($o@@127 T@U)
         ($f@@73 T@U))
  (! (let ((a!1 (= (type $f@@73) (FieldType (FieldTypeInv0 (type $f@@73)))))
           (a!2 (and (not (= $o@@127 |l#0@@96|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@72|
                                                               $o@@127)
                                               |l#2@@71|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#86| |l#0@@96|
                                                          |l#1@@72|
                                                          |l#2@@71|
                                                          |l#3@@71|)
                                             $o@@127
                                             $f@@73))
                   (=> a!2 |l#3@@71|))))
       (=> (and (= (type |l#0@@96|) refType)
                (= (type |l#1@@72|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@71|) (FieldType boolType))
                (= (type $o@@127) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#86| |l#0@@96|
                                            |l#1@@72|
                                            |l#2@@71|
                                            |l#3@@71|)
                               $o@@127
                               $f@@73))
     :skolemid |3646|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@682 T@U) (arg1@@382 T@U) (arg2@@245 T@U) (arg3@@172 Bool))
  (! (= (type (|lambda#87| arg0@@682 arg1@@382 arg2@@245 arg3@@172))
        (MapType6Type refType boolType))
     :pattern ((|lambda#87| arg0@@682 arg1@@382 arg2@@245 arg3@@172))
     :qid |funType:lambda#87|)))
(assert (forall ((|l#0@@97| T@U)
         (|l#1@@73| T@U)
         (|l#2@@72| T@U)
         (|l#3@@72| Bool)
         ($o@@128 T@U)
         ($f@@74 T@U))
  (! (let ((a!1 (= (type $f@@74) (FieldType (FieldTypeInv0 (type $f@@74)))))
           (a!2 (and (not (= $o@@128 |l#0@@97|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@73|
                                                               $o@@128)
                                               |l#2@@72|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#87| |l#0@@97|
                                                          |l#1@@73|
                                                          |l#2@@72|
                                                          |l#3@@72|)
                                             $o@@128
                                             $f@@74))
                   (=> a!2 |l#3@@72|))))
       (=> (and (= (type |l#0@@97|) refType)
                (= (type |l#1@@73|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@72|) (FieldType boolType))
                (= (type $o@@128) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#87| |l#0@@97|
                                            |l#1@@73|
                                            |l#2@@72|
                                            |l#3@@72|)
                               $o@@128
                               $f@@74))
     :skolemid |3647|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@683 T@U) (arg1@@383 T@U) (arg2@@246 T@U) (arg3@@173 Bool))
  (! (= (type (|lambda#88| arg0@@683 arg1@@383 arg2@@246 arg3@@173))
        (MapType6Type refType boolType))
     :pattern ((|lambda#88| arg0@@683 arg1@@383 arg2@@246 arg3@@173))
     :qid |funType:lambda#88|)))
(assert (forall ((|l#0@@98| T@U)
         (|l#1@@74| T@U)
         (|l#2@@73| T@U)
         (|l#3@@73| Bool)
         ($o@@129 T@U)
         ($f@@75 T@U))
  (! (let ((a!1 (= (type $f@@75) (FieldType (FieldTypeInv0 (type $f@@75)))))
           (a!2 (and (not (= $o@@129 |l#0@@98|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@74|
                                                               $o@@129)
                                               |l#2@@73|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#88| |l#0@@98|
                                                          |l#1@@74|
                                                          |l#2@@73|
                                                          |l#3@@73|)
                                             $o@@129
                                             $f@@75))
                   (=> a!2 |l#3@@73|))))
       (=> (and (= (type |l#0@@98|) refType)
                (= (type |l#1@@74|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@73|) (FieldType boolType))
                (= (type $o@@129) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#88| |l#0@@98|
                                            |l#1@@74|
                                            |l#2@@73|
                                            |l#3@@73|)
                               $o@@129
                               $f@@75))
     :skolemid |3648|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((arg0@@684 T@U) (arg1@@384 T@U) (arg2@@247 T@U) (arg3@@174 Bool))
  (! (= (type (|lambda#89| arg0@@684 arg1@@384 arg2@@247 arg3@@174))
        (MapType6Type refType boolType))
     :pattern ((|lambda#89| arg0@@684 arg1@@384 arg2@@247 arg3@@174))
     :qid |funType:lambda#89|)))
(assert (forall ((|l#0@@99| T@U)
         (|l#1@@75| T@U)
         (|l#2@@74| T@U)
         (|l#3@@74| Bool)
         ($o@@130 T@U)
         ($f@@76 T@U))
  (! (let ((a!1 (= (type $f@@76) (FieldType (FieldTypeInv0 (type $f@@76)))))
           (a!2 (and (not (= $o@@130 |l#0@@99|))
                     (U_2_bool (MapType1Select (MapType0Select |l#1@@75|
                                                               $o@@130)
                                               |l#2@@74|)))))
     (let ((a!3 (= (U_2_bool (MapType6Select (|lambda#89| |l#0@@99|
                                                          |l#1@@75|
                                                          |l#2@@74|
                                                          |l#3@@74|)
                                             $o@@130
                                             $f@@76))
                   (=> a!2 |l#3@@74|))))
       (=> (and (= (type |l#0@@99|) refType)
                (= (type |l#1@@75|) (MapType0Type refType MapType1Type))
                (= (type |l#2@@74|) (FieldType boolType))
                (= (type $o@@130) refType)
                a!1)
           a!3)))
     :pattern ((MapType6Select (|lambda#89| |l#0@@99|
                                            |l#1@@75|
                                            |l#2@@74|
                                            |l#3@@74|)
                               $o@@130
                               $f@@76))
     :skolemid |3649|
     :qid |DafnyPreludebpl.129:1|)))
(assert (forall ((|l#0@@100| T@U) (|l#1@@76| T@U) (|$l#0#heap#0| T@U) (|$l#0#i#0| T@U))
  (! (let ((a!1 (LinearMaybe.__default.has
                  |l#0@@100|
                  (|Seq#Index| |l#1@@76| (U_2_int ($Unbox intType |$l#0#i#0|))))))
       (=> (and (= (type |l#0@@100|) TyType)
                (= (type |l#1@@76|) (SeqType BoxType))
                (= (type |$l#0#heap#0|) (MapType0Type refType MapType1Type))
                (= (type |$l#0#i#0|) BoxType))
           (= (MapType2Select (|lambda#90| |l#0@@100| |l#1@@76|)
                              |$l#0#heap#0|
                              |$l#0#i#0|)
              ($Box (bool_2_U a!1)))))
     :pattern ((MapType2Select (|lambda#90| |l#0@@100| |l#1@@76|)
                               |$l#0#heap#0|
                               |$l#0#i#0|))
     :skolemid |3650|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@101| T@U)
         (|l#1@@77| Int)
         (|l#2@@75| Int)
         (|$l#0#heap#0@@0| T@U)
         (|$l#0#i#0@@0| T@U))
  (! (let ((a!1 (and ($IsBox |$l#0#i#0@@0| |l#0@@101|)
                     (INTERNAL_le_boogie
                       |l#1@@77|
                       (U_2_int ($Unbox intType |$l#0#i#0@@0|)))
                     (INTERNAL_lt_boogie
                       (U_2_int ($Unbox intType |$l#0#i#0@@0|))
                       |l#2@@75|))))
     (let ((a!2 (= (U_2_bool (MapType2Select (|lambda#91| |l#0@@101|
                                                          |l#1@@77|
                                                          |l#2@@75|)
                                             |$l#0#heap#0@@0|
                                             |$l#0#i#0@@0|))
                   a!1)))
       (=> (and (= (type |l#0@@101|) TyType)
                (= (type |$l#0#heap#0@@0|) (MapType0Type refType MapType1Type))
                (= (type |$l#0#i#0@@0|) BoxType))
           a!2)))
     :pattern ((MapType2Select (|lambda#91| |l#0@@101| |l#1@@77| |l#2@@75|)
                               |$l#0#heap#0@@0|
                               |$l#0#i#0@@0|))
     :skolemid |3651|
     :qid |DafnyPreludebpl.22:1|)))
(assert (forall ((|l#0@@102| Bool) (|$l#0#o#0| T@U))
  (! (let ((a!1 (= (U_2_bool (MapType0Select (|lambda#92| |l#0@@102|)
                                             |$l#0#o#0|))
                   |l#0@@102|)))
       (=> (= (type |$l#0#o#0|) refType) a!1))
     :pattern ((MapType0Select (|lambda#92| |l#0@@102|) |$l#0#o#0|))
     :skolemid |3652|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@103| T@U) (|$l#0#heap#0@@1| T@U) (|$l#0#i#0@@1| T@U))
  (! (=> (and (= (type |l#0@@103|) (MapType0Type BoxType boolType))
              (= (type |$l#0#heap#0@@1|) (MapType0Type refType MapType1Type))
              (= (type |$l#0#i#0@@1|) BoxType))
         (= (MapType2Select (|lambda#93| |l#0@@103|)
                            |$l#0#heap#0@@1|
                            |$l#0#i#0@@1|)
            |l#0@@103|))
     :pattern ((MapType2Select (|lambda#93| |l#0@@103|)
                               |$l#0#heap#0@@1|
                               |$l#0#i#0@@1|))
     :skolemid |3653|
     :qid |LinearSequencesdfy.69:25|)))
(assert (forall ((|l#0@@104| T@U) (|$l#0#ly#0| T@U))
  (! (=> (and (= (type |l#0@@104|) HandleTypeType)
              (= (type |$l#0#ly#0|) LayerTypeType))
         (= (MapType0Select (|lambda#94| |l#0@@104|) |$l#0#ly#0|) |l#0@@104|))
     :pattern ((MapType0Select (|lambda#94| |l#0@@104|) |$l#0#ly#0|))
     :skolemid |3654|
     :qid |LinearSequencesdfy.69:25|)))
(assert (forall ((|l#0@@105| T@U) (|$w#0@@2| T@U))
  (! (=> (and (= (type |l#0@@105|) BoxType) (= (type |$w#0@@2|) BoxType))
         (= (MapType0Select (|lambda#101| |l#0@@105|) |$w#0@@2|) |l#0@@105|))
     :pattern ((MapType0Select (|lambda#101| |l#0@@105|) |$w#0@@2|))
     :skolemid |3655|
     :qid |TotalMapsdfyTotalKMMapMod.28:5|)))
(assert (forall ((|l#0@@106| T@U) (|l#1@@78| T@U) (|l#2@@76| Int) (|$y#0| T@U))
  (! (let ((a!1 (and ($IsBox |$y#0| |l#0@@106|)
                     (> (U_2_int (MapType0Select |l#1@@78| |$y#0|)) |l#2@@76|))))
     (let ((a!2 (= (U_2_bool (MapType0Select (|lambda#104| |l#0@@106|
                                                           |l#1@@78|
                                                           |l#2@@76|)
                                             |$y#0|))
                   a!1)))
       (=> (and (= (type |l#0@@106|) TyType)
                (= (type |l#1@@78|) (MapType0Type BoxType intType))
                (= (type |$y#0|) BoxType))
           a!2)))
     :pattern ((MapType0Select (|lambda#104| |l#0@@106| |l#1@@78| |l#2@@76|)
                               |$y#0|))
     :skolemid |3656|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@107| T@U) (|l#1@@79| T@U) (|$y#0@@0| T@U))
  (! (let ((a!1 (= (U_2_bool (MapType0Select (|lambda#106| |l#0@@107| |l#1@@79|)
                                             |$y#0@@0|))
                   (and ($IsBox |$y#0@@0| |l#0@@107|)
                        (U_2_bool (MapType0Select |l#1@@79| |$y#0@@0|))))))
       (=> (and (= (type |l#0@@107|) TyType)
                (= (type |l#1@@79|) (MapType0Type BoxType boolType))
                (= (type |$y#0@@0|) BoxType))
           a!1))
     :pattern ((MapType0Select (|lambda#106| |l#0@@107| |l#1@@79|) |$y#0@@0|))
     :skolemid |3657|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@108| T@U)
         (|l#1@@80| T@U)
         (|l#2@@77| T@U)
         (|l#3@@75| T@U)
         (|$l#0#heap#0@@2| T@U)
         (|$l#0#i#0@@2| T@U))
  (! (let ((a!1 (Apply1 |l#0@@108|
                        |l#1@@80|
                        |$l#0#heap#0@@2|
                        |l#2@@77|
                        (|Seq#Index| |l#3@@75|
                                     (U_2_int ($Unbox intType |$l#0#i#0@@2|))))))
       (=> (and (= (type |l#0@@108|) TyType)
                (= (type |l#1@@80|) TyType)
                (= (type |l#2@@77|) HandleTypeType)
                (= (type |l#3@@75|) (SeqType BoxType))
                (= (type |$l#0#heap#0@@2|) (MapType0Type refType MapType1Type))
                (= (type |$l#0#i#0@@2|) BoxType))
           (= (MapType2Select (|lambda#112| |l#0@@108|
                                            |l#1@@80|
                                            |l#2@@77|
                                            |l#3@@75|)
                              |$l#0#heap#0@@2|
                              |$l#0#i#0@@2|)
              a!1)))
     :pattern ((MapType2Select (|lambda#112| |l#0@@108|
                                             |l#1@@80|
                                             |l#2@@77|
                                             |l#3@@75|)
                               |$l#0#heap#0@@2|
                               |$l#0#i#0@@2|))
     :skolemid |3658|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@109| T@U)
         (|l#1@@81| Int)
         (|l#2@@78| Int)
         (|l#3@@76| T@U)
         (|l#4| T@U)
         (|l#5| T@U)
         (|l#6| T@U)
         (|$l#0#heap#0@@3| T@U)
         (|$l#0#i#0@@3| T@U))
  (! (let ((a!1 (Requires1 |l#3@@76|
                           |l#4|
                           |$l#0#heap#0@@3|
                           |l#5|
                           (|Seq#Index| |l#6|
                                        (U_2_int ($Unbox intType |$l#0#i#0@@3|))))))
     (let ((a!2 (and ($IsBox |$l#0#i#0@@3| |l#0@@109|)
                     (INTERNAL_le_boogie
                       |l#1@@81|
                       (U_2_int ($Unbox intType |$l#0#i#0@@3|)))
                     (INTERNAL_lt_boogie
                       (U_2_int ($Unbox intType |$l#0#i#0@@3|))
                       |l#2@@78|)
                     a!1)))
     (let ((a!3 (= (U_2_bool (MapType2Select (|lambda#113| |l#0@@109|
                                                           |l#1@@81|
                                                           |l#2@@78|
                                                           |l#3@@76|
                                                           |l#4|
                                                           |l#5|
                                                           |l#6|)
                                             |$l#0#heap#0@@3|
                                             |$l#0#i#0@@3|))
                   a!2)))
       (=> (and (= (type |l#0@@109|) TyType)
                (= (type |l#3@@76|) TyType)
                (= (type |l#4|) TyType)
                (= (type |l#5|) HandleTypeType)
                (= (type |l#6|) (SeqType BoxType))
                (= (type |$l#0#heap#0@@3|) (MapType0Type refType MapType1Type))
                (= (type |$l#0#i#0@@3|) BoxType))
           a!3))))
     :pattern ((MapType2Select (|lambda#113| |l#0@@109|
                                             |l#1@@81|
                                             |l#2@@78|
                                             |l#3@@76|
                                             |l#4|
                                             |l#5|
                                             |l#6|)
                               |$l#0#heap#0@@3|
                               |$l#0#i#0@@3|))
     :skolemid |3659|
     :qid |DafnyPreludebpl.22:1|)))
(assert (forall ((arg0@@685 T@U)
         (arg1@@385 Int)
         (arg2@@248 Int)
         (arg3@@175 T@U)
         (arg4@@59 T@U)
         (arg5@@23 T@U)
         (arg6@@9 T@U)
         (arg7@@4 T@U)
         (arg8@@4 T@U)
         (arg9@@2 T@U)
         (arg10@@2 T@U)
         (arg11 T@U)
         (arg12 T@U))
  (! (= (type (|lambda#114| arg0@@685
                            arg1@@385
                            arg2@@248
                            arg3@@175
                            arg4@@59
                            arg5@@23
                            arg6@@9
                            arg7@@4
                            arg8@@4
                            arg9@@2
                            arg10@@2
                            arg11
                            arg12))
        (MapType0Type refType boolType))
     :pattern ((|lambda#114| arg0@@685
                             arg1@@385
                             arg2@@248
                             arg3@@175
                             arg4@@59
                             arg5@@23
                             arg6@@9
                             arg7@@4
                             arg8@@4
                             arg9@@2
                             arg10@@2
                             arg11
                             arg12))
     :qid |funType:lambda#114|)))
(assert (forall ((|l#0@@110| T@U)
         (|l#1@@82| Int)
         (|l#2@@79| Int)
         (|l#3@@77| T@U)
         (|l#4@@0| T@U)
         (|l#5@@0| T@U)
         (|l#6@@0| T@U)
         (|l#7| T@U)
         (|l#8| T@U)
         (|l#9| T@U)
         (|l#10| T@U)
         (|l#11| T@U)
         (|l#12| T@U)
         (|$l#0#o#0@@0| T@U))
  (! (let ((a!1 (exists ((|i#3@@3| Int) (|o#0| T@U))
                  (! (let ((a!1 (U_2_bool (MapType0Select (Reads1 |l#3@@77|
                                                                  |l#4@@0|
                                                                  |l#5@@0|
                                                                  |l#6@@0|
                                                                  (|Seq#Index| |l#7|
                                                                               |i#3@@3|))
                                                          ($Box |o#0|)))))
                       (and (= (type |o#0|) refType)
                            ($Is |o#0| |l#0@@110|)
                            (INTERNAL_le_boogie |l#1@@82| |i#3@@3|)
                            (INTERNAL_lt_boogie |i#3@@3| |l#2@@79|)
                            a!1
                            (= ($Box |$l#0#o#0@@0|) ($Box |o#0|))))
                     :pattern ((MapType0Select (Reads1 |l#8|
                                                       |l#9|
                                                       |l#10|
                                                       |l#11|
                                                       (|Seq#Index| |l#12|
                                                                    |i#3@@3|))
                                               ($Box |o#0|)))
                     :skolemid |2283|
                     :qid |Sequencesidfy.142:17|))))
     (let ((a!2 (= (U_2_bool (MapType0Select (|lambda#114| |l#0@@110|
                                                           |l#1@@82|
                                                           |l#2@@79|
                                                           |l#3@@77|
                                                           |l#4@@0|
                                                           |l#5@@0|
                                                           |l#6@@0|
                                                           |l#7|
                                                           |l#8|
                                                           |l#9|
                                                           |l#10|
                                                           |l#11|
                                                           |l#12|)
                                             |$l#0#o#0@@0|))
                   a!1)))
       (=> (and (= (type |l#0@@110|) TyType)
                (= (type |l#3@@77|) TyType)
                (= (type |l#4@@0|) TyType)
                (= (type |l#5@@0|) (MapType0Type refType MapType1Type))
                (= (type |l#6@@0|) HandleTypeType)
                (= (type |l#7|) (SeqType BoxType))
                (= (type |l#8|) TyType)
                (= (type |l#9|) TyType)
                (= (type |l#10|) (MapType0Type refType MapType1Type))
                (= (type |l#11|) HandleTypeType)
                (= (type |l#12|) (SeqType BoxType))
                (= (type |$l#0#o#0@@0|) refType))
           a!2)))
     :pattern ((MapType0Select (|lambda#114| |l#0@@110|
                                             |l#1@@82|
                                             |l#2@@79|
                                             |l#3@@77|
                                             |l#4@@0|
                                             |l#5@@0|
                                             |l#6@@0|
                                             |l#7|
                                             |l#8|
                                             |l#9|
                                             |l#10|
                                             |l#11|
                                             |l#12|)
                               |$l#0#o#0@@0|))
     :skolemid |3660|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@111| T@U)
         (|l#1@@83| Int)
         (|l#2@@80| Int)
         (|l#3@@78| T@U)
         (|l#4@@1| T@U)
         (|l#5@@1| T@U)
         (|l#6@@1| T@U)
         (|l#7@@0| T@U)
         (|l#8@@0| T@U)
         (|l#9@@0| T@U)
         (|l#10@@0| T@U)
         (|$l#0#heap#0@@4| T@U)
         (|$l#0#i#0@@4| T@U))
  (! (=> (and (= (type |l#0@@111|) TyType)
              (= (type |l#3@@78|) TyType)
              (= (type |l#4@@1|) TyType)
              (= (type |l#5@@1|) HandleTypeType)
              (= (type |l#6@@1|) (SeqType BoxType))
              (= (type |l#7@@0|) TyType)
              (= (type |l#8@@0|) TyType)
              (= (type |l#9@@0|) HandleTypeType)
              (= (type |l#10@@0|) (SeqType BoxType))
              (= (type |$l#0#heap#0@@4|) (MapType0Type refType MapType1Type))
              (= (type |$l#0#i#0@@4|) BoxType))
         (= (MapType2Select (|lambda#115| |l#0@@111|
                                          |l#1@@83|
                                          |l#2@@80|
                                          |l#3@@78|
                                          |l#4@@1|
                                          |l#5@@1|
                                          |l#6@@1|
                                          |l#7@@0|
                                          |l#8@@0|
                                          |l#9@@0|
                                          |l#10@@0|)
                            |$l#0#heap#0@@4|
                            |$l#0#i#0@@4|)
            (SetRef_to_SetBox (|lambda#114| |l#0@@111|
                                            |l#1@@83|
                                            |l#2@@80|
                                            |l#3@@78|
                                            |l#4@@1|
                                            |$l#0#heap#0@@4|
                                            |l#5@@1|
                                            |l#6@@1|
                                            |l#7@@0|
                                            |l#8@@0|
                                            |$l#0#heap#0@@4|
                                            |l#9@@0|
                                            |l#10@@0|))))
     :pattern ((MapType2Select (|lambda#115| |l#0@@111|
                                             |l#1@@83|
                                             |l#2@@80|
                                             |l#3@@78|
                                             |l#4@@1|
                                             |l#5@@1|
                                             |l#6@@1|
                                             |l#7@@0|
                                             |l#8@@0|
                                             |l#9@@0|
                                             |l#10@@0|)
                               |$l#0#heap#0@@4|
                               |$l#0#i#0@@4|))
     :skolemid |3661|
     :qid |unknown.0:0|)))
(assert (forall ((|$l#2#heap#0| T@U) (|$l#2#a#0| T@U) (|$l#2#e#0| T@U))
  (! (let ((a!1 ($Box (|Set#Union| ($Unbox (MapType0Type BoxType boolType)
                                           |$l#2#a#0|)
                                   ($Unbox (MapType0Type BoxType boolType)
                                           |$l#2#e#0|)))))
       (=> (and (= (type |$l#2#heap#0|) (MapType0Type refType MapType1Type))
                (= (type |$l#2#a#0|) BoxType)
                (= (type |$l#2#e#0|) BoxType))
           (= (MapType3Select |lambda#127| |$l#2#heap#0| |$l#2#a#0| |$l#2#e#0|)
              a!1)))
     :pattern ((MapType3Select |lambda#127| |$l#2#heap#0| |$l#2#a#0| |$l#2#e#0|))
     :skolemid |3662|
     :qid |DafnyPreludebpl.545:12|)))
(assert (forall ((|l#0@@112| T@U)
         (|l#1@@84| T@U)
         (|$l#2#heap#0@@0| T@U)
         (|$l#2#a#0@@0| T@U)
         (|$l#2#e#0@@0| T@U))
  (! (let ((a!1 (= (U_2_bool (MapType3Select (|lambda#128| |l#0@@112| |l#1@@84|)
                                             |$l#2#heap#0@@0|
                                             |$l#2#a#0@@0|
                                             |$l#2#e#0@@0|))
                   (and ($IsBox |$l#2#a#0@@0| |l#0@@112|)
                        ($IsBox |$l#2#e#0@@0| |l#1@@84|)))))
       (=> (and (= (type |l#0@@112|) TyType)
                (= (type |l#1@@84|) TyType)
                (= (type |$l#2#heap#0@@0|) (MapType0Type refType MapType1Type))
                (= (type |$l#2#a#0@@0|) BoxType)
                (= (type |$l#2#e#0@@0|) BoxType))
           a!1))
     :pattern ((MapType3Select (|lambda#128| |l#0@@112| |l#1@@84|)
                               |$l#2#heap#0@@0|
                               |$l#2#a#0@@0|
                               |$l#2#e#0@@0|))
     :skolemid |3663|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@113| T@U)
         (|$l#2#heap#0@@1| T@U)
         (|$l#2#a#0@@1| T@U)
         (|$l#2#e#0@@1| T@U))
  (! (=> (and (= (type |l#0@@113|) (MapType0Type BoxType boolType))
              (= (type |$l#2#heap#0@@1|) (MapType0Type refType MapType1Type))
              (= (type |$l#2#a#0@@1|) BoxType)
              (= (type |$l#2#e#0@@1|) BoxType))
         (= (MapType3Select (|lambda#130| |l#0@@113|)
                            |$l#2#heap#0@@1|
                            |$l#2#a#0@@1|
                            |$l#2#e#0@@1|)
            |l#0@@113|))
     :pattern ((MapType3Select (|lambda#130| |l#0@@113|)
                               |$l#2#heap#0@@1|
                               |$l#2#a#0@@1|
                               |$l#2#e#0@@1|))
     :skolemid |3664|
     :qid |Sequencesidfy.350:15|)))
(assert (forall ((|l#0@@114| T@U) (|l#1@@85| T@U) (|l#2@@81| T@U) (|$w#0@@3| T@U))
  (! (let ((a!1 (= (U_2_bool (MapType0Select (|lambda#147| |l#0@@114|
                                                           |l#1@@85|
                                                           |l#2@@81|)
                                             |$w#0@@3|))
                   (and ($IsBox |$w#0@@3| |l#0@@114|)
                        (U_2_bool (MapType0Select |l#1@@85| |$w#0@@3|))
                        (not (= |$w#0@@3| |l#2@@81|))))))
       (=> (and (= (type |l#0@@114|) TyType)
                (= (type |l#1@@85|) (MapType0Type BoxType boolType))
                (= (type |l#2@@81|) BoxType)
                (= (type |$w#0@@3|) BoxType))
           a!1))
     :pattern ((MapType0Select (|lambda#147| |l#0@@114| |l#1@@85| |l#2@@81|)
                               |$w#0@@3|))
     :skolemid |3665|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@115| T@U) (|$w#0@@4| T@U))
  (! (=> (and (= (type |l#0@@115|) (MapType0Type BoxType BoxType))
              (= (type |$w#0@@4|) BoxType))
         (= (MapType0Select (|lambda#148| |l#0@@115|) |$w#0@@4|)
            (MapType0Select |l#0@@115| |$w#0@@4|)))
     :pattern ((MapType0Select (|lambda#148| |l#0@@115|) |$w#0@@4|))
     :skolemid |3666|
     :qid |MapRemovesdfy.22:44|)))
(assert (forall ((|l#0@@116| T@U) (|l#1@@86| T@U) (|l#2@@82| T@U) (|$w#0@@5| T@U))
  (! (let ((a!1 (and ($IsBox |$w#0@@5| |l#0@@116|)
                     (U_2_bool (MapType0Select |l#1@@86| |$w#0@@5|))
                     (not (U_2_bool (MapType0Select |l#2@@82| |$w#0@@5|))))))
     (let ((a!2 (= (U_2_bool (MapType0Select (|lambda#153| |l#0@@116|
                                                           |l#1@@86|
                                                           |l#2@@82|)
                                             |$w#0@@5|))
                   a!1)))
       (=> (and (= (type |l#0@@116|) TyType)
                (= (type |l#1@@86|) (MapType0Type BoxType boolType))
                (= (type |l#2@@82|) (MapType0Type BoxType boolType))
                (= (type |$w#0@@5|) BoxType))
           a!2)))
     :pattern ((MapType0Select (|lambda#153| |l#0@@116| |l#1@@86| |l#2@@82|)
                               |$w#0@@5|))
     :skolemid |3667|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@117| T@U) (|l#1@@87| T@U) (|l#2@@83| T@U) (|$w#0@@6| T@U))
  (! (=> (and (= (type |l#0@@117|) TyType)
              (= (type |l#1@@87|) TyType)
              (= (type |l#2@@83|) (IMapType BoxType BoxType))
              (= (type |$w#0@@6|) BoxType))
         (= (MapType0Select (|lambda#158| |l#0@@117| |l#1@@87| |l#2@@83|)
                            |$w#0@@6|)
            (|$let#8_a| |l#0@@117| |l#1@@87| |l#2@@83| |$w#0@@6|)))
     :pattern ((MapType0Select (|lambda#158| |l#0@@117| |l#1@@87| |l#2@@83|)
                               |$w#0@@6|))
     :skolemid |3668|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@118| T@U) (|l#1@@88| T@U) (|l#2@@84| T@U) (|$w#0@@7| T@U))
  (! (let ((a!1 (= (U_2_bool (MapType0Select (|lambda#169| |l#0@@118|
                                                           |l#1@@88|
                                                           |l#2@@84|)
                                             |$w#0@@7|))
                   (and ($IsBox |$w#0@@7| |l#0@@118|)
                        (U_2_bool (MapType0Select |l#1@@88| |$w#0@@7|))
                        (U_2_bool (MapType0Select |l#2@@84| |$w#0@@7|))))))
       (=> (and (= (type |l#0@@118|) TyType)
                (= (type |l#1@@88|) (MapType0Type BoxType boolType))
                (= (type |l#2@@84|) (MapType0Type BoxType boolType))
                (= (type |$w#0@@7|) BoxType))
           a!1))
     :pattern ((MapType0Select (|lambda#169| |l#0@@118| |l#1@@88| |l#2@@84|)
                               |$w#0@@7|))
     :skolemid |3669|
     :qid |unknown.0:0|)))
(assert (forall ((|l#0@@119| T@U) (|l#1@@89| T@U) (|l#2@@85| T@U) (|$w#0@@8| T@U))
  (! (let ((a!1 (= (MapType0Select (|lambda#184| |l#0@@119| |l#1@@89| |l#2@@85|)
                                   |$w#0@@8|)
                   (ite (U_2_bool (MapType0Select |l#0@@119| |$w#0@@8|))
                        (MapType0Select |l#1@@89| |$w#0@@8|)
                        (MapType0Select |l#2@@85| |$w#0@@8|)))))
       (=> (and (= (type |l#0@@119|) (MapType0Type BoxType boolType))
                (= (type |l#1@@89|) (MapType0Type BoxType BoxType))
                (= (type |l#2@@85|) (MapType0Type BoxType BoxType))
                (= (type |$w#0@@8|) BoxType))
           a!1))
     :pattern ((MapType0Select (|lambda#184| |l#0@@119| |l#1@@89| |l#2@@85|)
                               |$w#0@@8|))
     :skolemid |3670|
     :qid |Mapsidfy.134:52|)))
(assert (forall ((|l#0@@120| T@U)
         (|l#1@@90| T@U)
         (|l#2@@86| T@U)
         (|l#3@@79| T@U)
         (|l#4@@2| T@U)
         (|$w#0@@9| T@U))
  (! (let ((a!1 (ite (U_2_bool (MapType0Select |l#0@@120| |$w#0@@9|))
                     (MapType0Select |l#1@@90| |$w#0@@9|)
                     (ite (U_2_bool (MapType0Select |l#2@@86| |$w#0@@9|))
                          (MapType0Select |l#3@@79| |$w#0@@9|)
                          (MapType0Select |l#4@@2| |$w#0@@9|)))))
       (=> (and (= (type |l#0@@120|) (MapType0Type BoxType boolType))
                (= (type |l#1@@90|) (MapType0Type BoxType BoxType))
                (= (type |l#2@@86|) (MapType0Type BoxType boolType))
                (= (type |l#3@@79|) (MapType0Type BoxType BoxType))
                (= (type |l#4@@2|) (MapType0Type BoxType BoxType))
                (= (type |$w#0@@9|) BoxType))
           (= (MapType0Select (|lambda#204| |l#0@@120|
                                            |l#1@@90|
                                            |l#2@@86|
                                            |l#3@@79|
                                            |l#4@@2|)
                              |$w#0@@9|)
              a!1)))
     :pattern ((MapType0Select (|lambda#204| |l#0@@120|
                                             |l#1@@90|
                                             |l#2@@86|
                                             |l#3@@79|
                                             |l#4@@2|)
                               |$w#0@@9|))
     :skolemid |3671|
     :qid |Mapsidfy.212:9|)))
(assert (forall ((|l#0@@121| T@U) (|l#1@@91| Int) (|l#2@@87| Int) (|$y#0@@1| T@U))
  (! (let ((a!1 (and ($IsBox |$y#0@@1| |l#0@@121|)
                     (INTERNAL_le_boogie
                       |l#1@@91|
                       (U_2_int ($Unbox intType |$y#0@@1|)))
                     (INTERNAL_lt_boogie
                       (U_2_int ($Unbox intType |$y#0@@1|))
                       |l#2@@87|))))
     (let ((a!2 (= (U_2_bool (MapType0Select (|lambda#211| |l#0@@121|
                                                           |l#1@@91|
                                                           |l#2@@87|)
                                             |$y#0@@1|))
                   a!1)))
       (=> (and (= (type |l#0@@121|) TyType) (= (type |$y#0@@1|) BoxType)) a!2)))
     :pattern ((MapType0Select (|lambda#211| |l#0@@121| |l#1@@91| |l#2@@87|)
                               |$y#0@@1|))
     :skolemid |3672|
     :qid |DafnyPreludebpl.22:1|)))
(assert (forall ((|l#0@@122| T@U)
         (|l#1@@92| T@U)
         (|$l#0#heap#0@@5| T@U)
         (|$l#0#i#0@@5| T@U))
  (! (let ((a!1 ($Unbox DatatypeTypeType
                        (|Seq#Index| |l#0@@122|
                                     (U_2_int ($Unbox intType |$l#0#i#0@@5|))))))
       (=> (and (= (type |l#0@@122|) (SeqType BoxType))
                (= (type |l#1@@92|) (MapType0Type BoxType boolType))
                (= (type |$l#0#heap#0@@5|) (MapType0Type refType MapType1Type))
                (= (type |$l#0#i#0@@5|) BoxType))
           (= (MapType2Select (|lambda#227| |l#0@@122| |l#1@@92|)
                              |$l#0#heap#0@@5|
                              |$l#0#i#0@@5|)
              ($Box (Buffers.Buffer.ApplyFilter a!1 |l#1@@92|)))))
     :pattern ((MapType2Select (|lambda#227| |l#0@@122| |l#1@@92|)
                               |$l#0#heap#0@@5|
                               |$l#0#i#0@@5|))
     :skolemid |3673|
     :qid |Buffersidfy.55:63|)))
(assert (forall ((|l#0@@123| T@U) (|$y#0@@2| T@U))
  (! (let ((a!1 (and ($IsBox |$y#0@@2| |l#0@@123|)
                     (Buffers.__default.AnyKey
                       ($Unbox (SeqType BoxType) |$y#0@@2|)))))
     (let ((a!2 (= (U_2_bool (MapType0Select (|lambda#242| |l#0@@123|)
                                             |$y#0@@2|))
                   a!1)))
       (=> (and (= (type |l#0@@123|) TyType) (= (type |$y#0@@2|) BoxType)) a!2)))
     :pattern ((MapType0Select (|lambda#242| |l#0@@123|) |$y#0@@2|))
     :skolemid |3674|
     :qid |KeyTypesdfy.10:8|)))
(assert (forall ((|l#0@@124| T@U) (|l#1@@93| T@U) (|l#2@@88| T@U) (|$w#0@@10| T@U))
  (! (let ((a!1 ($Box (ite (U_2_bool (MapType0Select |l#0@@124| |$w#0@@10|))
                           ($Unbox DatatypeTypeType
                                   (MapType0Select |l#1@@93| |$w#0@@10|))
                           |l#2@@88|))))
       (=> (and (= (type |l#0@@124|) (MapType0Type BoxType boolType))
                (= (type |l#1@@93|) (MapType0Type BoxType BoxType))
                (= (type |l#2@@88|) DatatypeTypeType)
                (= (type |$w#0@@10|) BoxType))
           (= (MapType0Select (|lambda#245| |l#0@@124| |l#1@@93| |l#2@@88|)
                              |$w#0@@10|)
              a!1)))
     :pattern ((MapType0Select (|lambda#245| |l#0@@124| |l#1@@93| |l#2@@88|)
                               |$w#0@@10|))
     :skolemid |3675|
     :qid |PagedBetreeidfy.99:39|)))
(assert (forall ((|l#0@@125| T@U)
         (|l#1@@94| T@U)
         (|l#2@@89| T@U)
         (|l#3@@80| T@U)
         (|l#4@@3| T@U)
         (|l#5@@2| T@U)
         (|l#6@@2| T@U)
         (|$w#0@@11| T@U))
  (! (let ((a!1 (PagedBetree.BetreeNode.FilterBuffersAndChildren
                  (PagedBetree.BetreeNode.Child
                    |l#1@@94|
                    ($Unbox (SeqType BoxType) |$w#0@@11|))
                  |l#2@@89|))
           (a!2 (PagedBetree.BetreeNode.FilterBuffersAndChildren
                  (PagedBetree.BetreeNode.Child
                    |l#4@@3|
                    ($Unbox (SeqType BoxType) |$w#0@@11|))
                  |l#5@@2|)))
     (let ((a!3 (ite (U_2_bool (MapType0Select |l#3@@80| |$w#0@@11|))
                     a!2
                     (PagedBetree.BetreeNode.Child
                       |l#6@@2|
                       ($Unbox (SeqType BoxType) |$w#0@@11|)))))
     (let ((a!4 ($Box (ite (U_2_bool (MapType0Select |l#0@@125| |$w#0@@11|))
                           a!1
                           a!3))))
       (=> (and (= (type |l#0@@125|) (MapType0Type BoxType boolType))
                (= (type |l#1@@94|) DatatypeTypeType)
                (= (type |l#2@@89|) (MapType0Type BoxType boolType))
                (= (type |l#3@@80|) (MapType0Type BoxType boolType))
                (= (type |l#4@@3|) DatatypeTypeType)
                (= (type |l#5@@2|) (MapType0Type BoxType boolType))
                (= (type |l#6@@2|) DatatypeTypeType)
                (= (type |$w#0@@11|) BoxType))
           (= (MapType0Select (|lambda#251| |l#0@@125|
                                            |l#1@@94|
                                            |l#2@@89|
                                            |l#3@@80|
                                            |l#4@@3|
                                            |l#5@@2|
                                            |l#6@@2|)
                              |$w#0@@11|)
              a!4)))))
     :pattern ((MapType0Select (|lambda#251| |l#0@@125|
                                             |l#1@@94|
                                             |l#2@@89|
                                             |l#3@@80|
                                             |l#4@@3|
                                             |l#5@@2|
                                             |l#6@@2|)
                               |$w#0@@11|))
     :skolemid |3676|
     :qid |PagedBetreeidfy.109:20|)))
(assert (forall ((|l#0@@126| T@U)
         (|l#1@@95| T@U)
         (|l#2@@90| T@U)
         (|l#3@@81| T@U)
         (|$w#0@@12| T@U))
  (! (let ((a!1 (PagedBetree.BetreeNode.Promote
                  (PagedBetree.BetreeNode.Child
                    |l#1@@95|
                    ($Unbox (SeqType BoxType) |$w#0@@12|)))))
     (let ((a!2 (ite (U_2_bool (MapType0Select |l#0@@126| |$w#0@@12|))
                     (PagedBetree.BetreeNode.PushBufferStack a!1 |l#2@@90|)
                     (PagedBetree.BetreeNode.Child
                       |l#3@@81|
                       ($Unbox (SeqType BoxType) |$w#0@@12|)))))
       (=> (and (= (type |l#0@@126|) (MapType0Type BoxType boolType))
                (= (type |l#1@@95|) DatatypeTypeType)
                (= (type |l#2@@90|) DatatypeTypeType)
                (= (type |l#3@@81|) DatatypeTypeType)
                (= (type |$w#0@@12|) BoxType))
           (= (MapType0Select (|lambda#257| |l#0@@126|
                                            |l#1@@95|
                                            |l#2@@90|
                                            |l#3@@81|)
                              |$w#0@@12|)
              ($Box a!2)))))
     :pattern ((MapType0Select (|lambda#257| |l#0@@126|
                                             |l#1@@95|
                                             |l#2@@90|
                                             |l#3@@81|)
                               |$w#0@@12|))
     :skolemid |3677|
     :qid |PagedBetreeidfy.136:20|)))
(assert (forall ((|l#0@@127| T@U) (|l#1@@96| T@U) (|l#2@@91| T@U) (|$w#0@@13| T@U))
  (! (let ((a!1 (ite (U_2_bool (MapType0Select |l#0@@127| |$w#0@@13|))
                     |l#1@@96|
                     (PagedBetree.BetreeNode.Child
                       |l#2@@91|
                       ($Unbox (SeqType BoxType) |$w#0@@13|)))))
       (=> (and (= (type |l#0@@127|) (MapType0Type BoxType boolType))
                (= (type |l#1@@96|) DatatypeTypeType)
                (= (type |l#2@@91|) DatatypeTypeType)
                (= (type |$w#0@@13|) BoxType))
           (= (MapType0Select (|lambda#263| |l#0@@127| |l#1@@96| |l#2@@91|)
                              |$w#0@@13|)
              ($Box a!1))))
     :pattern ((MapType0Select (|lambda#263| |l#0@@127| |l#1@@96| |l#2@@91|)
                               |$w#0@@13|))
     :skolemid |3678|
     :qid |PagedBetreeidfy.351:53|)))
(assert (and (= (type $_Frame@0) (MapType6Type refType boolType))
     (= (type $Heap@@50) (MapType0Type refType MapType1Type))
     (= (type |receipt#0@@9|) DatatypeTypeType)
     (= (type $_Frame@0@@0) (MapType6Type refType boolType))
     (= (type StartFuel_Sequences._default.Range) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.Range) LayerTypeType)
     (= (type StartFuel_Sequences._default.ApplyOpaque) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.ApplyOpaque) LayerTypeType)
     (= (type StartFuel_Sequences._default.remove) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.remove) LayerTypeType)
     (= (type StartFuel_Sequences._default.RemoveOneValue) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.RemoveOneValue) LayerTypeType)
     (= (type StartFuel_Sequences._default.insert) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.insert) LayerTypeType)
     (= (type StartFuel_Sequences._default.replace1with2) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.replace1with2) LayerTypeType)
     (= (type StartFuel_Sequences._default.replace2with1) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.replace2with1) LayerTypeType)
     (= (type StartFuel_Sequences._default.concat) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.concat) LayerTypeType)
     (= (type StartFuel_Sequences._default.concat3) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.concat3) LayerTypeType)
     (= (type StartFuel_Sequences._default.concatSeq) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.concatSeq) LayerTypeType)
     (= (type StartFuel_Sequences._default.IsPrefix) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.IsPrefix) LayerTypeType)
     (= (type StartFuel_Sequences._default.IsSuffix) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.IsSuffix) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.SeqIndexIterate) LayerTypeType)
     (= (type StartFuel_Sequences._default.SeqIndex) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.SeqIndex) LayerTypeType)
     (= (type StartFuel_Sequences._default.SeqOfLength) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.SeqOfLength) LayerTypeType)
     (= (type StartFuel_Sequences._default.SeqIndexUpdate) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.SeqIndexUpdate) LayerTypeType)
     (= (type StartFuel_Sequences._default.Zip) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.Zip) LayerTypeType)
     (= (type StartFuel_Sequences._default.Unzip) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.Unzip) LayerTypeType)
     (= (type StartFuel_Sequences._default.Flatten) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.Flatten) LayerTypeType)
     (= (type StartFuel_Sequences._default.seqMax) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.seqMax) LayerTypeType)
     (= (type StartFuel_Sequences._default.fill) LayerTypeType)
     (= (type StartFuelAssert_Sequences._default.fill) LayerTypeType)
     (= (type StartFuel_Maps._default.MapRemoveStrong) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapRemoveStrong) LayerTypeType)
     (= (type StartFuel_Maps._default.MapRemove1Strong) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapRemove1Strong) LayerTypeType)
     (= (type StartFuel_Maps._default.IMapInvert) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.IMapInvert) LayerTypeType)
     (= (type StartFuel_Maps._default.IMapRemove) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.IMapRemove) LayerTypeType)
     (= (type StartFuel_Maps._default.IMapRemove1) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.IMapRemove1) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapDisjointUnion) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapUnionPreferA) LayerTypeType)
     (= (type StartFuel_Maps._default.MapUnionPreferB) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapUnionPreferB) LayerTypeType)
     (= (type StartFuel_Maps._default.MapUnion) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapUnion) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.IMapUnionPreferA) LayerTypeType)
     (= (type StartFuel_Maps._default.IMapUnionPreferB) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.IMapUnionPreferB) LayerTypeType)
     (= (type StartFuel_Maps._default.IMapUnion) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.IMapUnion) LayerTypeType)
     (= (type StartFuel_Maps._default.MapDisjointUnion3) LayerTypeType)
     (= (type StartFuelAssert_Maps._default.MapDisjointUnion3) LayerTypeType)
     (= (type StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet) LayerTypeType)
     (= (type StartFuel_PagedBetree.Path.ReplacedChildren) LayerTypeType)
     (= (type StartFuelAssert_PagedBetree.Path.ReplacedChildren) LayerTypeType)
     (= (type StartFuelAssert_PagedBetreeRefinement._default.INode)
        LayerTypeType)
     (= (type StartFuel_PagedBetreeRefinement._default.MapApply) LayerTypeType)
     (= (type StartFuelAssert_PagedBetreeRefinement._default.MapApply)
        LayerTypeType)
     (= (type |out#0|) DatatypeTypeType)))
(assert (let ((a!1 (forall (($o@@131 T@U) ($f@@77 T@U))
             (! (let ((a!1 (= (type $f@@77)
                              (FieldType (FieldTypeInv0 (type $f@@77))))))
                  (=> (and (= (type $o@@131) refType) a!1 false)
                      (U_2_bool (MapType6Select $_Frame@0@@0 $o@@131 $f@@77))))
                :no-pattern (type $o@@131)
                :no-pattern (type $f@@77)
                :no-pattern (U_2_int $o@@131)
                :no-pattern (U_2_bool $o@@131)
                :no-pattern (U_2_int $f@@77)
                :no-pattern (U_2_bool $f@@77)
                :skolemid |1418|
                :qid |PagedBetreeRefinementidfy.174:22|)))
      (a!3 (and ($IsAlloc (PagedBetree.BetreeNode.children
                            (PagedBetree.QueryReceipt.root |receipt#0@@9|))
                          Tclass.PagedBetree.ChildMap
                          $Heap@@50)
                (|PagedBetree.ChildMap.WF#canCall|
                  (PagedBetree.BetreeNode.children
                    (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
                (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@9|)
                (|PagedBetree.ChildMap.WF#canCall|
                  (PagedBetree.BetreeNode.children
                    (PagedBetree.QueryReceipt.root |receipt#0@@9|)))))
      (a!4 (|IMap#Domain| (PagedBetree.ChildMap.mapp
                            (PagedBetree.BetreeNode.children
                              (PagedBetree.QueryReceipt.root |receipt#0@@9|)))))
      (a!7 (forall ((|k#0@@87| T@U))
             (! (let ((a!1 (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                              (PagedBetree.BetreeNode.children
                                                (PagedBetree.QueryReceipt.root
                                                  |receipt#0@@9|))))))
                (let ((a!2 (PagedBetree.BetreeNode.WF
                             ($LS ($LS $LZ))
                             ($Unbox DatatypeTypeType
                                     (MapType0Select a!1 ($Box |k#0@@87|))))))
                  (=> (= (type |k#0@@87|) (SeqType BoxType))
                      (=> (and ($Is |k#0@@87| Tclass.KeyType.Key)
                               (Buffers.__default.AnyKey |k#0@@87|))
                          a!2))))
                :pattern (($Unbox DatatypeTypeType
                                  (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp
                                                                     (PagedBetree.BetreeNode.children
                                                                       (PagedBetree.QueryReceipt.root
                                                                         |receipt#0@@9|))))
                                                  ($Box |k#0@@87|))))
                :pattern ((Buffers.__default.AnyKey |k#0@@87|))
                :skolemid |1419|
                :qid |PagedBetreeidfy.51:18|)))
      (a!10 (and (PagedBetree.ChildMap.ChildMap_q
                   (PagedBetree.BetreeNode.children
                     (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
                 (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@9|)))
      (a!12 (and (<= 0 (LitInt 1))
                 (<= (LitInt 1)
                     (|Seq#Length| (PagedBetree.QueryReceipt.lines
                                     |receipt#0@@9|))))))
(let ((a!2 (and (= (AsFuelBottom StartFuel_Sequences._default.SeqIndex)
                   StartFuel_Sequences._default.SeqIndex)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndex)
                   StartFuelAssert_Sequences._default.SeqIndex)
                (= (AsFuelBottom StartFuel_Sequences._default.SeqOfLength)
                   StartFuel_Sequences._default.SeqOfLength)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqOfLength)
                   StartFuelAssert_Sequences._default.SeqOfLength)
                (= (AsFuelBottom StartFuel_Sequences._default.SeqIndexUpdate)
                   StartFuel_Sequences._default.SeqIndexUpdate)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndexUpdate)
                   StartFuelAssert_Sequences._default.SeqIndexUpdate)
                (= (AsFuelBottom StartFuel_Sequences._default.Zip)
                   StartFuel_Sequences._default.Zip)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.Zip)
                   StartFuelAssert_Sequences._default.Zip)
                (= (AsFuelBottom StartFuel_Sequences._default.Unzip)
                   StartFuel_Sequences._default.Unzip)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.Unzip)
                   StartFuelAssert_Sequences._default.Unzip)
                (= (AsFuelBottom StartFuel_Sequences._default.FlattenShape)
                   StartFuel_Sequences._default.FlattenShape)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.FlattenShape)
                   StartFuelAssert_Sequences._default.FlattenShape)
                (= (AsFuelBottom StartFuel_Sequences._default.FlattenLength)
                   StartFuel_Sequences._default.FlattenLength)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.FlattenLength)
                   StartFuelAssert_Sequences._default.FlattenLength)
                (= (AsFuelBottom StartFuel_Sequences._default.Flatten)
                   StartFuel_Sequences._default.Flatten)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.Flatten)
                   StartFuelAssert_Sequences._default.Flatten)
                (= (AsFuelBottom StartFuel_Sequences._default.seqMax)
                   StartFuel_Sequences._default.seqMax)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.seqMax)
                   StartFuelAssert_Sequences._default.seqMax)
                (= (AsFuelBottom StartFuel_Sequences._default.fill)
                   StartFuel_Sequences._default.fill)
                (= (AsFuelBottom StartFuelAssert_Sequences._default.fill)
                   StartFuelAssert_Sequences._default.fill)
                (= (AsFuelBottom StartFuel_MapRemove_s._default.MapRemove1)
                   StartFuel_MapRemove_s._default.MapRemove1)
                (= (AsFuelBottom StartFuelAssert_MapRemove_s._default.MapRemove1)
                   StartFuelAssert_MapRemove_s._default.MapRemove1)
                (= (AsFuelBottom StartFuel_Maps._default.MapRemove)
                   StartFuel_Maps._default.MapRemove)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemove)
                   StartFuelAssert_Maps._default.MapRemove)
                (= (AsFuelBottom StartFuel_Maps._default.MapRemoveStrong)
                   StartFuel_Maps._default.MapRemoveStrong)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemoveStrong)
                   StartFuelAssert_Maps._default.MapRemoveStrong)
                (= (AsFuelBottom StartFuel_Maps._default.MapRemove1Strong)
                   StartFuel_Maps._default.MapRemove1Strong)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemove1Strong)
                   StartFuelAssert_Maps._default.MapRemove1Strong)
                (= (AsFuelBottom StartFuel_Maps._default.IMapInvert)
                   StartFuel_Maps._default.IMapInvert)
                (= (AsFuelBottom StartFuelAssert_Maps._default.IMapInvert)
                   StartFuelAssert_Maps._default.IMapInvert)
                (= (AsFuelBottom StartFuel_Maps._default.IMapRemove)
                   StartFuel_Maps._default.IMapRemove)
                (= (AsFuelBottom StartFuelAssert_Maps._default.IMapRemove)
                   StartFuelAssert_Maps._default.IMapRemove)
                (= (AsFuelBottom StartFuel_Maps._default.IMapRemove1)
                   StartFuel_Maps._default.IMapRemove1)
                (= (AsFuelBottom StartFuelAssert_Maps._default.IMapRemove1)
                   StartFuelAssert_Maps._default.IMapRemove1)
                (= (AsFuelBottom StartFuel_Maps._default.MapDisjointUnion)
                   StartFuel_Maps._default.MapDisjointUnion)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapDisjointUnion)
                   StartFuelAssert_Maps._default.MapDisjointUnion)
                (= (AsFuelBottom StartFuel_Maps._default.MapUnionPreferA)
                   StartFuel_Maps._default.MapUnionPreferA)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnionPreferA)
                   StartFuelAssert_Maps._default.MapUnionPreferA)
                (= (AsFuelBottom StartFuel_Maps._default.MapUnionPreferB)
                   StartFuel_Maps._default.MapUnionPreferB)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnionPreferB)
                   StartFuelAssert_Maps._default.MapUnionPreferB)
                (= (AsFuelBottom StartFuel_Maps._default.MapUnion)
                   StartFuel_Maps._default.MapUnion)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnion)
                   StartFuelAssert_Maps._default.MapUnion)
                (= (AsFuelBottom StartFuel_Maps._default.IMapUnionPreferA)
                   StartFuel_Maps._default.IMapUnionPreferA)
                (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnionPreferA)
                   StartFuelAssert_Maps._default.IMapUnionPreferA)
                (= (AsFuelBottom StartFuel_Maps._default.IMapUnionPreferB)
                   StartFuel_Maps._default.IMapUnionPreferB)
                (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnionPreferB)
                   StartFuelAssert_Maps._default.IMapUnionPreferB)
                (= (AsFuelBottom StartFuel_Maps._default.IMapUnion)
                   StartFuel_Maps._default.IMapUnion)
                (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnion)
                   StartFuelAssert_Maps._default.IMapUnion)
                (= (AsFuelBottom StartFuel_Maps._default.MapDisjointUnion3)
                   StartFuel_Maps._default.MapDisjointUnion3)
                (= (AsFuelBottom StartFuelAssert_Maps._default.MapDisjointUnion3)
                   StartFuelAssert_Maps._default.MapDisjointUnion3)
                (= (AsFuelBottom StartFuel_MsgHistoryMod.MsgHistory.LSNSet)
                   StartFuel_MsgHistoryMod.MsgHistory.LSNSet)
                (= (AsFuelBottom StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet)
                   StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet)
                (= (AsFuelBottom StartFuel_PagedBetree.Path.ReplacedChildren)
                   StartFuel_PagedBetree.Path.ReplacedChildren)
                (= (AsFuelBottom StartFuelAssert_PagedBetree.Path.ReplacedChildren)
                   StartFuelAssert_PagedBetree.Path.ReplacedChildren)
                (= (AsFuelBottom StartFuel_PagedBetreeRefinement._default.INode)
                   StartFuel_PagedBetreeRefinement._default.INode)
                (= (AsFuelBottom StartFuelAssert_PagedBetreeRefinement._default.INode)
                   StartFuelAssert_PagedBetreeRefinement._default.INode)
                (= (AsFuelBottom StartFuel_PagedBetreeRefinement._default.MapApply)
                   StartFuel_PagedBetreeRefinement._default.MapApply)
                (= (AsFuelBottom StartFuelAssert_PagedBetreeRefinement._default.MapApply)
                   StartFuelAssert_PagedBetreeRefinement._default.MapApply)
                ($IsAlloc |receipt#0@@9|
                          Tclass.PagedBetree.QueryReceipt
                          $Heap@@50)
                (= |b$reqreads#0@0| a!1)
                (|PagedBetree.QueryReceipt.Valid#canCall| |receipt#0@@9|)
                (PagedBetree.QueryReceipt.Valid |receipt#0@@9|)
                (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@9|)
                (INTERNAL_lt_boogie
                  1
                  (|Seq#Length| (PagedBetree.QueryReceipt.lines |receipt#0@@9|)))))
      (a!5 (or (PagedBetree.ChildMap.WF
                 ($LS $LZ)
                 (PagedBetree.BetreeNode.children
                   (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
               (Buffers.__default.Total a!4)))
      (a!8 (or (PagedBetree.ChildMap.WF
                 ($LS $LZ)
                 (PagedBetree.BetreeNode.children
                   (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
               a!7))
      (a!11 (U_2_bool (MapType0Select a!4
                                      ($Box (PagedBetree.QueryReceipt.key
                                              |receipt#0@@9|)))))
      (a!13 (=> (and (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@9|)
                     (= (ControlFlow 0 77744) (- 0 465762)))
                a!12)))
(let ((a!6 (=> (|PagedBetree.ChildMap.WF#canCall|
                 (PagedBetree.BetreeNode.children
                   (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
               a!5))
      (a!9 (=> (|PagedBetree.ChildMap.WF#canCall|
                 (PagedBetree.BetreeNode.children
                   (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
               a!8))
      (a!14 (and (=> (= (ControlFlow 0 77744) (- 0 465740)) a!11)
                 (=> a!11 a!13))))
(let ((a!15 (and (=> (= (ControlFlow 0 77744) (- 0 465722))
                     (PagedBetree.BetreeNode.BetreeNode_q
                       (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
                 (=> (PagedBetree.BetreeNode.BetreeNode_q
                       (PagedBetree.QueryReceipt.root |receipt#0@@9|))
                     (=> a!10 a!14)))))
(let ((a!16 (=> (PagedBetree.ChildMap.WF
                  ($LS ($LS $LZ))
                  (PagedBetree.BetreeNode.children
                    (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
                (=> (and (PagedBetree.QueryReceipt.QueryReceipt_q
                           |receipt#0@@9|)
                         (PagedBetree.QueryReceipt.QueryReceipt_q
                           |receipt#0@@9|))
                    a!15))))
(let ((a!17 (and (=> (= (ControlFlow 0 77744) (- 0 465568)) a!6)
                 (=> (= (ControlFlow 0 77744) (- 0 465604)) a!9)
                 a!16)))
(let ((a!18 (and (=> (= (ControlFlow 0 77744) (- 0 465528))
                     (PagedBetree.BetreeNode.BetreeNode_q
                       (PagedBetree.QueryReceipt.root |receipt#0@@9|)))
                 (=> (PagedBetree.BetreeNode.BetreeNode_q
                       (PagedBetree.QueryReceipt.root |receipt#0@@9|))
                     (=> a!3 a!17)))))
(let ((a!19 (=> (and (= $_Frame@0 (|lambda#41| null $Heap@@50 alloc false))
                     (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@9|))
                a!18)))
(let ((a!20 (and (=> (= (ControlFlow 0 77738) 77742) true)
                 (=> (= (ControlFlow 0 77738) 77744) a!19))))
(let ((a!21 (and (=> (= (ControlFlow 0 77738) (- 0 465497)) |b$reqreads#0@0|)
                 (=> |b$reqreads#0@0| a!20))))
(let ((a!22 (=> (and (= (AsFuelBottom StartFuel_Sequences._default.replace1with2)
                        StartFuel_Sequences._default.replace1with2)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.replace1with2)
                        StartFuelAssert_Sequences._default.replace1with2)
                     (= (AsFuelBottom StartFuel_Sequences._default.replace2with1)
                        StartFuel_Sequences._default.replace2with1)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.replace2with1)
                        StartFuelAssert_Sequences._default.replace2with1)
                     (= (AsFuelBottom StartFuel_Sequences._default.concat)
                        StartFuel_Sequences._default.concat)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.concat)
                        StartFuelAssert_Sequences._default.concat)
                     (= (AsFuelBottom StartFuel_Sequences._default.concat3)
                        StartFuel_Sequences._default.concat3)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.concat3)
                        StartFuelAssert_Sequences._default.concat3)
                     (= (AsFuelBottom StartFuel_Sequences._default.concatSeq)
                        StartFuel_Sequences._default.concatSeq)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.concatSeq)
                        StartFuelAssert_Sequences._default.concatSeq)
                     (= (AsFuelBottom StartFuel_Sequences._default.IsPrefix)
                        StartFuel_Sequences._default.IsPrefix)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.IsPrefix)
                        StartFuelAssert_Sequences._default.IsPrefix)
                     (= (AsFuelBottom StartFuel_Sequences._default.IsSuffix)
                        StartFuel_Sequences._default.IsSuffix)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.IsSuffix)
                        StartFuelAssert_Sequences._default.IsSuffix)
                     (= (AsFuelBottom StartFuel_Sequences._default.SeqIndexIterate)
                        StartFuel_Sequences._default.SeqIndexIterate)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndexIterate)
                        StartFuelAssert_Sequences._default.SeqIndexIterate))
                (=> a!2 a!21))))
(let ((a!23 (=> (and (= (AsFuelBottom StartFuel_Sequences._default.ApplyOpaque)
                        StartFuel_Sequences._default.ApplyOpaque)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.ApplyOpaque)
                        StartFuelAssert_Sequences._default.ApplyOpaque)
                     (= (AsFuelBottom StartFuel_Sequences._default.remove)
                        StartFuel_Sequences._default.remove)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.remove)
                        StartFuelAssert_Sequences._default.remove)
                     (= (AsFuelBottom StartFuel_Sequences._default.RemoveOneValue)
                        StartFuel_Sequences._default.RemoveOneValue)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.RemoveOneValue)
                        StartFuelAssert_Sequences._default.RemoveOneValue)
                     (= (AsFuelBottom StartFuel_Sequences._default.insert)
                        StartFuel_Sequences._default.insert)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.insert)
                        StartFuelAssert_Sequences._default.insert))
                a!22)))
(let ((a!24 (=> (and (= (AsFuelBottom StartFuel_Sequences._default.NoDupes)
                        StartFuel_Sequences._default.NoDupes)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.NoDupes)
                        StartFuelAssert_Sequences._default.NoDupes)
                     (= (AsFuelBottom StartFuel_Sequences._default.Range)
                        StartFuel_Sequences._default.Range)
                     (= (AsFuelBottom StartFuelAssert_Sequences._default.Range)
                        StartFuelAssert_Sequences._default.Range))
                a!23)))
(let ((a!25 (=> (and ($Is |receipt#0@@9| Tclass.PagedBetree.QueryReceipt)
                     ($Is |out#0| Tclass.PagedBetree.QueryReceipt)
                     (= 32 $FunctionContextHeight)
                     (= (ControlFlow 0 464695) 77738))
                (=> (= $_Frame@0@@0 (|lambda#40| null $Heap@@50 alloc false))
                    a!24))))
(let ((a!26 (=> (= (ControlFlow 0 0) 464695)
                (=> (and ($IsGoodHeap $Heap@@50) ($IsHeapAnchor $Heap@@50))
                    a!25))))
  (not a!26)))))))))))))))))
(check-sat)
